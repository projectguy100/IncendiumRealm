// Adventure.js

/*global adventurejs A*/
"use strict";
/**
 * @class adventurejs
 * @ajsconstruct this.adventurejs = this.adventurejs||{}
 * @hideconstructor
 * @ajsnavheading FrameworkReference
 * @summary Self-invoking anonymous function and main framework container for adventure.js.
 * @classdesc
 * <p>
 * <strong>adventurejs</strong> is a self-invoking anonymous
 * function that creates a container to hold the main framework for
 * adventure.js. adventurejs is singular and scoped to window
 * (meaning, the <a class="external"
 * href="https://www.w3schools.com/js/js_window.asp">browser window object</a>),
 * and can support simultaneous multiple Game instances.
 * See {@link adventurejs.Game|Game}
 * for more information on constructing a Game instance.
 * </p>
 */

this.adventurejs =
  this.ajs =
  this.A =
    this.adventurejs || {
      Preverbs: {},
      GlobalAssets: {
        Exits: [],
        Walls: [],
        Floors: [],
        Ceilings: [],
        Scenery: [],
      },
      Utils: {},
    };

// addWorldToHistory.js
/*global adventurejs A*/
"use strict";

/**
 * Save the current world state for UNDO.
 * @method adventurejs#addWorldToHistory
 * @memberOf adventurejs
 * @param {Object} world
 */
adventurejs.addWorldToHistory = function Adventurejs_addWorldToHistory(world) {
  this.game.log(
    "log",
    "high",
    "worldSave.js > Attempting to save the world.",
    "CopyOperations"
  );

  this.game.world_history.unshift(world);

  if (this.settings.max_undos < this.game.world_history.length) {
    // setting to null not really necessary
    // but doubling down for garbage collection
    // because these saves represent a fair amount of resources
    this.game.world_history[this.game.world_history.length - 1] = null;
    this.game.world_history.pop();
  }

  this.game.log(
    "log",
    "high",
    "worldSave.js > Saved the world.",
    "CopyOperations"
  );
  return;
};

// TODO: can I use proxy to intercept and record all changes?
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
// not supported in IE11 - https://caniuse.com/#search=proxy

//arrayToLowerCase.js
/*global adventurejs A*/

/**
 * Takes an array of strings, converts them to lowercase, and returns the array.
 * @method adventurejs#arrayToLowerCase
 * @memberOf adventurejs
 * @param {Array} array
 * @returns {Array}
 */
adventurejs.arrayToLowerCase = function Adventurejs_arrayToLowerCase(array) {
  if (!Array.isArray(array)) {
    console.warn(
      "arrayToLowerCase.js received something that's not an array. "
    );
    return false;
  }
  for (var item in array) {
    if ("string" === typeof array[item]) {
      array[item] = array[item].toLowerCase();
    }
  }
  return array;
};

//clone.js
/*global adventurejs A*/
"use strict";

/**
 * A deep clone function for simple object types.
 * @method adventurejs#clone
 * @memberOf adventurejs
 * @param {Object} source
 * @returns {Object} output
 */
adventurejs.clone = function Adventurejs_clone(source) {
  //this.game.log( "log", "high", "clone(, 'CopyOperations' )" );

  var dest;

  // Handle the 3 simple types, and null or undefined
  if (null == source || "object" != typeof source) return source;

  // Handle Date - not using dates
  // if (source instanceof Date) {
  //     dest = new Date();
  //     dest.setTime(source.getTime());
  //     return dest;
  // }

  // Handle Array
  if (source instanceof Array) {
    dest = [];
    for (var i = 0, len = source.length; i < len; i++) {
      dest[i] = A.clone.call(this, source[i]);
    }
    return dest;
  }

  // Handle Function
  if (source instanceof Function) {
    var stringified = source.toString();
    dest = eval("(" + stringified + ")");

    return dest;
  }

  // Handle Object
  if (source instanceof Object) {
    if (source.class && adventurejs[source.class]) {
      dest = new adventurejs[source.class](source.name, this.game_name);
    } else {
      dest = {};
    }
    for (var property in source) {
      if (Object.prototype.hasOwnProperty.call(source, property)) {
        dest[property] = A.clone.call(this, source[property]);
      }
    }
    return dest;
  }
  throw new Error(
    "clone.js unable to copy source because its type isn't supported."
  );
};

// another cloning tool
// http://www.eslinstructor.net/jsonfn/

// might also try lodash

// cloneWorld.js

/*global adventurejs A*/
"use strict";

/**
 * Clone the game world for save / restore functions.
 * @memberOf adventurejs
 * @method adventurejs#cloneWorld
 * @param {Object} source
 * @returns {Object} Returns a copy of the source world.
 */
adventurejs.cloneWorld = function Adventurejs_cloneWorld(source) {
  console.warn("cloneWorld");
  this.game.log("log", "high", `cloneWorld()`, "CopyOperations");

  var dest = {};

  var starttime = new Date().getTime();

  for (var object in source) {
    if ("undefined" === typeof source[object].class) {
      dest[object] = source[object];
    } else {
      dest[object] = new adventurejs[source[object].class](
        source[object].id,
        this.game_name
      );
      for (var prop in source[object]) {
        var stringified;

        //if( false === source[ object ].hasOwnProperty( prop ) ) continue;

        if ("string" === typeof source[object][prop]) {
          dest[object][prop] = source[object][prop];
          continue;
        }

        // functions need to be converted to string then reconstituted with eval()
        if ("function" === typeof source[object][prop]) {
          // this version does stringify then parse - unsure its necessary
          //stringified = JSON.stringify( source[ object ][ prop ].toString() );
          //dest[ object ][ prop ] = eval( '(' + JSON.parse(stringified) + ')' );

          // alt version that converts to string but doesn't stringify
          stringified = source[object][prop].toString();
          dest[object][prop] = eval("(" + stringified + ")");

          continue;
        }

        // if it's an object, we might need to recurse, so use clone()
        if ("object" === typeof source[object][prop]) {
          dest[object][prop] = A.clone.call(this.game, source[object][prop]);
          continue;
        }

        // not a string, not a function, do ordinary stringify
        stringified = JSON.stringify(source[object][prop]);
        if ("undefined" !== typeof stringified) {
          dest[object][prop] = JSON.parse(stringified);
        }
      }
    }
  } // for( var object

  this.game.log(
    "log",
    "high",
    "cloneWorld() took " +
      (new Date().getTime() - starttime) / 1000 +
      " seconds.",
    "CopyOperations"
  );

  //console.warn( dest );
  return dest;
};

// another cloning tool
// http://www.eslinstructor.net/jsonfn/

// might also try lodash

//convertTemperature.js
/*global adventurejs A*/ 
"use strict";
/**
 * INCOMPLETE. A simple function to check whether a value is === false or null.
 * @method adventurejs.Game#convertTemperature
 * @memberOf adventurejs.Game
 * @param {Number|String} temperature In Celsius.
 * @param {String} parent_id The ID of the game object the temperature applies to.
 * @returns {Boolean}
 * @todo Finish writing this.
 */
adventurejs.convertTemperature = function Adventurejs_convertTemperature(temperature, parent_id) {
  var newtemperature;

  // if it's number-as-string, convert to number
  // we default to celsius, so there y'go
  if( false === isNaN( temperature ) )
  {
    newtemperature = Number( temperature );
  }

  // if it's a string, check for digits and suffix
  else if( "string" === typeof temperature ) 
  { 

    // strip out spaces
    newtemperature = temperature.replace(/[ ]/g, "");

    var digits = "";
    var suffix = "";
  
    // separate digits from suffix
    // we're going to allow different forms of suffixes
    // so we're going to check every character 
    for(var char in temperature)
    {
      var digit = ( false === isNaN(temperature[char]) || "." == temperature[char] );

      if( digit )
      {

        // we only count digits until we start assembling a suffix
        // if this is true, we've encountered a digit in what we 
        // think is the suffix and we don't know what to do with that
        if( 0 > suffix.length  ) break;

        digits = digits + temperature[char];
        continue;

      }

      suffix = suffix + temperature[char];

    }

    digits = Number( digits );

    if( "f" === suffix.toLowerCase() ) {
      // convert fahrenheit to celsius
      newtemperature = ( digits - 32 ) * ( 5 / 9 );
    }

    // no need here for c to f, but it would be
    // newtemperature = ( digits * ( 9 / 5 ) ) + 32

  }

  if( isNaN( newtemperature ) )
  {
    newtemperature = this.game.settings.room_temperature;
    // let author know we don't know what to do with temperature
    // and set newtemperature to 0 for a valid return
    var msg = "";
    if( "undefined" !== typeof parent_id ) msg += parent_id + "'s ";
    else msg += "An object's ";
    msg += "temperature was set to an invalid value. [MORE...] "
      + "\nconvertTemperature received a value of " + temperature + ". "
      + "\nAdventure.js defaults to temperature in celsius. "
      + "\nRecognized suffixes are: "
      + "\n - c (celsius)"
      + "\n - f (fahrenheit)";
    this.game.log( "warn", "critical", msg , 'Utility' );
  }

  return newtemperature;

}  

//convertVolume.js
/*global adventurejs A*/ 
"use strict";

/**
 * Converts a string or number into milliliters. Accepts a number representing volume in milliliters, or a string to be converted to milliliters (ex: "100ml"), in nL, Î¼L, mL, cL, dL, L, daL, hL, kL, ML.
 * @method adventurejs#convertVolume
 * @memberOf adventurejs
 * @param {Number|String} volume In milliliters.
 * @param {String} parent_id The ID of the Vessel containing the substance.
 * @returns {Number}
 * @todo Handle measurements other than milliliters.
 */
adventurejs.convertVolume = function Adventurejs_convertVolume(volume, parent_id) {
  // we use milliliters by default
  // TODO? pints, quarts, gallons

  var newvolume;

  // if it's number-as-string, convert to number
  // we default to milliliters, so there y'go
  if( false === isNaN( volume ) )
  {
    newvolume = Number( volume );
  }

  // if it's a string, check for digits and suffix
  else if( "string" === typeof volume ) 
  { 

    // strip out commas and spaces
    newvolume = volume.replace(/[ ,]/g, "");

    var digits = "";
    var suffix = "";

    // separate digits from suffix
    // we're going to allow different forms of suffixes
    // so we're going to check every character 
    for(var char in volume)
    {
      var digit = ( false === isNaN(volume[char]) || "." == volume[char] );

      if( digit )
      {

        // we only count digits until we start assembling a suffix
        // if this is true, we've encountered a digit in what we 
        // think is the suffix and we don't know what to do with that
        if( 0 > suffix.length  ) break;

        digits = digits + volume[char];
        continue;

      }

      suffix = suffix + volume[char];

    }

    digits = Number( digits );

    // conversion tables
    // https://converterin.com/volume/mililiter-ml-to-megaliter-ml.html
    // https://www.checkyourmath.com/convert/volume/megaliter.php

    switch( suffix )
    {
      case "":
        break;
      case "nL":
        newvolume = digits / 1000000;
        break;
      case "Î¼L":
        newvolume = digits / 1000;
        break;
      case "mL":
        newvolume = digits;
        break;
      case "cL":
        newvolume = digits * 10;
        break;
      case "dL":
        newvolume = digits * 100;
        break;
      case "L":
        newvolume = digits * 1000;
        break;
      case "daL":
        newvolume = digits * 10000;
        break;
      case "hL":
        newvolume = digits * 100000;
        break;
      case "kL":
        newvolume = digits * 1000000;
        break;
      case "ML":
        newvolume = digits * 1000000000;
        break;
      default:
        break;
    }
  }

  if( isNaN( newvolume ) )
  {
    newvolume = 0;
    // let author know we don't know what to do with volume
    // and set newvolume to 0 for a valid return
    var msg = "";
    if( "undefined" !== typeof parent_id ) msg += parent_id + "'s ";
    else msg += "An object's ";
    msg += "volume was set to an invalid value. [MORE...] "
      + "\nconvertVolume received a value of " + volume + ". "
      + "\nAdventure.js defaults to volume in milliliters. "
      + "\nSuffixes are case sensitive. "
      + "\nRecognized suffixes are: "
      + "\n - nL (nanoliters)"
      + "\n - Î¼L (microliters)"
      + "\n - mL (milliliters)"
      + "\n - cL (centiliters)"
      + "\n - dL (deciliters)"
      + "\n - L (liters)"
      + "\n - daL (decaliters)"
      + "\n - hL (hectoliters)"
      + "\n - kL (kiloliters)"
      + "\n - ML (megaliters)"
      + "\nAdventure.js doesn't handle other measurements at this time. ";
    this.game.log( "warn", "critical", msg , 'Utility' );
  }

  // prevent negative values
  newvolume = Math.max( newvolume, 0 );

  return newvolume;

}  

// deepSet.js
/*global adventurejs A*/
"use strict";

/**
 * This is a deep copy method used for assets and verbs.
 * Returns the object being set for chaining.
 * @memberOf adventurejs
 * @method adventurejs#deepSet
 * @param {Object} props A generic object containing properties to copy to the classed object.
 * @param {Object} object A class instance to copy properties to.
 * @returns {Object} Returns the instance the method is called on (useful for chaining calls.)
 * @chainable
 */
adventurejs.deepSet = function Adventurejs_deepSet(props, object) {
  //console.warn( 'deepSet', props.name || object.name || object.id );
  if (props === null) return object;

  for (var prop in props) {
    if (
      typeof props[prop] === "function" ||
      Array.isArray(props[prop]) ||
      typeof props[prop] !== "object"
    ) {
      // copy simple types and arrays
      object[prop] = props[prop];
    } else if ("undefined" === typeof props[prop]) {
      var msg = "Error during Atom construction. props[prop] is undefined. ";
      this.game.log("error", "high", msg);
      return false;
    } else {
      // incoming prop is classed but this prop is not
      // look for id in prop & if not found use prop as id

      if (props && props[prop] && props[prop].class) {
        var id = props[prop].id;
        if ("undefined" === typeof id) {
          props[prop].id = prop;
          id = prop;
        }

        object[prop] = A.clone.call(this.game, props[prop], object[prop]);
      }

      if ("object" === typeof object[prop]) {
        object[prop] = A.mergeWorld.call(this, props[prop], object[prop]);
      } else {
        /**
         * AS OF 12/19/22 THIS PATH SHOULD NEVER BE CALLED...?
         */

        // create prop on this if needed
        if ("undefined" === typeof object[prop]) object[prop] = props[prop];

        // copy nested properties
        for (var nestedprop in props[prop]) {
          // ignore native prototype properties
          if (!Object.prototype.hasOwnProperty.call(object[prop], nestedprop))
            continue;
          object[prop][nestedprop] = props[prop][nestedprop];
        }
      }
    }
  }

  return object;
};

//deserialize.js
/*global adventurejs A*/ 

/**
 * Reverses serialize function. <ul><li>convert '_' to ' '</li><li>convert '&' to ' and '</li><li>convert '$' to '.'</li></ul>
 * @method adventurejs#deserialize
 * @memberOf adventurejs
 * @param {String} name 
 * @returns {String}
 */
adventurejs.deserialize = function Adventurejs_deserialize(name) 
{
  "use strict";
  if( "string" !== typeof name ) return '';
  return name.replace(/&/g, " and ").replace(/_/g, " ").replace(/\$/g, ".").toLowerCase();
};

//diff.js
/*global adventurejs A*/ 
"use strict";

/**
 * diff function for comparing objects.
 * Specifically intended to support UNDO and SAVE / RESTORE.
 * It recurses objects, stringifies arrays, copies others.
 * @method adventurejs.Game#diff
 * @memberOf adventurejs.Game
 * @param {Object} baseline_object Old object
 * @param {Object} updated_object New object
 * @returns {Object}
 */
adventurejs.diff = function Adventurejs_diff( baseline_object, updated_object )
{
  var diff_object = {};
  var starttime = new Date().getTime();

  for (var prop in updated_object) 
  {
    //if( false === updated_object.hasOwnProperty(prop) ) continue;
    if( false === Object.prototype.hasOwnProperty.call(updated_object, prop) ) continue;

    // if prop is of different type, include in diff
    if( typeof updated_object[prop] !== typeof baseline_object[prop] ) 
    {
      diff_object[ prop ] = A.clone( updated_object[ prop ] );
      continue;
    }

    // if updated_object prop doesn't exist in baseline_object, include in diff
    if( "undefined" === typeof baseline_object[prop] ) 
    {
      diff_object[ prop ] = A.clone( updated_object[ prop ] );
      continue;
    }

    // Handle the 3 simple types, and null or undefined
    if ( ( null == updated_object[ prop ] || "object" != typeof updated_object[ prop ] )
    && updated_object[ prop ] !== baseline_object[ prop ] ) 
    {
      diff_object[ prop ] = A.clone( updated_object[ prop ] );
      continue;
    }

    // Handle Array - just stringify, it's not worth worrying about 
    // the complexity of splicing or reordering
    if ( updated_object[ prop ] instanceof Array ) 
    {
      var baseline_object_prop = JSON.stringify( baseline_object[ prop ] );
      var updated_object_prop = JSON.stringify( updated_object[ prop ] );
      if( updated_object_prop !== baseline_object_prop ) 
      {
        diff_object[prop] = JSON.parse( updated_object_prop );
      }
      continue;
    }

    // Handle Object - recursive
    if ( updated_object[ prop ] instanceof Function ) 
    {
      // this version does stringify then parse - unsure its necessary
      // var baseline_object_prop = JSON.stringify( baseline_object[ prop ], 
      //   function(key, val) {
      //     return val.toString()
      //   });
      // var updated_object_prop = JSON.stringify( updated_object[ prop ], 
      //   function(key, val) {
      //     return val.toString()
      //   });

      // this version converts to string without stringify
      var baseline_object_prop = baseline_object[ prop ].toString();
      var updated_object_prop = updated_object[ prop ].toString();  
        
      if( updated_object_prop !== baseline_object_prop ) 
      {
        diff_object[prop] = eval( '(' + updated_object_prop + ')' );
      }
      continue;
    }

    // Handle Object - recursive
    if ( updated_object[ prop ] instanceof Object ) 
    {
      var diff_object_prop = A.diff( baseline_object[ prop ], updated_object[ prop ] );
      var diff_object_prop_keys = Object.keys( diff_object_prop );
      if( 0 < diff_object_prop_keys.length )
      {
        diff_object[prop] = diff_object_prop;
      }
      continue;
    }
  }

  return diff_object;
}  

//dijkstra.js
/*global adventurejs A*/ 
"use strict";

/**
 * A <a href="https://en.wikipedia.org/wiki/Pathfinding">pathfinding</a> function used to determine whether travel between two given locations is possible. 
 * Based on 
 * <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra's algorithm</a>, 
 * specifically adapted from <a href="https://gist.github.com/jpillora/7382441">jpillora's dijkstra.js</a>.
 * @method adventurejs#dijkstra
 * @memberOf adventurejs
 * @param {Array} graph 
 * @param {String} s 
 * @returns {Object}
 */
adventurejs.dijkstra = function Adventurejs_dijkstra( graph, s ) 
{

  var solutions = {};
  solutions[s] = [];
  solutions[s].dist = 0;
  
  while(true) 
  {
    var parent = null;
    var nearest = null;
    var dist = Infinity;
    
    //for each existing solution
    for(var n in solutions) 
    {
      if(!solutions[n]) 
      { 
        continue; 
      }
      var ndist = solutions[n].dist;
      var adj = graph[n];

      //for each of its adjacent nodes...
      for(var a in adj) 
      {
        //without a solution already...
        if(solutions[a]) 
        { 
          continue; 
        }
        //choose nearest node with lowest *total* cost
        var d = adj[a] + ndist;
        if(d < dist) 
        {
          //reference parent
          parent = solutions[n];
          nearest = a;
          dist = d;
        }
      }
    }
    
    //no more solutions
    if(dist === Infinity) 
    {
      break;
    }
    
    //extend parent's solution path
    solutions[nearest] = parent.concat(nearest);
    //extend parent's cost
    solutions[nearest].dist = dist;
  }

return solutions;
}


// getBaselineDiff.js

/*global adventurejs A*/
"use strict";

/**
 * Get the diff between the baseline world state
 * and the current world state
 * to create a minimum data set for writing saved games.
 * @method adventurejs.Game#getBaselineDiff
 * @memberOf adventurejs.Game
 * @param {Object} source_world
 * @returns {String} Returns a stringified diff.
 */
adventurejs.getBaselineDiff = function Adventurejs_getBaselineDiff() {
  var world_diff = {};
  //var starttime = new Date().getTime();

  world_diff = A.diff(this.game.baseline.world, this.game.world);

  // save title for restore verification
  // TODO change to int-fiction global game id
  if ("undefined" === typeof world_diff._titleSerialized) {
    world_diff._titleSerialized = this.game.world._titleSerialized;
  }

  // save timestamp
  if ("undefined" === typeof world_diff._timestamp) {
    world_diff._timestamp = new Date().getTime().toString();
  }

  // save intervals
  if ("undefined" === typeof world_diff._intervals) {
    world_diff._intervals = this.game.world._intervals;
  }

  // save vars
  if ("undefined" === typeof world_diff._vars) {
    world_diff._vars = this.game.world._vars;
  }

  // stringify
  world_diff = JSON.stringify(world_diff);

  //this.game.log( "log", "high", "getBaselineDiff(, 'CopyOperations' ) took "
  //+ (( new Date().getTime() - starttime ) / 1000 )
  //+ " seconds." );

  return world_diff;
};

//getHorizontalDistance.js
/*global adventurejs A*/

/**
 * Calculate the distance between two x/z points.
 * @method adventurejs#getHorizontalDistance
 * @memberOf adventurejs
 * @param {Object} point1
 * @param {Object} point2
 * @returns {Float}
 */
adventurejs.getHorizontalDistance = function Adventurejs_getHorizontalDistance(
  point1,
  point2
) {
  const deltaX = point2.x - point1.x;
  const deltaZ = point2.z - point1.z;

  return Math.sqrt(deltaX * deltaX + deltaZ * deltaZ);
};

// getStringOrArrayOrFunction.js

/*global adventurejs A*/
"use strict";

/**
 * <p>
 * Get string or array or function.
 * Because Javascript is untyped, we can pass any kind of value in a
 * variable. We take advantage of that here to provide flexibility
 * to authors in properties that print a string back to the player.
 * </p>
 * <ul>
 * <li><strong>Strings</strong> will be printed as is.</li>
 * <li><strong>Arrays</strong> can be set to provide a string from
 * a randomized index, or a sequential index that increments each time
 * it's called.</li>
 * <li><strong>Functions</strong> can use their
 * own internal logic to return a string, allowing for dynamic
 * state-based descriptions, such as whether an Asset is open or closed.
 * </ul>
 * <h3 class="examples">Example:</h3>
 * <pre class="display"><code class="language-javascript">MyGame.createAsset({
 *   class: "Desk",
 *   name: "desk",
 *   descriptions: { look: "An old school wooden desk. ", },
 * });
 * MyGame.createAsset({
 *   class: "Drawer",
 *   name: "drawer",
 *   descriptions: {
 *     look: function(){
 *       return "The drawer is $( drawer is| open or| closed ). ";
 *     },
 *   },
 * });
 * MyGame.createAsset({
 *   class: "Blotter",
 *   name: "blotter",
 *   descriptions: {
 *     look: [
 *       {randomize: true},
 *       "The words 'live and let die' are scrawled on the blotter. ",
 *       "The desk blotter has 'born to bleed' carved into it. ",
 *       "You see 'zep rulez!' scratched in to the desk blotter. ",
 *     ],
 *   },
 * });
 * </code></pre>
 * <p>
 * For more information, see
 * <a href="/doc/Scripting_StringArrayFunction.html">How to Use String|Array|Function</a>.
 * </p>
 * <h3 class="examples">Properties that call getStringOrArrayOrFunction</h3>
 * <ul>
 *   <li>verb subscription on_success: asset.[i|d]ov[verb].on_success</li>
 *   <li>verb subscription then_destroy: asset.[i|d]ov[verb].then_destroy</li>
 *   <li>all descriptions: asset.description and asset.descriptions[any]</li>
 *   <li>room events: room.room_events</li>
 *   <li>zone events: room.zone.zone_events</li>
 *   <li>custom vars: MyGame.world._vars[ property ]</li>
 *   <li>constraint message: character.constrained_msg</li>
 * </ul>
 *
 * @method adventurejs#getStringOrArrayOrFunction
 * @memberOf adventurejs
 * @param {String|Array|Function|Boolean|null} obj Can be string or array or function.
 * @param {Object} scope Optional reference to set scope to an object.
 * @param {Object} params Optional params to pass to a function.
 * @returns {String}
 * @ajsalias A.getSAF()
 */
adventurejs.getStringOrArrayOrFunction = adventurejs.getSAF =
  function Adventurejs_getStringOrArrayOrFunction(obj, scope, params = {}) {
    // console.warn( 'getSAF', obj );

    var msg = "";
    var err = "";

    // if it's string or bool or null just pass it on
    if ("string" === typeof obj || "boolean" === typeof obj || null === obj) {
      return obj;
    } // string / bool / null

    // if it's an array, check for meta data in first position
    if (Array.isArray(obj)) {
      if ("object" !== typeof obj[0]) {
        obj.unshift({
          randomize: false,
          frequency: 1,
          index: 0,
        });
      } // object in first slot?

      // ensure that we have randomize setting
      if ("undefined" === typeof obj[0].randomize) {
        obj[0].randomize =
          this.game.settings.randomize_arrays_in_getStringOrArrayOrFunction;
      }

      // ensure that we have index object
      if ("undefined" === typeof obj[0].index) {
        obj[0].index = 0;
      }

      // ensure that we have frequency setting
      if ("undefined" === typeof obj[0].frequency) {
        obj[0].frequency = 1;
      }

      // are we randomizing?
      if (true === obj[0].randomize) {
        var rand = Math.floor(Math.random() * (obj.length - 2) + 1);

        msg = obj[rand];

        // we might be calling an arbitrary function set by an author
        // that isn't returning a string
        if ("string" !== typeof msg) {
          msg = "";
          err =
            "getStringOrArrayOrFunction found an array item that is something other than a string.";
          this.log("warn", 0, err, "Game");
        }
        return msg;
      } // random

      // if we're not randomizing then we're sequencing, so increment
      // we increment here instead of at the end because we may have
      // just changed the length by adding the meta object
      obj[0].index++;

      // if at end, reset to beginning
      if (obj[0].index === obj.length) {
        obj[0].index = 1;
      }

      // get it
      msg = obj[obj[0].index];

      // check it
      if ("string" !== typeof msg) {
        msg = "";
        err =
          "getStringOrArrayOrFunction found an array item that is something other than a string.";
        this.log("warn", 0, err, "Game");
        //console.warn( msg, obj[rand] );
      }

      return msg;
    } // isArray

    if (typeof obj === "function") {
      // it's a function so call it
      // passing this because there's some scope weirdness
      msg = scope ? obj.call(scope) : obj(this);

      // we might be calling an arbitrary function set by an author
      // that isn't returning a string
      if ("string" !== typeof msg) {
        msg = "";
        err =
          "getStringOrArrayOrFunction called a function that returned something other than a string.";
        this.log("warn", 0, err, "Game");
      }
      return msg;
    } // function
  };

//indexOfSubarray.js
/*global adventurejs A*/ 

/**
 * Determine if one array is nested in another.
 * @method adventurejs#indexOfSubarray
 * @memberOf adventurejs
 * @param {Array} sub 0=log, 1=warn, 2=error 
 * @param {Array} arr 0=critical, 1=high, 2=medium, 3=low
 * @returns {int}
 */
adventurejs.indexOfSubarray = function Adventurejs_indexOfSubarray( sub, arr ) 
{
  var index = -1;
  var subJson = JSON.stringify( sub );
  if( false === Array.isArray( sub) 
  || false === Array.isArray( arr ) ) 
  {
    return index;
  }
  for( var i = 0; i < arr.length; i++ )
  {
    if( subJson === JSON.stringify( arr[i] ) ) 
    {
      index = i;
      break;
    }
  }
  return index;
};

//isFalseOrNull.js
/*global adventurejs A*/ 

/**
 * A simple function to check whether a value is === false or null.
 * @method adventurejs.Game#isFalseOrNull
 * @memberOf adventurejs.Game
 * @param {*} value 
 * @returns {Boolean}
 */
adventurejs.isFalseOrNull = function Adventurejs_isFalseOrNull(value) {
  return ( false === value || null === value );
};
//isIdInMixedArray.js
/*global adventurejs A*/ 
"use strict";

/**
 * Convert an array of arbitrary strings to an array of IDs useable by game objects.
 * <ul><li>convert ' ' to '_'</li>
 * <li>convert ' and ' to '&'</li>
 * <li>convert '.' to '$'</li>
 * </ul>
 * @method adventurejs.Game#isIdInMixedArray
 * @memberOf adventurejs.Game
 * @param {Array} array 
 * @returns {Array}
 */
adventurejs.isIdInMixedArray = function Adventurejs_isIdInMixedArray( id, array ) 
{
  var bool = false;

  //console.error( 'array',array);
  for( var i = 0; i < array.length; i++ )
  {
    var object_i = array[i];
    // is it a string such as ["bed", "table"] ?
    if( "string" === typeof object_i 
    && object_i === id ) 
    {
      bool = true;
    }
    else if( Object( object_i ) === object_i ) // it's an object
    {
      var object_i_keys = Object.keys( object_i );
      // we're expecting objects to have only one key such as
      // [{desk: ["on"]}, {uncomfortable_looking_bed: ["on"]}]
      for( var num in object_i_keys )
      {
        var object_i_key = object_i_keys[num];
        if( object_i_key === id )
        {
          bool = true;
        }
      }

    }
  }

  return bool;

}    

//mergeWorld.js
/*global adventurejs A*/
"use strict";

/**
 * Deep mergeWorld function for simple object types,
 * used to merge restored save game files into baseline game state.
 * @method adventurejs.Game#mergeWorld
 * @memberOf adventurejs.Game
 * @param {Object} source
 * @param {Object} dest
 * @returns {Object} dest
 */
adventurejs.mergeWorld = function Adventurejs_mergeWorld(source, dest) {
  //this.game.log( "log", "high", "mergeWorld(, 'CopyOperations' )" );
  var starttime = new Date().getTime();

  // merge updated properties from saved game
  // console.log( source );
  var props = Object.keys(source);

  for (var i = 0; i < props.length; i++) {
    var prop = props[i];

    // if source has a prop that's not in dest,
    // initialize its class if it has one then clone it
    if (source[prop] && !dest[prop]) {
      //console.warn( "mergeWorld > make new instance of " + source[ prop ].class );
      if (source[prop].class) {
        dest[prop] = new adventurejs[source[prop].class](
          source[prop].id,
          this.game_name
        );
      }
      dest[prop] = A.clone.call(this.game, source[prop]);
    }

    // if source has a prop with a class,
    // and dest has a prop without a class,
    // instantiate the class in dest then copy props
    if (source[prop] && dest[prop] && source[prop].class && !dest[prop].class) {
      dest[prop] = new adventurejs[source[prop].class](
        source[prop].id,
        this.game_name
      );
      dest[prop] = A.clone.call(this.game, source[prop]);
    }

    // or if it's one of these types then just clone it
    else if (
      "string" === typeof source[prop] ||
      !source[prop] ||
      "function" === typeof source[prop] ||
      Array.isArray(source[prop]) ||
      "object" !== typeof source[prop] ||
      null === source[prop]
    ) {
      dest[prop] = A.clone.call(this.game, source[prop]);
    }

    // or recurse
    else {
      dest[prop] = A.mergeWorld.call(this, source[prop], dest[prop]);
    }
  }

  //this.game.log( "log", "high", "mergeWorld(, 'CopyOperations' ) took "
  //+ ( ( new Date().getTime() - starttime ) / 1000 )
  //+ " seconds." );
  return dest;
};

//propercase.js
/*global adventurejs A*/
"use strict";

/**
 * Converts a string to Propercase (lower case with leading cap).
 * @method adventurejs.Game#propercase
 * @memberOf adventurejs.Game
 * @param {String} string
 * @returns {String}
 */
adventurejs.propercase = function Adventurejs_propercase(string) {
  if ("string" !== typeof string) return "";
  string = string.toLowerCase();
  string = string.charAt(0).toUpperCase() + string.substring(1);
  return string;
};

// restoreWorld.js

/*global adventurejs A*/
"use strict";

/**
 * For UNDO and RESTORE.
 * Revert the world to the baseline snapshot
 * and then merge in updates from a partial copy.
 * @method adventurejs.Game#restoreWorld
 * @memberOf adventurejs.Game
 * @param {Object} source
 */
adventurejs.restoreWorld = function Adventurejs_restoreWorld(source) {
  this.game.log(
    "log",
    "high",
    "restoreWorld.js attempting to restore the world.",
    "CopyOperations"
  );
  var starttime = new Date().getTime();

  // we're expecting a string but allowing that we
  // might have received a pre-formed world object
  if ("string" === typeof source) {
    source = JSON.parse(source);
  }

  // Verify a key property to ensure that we're looking at a save.
  if ("undefined" === typeof source._timestamp) {
    alert(
      "The selected json file doesn't appear to be a valid adventurejs save file."
    );
    return false;
  }

  // Verify that save is for this game.
  if (source._titleSerialized !== this.game.titleSerialized) {
    alert("The selected save file doesn't appear to be for this game.");
    return false;
  }

  // Verify that save was made with same version of the game.
  // Holding off on this for now to see how well we can handle version changes.
  //if( source._version !== this.game.version ) {
  //  alert( "The selected save file doesn't appear to be for this game." );
  //  return false;
  //}

  //delete the current world
  delete this.world;

  // restore entire world from baseline
  //this.world = A.cloneWorld.call(this, this.baseline.world);
  this.world = A.clone.call(this, this.baseline.world);
  //@TODO testing clone vs cloneWorld - initial tests are good and much faster

  this.world = A.mergeWorld.call(this, source, this.world);

  // TODO vars, score, other meta info

  source = null;

  // lastly, update the main display
  // TODO this should update entire display set
  this.game.updateDisplayRoom();

  this.game.log(
    "log",
    "high",
    "restoreWorld() took " +
      (new Date().getTime() - starttime) / 1000 +
      " seconds.",
    "CopyOperations"
  );

  return true;
};

//serialize.js
/*global adventurejs A*/ 

/**
 * Convert an arbitrary string to an id useable by game objects.
 * <ul><li>convert ' ' to '_'</li>
 * <li>convert ' and ' to '&'</li>
 * <li>convert '.' to '$'</li>
 * </ul>
 * @method adventurejs#serialize
 * @memberOf adventurejs
 * @param {String} name 
 * @returns {String}
 */
adventurejs.serialize = function Adventurejs_serialize( name )
{
  "use strict";
  if( "string" !== typeof name ) return '';
  return name.replace(/ /g, "_").replace(/\./g, "$").toLowerCase();
};

//serializeArray.js
/*global adventurejs A*/ 
"use strict";

/**
 * Convert an array of arbitrary strings to an array of IDs useable by game objects.
 * <ul><li>convert ' ' to '_'</li>
 * <li>convert ' and ' to '&'</li>
 * <li>convert '.' to '$'</li>
 * </ul>
 * @method adventurejs#serializeArray
 * @memberOf adventurejs
 * @param {Array} array 
 * @returns {Array}
 */
adventurejs.serializeArray = function Adventurejs_serializeArray( array ) 
{
  if( false === Array.isArray( array )  ) 
  {
    console.warn( "SerializeArray: " + array + " is not an array." );
    return array;
  }
  for( var i = 0; i < array.length; i++ ) 
  {
    if( "string" === typeof array[i] )
    {
      array[i] = A.serialize( array[i] );
    }
    if( "object" === typeof array[i] )
    {
      // this should not happen
    }
  }
  return array;
}    

//stringToArray.js
/*global adventurejs A*/ 

/**
  * Convert a string into an array containing the string.
  * @method adventurejs.Game#stringToArray
  * @memberOf adventurejs.Game
  * @param {String} string 
  * @returns {Array}
  */
adventurejs.stringToArray = function Adventurejs_stringToArray(string) 
{
  "use strict";
  if("string" === typeof string ) 
  {
    string = [ string ];
  }
  return string;
};
//substituteCustomTemplates.js
/*global adventurejs A*/
"use strict";

/**
 * <strong>substituteCustomTemplates</strong> acts on strings prior to
 * printing them to {@link adventurejs.Display|Display}.
 * Substitution is the last step of
 * {@link adventurejs.Game#print|Game.print()}.
 * It replaces custom templates, aka substrings bracketed
 * inside parentheses, like $(door is| open or| closed).
 * <br><br>
 *
 * For example:
 * <pre class="display">descriptions: { look: "The drawer is $( drawer is| open or| closed )." }</pre>
 * <br><br>
 *
 * This method is similar to Javascript ES6
 * template literals but with important distinctions.
 * <li>The adventurejs version uses different symbols: $(parentheses)
 * instead of Javascript's native ${curly braces}. </li>
 * <li>Substrings inside $(parens) are evaluated by adventurejs, rather
 * than native Javascript, so they have limited scope.</li>
 * <br><br>
 *
 * There are several types of valid substitutions:
 *
 * <li><code class="property">$( author_variables )</code>
 * refers to author-created custom variables
 * that are stored within the game scope so that they
 * can be written out to saved game files. (See
 * <a href="/doc/Scripting_CustomVars.html">How to Use Custom Vars</a>
 * for more info.)
 * </li>
 *
 * <li><code class="property">$( asset is| state or| unstate )</code>
 * allows authors to refer to a game asset by name or id
 * and print certain verb states. Names are serialized
 * during the substitution process, meaning that, for example:
 * <code class="property">$( brown jar is| open or| closed )</code>
 * will be interpreted to check for
 * <code class="property">MyGame.world.brown_jar.is.closed</code>.</li>
 *
 * <li><code class="property">$(tag|text)</code> is a
 * shortcut to &lt;span class="tag"&gt;text&lt;/span&gt;,
 * to make it easier to add custom CSS styles to text.
 * <br><br>
 *
 * Adventurejs custom templates can be mixed & matched with
 * template literals. Custom templates can be used in any
 * string that outputs to the game display. However, because
 * template literals in strings are evaluated when the
 * properties containing them are created, they will cause
 * errors on game startup. In order to use native Javascript
 * template literals, they must be returned by functions.
 *
 * MyGame.createAsset({
 *   class: "Room",
 *   name: "Standing Room",
 *   descriptions: {
 *     brief: "The north door is $(north is| open or| closed). ",
 *     through: "Through the door you see a $(northcolor) light. ",
 *     verbose: return function(){ `The north door
 *     ${MyGame.world.aurora_door.is.closed ?
 *     "is closed, hiding the aurora. " :
 *     "is open, revealing the $(northcolor) aurora light" }` }
 *   }
 * })
 *
 * @TODO update classdesc
 * @memberOf adventurejs
 * @method adventurejs#substituteCustomTemplates
 * @param {String} msg A string on which to perform substitutions.
 * @returns {String}
 */

adventurejs.substituteCustomTemplates =
  function Adventurejs_substituteCustomTemplates(msg) {
    var token_regex = /\$\((.*?)\)/g;
    var exec_results = [];
    var tokens = [];

    const getVerbState = (asset, state) => {
      let verb =
        this.dictionary.verbs[this.dictionary.verb_state_lookup[state]];

      if (verb && asset.dov[verb.name]) {
        if (verb.state && asset.is[verb.state]) {
          return verb.state_string;
        }
        if (false === asset.is[verb.state]) {
          // undefined doesn't qualify
          return verb.unstate_string;
        }
      }
    }; // getVerbState

    // const processDebug = (token) => {
    //   token = token.substring(6);
    //   let token_array = token.split("|");
    //   if (token_array.length > 1) {
    //     for (var i = 0; i < token_array.length; i++) {
    //       token_array[i] =
    //         "<span class='debug_" + i + "'>" + token_array[i] + "</span>";
    //     }
    //     token = token_array.join("");
    //   }
    //   return '<em class="debug">' + token + "</em>";
    // }; // processDebug

    const processSpans = (token) => {
      let tag = token.split("|")[0];
      let content = token.split("|")[1];
      return `<span class="${tag}">${content}</span>`;
    }; // processSpans

    const getAssetFromTokenId = (token_id) => {
      let asset;
      let direction;
      direction = this.dictionary.getDirection(token_id);
      if (direction) {
        asset = this.getExitFromDirection(direction);
        if (asset && asset.aperture) {
          asset = this.getAsset(asset.aperture);
        }
      } else {
        asset = this.getAsset(token_id);
      }
      return asset;
    };

    const processAssetIsOr = (token) => {
      let token_array = token.split(" is|").map((e) => e.trim());
      let token_id = token_array[0];
      let token_state = token_array[1]; // everything after 'is'
      let new_string = "in an unknown state";
      let asset = getAssetFromTokenId(token_id);
      let verb_states = token_state.split(" or|").map((e) => e.trim());
      if (verb_states.length) {
        // we expect something like verb_states=[ "plugged", "unplugged" ]
        // but we can handle one or more than two
        let found = false;
        for (let i = 0; i < verb_states.length; i++) {
          let state = verb_states[i];
          let state_string;
          if (state) {
            state_string = getVerbState(asset, state);
          }
          if (state_string) {
            new_string = state_string;
            found = true;
            break;
          }
        }

        if (!found) {
          // we didn't find a clear verb state
          // is there a state property we can get?
          for (let i = 0; i < verb_states.length; i++) {
            if (asset.is[verb_states[i]]) {
              new_string = verb_states[i];
              break;
            }
          }
        }
      } // verb_states

      return new_string;
    }; // processAssetIsOr

    const processAssetIsThen = (token) => {
      let token_array = token.split(" is|").map((e) => e.trim());
      let token_id = token_array[0];
      let isThen = token_array[1];
      let is, then, ells;
      let isState = false;

      let hasElse = -1 !== isThen.indexOf(" else|");
      if (hasElse) {
        ells = isThen.split(" else|")[1];
        isThen = isThen.split(" else|")[0];
      }
      then = isThen.split(" then|")[1];
      is = isThen.split(" then|")[0].split("is|")[0].trim();

      //console.warn( 'processAssetIsThen token:', token, ', is:',is,', then:',then,', ells:',ells );

      let asset = getAssetFromTokenId(token_id);
      if (asset.is[is]) {
        isState = true;
      }

      if (isState && then) return then;
      if (!isState && ells) return ells;
      return "";
    }; // processAssetIsThen

    const processPronoun = (token, pronoun) => {
      // respect case of the original
      let upper = new RegExp(/[A-Z]/);
      let lower = new RegExp(/[a-z]/);
      if (token.search(lower) === -1) {
        pronoun = pronoun.toUpperCase();
      } else if (token.substring(0, 1).search(upper) > -1) {
        pronoun = A.propercase(pronoun);
      }
      return pronoun;
    }; // processPronoun

    // specifically using exec() here rather than replace() or match()
    // because replace() can't take a scope arg
    // and match() doesn't return an index for groups
    while ((exec_results = token_regex.exec(msg)) !== null) {
      // exec() returns each found token with its first/last indices
      tokens.push([exec_results[1], exec_results.index, token_regex.lastIndex]);
    }

    while (tokens.length > 0) {
      let token, first, last, pronoun;
      let new_string = "unknown";

      // we have to work backwords because we'll be changing the string length
      token = tokens[tokens.length - 1][0];
      first = tokens[tokens.length - 1][1];
      last = tokens[tokens.length - 1][2];

      // default to an error message for author
      new_string =
        "<span class='system error'>No substitute found for $(" +
        token +
        ")</span>";

      // SEARCH TYPES
      // $(we) // pronouns
      // $(success_adverb) // randomizer
      // $(fail_adverb) // randomizer
      // $(var) // game vars
      // $(debug:message) // debug message - moved to debug function
      // $(north is| open or| closed) // direction + state
      // $(sink is| plugged or| unplugged) // asset + state
      // $(sink is| plugged then| " some string ") // asset + state + string
      // $(sink is| plugged then| " some string " else| " other string ") // asset + state + string + string

      // is it a pronoun?
      pronoun = this.dictionary.getPronoun(token.toLowerCase());
      if (pronoun) {
        new_string = processPronoun(token, pronoun);
      }

      // is it a success adverb?
      else if (token === "success_adverb") {
        new_string =
          this.dictionary.success_adverbs[
            Math.floor(Math.random() * this.dictionary.success_adverbs.length)
          ];
      }

      // is it a fail adverb?
      else if (token === "fail_adverb") {
        new_string =
          this.dictionary.fail_adverbs[
            Math.floor(Math.random() * this.dictionary.fail_adverbs.length)
          ];
      }

      // is it an author's game var?
      else if ("undefined" !== typeof this.world._vars[token]) {
        new_string = A.getSAF.call(this, this.world._vars[token]);
      }

      // if ("debug:" === token.substring(0, 6)) {
      //   new_string = this.settings.print_debug_messages
      //     ? processDebug(token, this)
      //     : "";
      // }

      // look for ' is ' and ' then ' as in 'sink drain is open then "output"'
      // ex MyGame.substituteCustomTemplates(`$(door is| open then| "string" else| "other string")`)
      // @TODO changing this to is|
      else if (-1 !== token.indexOf(" is|") && -1 !== token.indexOf(" then|")) {
        new_string = processAssetIsThen(token);
      } // is

      // look for ' is| ' as in 'east is| open' or 'door is| open or| closed'
      // ex MyGame.substituteCustomTemplates(`$(east is| open)`)
      // ex MyGame.substituteCustomTemplates(`$(door is| open or| closed)`)
      // @TODO changing this to is|
      else if (-1 !== token.indexOf(" is|") || -1 !== token.indexOf(" is ")) {
        new_string = processAssetIsOr(token);
      } // is

      // look for cssclass|content
      // ex MyGame.substituteCustomTemplates(`$(foo|bar)`)
      else if (-1 !== token.indexOf("|")) {
        new_string = processSpans(token, this);
      }

      // do replacement
      msg =
        msg.substring(0, first) + new_string + msg.substring(last, msg.length);
      tokens.pop();
    }

    return msg;
  }; // substituteCustomTemplates

//substituteHTMLTags.js
/*global adventurejs A*/
"use strict";

/**
 * <strong>substituteHTMLTags</strong> acts on strings prior to
 * printing them to {@link adventurejs.Display|Display}.
 * Substitution is the last step of
 * {@link adventurejs.Game#print|Game.print()}.
 * It replaces text in &lt;angle&gt;brackets&lt;/&gt;
 * with &lt;span class="angle"&gt;brackets&lt;/span&gt;,
 * providing a shortcut method to adding CSS styles to text.
 * <br><br>
 * For example:
 * <br><br>
 *
 * MyGame.createAsset({
 *   class: "Room",
 *   name: "Standing Room",
 *   descriptions: {
 *     brief: "The north door is <hilite>open</>. ",
 *     through: "Through the door you see a <hilite>bright light</>. ",  *
 *     verbose: return function(){ `The north door
 *     ${MyGame.world.aurora_door.is.closed ?
 *     "is <hilite>closed</>, hiding the aurora. " :
 *     "is <hilite>open</>, revealing the $(northcolor) aurora light" }` }
 *   }
 * })
 * @memberOf adventurejs.Game
 * @method adventurejs.Game#substituteHTMLTags
 * @param {String} msg A string on which to perform substitutions.
 * @returns {String}
 */

adventurejs.substituteHTMLTags = function Adventurejs_substituteHTMLTags(msg) {
  //console.warn(msg);
  msg = msg.replace(
    /<([a-zA-Z\s_][a-zA-Z\s_\d]*)>([^<>]+?)<\/>/g,
    function (match, tagName, tagContent) {
      return `<span class="${tagName}">${tagContent}</span>`;
    }
  );
  return msg;
};

// UID.js
(function() {
	/*global adventurejs A*/ 
  "use strict";

  /**
	 * 
	 * @class adventurejs.UID
   * @ajsnavheading FrameworkReference
   * @ajsinternal
   * @summary Generates sequential unique ID numbers.
   * @classdesc 
	 * <p>
   * Global utility for generating sequential unique ID numbers. 
   * The UID class uses a static interface (ex. 
   * <code class="property">UID.get()</code>)
	 * and should not be instantiated.
   * </p>
   * <p>
   * Shamelessly cribbed from 
   * <a href="https://www.createjs.com/">create.js</a> by 
   * <a href="https://gskinner.com/">gskinner</a>
   * </p>
	 */
  function UID() {
		throw "UID cannot be instantiated";
	}


// private static properties:
	/**
	 * @method adventurejs.UID#_nextID
	 * @memberOf adventurejs.UID
	 * @type Number
	 * @protected
	 **/
	UID._nextID = 0;


// public static methods:
	/**
	 * Returns the next unique id.
	 * @method adventurejs.UID#get
	 * @memberOf adventurejs.UID
	 **/
	UID.get = function UID_get() {
		return "_"+UID._nextID++;
	};

	adventurejs.UID = UID;
}());

//validateAssetList.js
/*global adventurejs A*/ 
"use strict";

/**
 * Serialize asset names in an array. Asset names may be nested 
 * inside objects in the array. A secondary effect of this function
 * is that it converts object properties from strings to arrays,
 * which corrects for cases of authors providing strings for 
 * properties that want arrays. For example: "skeleton key" 
 * would be converted to ["skeleton_key"].
 * @method adventurejs#validateAssetList
 * @memberOf adventurejs
 * @param {String|Array} property 
 * @returns {Array}
 */
adventurejs.validateAssetList = function Adventurejs_validateAssetList( property )
{
  if( "undefined" === typeof property ) return [];
  if( "string" === typeof property ) 
  {
    property = A.stringToArray( property );
  }

  if( Array.isArray( property ) ) 
  {

    for( var i = 0; i < property.length; i++ ) 
    {

      // ex: [ "id" ]
      if( "string" === typeof property[i] )
      {
        property[i] = A.serialize( property[i] );
      }

      // ex: [ {"id":['preposition']} ]
      else if( Object(property[i]) === property[i] )
      {
        for( var key in property[i] ){ 
          var value = property[i][key];
          var id = A.serialize( key );
          if( "string" === typeof value )
          {
            value = A.stringToArray( A.serialize(value) );
          }
          if( Array.isArray(value) || Object(value) === value ) 
          {
            value = A.validateAssetList( value );
          }
          delete property[i][key];
          property[i][id] = value;
        } 
      }

    }
  }

  // ex: [ {"id":['preposition']} ]
  else if( Object(property) === property )
  {
    for( var key in property ){ 
      var value = property[key];
      var id = A.serialize( key );
      if( "string" === typeof value )
      {
        value = A.stringToArray( A.serialize(value) );
      }
      else if( Array.isArray(value) || Object(value) === value ) 
      {
        value = A.validateAssetList( value );
      }
      delete property[key];
      property[id] = value;
    } 
  }

  return property;
};

//validateClassList.js
/*global adventurejs A*/ 

/**
 * Validate a list of classes. Unused?
 * @method adventurejs.Game#validateClassList
 * @memberOf adventurejs.Game
 * @param {String|Array} property 
 * @returns {Array}
 * @todo Is this unused?
 */

adventurejs.validateClassList = function Adventurejs_validateClassList( property )
{
  // "use strict";
  if( "string" === typeof property ) 
  {
    property = adventurejs.stringToArray( property );
  }
  for(var i = 0; i < property.length; i++ )
  {
    if( !A[ property[i] ] )
    {
      property[i] = null;
    }
  }
  return property;
};

// objectAssign.js
// polyfill for IE11
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill
/**
 * @external
 */
(function() {
	/*global adventurejs A*/ 
  "use strict";

  if (typeof Object.assign !== 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
      value: function assign(target, varArgs) { // .length of function is 2
        'use strict';
        if (target === null || target === undefined) {
          throw new TypeError('Cannot convert undefined or null to object');
        }

        var to = Object(target);

        for (var index = 1; index < arguments.length; index++) {
          var nextSource = arguments[index];

          if (nextSource !== null && nextSource !== undefined) { 
            for (var nextKey in nextSource) {
              // Avoid bugs when hasOwnProperty is shadowed
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
        return to;
      },
      writable: true,
      configurable: true
    });
  }
}());

'use strict';
/**
 * @function polyfill
 * @external
 * @ignore
 */
function polyfill() {
  // aliases
  var w = window;
  var d = document;

  // return if scroll behavior is supported and polyfill is not forced
  if (
    'scrollBehavior' in d.documentElement.style &&
    w.__forceSmoothScrollPolyfill__ !== true
  ) {
    return;
  }

  // globals
  var Element = w.HTMLElement || w.Element;
  var SCROLL_TIME = 468;

  // object gathering original scroll methods
  var original = {
    scroll: w.scroll || w.scrollTo,
    scrollBy: w.scrollBy,
    elementScroll: Element.prototype.scroll || scrollElement,
    scrollIntoView: Element.prototype.scrollIntoView
  };

  // define timing method
  var now =
    w.performance && w.performance.now
      ? w.performance.now.bind(w.performance)
      : Date.now;

  /**
   * indicates if a the current browser is made by Microsoft
   * @method isMicrosoftBrowser
   * @param {String} userAgent
   * @returns {Boolean}
   * @ignore
   */
  function isMicrosoftBrowser(userAgent) {
    var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];

    return new RegExp(userAgentPatterns.join('|')).test(userAgent);
  }

  /*
   * IE has rounding bug rounding down clientHeight and clientWidth and
   * rounding up scrollHeight and scrollWidth causing false positives
   * on hasScrollableSpace
   */
  var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;

  /**
   * changes scroll position inside an element
   * @method scrollElement
   * @param {Number} x
   * @param {Number} y
   * @returns {undefined}
   * @ignore
   */
  function scrollElement(x, y) {
    this.scrollLeft = x;
    this.scrollTop = y;
  }

  /**
   * returns result of applying ease math function to a number
   * @method ease
   * @param {Number} k
   * @returns {Number}
   * @ignore
   */
  function ease(k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  }

  /**
   * indicates if a smooth behavior should be applied
   * @method shouldBailOut
   * @param {Number|Object} firstArg
   * @returns {Boolean}
   * @ignore
   */
  function shouldBailOut(firstArg) {
    if (
      firstArg === null ||
      typeof firstArg !== 'object' ||
      firstArg.behavior === undefined ||
      firstArg.behavior === 'auto' ||
      firstArg.behavior === 'instant'
    ) {
      // first argument is not an object/null
      // or behavior is auto, instant or undefined
      return true;
    }

    if (typeof firstArg === 'object' && firstArg.behavior === 'smooth') {
      // first argument is an object and behavior is smooth
      return false;
    }

    // throw error when behavior is not supported
    throw new TypeError(
      'behavior member of ScrollOptions ' +
        firstArg.behavior +
        ' is not a valid value for enumeration ScrollBehavior.'
    );
  }

  /**
   * indicates if an element has scrollable space in the provided axis
   * @method hasScrollableSpace
   * @param {Node} el
   * @param {String} axis
   * @returns {Boolean}
   * @ignore
   */
  function hasScrollableSpace(el, axis) {
    if (axis === 'Y') {
      return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;
    }

    if (axis === 'X') {
      return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;
    }
  }

  /**
   * indicates if an element has a scrollable overflow property in the axis
   * @method canOverflow
   * @param {Node} el
   * @param {String} axis
   * @returns {Boolean}
   * @ignore
   */
  function canOverflow(el, axis) {
    var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];

    return overflowValue === 'auto' || overflowValue === 'scroll';
  }

  /**
   * indicates if an element can be scrolled in either axis
   * @method isScrollable
   * @param {Node} el
   * @param {String} axis
   * @returns {Boolean}
   * @ignore
   */
  function isScrollable(el) {
    var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');
    var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');

    return isScrollableY || isScrollableX;
  }

  /**
   * finds scrollable parent of an element
   * @method findScrollableParent
   * @param {Node} el
   * @returns {Node} el
   * @ignore
   */
  function findScrollableParent(el) {
    while (el !== d.body && isScrollable(el) === false) {
      el = el.parentNode || el.host;
    }

    return el;
  }

  /**
   * self invoked function that, given a context, steps through scrolling
   * @method step
   * @param {Object} context
   * @returns {undefined}
   * @ignore
   */
  function step(context) {
    var time = now();
    var value;
    var currentX;
    var currentY;
    var elapsed = (time - context.startTime) / SCROLL_TIME;

    // avoid elapsed times higher than one
    elapsed = elapsed > 1 ? 1 : elapsed;

    // apply easing to elapsed time
    value = ease(elapsed);

    currentX = context.startX + (context.x - context.startX) * value;
    currentY = context.startY + (context.y - context.startY) * value;

    context.method.call(context.scrollable, currentX, currentY);

    // scroll more if we have not reached our destination
    if (currentX !== context.x || currentY !== context.y) {
      w.requestAnimationFrame(step.bind(w, context));
    }
  }

  /**
   * scrolls window or element with a smooth behavior
   * @method smoothScroll
   * @param {Object|Node} el
   * @param {Number} x
   * @param {Number} y
   * @returns {undefined}
   * @ignore
   */
  function smoothScroll(el, x, y) {
    var scrollable;
    var startX;
    var startY;
    var method;
    var startTime = now();

    // define scroll context
    if (el === d.body) {
      scrollable = w;
      startX = w.scrollX || w.pageXOffset;
      startY = w.scrollY || w.pageYOffset;
      method = original.scroll;
    } else {
      scrollable = el;
      startX = el.scrollLeft;
      startY = el.scrollTop;
      method = scrollElement;
    }

    // scroll looping over a frame
    step({
      scrollable: scrollable,
      method: method,
      startTime: startTime,
      startX: startX,
      startY: startY,
      x: x,
      y: y
    });
  }

  // ORIGINAL METHODS OVERRIDES
  // w.scroll and w.scrollTo
  w.scroll = w.scrollTo = function() {
    // avoid action when no arguments are passed
    if (arguments[0] === undefined) {
      return;
    }

    // avoid smooth behavior if not required
    if (shouldBailOut(arguments[0]) === true) {
      original.scroll.call(
        w,
        arguments[0].left !== undefined
          ? arguments[0].left
          : typeof arguments[0] !== 'object'
            ? arguments[0]
            : w.scrollX || w.pageXOffset,
        // use top prop, second argument if present or fallback to scrollY
        arguments[0].top !== undefined
          ? arguments[0].top
          : arguments[1] !== undefined
            ? arguments[1]
            : w.scrollY || w.pageYOffset
      );

      return;
    }

    // LET THE SMOOTHNESS BEGIN!
    smoothScroll.call(
      w,
      d.body,
      arguments[0].left !== undefined
        ? ~~arguments[0].left
        : w.scrollX || w.pageXOffset,
      arguments[0].top !== undefined
        ? ~~arguments[0].top
        : w.scrollY || w.pageYOffset
    );
  };

  // w.scrollBy
  w.scrollBy = function() {
    // avoid action when no arguments are passed
    if (arguments[0] === undefined) {
      return;
    }

    // avoid smooth behavior if not required
    if (shouldBailOut(arguments[0])) {
      original.scrollBy.call(
        w,
        arguments[0].left !== undefined
          ? arguments[0].left
          : typeof arguments[0] !== 'object' ? arguments[0] : 0,
        arguments[0].top !== undefined
          ? arguments[0].top
          : arguments[1] !== undefined ? arguments[1] : 0
      );

      return;
    }

    // LET THE SMOOTHNESS BEGIN!
    smoothScroll.call(
      w,
      d.body,
      ~~arguments[0].left + (w.scrollX || w.pageXOffset),
      ~~arguments[0].top + (w.scrollY || w.pageYOffset)
    );
  };

  // Element.prototype.scroll and Element.prototype.scrollTo
  Element.prototype.scroll = Element.prototype.scrollTo = function() {
    // avoid action when no arguments are passed
    if (arguments[0] === undefined) {
      return;
    }

    // avoid smooth behavior if not required
    if (shouldBailOut(arguments[0]) === true) {
      // if one number is passed, throw error to match Firefox implementation
      if (typeof arguments[0] === 'number' && arguments[1] === undefined) {
        throw new SyntaxError('Value could not be converted');
      }

      original.elementScroll.call(
        this,
        // use left prop, first number argument or fallback to scrollLeft
        arguments[0].left !== undefined
          ? ~~arguments[0].left
          : typeof arguments[0] !== 'object' ? ~~arguments[0] : this.scrollLeft,
        // use top prop, second argument or fallback to scrollTop
        arguments[0].top !== undefined
          ? ~~arguments[0].top
          : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop
      );

      return;
    }

    var left = arguments[0].left;
    var top = arguments[0].top;

    // LET THE SMOOTHNESS BEGIN!
    smoothScroll.call(
      this,
      this,
      typeof left === 'undefined' ? this.scrollLeft : ~~left,
      typeof top === 'undefined' ? this.scrollTop : ~~top
    );
  };

  // Element.prototype.scrollBy
  Element.prototype.scrollBy = function() {
    // avoid action when no arguments are passed
    if (arguments[0] === undefined) {
      return;
    }

    // avoid smooth behavior if not required
    if (shouldBailOut(arguments[0]) === true) {
      original.elementScroll.call(
        this,
        arguments[0].left !== undefined
          ? ~~arguments[0].left + this.scrollLeft
          : ~~arguments[0] + this.scrollLeft,
        arguments[0].top !== undefined
          ? ~~arguments[0].top + this.scrollTop
          : ~~arguments[1] + this.scrollTop
      );

      return;
    }

    this.scroll({
      left: ~~arguments[0].left + this.scrollLeft,
      top: ~~arguments[0].top + this.scrollTop,
      behavior: arguments[0].behavior
    });
  };

  // Element.prototype.scrollIntoView
  Element.prototype.scrollIntoView = function() {
    // avoid smooth behavior if not required
    if (shouldBailOut(arguments[0]) === true) {
      original.scrollIntoView.call(
        this,
        arguments[0] === undefined ? true : arguments[0]
      );

      return;
    }

    // LET THE SMOOTHNESS BEGIN!
    var scrollableParent = findScrollableParent(this);
    var parentRects = scrollableParent.getBoundingClientRect();
    var clientRects = this.getBoundingClientRect();

    if (scrollableParent !== d.body) {
      // reveal element inside parent
      smoothScroll.call(
        this,
        scrollableParent,
        scrollableParent.scrollLeft + clientRects.left - parentRects.left,
        scrollableParent.scrollTop + clientRects.top - parentRects.top
      );

      // reveal parent in viewport unless is fixed
      if (w.getComputedStyle(scrollableParent).position !== 'fixed') {
        w.scrollBy({
          left: parentRects.left,
          top: parentRects.top,
          behavior: 'smooth'
        });
      }
    } else {
      // reveal element in viewport
      w.scrollBy({
        left: clientRects.left,
        top: clientRects.top,
        behavior: 'smooth'
      });
    }
  };
}

if (typeof exports === 'object' && typeof module !== 'undefined') {
  // commonjs
  module.exports = { polyfill: polyfill };
} else {
  // global
  polyfill();
}

/**
 * @ignore
 * @namespace aria
 * @external
 */

var aria = aria || {};

/**
 * @ignore
 * @desc
 *  Key code constants
 */
aria.KeyCode = {
  BACKSPACE: 8,
  TAB: 9,
  RETURN: 13,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  DELETE: 46
};

aria.Utils = aria.Utils || {};

// Polyfill src https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
aria.Utils.matches = function (element, selector) {
  if (!Element.prototype.matches) {
    Element.prototype.matches =
      Element.prototype.matchesSelector ||
      Element.prototype.mozMatchesSelector ||
      Element.prototype.msMatchesSelector ||
      Element.prototype.oMatchesSelector ||
      Element.prototype.webkitMatchesSelector ||
      function (s) {
        var matches = element.parentNode.querySelectorAll(s);
        var i = matches.length;
        while (--i >= 0 && matches.item(i) !== this) {}
        return i > -1;
      };
  }

  return element.matches(selector);
};

aria.Utils.remove = function (item) {
  if (item.remove && typeof item.remove === 'function') {
    return item.remove();
  }
  if (item.parentNode &&
      item.parentNode.removeChild &&
      typeof item.parentNode.removeChild === 'function') {
    return item.parentNode.removeChild(item);
  }
  return false;
};

aria.Utils.isFocusable = function (element) {
  if (element.tabIndex > 0 || (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)) {
    return true;
  }

  if (element.disabled) {
    return false;
  }

  switch (element.nodeName) {
    case 'A':
      return !!element.href && element.rel != 'ignore';
    case 'INPUT':
      return element.type != 'hidden' && element.type != 'file';
    case 'BUTTON':
    case 'SELECT':
    case 'TEXTAREA':
      return true;
    default:
      return false;
  }
};

aria.Utils.getAncestorBySelector = function (element, selector) {
  if (!aria.Utils.matches(element, selector + ' ' + element.tagName)) {
    // Element is not inside an element that matches selector
    return null;
  }

  // Move up the DOM tree until a parent matching the selector is found
  var currentNode = element;
  var ancestor = null;
  while (ancestor === null) {
    if (aria.Utils.matches(currentNode.parentNode, selector)) {
      ancestor = currentNode.parentNode;
    }
    else {
      currentNode = currentNode.parentNode;
    }
  }

  return ancestor;
};

aria.Utils.hasClass = function (element, className) {
  return (new RegExp('(\\s|^)' + className + '(\\s|$)')).test(element.className);
};

aria.Utils.addClass = function (element, className) {
  if (!aria.Utils.hasClass(element, className)) {
    element.className += ' ' + className;
  }
};

aria.Utils.removeClass = function (element, className) {
  var classRegex = new RegExp('(\\s|^)' + className + '(\\s|$)');
  element.className = element.className.replace(classRegex, ' ').trim();
};

aria.Utils.bindMethods = function (object /* , ...methodNames */) {
  var methodNames = Array.prototype.slice.call(arguments, 1);
  methodNames.forEach(function (method) {
    object[method] = object[method].bind(object);
  });
};

/*
*   This content is licensed according to the W3C Software License at
*   https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
*/
/**
 * @ignore
 * @namespace aria
 * @external
 */
var aria = aria || {};

/**
 * @ignore
 * @constructor
 *
 * @desc
 *  Listbox object representing the state and interactions for a listbox widget
 *
 * @param listboxNode
 *  The DOM node pointing to the listbox
 */
aria.Listbox = function (listboxNode) {
  this.listboxNode = listboxNode;
  this.activeDescendant = this.listboxNode.getAttribute('aria-activedescendant');
  this.multiselectable = this.listboxNode.hasAttribute('aria-multiselectable');
  this.moveUpDownEnabled = false;
  this.siblingList = null;
  this.upButton = null;
  this.downButton = null;
  this.moveButton = null;
  this.keysSoFar = '';
  this.handleFocusChange = function () {};
  this.handleItemChange = function (event, items) {};
  this.registerEvents();
};

/**
 * 
 * @desc
 *  Register events for the listbox interactions
 */
aria.Listbox.prototype.registerEvents = function () {
  this.listboxNode.addEventListener('focus', this.setupFocus.bind(this));
  this.listboxNode.addEventListener('keydown', this.checkKeyPress.bind(this));
  this.listboxNode.addEventListener('click', this.checkClickItem.bind(this));
};

/**
 * @desc
 *  If there is no activeDescendant, focus on the first option
 */
aria.Listbox.prototype.setupFocus = function () {
  if (this.activeDescendant) {
    return;
  }

  //this.focusFirstItem();
};

/**
 * @desc
 *  Focus on the first option
 */
aria.Listbox.prototype.focusFirstItem = function () {
  var firstItem;

  firstItem = this.listboxNode.querySelector('[role="option"]');

  if (firstItem) {
    this.focusItem(firstItem);
  }
};

/**
 * @desc
 *  Focus on the last option
 */
aria.Listbox.prototype.focusLastItem = function () {
  var itemList = this.listboxNode.querySelectorAll('[role="option"]');

  if (itemList.length) {
    this.focusItem(itemList[itemList.length - 1]);
  }
};

/**
 * @desc
 *  Handle various keyboard controls; UP/DOWN will shift focus; SPACE selects
 *  an item.
 *
 * @param evt
 *  The keydown event object
 */
aria.Listbox.prototype.checkKeyPress = function (evt) {
  var key = evt.which || evt.keyCode;
  var nextItem = document.getElementById(this.activeDescendant);

  if (!nextItem) {
    return;
  }

  switch (key) {
    case aria.KeyCode.PAGE_UP:
    case aria.KeyCode.PAGE_DOWN:
      if (this.moveUpDownEnabled) {
        evt.preventDefault();

        if (key === aria.KeyCode.PAGE_UP) {
          this.moveUpItems();
        }
        else {
          this.moveDownItems();
        }
      }

      break;
    case aria.KeyCode.UP:
    case aria.KeyCode.DOWN:
      evt.preventDefault();

      if (this.moveUpDownEnabled && evt.altKey) {
        if (key === aria.KeyCode.UP) {
          this.moveUpItems();
        }
        else {
          this.moveDownItems();
        }
        return;
      }

      if (key === aria.KeyCode.UP) {
        nextItem = nextItem.previousElementSibling;
      }
      else {
        nextItem = nextItem.nextElementSibling;
      }

      if (nextItem) {
        this.focusItem(nextItem);
      }

      break;
    case aria.KeyCode.HOME:
      evt.preventDefault();
      this.focusFirstItem();
      break;
    case aria.KeyCode.END:
      evt.preventDefault();
      this.focusLastItem();
      break;
    case aria.KeyCode.SPACE:
      evt.preventDefault();
      this.toggleSelectItem(nextItem);
      break;
    case aria.KeyCode.BACKSPACE:
    case aria.KeyCode.DELETE:
    case aria.KeyCode.RETURN:
      if (!this.moveButton) {
        return;
      }

      var keyshortcuts = this.moveButton.getAttribute('aria-keyshortcuts');
      if (key === aria.KeyCode.RETURN && keyshortcuts.indexOf('Enter') === -1) {
        return;
      }
      if (
        (key === aria.KeyCode.BACKSPACE || key === aria.KeyCode.DELETE) &&
        keyshortcuts.indexOf('Delete') === -1
      ) {
        return;
      }

      evt.preventDefault();

      var nextUnselected = nextItem.nextElementSibling;
      while (nextUnselected) {
        if (nextUnselected.getAttribute('aria-selected') != 'true') {
          break;
        }
        nextUnselected = nextUnselected.nextElementSibling;
      }
      if (!nextUnselected) {
        nextUnselected = nextItem.previousElementSibling;
        while (nextUnselected) {
          if (nextUnselected.getAttribute('aria-selected') != 'true') {
            break;
          }
          nextUnselected = nextUnselected.previousElementSibling;
        }
      }

      this.moveItems();

      if (!this.activeDescendant && nextUnselected) {
        this.focusItem(nextUnselected);
      }
      break;
    default:
      var itemToFocus = this.findItemToFocus(key);
      if (itemToFocus) {
        this.focusItem(itemToFocus);
      }
      break;
  }
};

aria.Listbox.prototype.findItemToFocus = function (key) {
  var itemList = this.listboxNode.querySelectorAll('[role="option"]');
  var character = String.fromCharCode(key);

  if (!this.keysSoFar) {
    for (var i = 0; i < itemList.length; i++) {
      if (itemList[i].getAttribute('id') == this.activeDescendant) {
        this.searchIndex = i;
      }
    }
  }
  this.keysSoFar += character;
  this.clearKeysSoFarAfterDelay();

  var nextMatch = this.findMatchInRange(
    itemList,
    this.searchIndex + 1,
    itemList.length
  );
  if (!nextMatch) {
    nextMatch = this.findMatchInRange(
      itemList,
      0,
      this.searchIndex
    );
  }
  return nextMatch;
};

aria.Listbox.prototype.clearKeysSoFarAfterDelay = function () {
  if (this.keyClear) {
    clearTimeout(this.keyClear);
    this.keyClear = null;
  }
  this.keyClear = setTimeout((function () {
    this.keysSoFar = '';
    this.keyClear = null;
  }).bind(this), 500);
};

aria.Listbox.prototype.findMatchInRange = function (list, startIndex, endIndex) {
  // Find the first item starting with the keysSoFar substring, searching in
  // the specified range of items
  for (var n = startIndex; n < endIndex; n++) {
    var label = list[n].innerText;
    if (label && label.toUpperCase().indexOf(this.keysSoFar) === 0) {
      return list[n];
    }
  }
  return null;
};

/**
 * @desc
 *  Check if an item is clicked on. If so, focus on it and select it.
 *
 * @param evt
 *  The click event object
 */
aria.Listbox.prototype.checkClickItem = function (evt) {
  if (evt.target.getAttribute('role') === 'option') {
    this.focusItem(evt.target);
    this.toggleSelectItem(evt.target);
  }
};

/**
 * @desc
 *  Toggle the aria-selected value
 *
 * @param element
 *  The element to select
 */
aria.Listbox.prototype.toggleSelectItem = function (element) {
  if (this.multiselectable) {
    element.setAttribute(
      'aria-selected',
      element.getAttribute('aria-selected') === 'true' ? 'false' : 'true'
    );

    if (this.moveButton) {
      if (this.listboxNode.querySelector('[aria-selected="true"]')) {
        this.moveButton.setAttribute('aria-disabled', 'false');
      }
      else {
        this.moveButton.setAttribute('aria-disabled', 'true');
      }
    }
  }
};

/**
 * @desc
 *  Defocus the specified item
 *
 * @param element
 *  The element to defocus
 */
aria.Listbox.prototype.defocusItem = function (element) {
  if (!element) {
    return;
  }
  if (!this.multiselectable) {
    element.removeAttribute('aria-selected');
  }
  aria.Utils.removeClass(element, 'focused');
};

/**
 * @desc
 *  Focus on the specified item
 *
 * @param element
 *  The element to focus
 */
aria.Listbox.prototype.focusItem = function (element) {
  this.defocusItem(document.getElementById(this.activeDescendant));
  if (!this.multiselectable) {
    element.setAttribute('aria-selected', 'true');
  }
  aria.Utils.addClass(element, 'focused');
  this.listboxNode.setAttribute('aria-activedescendant', element.id);
  this.activeDescendant = element.id;

  if (this.listboxNode.scrollHeight > this.listboxNode.clientHeight) {
    var scrollBottom = this.listboxNode.clientHeight + this.listboxNode.scrollTop;
    var elementBottom = element.offsetTop + element.offsetHeight;
    if (elementBottom > scrollBottom) {
      this.listboxNode.scrollTop = elementBottom - this.listboxNode.clientHeight;
    }
    else if (element.offsetTop < this.listboxNode.scrollTop) {
      this.listboxNode.scrollTop = element.offsetTop;
    }
  }

  if (!this.multiselectable && this.moveButton) {
    this.moveButton.setAttribute('aria-disabled', false);
  }

  this.checkUpDownButtons();
  this.handleFocusChange(element);
};

/**
 * @desc
 *  Enable/disable the up/down arrows based on the activeDescendant.
 */
aria.Listbox.prototype.checkUpDownButtons = function () {
  var activeElement = document.getElementById(this.activeDescendant);

  if (!this.moveUpDownEnabled) {
    return false;
  }

  if (!activeElement) {
    this.upButton.setAttribute('aria-disabled', 'true');
    this.downButton.setAttribute('aria-disabled', 'true');
    return;
  }

  if (this.upButton) {
    if (activeElement.previousElementSibling) {
      this.upButton.setAttribute('aria-disabled', false);
    }
    else {
      this.upButton.setAttribute('aria-disabled', 'true');
    }
  }

  if (this.downButton) {
    if (activeElement.nextElementSibling) {
      this.downButton.setAttribute('aria-disabled', false);
    }
    else {
      this.downButton.setAttribute('aria-disabled', 'true');
    }
  }
};

/**
 * @desc
 *  Add the specified items to the listbox. Assumes items are valid options.
 *
 * @param items
 *  An array of items to add to the listbox
 */
aria.Listbox.prototype.addItems = function (items) {
  if (!items || !items.length) {
    return false;
  }

  items.forEach((function (item) {
    this.defocusItem(item);
    this.toggleSelectItem(item);
    this.listboxNode.append(item);
  }).bind(this));

  if (!this.activeDescendant) {
    this.focusItem(items[0]);
  }

  this.handleItemChange('added', items);
};

/**
 * @desc
 *  Remove all of the selected items from the listbox; Removes the focused items
 *  in a single select listbox and the items with aria-selected in a multi
 *  select listbox.
 *
 * @returns items
 *  An array of items that were removed from the listbox
 */
aria.Listbox.prototype.deleteItems = function () {
  var itemsToDelete;

  if (this.multiselectable) {
    itemsToDelete = this.listboxNode.querySelectorAll('[aria-selected="true"]');
  }
  else if (this.activeDescendant) {
    itemsToDelete = [ document.getElementById(this.activeDescendant) ];
  }

  if (!itemsToDelete || !itemsToDelete.length) {
    return [];
  }

  itemsToDelete.forEach((function (item) {
    item.remove();

    if (item.id === this.activeDescendant) {
      this.clearActiveDescendant();
    }
  }).bind(this));

  this.handleItemChange('removed', itemsToDelete);

  return itemsToDelete;
};

aria.Listbox.prototype.clearActiveDescendant = function () {
  this.activeDescendant = null;
  this.listboxNode.setAttribute('aria-activedescendant', null);

  if (this.moveButton) {
    this.moveButton.setAttribute('aria-disabled', 'true');
  }

  this.checkUpDownButtons();
};

/**
 * @desc
 *  Shifts the currently focused item up on the list. No shifting occurs if the
 *  item is already at the top of the list.
 */
aria.Listbox.prototype.moveUpItems = function () {
  var previousItem;

  if (!this.activeDescendant) {
    return;
  }

  currentItem = document.getElementById(this.activeDescendant);
  previousItem = currentItem.previousElementSibling;

  if (previousItem) {
    this.listboxNode.insertBefore(currentItem, previousItem);
    this.handleItemChange('moved_up', [ currentItem ]);
  }

  this.checkUpDownButtons();
};

/**
 * @desc
 *  Shifts the currently focused item down on the list. No shifting occurs if
 *  the item is already at the end of the list.
 */
aria.Listbox.prototype.moveDownItems = function () {
  var nextItem;

  if (!this.activeDescendant) {
    return;
  }

  currentItem = document.getElementById(this.activeDescendant);
  nextItem = currentItem.nextElementSibling;

  if (nextItem) {
    this.listboxNode.insertBefore(nextItem, currentItem);
    this.handleItemChange('moved_down', [ currentItem ]);
  }

  this.checkUpDownButtons();
};

/**
 * @desc
 *  Delete the currently selected items and add them to the sibling list.
 */
aria.Listbox.prototype.moveItems = function () {
  if (!this.siblingList) {
    return;
  }

  var itemsToMove = this.deleteItems();
  this.siblingList.addItems(itemsToMove);
};

/**
 * @desc
 *  Enable Up/Down controls to shift items up and down.
 *
 * @param upButton
 *   Up button to trigger up shift
 *
 * @param downButton
 *   Down button to trigger down shift
 */
aria.Listbox.prototype.enableMoveUpDown = function (upButton, downButton) {
  this.moveUpDownEnabled = true;
  this.upButton = upButton;
  this.downButton = downButton;
  upButton.addEventListener('click', this.moveUpItems.bind(this));
  downButton.addEventListener('click', this.moveDownItems.bind(this));
};

/**
 * @desc
 *  Enable Move controls. Moving removes selected items from the current
 *  list and adds them to the sibling list.
 *
 * @param button
 *   Move button to trigger delete
 *
 * @param siblingList
 *   Listbox to move items to
 */
aria.Listbox.prototype.setupMove = function (button, siblingList) {
  this.siblingList = siblingList;
  this.moveButton = button;
  button.addEventListener('click', this.moveItems.bind(this));
};

aria.Listbox.prototype.setHandleItemChange = function (handlerFn) {
  this.handleItemChange = handlerFn;
};

aria.Listbox.prototype.setHandleFocusChange = function (focusChangeHandler) {
  this.handleFocusChange = focusChangeHandler;
};

// Dictionary.js
(function () {
  /*global adventurejs A*/
  "use strict";
  /*global adventurejs A*/
  /**
   * @class adventurejs.Dictionary
   * @param {Game} game A reference to the game instance.
   * @ajsnavheading FrameworkReference
   * @ajsinternal
   * @summary Framework class that manages verb instances and lookup tables for verbs and nouns.
   * @classdesc
   * <p>
   * <strong>Dictionary</strong> manages all {@link adventurejs.Verb|Verbs}
   * and Verb related functions. It also manages lookup tables for
   * Verbs, nouns, directions, and sentence patterns. A Dictionary
   * instance is created automatically by {@link adventurejs.Game|Game}
   * at runtime. There is no public constructor, and authors should
   * not need to make new instances.
   * </p>
   */
  class Dictionary {
    constructor(game) {
      /**
       * A reference back to the main {@link adventurejs.Game|Game} object.
       * @var {Object} adventurejs.Dictionary#game
       * @default {}
       */
      this.game = game;

      /**
       * Unused?
       * @var {Object} adventurejs.Dictionary#directions
       * @default {}
       * @todo Is this irrelevant?
       */
      this.directions = {};

      /**
       * Lookup table for direction keywords.
       * @var {Object} adventurejs.Dictionary#directionLookup
       * @default {}
       * @ajsnode game.dictionary.directionLookup
       */
      this.directionLookup = {};

      /**
       * Container for all constructed instance of
       * {@link adventurejs.Verb|Verb}.
       * @var {Object} adventurejs.Dictionary#verbs
       * @default {}
       * @ajsnode game.dictionary.verbs
       */
      this.verbs = {};

      /**
       * When using <a href="#disableAllVerbsBut">disableAllVerbsBut</a>,
       * save the enabled verb IDs here.
       * @var {Array} adventurejs.Dictionary#enabled_verbs
       * @default []
       */
      this.enabled_verbs = [];

      /**
       * When using <a href="#disableVerbs">disableVerbs</a>,
       * save the disabled verb IDs here.
       * @var {Array} adventurejs.Dictionary#disabled_verbs
       * @default []
       */
      this.disabled_verbs = [];

      /**
       * Boolean used to determine if we've initialize all predefined verbs.
       * @var {Boolean} adventurejs.Dictionary#did_initialize_verbs
       * @default false
       */
      this.did_initialize_verbs = false;

      /**
       * A lookup table for verb keywords.
       * @var {Object} adventurejs.Dictionary#verb_lookup
       * @default {}
       */
      this.verb_lookup = {};

      //this.stringLookup = {};

      /**
       * We store a variety of verb/noun/preposition patterns per verb,
       * which we compare against when searching player input.
       * @var {Array} adventurejs.Dictionary#verb_noun_preps
       * @default []
       */
      this.verb_noun_preps = [];

      /**
       * We store a variety of verb/noun/preposition patterns per verb,
       * which we compare against when searching player input.
       * @var {Array} adventurejs.Dictionary#verb_prep_nouns
       * @default []
       */
      this.verb_prep_nouns = [];

      /**
       * We store a variety of verb/noun/preposition patterns per verb,
       * which we compare against when searching player input.
       * @var {Array} adventurejs.Dictionary#verb_prep_prep_nouns
       * @default []
       */
      this.verb_prep_prep_nouns = [];

      /**
       * We store a variety of verb/noun/preposition patterns per verb,
       * which we compare against when searching player input.
       * @var {Array} adventurejs.Dictionary#verb_prep_prep_prep_nouns
       * @default []
       */
      this.verb_prep_prep_prep_nouns = [];

      /**
       * We store a variety of verb/noun/preposition patterns per verb,
       * which we compare against when searching player input.
       * @var {Array} adventurejs.Dictionary#verb_noun_prep_nouns
       * @default []
       */
      this.verb_noun_prep_nouns = [];

      /**
       * We store a variety of verb/noun/preposition patterns per verb,
       * which we compare against when searching player input.
       * @var {Array} adventurejs.Dictionary#verb_noun_prep_prep_nouns
       * @default []
       */
      this.verb_noun_prep_prep_nouns = [];

      /**
       * We store a variety of verb/noun/preposition patterns per verb,
       * which we compare against when searching player input.
       * @var {Array} adventurejs.Dictionary#verb_noun_prep_noun_prep_nouns
       * @default []
       */
      this.verb_noun_prep_noun_prep_nouns = [];

      /**
       * We store a variety of verb/noun/preposition patterns per verb,
       * which we compare against when searching player input.
       * @var {Array} adventurejs.Dictionary#verb_prep_noun_prep_nouns
       * @default []
       */
      this.verb_prep_noun_prep_nouns = [];

      /**
       * We store a variety of verb/noun/preposition patterns per verb,
       * which we compare against when searching player input.
       * @var {Array} adventurejs.Dictionary#verb_prep_noun_prep_noun_prep_nouns
       * @default []
       */
      this.verb_prep_noun_prep_noun_prep_nouns = [];

      /**
       * A placeholder for verbs to write their state/unstate strings to for lookup..
       * @var {Object} adventurejs.Dictionary#verb_state_lookup
       */
      this.verb_state_lookup = {};

      return this;
    } // Dictionary constructor

    /**
     * Construct all native verbs. When complete,
     * sets game.dictionary.did_initialize_verbs to true.
     * @memberOf adventurejs.Dictionary
     * @method adventurejs.Dictionary#initStandardVerbs
     * @kind function
     * @ajsinternal
     */
    initStandardVerbs() {
      for (var preverb in A.Preverbs) {
        this.createVerb(A.Preverbs[preverb]);
      }
      this.did_initialize_verbs = true;
    }

    /**
     * Determine whether string is recognized as a preposition.
     * @memberOf adventurejs.Dictionary
     * @method adventurejs.Dictionary#isPreposition
     * @param {String} preposition
     * @returns {Boolean}
     */
    isPreposition(word) {
      var bool = false;
      if (this.prepositions.indexOf(word) > -1) bool = true;
      return bool;
    }

    /**
     * Determine whether string is recognized as a preposition
     * and return the string.
     * @memberOf adventurejs.Dictionary
     * @method adventurejs.Dictionary#getPreposition
     * @param {String} preposition
     * @returns {String|Boolean}
     */
    getPreposition(word) {
      if (this.prepositions.indexOf(word) > -1) return word;
      else return false;
    }

    /**
     * Determine whether string is recognized as an adverb
     * and return the string.
     * @memberOf adventurejs.Dictionary
     * @method adventurejs.Dictionary#getAdverb
     * @param {String} preposition
     * @returns {String|Boolean}
     */
    getAdverb(word) {
      if (this.adverbs.indexOf(word) > -1) return word;
      else return false;
    }

    /**
     * Determine whether string is recognized as an getAdjective
     * and return the string.
     * @memberOf adventurejs.Dictionary
     * @method adventurejs.Dictionary#getAdjective
     * @param {String} preposition
     * @returns {String|Boolean}
     */
    getAdjective(word) {
      if (this.adjectives.indexOf(word) > -1) return word;
      else return false;
    }

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     * @method adventurejs.Dictionary#set
     * @param {Object} props A generic object containing properties to copy to the instance.
     * @returns {adventurejs.Dictionary} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(props) {
      return A.deepSet.call(this.game, props, this);
    }
  }

  adventurejs.Dictionary = Dictionary;
})();

// adjectives.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Adjectives recognized by the parser.
   * @var {Object} adventurejs.Dictionary#adjectives
   */
  p.adjectives = [
    "south",
    "s",
    "north",
    "n",
    "east",
    "e",
    "west",
    "w",
    "northeast",
    "ne",
    "northwest",
    "nw",
    "southeast",
    "se",
    "southwest",
    "sw",
    "port",
    "starboard",
    "aft",
    "fore",
    "old",
    "new",
    "dirty",
    "clean",
    "loud",
    "quiet",
    "good",
    "bad",
    "best",
    "worst",
    "big",
    "little",
    "small",
    "large",
    "tiny",
    "huge",
    "tall",
    "short",
    "long",
    "wide",
    "narrow",
    "heavy",
    "light",
    "strong",
    "weak",
    "fast",
    "slow",
    "hot",
    "cold",
    "red",
    "orange",
    "yellow",
    "green",
    "blue",
    "indigo",
    "violet",
    "purple",
    "pink",
    "white",
    "black",
    "grey",
    "brown",
    "tan",
    "beige",
    "clear",
    "transparent",
    "opaque",
  ];
})();

// adverbs.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Adverbs are currently unused but may be supported in future.
   * @var {Object} adventurejs.Dictionary#adverbs
   */
  p.adverbs = [
    "forward",
    "back",
    "backwards",
    "left",
    "right",
    "up",
    "down",
    "across",
    "upstairs",
    "downstairs",
    "over",
    "through",
    "towards",
    "near",
    "along",
  ];
})();

// aspects.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Prepositions that are recognized as tangible aspects.
   * @var {Object} adventurejs.Dictionary#aspects
   */
  p.aspects = [
    "attached",
    "behind",
    "in",
    "on",
    "under",
    "worn",
    "hung",
    "tied",
  ];
  // out? off?
})();

// combineVerbs.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * <strong>combineVerbs</strong> is a method to allow authors
   * to consolidate verbs.
   * For example, consider move and push.
   * These verbs are almost identical and only exist here as
   * distinct verbs because it seems that "push character" has
   * a very different connotation than "move character".
   * Authors who find the distinction unhelpful
   * may want to combine them so they don't have to write custom
   * responses for both verbs.
   * What combineVerbs does under the hood is delete the
   * verb(s) provided in the first param and add their synonyms
   * to the verb provided in the second param.
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#combineVerbs
   * @param {String} pushVerbs
   * @param {String} intoVerb
   */
  p.combineVerbs = function (pushVerbs, intoVerb) {
    // validate intoVerb
    if ("string" !== typeof intoVerb) {
      var msg =
        "combineVerbs takes a string but received unknown object " +
        intoVerb +
        ". ";
      this.game.log("warn", "critical", msg, "dictionary");
      return false;
    }
    if ("undefined" === typeof this.verbs[intoVerb]) {
      var msg = "combineVerbs received unknown verb " + intoVerb + ". ";
      this.game.log("warn", "critical", msg, "dictionary");
      return false;
    }
    // pushVerbs can take string or array, so convert to array
    if ("string" === typeof pushVerbs) {
      pushVerbs = [pushVerbs];
    }
    // copy pushVerb's synonyms to intoVerb then delete pushVerb from lookup
    for (var v = 0; v < pushVerbs.length; v++) {
      var pushVerb = pushVerbs[v]; //this.verb_lookup[ pushVerb ];
      if ("undefined" === typeof this.verbs[pushVerb]) {
        var msg = "combineVerbs received unknown verb " + pushVerb + ". ";
        this.game.log("warn", "critical", msg, "dictionary");
        continue;
      }
      for (var s = 0; s < this.verbs[pushVerb].synonyms.length; s++) {
        this.verb_lookup[intoVerb].synonyms.push(
          this.verbs[pushVerb].synonyms[s]
        );
      }
      delete this.verb_lookup[pushVerb];
      delete this.verbs[pushVerb];
    }
    return;
  };
})();

// compound_prepositions.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Compound prepositions are converted to single words by the parser.
   * @var {Object} adventurejs.Dictionary#compound_prepositions
   */
  p.compound_prepositions = [
    [" below ", " under "],
    [" down under ", " under "],
    [" towards ", " to "],
    [" toward ", " to "],
    [" away from ", " from "],
    [" above ", " over "],
    [" inside ", " in "],
    [" into ", " in "],
    [" in to ", " in "],
    [" inside ", " in "],
    [" up on to ", " on "],
    [" up onto ", " on "],
    [" up on ", " on "],
    [" up in ", " in "],
    [" up over ", " over "],
    [" onto ", " on "],
    [" on to ", " on "],
    [" down off of ", " off "],
    [" down off ", " off "],
    [" down from ", " off "],
    [" off of ", " off "],
    [" up off ", " off "],
    [" out of ", " out "],
    [" over to ", " to "],
    [" go to ", " goto "],
    [" in front of ", " infrontof "],
    [" out from under ", " outfromunder "],
    [" out from behind ", " outfrombehind "],
    [" from under ", " fromunder "],
    [" from behind ", " frombehind "],
    [" from on ", " fromon "],
    [" from in ", " fromin "],
    [" from inside ", " fromin "],
  ];
})();

// createVerb.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Native verbs are stored as non-classed objects, aka preverbs.
   * This method calls the <a href="/doc/adventurejs.Verb.html">Verb()</a>
   * constructor and passes data from
   * preverb to verb, then adds the new verb to game.dictionary.verbs.
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#createVerb
   * @kind function
   * @param  {object} preverb A generic object.
   * @returns {Verb} The constructed verb
   */
  p.createVerb = function (preverb) {
    // add new verb to the dictionary
    if ("undefined" === typeof preverb) {
      var msg = "createVerb received a bad value: " + preverb;
      this.game.log("warn", 0, msg, "dictionary");
      return false;
    }
    if ("undefined" === typeof preverb.name) {
      var msg = "createVerb received a preverb without a name: " + preverb;
      this.game.log("warn", 0, msg, "dictionary");
      return false;
    }
    if (this.verbs[preverb.name]) {
      var msg =
        "createVerb.js > Found an existing verb named " + preverb.name + ". ";
      this.game.log("warn", "critical", msg, "dictionary");
      return false;
    }
    this.verbs[preverb.name] = new adventurejs.Verb(this.game);
    //if(preverb.phrase1) this.verbs[preverb.name].phrase1 = new adventurejs.Phrase();
    //if(preverb.phrase2) this.verbs[preverb.name].phrase2 = new adventurejs.Phrase();
    //if(preverb.phrase3) this.verbs[preverb.name].phrase3 = new adventurejs.Phrase();
    this.verbs[preverb.name].set(preverb);
    this.verbs[preverb.name].validate();
    this.verbs[preverb.name].initialize();
    this.verb_lookup[preverb.name] = {
      synonyms: preverb.synonyms,
    };
    return this.verbs[preverb.name];
  };
})();

// disableAllVerbsBut.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * A method to allow authors to consolidate verbs.
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#disableAllVerbsBut
   * @param {Array} enabled_verbs
   */
  p.disableAllVerbsBut = function (enabled_verbs) {
    // can take string or array, so convert to array
    if ("string" === typeof enabled_verbs) {
      enabled_verbs = [enabled_verbs];
    }
    var verbs = Object.keys(this.verbs);
    // for all verbs in our pre-defined verb list...
    for (var i = verbs.length - 1; i > -1; i--) {
      var verb = verbs[i];
      // is this verb in our new enabled verbs list?
      var index = enabled_verbs.indexOf(verbs[i]);
      if (-1 === index) {
        // if not, delete it
        delete this.verb_lookup[verb];
        delete this.verbs[verb];
      }
    }
  };
})();

// disableVerbs.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * A method to allow authors to disable specific verbs.
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#disableVerbs
   * @param {String|Array} disabled_verbs
   */
  p.disableVerbs = function (disabled_verbs) {
    console.warn("disableVerbs", disabled_verbs);
    // can take string or array, so convert to array
    if ("string" === typeof disabled_verbs) {
      disabled_verbs = [disabled_verbs];
    }
    for (var i = 0; i < disabled_verbs.length; i++) {
      var verb = disabled_verbs[i];
      if ("undefined" === typeof this.verb_lookup[verb]) {
        var msg = "disableVerbs received unknown verb " + verb + ". ";
        this.game.log("warn", "critical", msg, "dictionary");
        continue;
      }
      delete this.verb_lookup[verb];
      delete this.verbs[verb];
      this.disabled_verbs.push(disabled_verbs[i]);
    }
  };
})();

// doVerb.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Passthrough method to call a verb.
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#doVerb
   * @param {String} verb
   */
  p.doVerb = function (verb) {
    this.game.log(
      "log",
      "high",
      "Dictionary.doVerb > verb: " + verb,
      "dictionary"
    );
    if ("undefined" !== typeof this.verbs[verb]) {
      this.verbs[verb].do();
    } else return false;
  };
})();

// enableVerbs.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * A method to allow authors to reenable verbs.
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#enableVerbs
   * @param {Array|String} disabled_verbs
   */
  p.enableVerbs = function (disabled_verbs) {
    // can take string or array, so convert to array
    if ("string" === typeof disabled_verbs) {
      disabled_verbs = [disabled_verbs];
    }
    for (var i = 0; i < disabled_verbs.length; i++) {
      var verb = disabled_verbs[i];
      if (!this.verbs[verb]) {
        if (A.Preverbs[verb]) {
          this.createVerb(A.Preverbs[verb]);
          this.disabled_verbs.splice(this.disabled_verbs.indexOf(verb), 1);
        }
      }
    }
  };
})();

// exit_prepositions.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Exit prepositions are used to describe leaving a nested position.
   * @var {Object} adventurejs.Dictionary#exit_prepositions
   */
  p.exit_prepositions = {
    behind: "out",
    in: "out",
    on: "off",
    under: "out",
  };
})();

// fail_adverbs.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * A list of adverbs that can be used randomly in negative responses.
   * @var {Object} adventurejs.Dictionary#fail_adverbs
   */
  p.fail_adverbs = [
    "dramatically",
    "astonishingly",
    "stunningly",
    "remarkably",
    "extravagantly",
    "magnificently",
    "breathtakingly",
    "impressively",
    "phenomenally",
    "astoundingly",
    "gloriously",
    "grandly",
    "majestically",
    "unbelievably",
    "overwhelmingly",
    "incredibly",
    "sensationally",
    "epicly",
    "catastrophically",
    "disastrously",
    "horrifically",
    "terribly",
    "miserably",
    "abysmally",
    "dreadfully",
    "appallingly",
    "disgracefully",
    "atrociously",
    "cringeworthily",
    "ingloriously",
    "infamously",
    "shamefully",
    "embarrassingly",
    "pathetically",
    "abominably",
    "monumentally",
    "colossally",
    "epicly",
  ];
})();

// getDirection.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Dictionary.prototype;

  /**
   * 
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#getDirection
   * @param {String} word A direction name. 
   * Directions can have aliases, 
   * for example 'ne' as a shortcut for 'northeast'.
   * When player inputs an alias, we want to lookup the primary name, 
   * which we need to get the direction object.
   * @returns {String} The primary direction name.
   */
   p.getDirection = function Dictionary_getDirection( word ) 
  {
		if(typeof this.directionLookup[word] !== "undefined" )
    {
			return(word);
		}
		for (var prop in this.directionLookup) 
    {
			if("undefined" === typeof this.directionLookup[prop].synonyms) 
      {
				continue;
			}
			var synonyms = this.directionLookup[prop].synonyms;
			for(var i = 0; i < synonyms.length;i++) 
      {
				if(word===synonyms[i]) {
					// found a synonym, return the base word
					return prop;
				}
			}
		}
		return false;
	}
  
}());

// getDirection.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Dictionary.prototype;

  /**
   * Takes a plural pronoun token and converts to the equivalent 
   * person pronoun according to game.settings.person.
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#getPronoun
   * @kind function
   * @param {String} pronoun
   * @ajsinternal
   */
  p.getPronoun = function Dictionary_getPronoun(pronoun) 
  {
    return this.pronouns[this.game.settings.person]?.[pronoun];
  }
  
}());

// getVerb.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * A method to get a dictionary verb object from a verb name string.
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#getVerb
   * @param {String} verb
   * @returns {object}
   */
  p.getVerb = function (verb) {
    if ("string" !== typeof verb) return false;
    return this.verbs[verb] || null;
  };
})();

// isDirection.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Dictionary.prototype;

  /**
   * Is this a direction?
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#isDirection
   * @param {String} word A string to be evaluated.
   * @returns {Boolean}
   */
   p.isDirection = function Dictionary_isDirection( word ) 
  {
    return this.getDirection(word) !== false;
	}
  
}());

// NounMustBe.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.NounMustBe
   * @ajsinternal
   * @ajsnavheading FrameworkReference
   * @summary Framework class, used as a property of a verb instance, that sets conditions a noun must meet for the verb to act on it.
   * @classdesc
   * <p>
   * <strong>NounMustBe</strong> is a special class
   * used while parsing {@link adventurejs.Input|Input}
   * to specify general conditions that
   * a noun must meet for a {@link adventurejs.Verb|Verb}
   * to act on it. This is a broad set
   * of exclusions used to narrow items by class or by certain
   * properties, or availability to the player character.
   * Exclusion is handled by
   * {@link adventurejs.Parser#qualifyParsedNoun|Parser.qualifyParsedNoun}.
   * Each verb has more specific logic to handle more specific
   * conditions.  This is an internal class
   * that authors should not need to construct, though there are
   * methods to allow authors to customize these settings
   * per Verb. See
   * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>
   * for more info.
   * </p>
   */
  class NounMustBe {
    constructor() {
      /**
       * Extant means the asset is available in the game world.
       * If extant is false the asset can be referred to
       * but not used.
       * @var {Boolean} adventurejs.NounMustBe#extant
       * @default true
       */
      this.extant = true; // maybe our only true by default?

      /**
       * If true, Verb will only act on directions, such as "go north".
       * @var {Boolean} adventurejs.NounMustBe#direction
       * @default false
       */
      this.direction = false;

      /**
       * If true, Verb will not act on directions.
       * @var {Boolean} adventurejs.NounMustBe#not_direction
       * @default false
       */
      this.not_direction = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Matter|Matter},
       * which includes Tangibles and Substances.
       * @var {Boolean} adventurejs.NounMustBe#matter
       * @default false
       */
      this.matter = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Tangible|Tangibles}.
       * @var {Boolean} adventurejs.NounMustBe#tangible
       * @default false
       */
      this.tangible = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Intangible|Intangibles}.
       * @var {Boolean} adventurejs.NounMustBe#intangible
       * @default false
       */
      this.intangible = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Character|Characters}.
       * @var {Boolean} adventurejs.NounMustBe#character
       * @default false
       */
      this.character = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Tangible|Tangibles}
       * that are in the current {@link adventurejs.Room|Room}
       * @var {Boolean} adventurejs.NounMustBe#present
       * @default false
       */
      this.present = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Tangible|Tangibles}
       * that are in the current {@link adventurejs.Room|Room}
       * @var {Boolean} adventurejs.NounMustBe#present_if_tangible
       * @default false
       */
      this.present_if_tangible = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Tangible|Tangibles}
       * that are in reachable to player.
       * @var {Boolean} adventurejs.NounMustBe#reachable_if_tangible
       * @default false
       */
      this.reachable_if_tangible = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Tangible|Tangibles}
       * that are visible to player character. Visibility may be
       * determined by a number of factors.
       * @var {Boolean} adventurejs.NounMustBe#visible
       * @default false
       */
      this.visible = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Tangible|Tangibles}
       * that are reachable to player character. Reachability may be
       * determined by a number of factors.
       * @var {Boolean} adventurejs.NounMustBe#reachable
       * @default false
       */
      this.reachable = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Tangible|Tangibles}
       * that can be taken by player character.
       * @var {Boolean} adventurejs.NounMustBe#takeable
       * @default false
       */
      this.takeable = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Asset|Assets}
       * that are known by player character.
       * @var {Boolean} adventurejs.NounMustBe#known
       * @default false
       */
      this.known = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Asset|Assets}
       * in player's inventory.
       * @var {Boolean} adventurejs.NounMustBe#in_inventory
       * @default false
       */
      this.in_inventory = false;

      /**
       * If true, if {@link adventurejs.Asset|Asset} is takeable,
       * it must be in player character's inventory for
       * verb to act on it.
       * @var {Boolean} adventurejs.NounMustBe#in_inventory_if_takeable
       * @default false
       */
      this.in_inventory_if_takeable = false;

      /**
       * If true, Verb will not act on {@link adventurejs.Asset|Assets}
       * in player's inventory.
       * @var {Boolean} adventurejs.NounMustBe#not_in_inventory
       * @default false
       */
      this.not_in_inventory = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Asset|Assets}
       * worn by player.
       * @var {Boolean} adventurejs.NounMustBe#worn
       * @default false
       */
      this.worn = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Asset|Assets}
       * not worn by player.
       * @var {Boolean} adventurejs.NounMustBe#not_worn
       * @default false
       */
      this.not_worn = false;

      /**
       * If true, Verb will only act on {@link adventurejs.Asset|Assets}
       * in the player character's hands, such as held objects
       * like ropes.
       * @var {Boolean} adventurejs.NounMustBe#in_hands
       * @default false
       */
      this.in_hands = false;

      /**
       * If true, Verb will not act on {@link adventurejs.Asset|Assets}
       * in the player character's hands, such as held objects
       * like ropes.
       * @var {Boolean} adventurejs.NounMustBe#not_in_hands
       * @default false
       */
      this.not_in_hands = false;

      /**
       * If true, Verb will not act on items that are not singular, such as collections.
       * For example, author might make a collection to represent three drawers in a desk.
       * Though the collection itself is a single asset, it represents multiple other assets.
       * @var {Boolean} adventurejs.NounMustBe#singular
       * @default false
       */
      this.singular = false;

      /**
       * If true, Verb will not act on a group of items. This is distinct from singular.
       * For example, if player has three keys and tries to "unlock door with all keys",
       * "all keys" being plural will be rejected.
       * @var {Boolean} adventurejs.NounMustBe#singular
       * @default true
       */
      //this.single = true;

      /**
       * If true, Verb will only act on the parent object of the
       * player character.
       * @var {Boolean} adventurejs.NounMustBe#player_parent
       * @default false
       */
      this.player_parent = false;

      /**
       * If true, Verb will not act on the parent object of the player character.
       * @var {Boolean} adventurejs.NounMustBe#not_player_parent
       * @default false
       */
      this.not_player_parent = false;

      /**
       * If true, Verb will only act on noun1 if it is a child of noun2.
       * For verbs such as 'take a from b', where b must be in a
       * for verb to be relevant.
       * @var {Boolean} adventurejs.NounMustBe#child_of_noun2
       * @default false
       */
      this.child_of_noun2 = false;

      /**
       * If true, qualified object of noun2 will be excluded
       * from noun1. Chiefly intended for cases like 'put all in thing'
       * where 'thing' should not be included in 'all'.
       * @var {Boolean} adventurejs.NounMustBe#not_in_prior_plural
       * @default false
       */
      this.not_in_prior_plural = false;

      /**
       * If true, Verb will only act on strings, for example:
       * say "foo" to npc
       * @var {Boolean} adventurejs.NounMustBe#string
       * @default false
       */
      this.string = false;

      /**
       * If true, Verb will only act on
       * {@link adventurejs.Asset#is!global|global}
       * {@link adventurejs.Asset|Assets}
       * @var {Boolean} adventurejs.NounMustBe#global
       * @default false
       */
      this.global = false;

      /**
       * If true, Verb will not act on
       * {@link adventurejs.Asset#is!global|global}
       * {@link adventurejs.Asset|Assets}
       * @var {Boolean} adventurejs.NounMustBe#not_global
       * @default false
       */
      this.not_global = false;

      /**
       * If true, Verb will only act on
       * {@link adventurejs.Asset#Scenery|Scenery}
       * @var {Boolean} adventurejs.NounMustBe#scenery
       * @default false
       */
      this.scenery = false;

      /**
       * If true, Verb will not act on
       * {@link adventurejs.Asset#Scenery|Scenery}
       * @var {Boolean} adventurejs.NounMustBe#not_scenery
       * @default false
       */
      this.not_scenery = false;

      /**
       * If true, Verb will only act on
       * {@link adventurejs.Asset#Exit|Exits}
       * @var {Boolean} adventurejs.NounMustBe#exit
       * @default false
       */
      this.exit = false;

      /**
       * If true, Verb will not act on
       * {@link adventurejs.Asset#Exit|Exits}
       * @var {Boolean} adventurejs.NounMustBe#not_exit
       * @default false
       */
      this.not_exit = false;

      /**
       * If true, Verb will not act on
       * {@link adventurejs.Asset#Substance|Substances}
       * @var {Boolean} adventurejs.NounMustBe#not_substance
       * @default true
       */
      this.not_substance = false;

      /**
       * If true, Verb will only act on
       * {@link adventurejs.Asset#Substance|Substances}.
       * Looks for Substances in a present Vessel.
       * @var {Boolean} adventurejs.NounMustBe#
       * @default false
       */
      this.substance = false;

      /**
       * If true, Verb will only act on global_substance.
       * This is method for referring to a substance in the abstract
       * rather than to a specific portion of substance.
       *
       * @var {Boolean} adventurejs.NounMustBe#global_substance
       * @default false
       */
      this.global_substance = false;
    }
  }

  adventurejs.NounMustBe = NounMustBe;
})();

// patchVerb.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * A method to allow authors to revise predefined verbs.
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#patchVerb
   * @param {Object} patchVerb
   */
  p.patchVerb = function (patchVerb) {
    if ("object" !== typeof patchVerb) {
      var msg =
        "patchVerb takes an object, but received " +
        typeof patchVerb +
        ": " +
        patchVerb;
      this.game.log("warn", "critical", msg, "dictionary");
      return false;
    }
    if ("undefined" === typeof patchVerb.name) {
      var msg =
        "patchVerb received an object without a name: " +
        JSON.stringify(patchVerb);
      this.game.log("warn", "critical", msg, "dictionary");
      return false;
    }
    if ("undefined" === typeof this.verbs[patchVerb.name]) {
      var msg =
        "patchVerb received a verb name that doesn't exist: " + patchVerb.name;
      this.game.log("warn", "critical", msg, "dictionary");
      return false;
    }
    var verb = this.verbs[patchVerb.name];
    // for( var prop in patchVerb )
    // {
    //   if (patchVerb.hasOwnProperty(prop)) {
    //     verb[ prop ] = patchVerb[ prop ];
    //   }
    // }
    verb.set(patchVerb);
    verb.initialize(); // this adds but does not remove
    // TODO account for removal of words from verb_lookup

    if (false !== verb) {
      this.game.log(
        "log",
        "medium",
        "patchVerb successfully patched verb " + verb.name + ".",
        "dictionary"
      );
    }
    return verb;
  };
})();

// Phrase.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.Phrase
   * @ajsinternal
   * @ajsnavheading FrameworkReference
   * @summary Special class used to identify nouns that a verb can act on.
   * @classdesc
   * <p>
   * <strong>Phrase</strong> is a special class
   * used while parsing {@link adventurejs.Input|Input}
   * to refer to and set rules for noun / preposition pairs.
   * </p>
   */
  class Phrase {
    constructor() {
      /**
       * Currently unused.
       * @var {String} adventurejs.Verb#accepts_string
       *
       */
      this.accepts_string = false;

      /**
       * Currently unused.
       * @var {String} adventurejs.Verb#accepts_direction
       *
       */
      this.accepts_direction = false;

      /**
       * Currently unused.
       * @var {String} adventurejs.Verb#requires_string
       *
       */
      this.requires_string = false;

      /**
       * Currently unused.
       * @var {String} adventurejs.Verb#accepts_number
       *
       */
      this.accepts_number = false;

      /**
       * Currently unused.
       * @var {String} adventurejs.Verb#requires_number
       *
       */
      this.requires_number = false;

      /**
       * If accepts_noun is true, the verb will accept a noun
       * for this phrase. If requires_noun is false, verb
       * will work with one noun or no nouns.<br>
       * Examples: "look" or "look north"
       * @var {Boolean} adventurejs.Phrase#accepts_noun
       * @default false
       */
      this.accepts_noun = false;

      /**
       * If requires_noun is true, the verb must receive
       * a noun for this phrase.<br>
       * Examples: "go north" or "take thing"
       * @var {Boolean} adventurejs.Phrase#
       * @default false
       */
      this.requires_noun = false;

      /**
       * If accepts_preposition is true, it is possible, but not required,
       * to accept a preposition with noun3.<br>
       * @var {Boolean} adventurejs.Phrase#accepts_preposition
       * @default false
       */
      this.accepts_preposition = false;

      /**
       * If accepts_preposition_without_noun is true, parser will accept
       * a preposition that has no corresponding noun.<br>
       * Examples:<br>
       *  "fly over"<br>
       * @var {Boolean} adventurejs.Phrase#accepts_preposition_without_noun
       * @default false
       */
      this.accepts_preposition_without_noun = false;
      //this.preposition_requires_noun = true;

      /**
       * If requires_preposition is true, a preposition must be provided with noun3.<br>
       * @var {Boolean} adventurejs.Phrase#requires_preposition
       * @default false
       */
      this.requires_preposition = false;

      /**
       * Only these prepositions are allowed with this phrase.
       * @var {Boolean} adventurejs.Phrase#
       * @default false
       */
      this.accepts_these_prepositions = [];

      /**
       *
       * @var {Boolean} adventurejs.Phrase#
       * @default false
       */
      this.declines_these_prepositions = [];

      /**
       * When the player enters a verb and one or more nouns,
       * the parser will perform disambiguation to determine what
       * game object(s) match the player's input. You can use
       * these qualifiers to narrow down potential matches.
       * For example, if your verb only acts on tangible objects,
       * like "take" for instance, then set "tangible: true".
       * If your verb only applies to characters, like "talk to",
       * then uncomment "character: true". For more information, see
       * {@link adventurejs.NounMustBe|NounMustBe}. For more
       * information about creating Verbs or modifying Verbs, see
       * <a href="/doc/Scripting_VerbSubscriptions.html">Verb Subscriptions</a>,
       * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>,
       * <a href="/doc/Scripting_VerbActions.html">Verb Actions</a>,
       * <a href="/doc/Verbs_VerbAnatomy.html">Verb Anatomy</a>,
       * <a href="/doc/Verbs_VerbAnatomy.html">Verb Process</a>, or
       * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>.
       * @var {adventurejs.NounMustBe} adventurejs.Phrase#noun_must_be
       * @default false
       */
      this.noun_must_be = new adventurejs.NounMustBe();

      /**
       * can_be_plural means verb can act on multiple objects.<br>
       * Examples: <br>
       *  "take shield and sword"<br>
       *  "take all keys"<br>
       *  "take all"
       * @var {Boolean} adventurejs.Phrase#
       * @default false
       */
      this.accepts_plural_noun = false;

      //this.soft_prompt_for_noun = false;
      //this.soft_prompt_for_preposition = false;
    }
  }

  adventurejs.Phrase = Phrase;
})();

// postures.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Postures that can be applied to Characters.
   * @var {Object} adventurejs.Dictionary#postures
   */
  p.postures = {
    climb: {
      gerund: "climbing",
    },
    crawl: {
      gerund: "crawling",
    },
    float: {
      gerund: "float",
    },
    fly: {
      gerund: "fly",
    },
    hop: {
      gerund: "hopping",
    },
    hover: {
      gerund: "hover",
    },
    slither: {
      gerund: "slithering",
    },
    swim: {
      gerund: "swimming",
    },

    cling: {
      gerund: "clinging",
    },
    hang: {
      gerund: "hang",
    },
    kneel: {
      gerund: "kneel",
    },
    lie: {
      gerund: "lying",
    },
    sit: {
      gerund: "sitting",
    },
    stand: {
      gerund: "standing",
    },
  };
})();

// prepositions.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * These prepositions are recognized by the parser.
   * Some are the result of compound operations such as outfromunder.
   * @var {Object} adventurejs.Dictionary#prepositions
   */
  p.prepositions = [
    "above",
    "across",
    "against",
    "at",
    "attached",
    "behind",
    "beside",
    "between",
    "beyond",
    "from",
    "frombehind",
    "fromin",
    "fromon",
    "fromunder",
    "in",
    "infront",
    "off",
    "on",
    "out",
    "outfrombehind",
    "outfromunder",
    "over",
    "past",
    "through",
    "toward",
    "towards",
    "to",
    "under",
    "with",
    "up",
    "down",
  ];
})();

// pretty_exit_prepositions.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Pretty exit prepositions are used to describe leaving a nested position.
   * @var {Object} adventurejs.Dictionary#pretty_exit_prepositions
   */
  p.pretty_exit_prepositions = {
    behind: "out from behind",
    in: "out of",
    on: "off of",
    under: "out from under",
    over: "down from over",
    between: "out from between",
    beside: "from beside",
    across: "from across",
    attached: "from where it's attached to",
    through: "from",
  };
})();

// pronouns.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   * Pronoun groups include language for first person,
   * second person, plural, male third person,
   * female third person, nonbinary third person,
   * and nonhuman third person. These can be applied
   * to all of the default response strings built-in
   * to Adventurejs, by setting the person property.
   * @var {Object} adventurejs.Dictionary#pronouns
   */
  p.pronouns = {
    first: {
      we: "I",
      us: "me",
      "we've": "I've",
      "we'll": "I'll",
      "we're": "I'm",
      our: "my",
      ours: "mine",
      ourself: "myself",
      ourselves: "myself",
    },
    second: {
      we: "you",
      us: "you",
      "we've": "you've",
      "we'll": "you'll",
      "we're": "you're",
      our: "your",
      ours: "yours",
      ourself: "yourself",
      ourselves: "yourself",
    },
    plural: {
      we: "we",
      us: "us",
      "we've": "we've",
      "we'll": "we'll",
      "we're": "we're",
      our: "our",
      ours: "ours",
      ourself: "ourselves",
      ourselves: "ourselves",
    },
    male: {
      we: "he",
      us: "him",
      "we've": "he's",
      "we'll": "he'll",
      "we're": "he's",
      our: "his",
      ours: "his",
      ourself: "himself",
      ourselves: "himself",
    },
    female: {
      we: "she",
      us: "her",
      "we've": "she's",
      "we'll": "she'll",
      "we're": "she's",
      our: "her",
      ours: "hers",
      ourself: "herself",
      ourselves: "herself",
    },
    nonbinary: {
      we: "they",
      us: "them",
      "we've": "they've",
      "we'll": "they'll",
      "we're": "they're",
      our: "their",
      ours: "theirs",
      ourself: "themself",
      ourselves: "themself",
    },
    nonhuman: {
      we: "it",
      us: "it",
      "we've": "it's",
      "we'll": "it'll",
      "we're": "It's",
      our: "its",
      ours: "its",
      ourself: "itself",
      ourselves: "itself",
    },
  };
})();

// replaceVerb.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Dictionary.prototype;

  /**
   *
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#replaceVerb
   * @param {String} oldVerb
   * @param {Object} newVerb
   */
  p.replaceVerb = function (oldVerb, newVerb) {
    oldVerb = this.disableVerbs(oldVerb);
    newVerb = this.createVerb(newVerb);
    if (false !== newVerb) {
      this.game.log(
        "log",
        2,
        "replaceVerb successfully replaced verb " + newVerb.name + ".",
        "dictionary"
      );
    }
    return newVerb;
  };
})();

// set.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

  var p = adventurejs.Dictionary.prototype;
  
  /**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 *
   * @memberOf adventurejs.Dictionary
	 * @method adventurejs.Dictionary#set
	 * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
	 * @returns {adventurejs.Dictionary} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function Dictionary_set(props) {
		if (props != null) {
			for (var n in props) { 
				this[n] = props[n]; 
			}
		}
		return this;
	};

}());

// string_lookup.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Dictionary.prototype;

  /**
  * A lookup table for strings to describe ranges, such as temperature.
  * @var {Object} adventurejs.Dictionary#string_lookup
  * @default {}
  */
  p.string_lookup = 
  {

  /**
    * Lookup table for prepositions that describe Aspects.
    * @var {Object} adventurejs.Dictionary#string_lookup.prepositions
    * @todo add ability to set new prepositions?
    * @todo revisit - is this needed? not currently using but can see case for 'attached to'
    */
    prepositions: 
    {
      "attached": "attached to",
      "behind": "behind",
      "in": "in",
      "on": "on",
      "over": "over",
      "through": "through",
      "under": "under",
      "worn": "worn", /* experimental */
    },


  /**
    * Lookup table for strings that describe the player's position.
    * @var {Object} adventurejs.Dictionary#string_lookup#positions
    */
    posture_positions:
    {
      "default": "resting",
      "resting": "resting",
      "lying": "lying",
      "sitting": "sitting",
      "standing": "standing",
      "hanging": "hanging",
      "suspended": "suspended",
      "floating": "floating",
      "tied": "tied",
    },

  /**
    * Lookup table for strings that provide a gerund 
    * to describe the player's current posture.
    * @var {Object} adventurejs.Dictionary#string_lookup#posture_gerunds
    */
    posture_gerunds:
    {
      "climb":"climbing",
      "cling":"clinging",
      "crawl":"crawling",
      "float":"floating",
      "fly":"flying",
      "hang":"hanging",
      "hover":"hovering",
      "kneel":"kneeling",
      "lie":"lying",
      "sit":"sitting",
      "slither":"slithering",
      "stand":"standing",
      "swim":"swimming",
    },

  /**
    * Lookup table for strings that provide a gerund 
    * to describe the player's movement.
    * @var {Object} adventurejs.Dictionary#string_lookup#movement_gerunds
    */
   movement_verbs:
   {
      "climb":"climb",
      "cling":"shinny",
      "crawl":"crawl",
      "float":"float",
      "fly":"fly",
      "hang":"hang",
      "hover":"hover",
      "kneel":"crawl",
      "lie":"belly crawl",
      "sit":"scoot",
      "slither":"slither",
      "stand":"walk",
      "swim":"swim",
   },

  /**
    * Lookup table for strings that describe how full of 
    * {@link adventurejs.Substance|Substance} is a 
    * {@link adventurejs.Vessel|Vessel}.
    * @var {Object} adventurejs.Dictionary#string_lookup#substance_percents
    */
    substance_percents:
    {
      "0" : "empty",
      "0.0" : "empty",
      "0.1" : "slightly full",
      "0.2" : "about a quarter full",
      "0.3" : "about a third full",
      "0.4" : "almost half full",
      "0.5" : "half full",
      "0.6" : "slightly over half full",
      "0.7" : "about three quarters full",
      "0.8" : "mostly full",
      "0.9" : "about full",
      "1.0" : "full",
      "1" : "full",
    },

  /**
    * Lookup table for strings that describe temperature of 
    * {@link adventurejs.Substance|Substance} in a 
    * {@link adventurejs.Vessel|Vessel}.
    * @var {Object} adventurejs.Dictionary#string_lookup#substance_temperatures
    */
    substance_temperatures:
    {
      "0" : "freezing",
      "5" : "near freezing",
      "10" : "chilled",
      "14" : "cold",
      "17" : "cool",
      "20" : "tepid",
      "23" : "lukewarm",
      "40" : "warm",
      "60" : "hot",
      "85" : "scalding",
      "90" : "near boiling",
      "100" : "boiling",
    },
  }  

 /**
  * 
  * @memberOf adventurejs.Dictionary
  * @method adventurejs.Dictionary#getStringLookup
  * @param {string} type The type to look up, ie "prepositions" 
  * or "posture_gerunds".
  * @param {string} value The value to look up, ie "standing" or "0.1".
  * @returns {string}
  */
  p.getStringLookup = function Dictionary_getStringLookup( type, value ) 
  {
    var see = "See adventurejs.Dictionary.html#getStringLookup. ";
    if( "string" !== typeof type )
    {
      var msg = "Dictionary.getStringLookup received a non-string for type. " 
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
      return '';
    }
    if( "string" !== typeof value )
    {
      var msg = "Dictionary.getStringLookup received a non-string for " 
        + type
        + "value. " 
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
      return '';
    }
    if( "undefined" === typeof this.string_lookup[type] )
    {
      var msg = "Dictionary.getStringLookup received a non-existent type: "
        + type
        + ". "
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
      return '';
    }
    if( "undefined" === typeof this.string_lookup[type][value] )
    {
      var msg = "Dictionary.getStringLookup received a non-existent value of "
        + type 
        + ": " 
        + value
        + ". " 
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
      return '';
    }
    return this.string_lookup[type][value];
  }

 /**
  * 
  * @memberOf adventurejs.Dictionary
  * @method adventurejs.Dictionary#setStringLookup
  * @param {string} type The type to set, ie "prepositions" 
  * or "posture_gerunds".
  * @param {object} values An object containing values to set, 
  * ie {"standing":"standing up"} or {"0":"empty","1":"full"}.
  * @returns {boolean}
  */
  p.setStringLookup = function Dictionary_setStringLookup( type, values ) 
  {
    var see = "See adventurejs.Dictionary.html#setStringLookup. ";
    if( "string" !== typeof type )
    {
      var msg = "Dictionary.setStringLookup received a non-string for type. " 
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
      return false;
    }
    if( "object" !== typeof values )
    {
      var msg = "Dictionary.getStringLookup received a non-object for " 
        + type
        + " values. " 
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
      //console.warn( 'a' );
      return false;
    }
    if( "undefined" === typeof this.string_lookup[type] )
    {
      this.string_lookup[type] = {};
      var msg = "Dictionary.getStringLookup received a non-existent type: "
        + type
        + ". adventurejs will try to add this type. "
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
    }

    var valuekeys = Object.keys(values);
    for(var v=0; v<valuekeys.length; v++)
    {
      var valuekey = valuekeys[v];      
      this.string_lookup[type][valuekey] = values[valuekey];
    }

    msg = "Dictionary.setStringLookup: " + JSON.stringify(this.string_lookup[type]);
    this.game.log( "log", "high", msg , 'dictionary' );

    return true;

  }



/*
// this sorts by value
var list = {"you": 100, "me": 75, "foo": 116, "bar": 15};
keysSorted = Object.keys(list).sort(function(a,b){return list[a]-list[b]})
console.log(keysSorted);     

// this sorts by key
var list = {"100": "you", "75":"me", "116":"foo", "15":"bar"};console.log("Object.keys(list): " + Object.keys(list));     
keysSorted = Object.keys(list).sort(function(a,b){return a-b})
console.log("keysSorted: " + keysSorted);     
*/

 /**
  * 
  * @memberOf adventurejs.Dictionary
  * @method adventurejs.Dictionary#getStringLookupByRange
  * @param {string} type The type to look up, ie "prepositions" 
  * or "posture_gerunds".
  * @param {string|number} value The numerical value to look up, ie "70" or "0.1".
  * @returns {string}
  */
  p.getStringLookupByRange = function Dictionary_getStringLookupByRange( type, value ) 
  {
    var see = "See adventurejs.Dictionary.html#getStringLookupByRange. ";
    var str_return = '';
    var keysSorted;

    if( "string" !== typeof type )
    {
      var msg = "Dictionary.getStringLookupByRange received a non-string for type. " 
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
    }
    if( isNaN(value) )
    {
      var msg = "Dictionary.getStringLookupByRange received a non-numerical value for " 
        + type
        + " value. " 
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
    }
    if( "undefined" === typeof this.string_lookup[type] )
    {
      var msg = "Dictionary.getStringLookup received a non-existent type: "
        + type
        + ". "
        + see;
      this.game.log("warn","critical",msg, 'dictionary' );
      return '';
    }

    keysSorted = Object.keys( this.string_lookup[type] ).sort(function(a,b){return a-b});
    for(var i = 0; i < keysSorted.length; i++)
    {
      if( Number(value) >= keysSorted[i] ) 
      {
        str_return = this.string_lookup[type][keysSorted[i]];
      }      
    }

    return str_return;
  }



}());


// testVerbSynonyms.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Dictionary.prototype;

  /**
   * Takes two verb names and checks to see if they're synonyms. 
   * @memberOf adventurejs.Dictionary
   * @method adventurejs.Dictionary#testVerbSynonyms
   * @kind function
   * @param  {String} word1 An unclassed verb object.
   * @returns {Verb} The constructed verb
   */
   p.testVerbSynonyms = function Dictionary_testVerbSynonyms( word1, word2 ) 
  {
		var prop, testword;

		// this is a private function so input is probably trustworthy
		if( word1 === word2 ) 
    {
			return true;
		}

		// check that both are strings
		if( "string" !== typeof word1 || "string" !== typeof word2 ) 
    {
			// warn because input is bad
			console.warn( 
				"synonyms function takes two strings, but received:", word1, word2 
			);
			return false;
		}

		// check if both verbs are undefined
		if( "undefined" === typeof this.verb_lookup[word1] && "undefined" === typeof this.verb_lookup[word2] ) 
    {
			// warn because input is bad
			console.warn( 
				"Neither " + word1 + " nor " + word2 + " were found in the dictionary."
			);
			return false;
		}

		// check that both aren't unique verbs
		if( "undefined" !== typeof this.verb_lookup[word1] && "undefined" !== typeof this.verb_lookup[word2] ) 
    {
			return false;
		}

		if( "undefined" === typeof this.verb_lookup[word1] ) 
    {
			testword = word1;
			prop = word2;
		} 
    else 
    {
			testword = word2;
			prop = word1;
		}

		//console.log( "prop, testword", prop, testword);
    var synonyms = this.verb_lookup[prop].synonyms;

    // error check
    if( "undefined" === typeof synonyms ) return false;

		for(var i = 0; i < synonyms.length;i++) 
    {
			if(testword===synonyms[i]) 
      {
				// found a match, return prop testword of synonym
				return prop;
			}
		}
		return false;
	}
  
}());

// Verb.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.Verb
   * @param {adventurejs.Game} game A reference to the game instance.
   * @ajsnavheading FrameworkReference
   * @summary Framework class that all verbs are instanced from.
   * @classdesc
   * <p>
   * <strong>Verb</strong> is the base class for all Verb
   * instances. {@link adventurejs} comes with over 100
   * predefined Verbs, each with logic to support
   * all of the predefined {@link adventurejs.Asset|Asset}
   * classes. You can get pretty far using the predefined
   * Verbs and Assets. Naturally, you're going to have
   * ideas that don't fit the predefined logic. adventurejs
   * provides several methods to modify Verbs, which range
   * in complexity from making small edits all the way up
   * to writing new Verbs from scratch.
   * </p>
   * <ul>
   *
   * <li>{@link adventurejs.Dictionary#patchVerb|patchVerb()}
   * lets an author replace only selected properties
   * and methods of any predefined Verb.</li>
   *
   * <li>{@link adventurejs.Dictionary#replaceVerb|replaceVerb()}
   * lets an author completely replace any of the predefined
   * Verbs.</li>
   *
   * <li>{@link adventurejs.Dictionary#combineVerbs|combineVerbs()}
   * lets an author consolidate predefined Verbs. Some of
   * the predefined Verbs exist to catch subtle distinctions
   * that may not be necessary for your game. For instance,
   * <code class="property">twist</code> and
   * <code class="property">turn</code> are predefined
   * as distinct Verbs. If you don't need that level of
   * distinction, you can use combineVerbs to
   * consolidate them.</li>
   *
   * <li>{@link adventurejs.Dictionary#disableVerbs|disableVerbs()}
   * lets an author delete specified Verbs from their game's
   * {@link adventurejs.Dictionary|Dictionary}. Useful when
   * you don't want to support certain Verbs.</li>
   *
   * <li>{@link adventurejs.Dictionary#enableVerbs|enableVerbs()}
   * lets an author re-enable Verbs that have been disabled.</li>
   *
   * <li>{@link adventurejs.Dictionary#disableAllVerbsBut|disableAllVerbsBut()}
   * lets an author disable all but specified Verbs. Useful
   * for creating a game with limited language. </li>
   *
   * <li>{@link adventurejs.Dictionary#createVerb|createVerb()}
   * lets an author create a new Verb from scratch.</li>
   *
   * <li>{@link adventurejs.Dictionary#doVerb|doVerb()}
   * lets an author call a Verb from custom code
   * during runtime.</li>
   *
   * </ul>
   * <h3 class="examples">Examples:</h3>
   * <pre class="display"><code class="language-javascript"><h4>// patchVerb()</h4>
   * MyGame.patchVerb({
   *   name: "crawl",
   *   prettyname: "wriggle", // change prettyname
   * });
   * </code></pre>
   * <br>
   * <pre class="display"><code class="language-javascript"><h4>//replaceVerb()</h4>
   * MyGame.replaceVerb( "xyzzy", {
   *   name: "xyzzy",
   *   prettyname: "xyzzy",
   *   synonyms: [],
   *   do: function( params )
   *   {
   *     console.log( "verbs.do" );
   *     var msg = "Clever xyzzy response!";
   *     if(msg) this.game.print( msg, MyGame.input.output_class );
   *     return params
   *   },
   * });
   * </code></pre>
   * <br>
   * <pre class="display"><code class="language-javascript"><h4>// combineVerbs()</h4>
   * MyGame.combineVerbs( [ "twist" ], "turn" );
   * </code></pre>
   * <br>
   * <pre class="display"><code class="language-javascript"><h4>// disableVerbs()</h4>
   * MyGame.disableVerbs( [ "lick", "eat" ] );
   * </code></pre>
   * <br>
   * <pre class="display"><code class="language-javascript"><h4>// enableVerbs()</h4>
   * MyGame.enableVerbs( [ "lick", "eat" ] );
   * </code></pre>
   * <br>
   * <pre class="display"><code class="language-javascript"><h4>// disableAllVerbsBut()</h4>
   * MyGame.disableAllVerbsBut( [ "look", "examine" ] );
   * </code></pre>
   * <br>
   * <pre class="display"><code class="language-javascript"><h4>// createVerb()</h4>
   * MyGame.createVerb({
   *   name: "blab_about_noun1",
   *   prettyname: "blab about",
   *   verb_prep_noun: [ "blab about" ], // blab about thing
   *   verb_noun_prep_noun: [ "blab about" ], // blab person about thing
   *   doTry: function( input )
   *   {
   *     [insert logic here]
   *     return true;
   *   },
   *   doSuccess: function( input )
   *   {
   *     [insert logic here]
   *     return true;
   *   },
   * });
   * </code></pre>
   * <br>
   * <pre class="display"><code class="language-javascript"><h4>// doVerb() (call during runtime)</h4>
   * this.game.dictionary.doVerb("xyzzy");
   * </code></pre>
   * <p>
   * For more information about creating Verbs or modifying Verbs, see
   * <a href="/doc/Scripting_VerbSubscriptions.html">Verb Subscriptions</a>,
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>,
   * <a href="/doc/Scripting_VerbActions.html">Verb Actions</a>,
   * <a href="/doc/Verbs_VerbAnatomy.html">Verb Anatomy</a>,
   * <a href="/doc/Verbs_VerbProcess.html">Verb Process</a>, or
   * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>.
   * </p>
   */
  class Verb {
    constructor(game) {
      /**
       * A reference back to the main {@link adventurejs.Game|Game} object.
       * @var {Object} adventurejs.Verb#game
       * @default {}
       */
      this.game = game;

      /**
       * A shortcut to the main {@link adventurejs.Game|Game}
       * {@link adventurejs.Dictionary|Dictionary}.
       * @var {Object} adventurejs.Verb#dictionary
       * @default {}
       */
      this.dictionary = game.dictionary;

      /**
       * May be used to help narrow verb selections in ambiguous situations.
       * @var {String} adventurejs.Verb#type
       * @default ""
       *
       */
      this.type = {
        travel: false,
        manipulation: false,
        direction: false,
        locomotion: false,
      };

      /**
       * Extension verbs may perform some contextual logic before forwarding
       * to another verb for the bulk of logic, such as "crawl" -> "go".
       * @var {String} adventurejs.Verb#extends
       * @default ""
       *
       */
      this.extends = "";

      /**
       * String provided in Verb definition file (aka preverb).
       * @var {String} adventurejs.Verb#name
       * @default ""
       *
       */
      this.name = "";

      /**
       * String provided in verb definition file. The prettyname
       * is used for printing, and can include spaces,
       * ie ask prints as "ask about".
       * @var {String} adventurejs.Verb#prettyname
       *
       */
      this.prettyname = "";

      /**
       * The past tense of the verb. May be used in output strings.
       * @var {String} adventurejs.Verb#past_tense
       *
       */
      this.past_tense = "";

      /**
       * <code>state</code> is an optional property for verbs that apply
       * state to assets, such as close and lock. For example, "close door"
       * will set door.is.closed to true. When used, state will contain the
       * state to be set true on an asset. In the case of close, its state
       * would be "closed".
       * @var {String} adventurejs.Verb#state
       */
      this.state = "";

      /**
       * <code>unstate</code> is an optional property for verbs that unset
       * state from assets, such as open and unlock. For example, "open door"
       * will set door.is.closed to false. When used, unstate will contain the
       * state to be set false on an asset. In the case of open, its unstate
       * would be "closed".
       * @var {String} adventurejs.Verb#unstate
       */
      this.unstate = "";

      /**
       * <code>state_strings</code> is an optional property for verbs that is
       * used to provide string substitutions for authors using the string
       * substitution form of $(sink drain is| plugged or| unplugged).
       * Because "unplugged" isn't a proper verb state, we'll use this as a
       * reverse lookup to test whether the asset, sink_drain in this case,
       * is subscribed to the relevant verb and has the specified state.
       * state_strings only apply to direct objects.
       * @var {String} adventurejs.Verb#state_strings
       */
      this.state_strings = { state: "", unstate: "" };

      /**
       * <code>with_params</code> can contain properties specific to this verb
       * that may be applied to assets which are objects of the verb. For example:
       * the verb <code class="property">plugIn</code> has
       * <code class="property">with_params.max_connections</code>,
       * and in the case of something like a power cable that can be plugged in at
       * both ends, an author could set its
       * <code>asset.dov.plugIn.with_params.max_connections</code>
       * to 2.
       */
      this.with_params = {};

      /**
       * <code>linked_params</code> are params in with_params that are used
       * to store the IDs of assets that share state as a result of being
       * acted upon by this verb. For example: the verb
       * <code class="property">plugIn</code> connects a direct object with
       * an indirect object, and both assets need a reference back to the other.
       */
      this.linked_params = [];

      /**
       * Verb.adjectives are for direction verbs so that, for example,
       * 'south' can be associated with 'southern' and 'southernly'.
       * @var {String} adventurejs.Verb#adjectives
       *
       */
      this.adjectives = [];

      /**
       * <strong>player_must_be</strong> sets conditions that the
       * Player Character must meet in order for the Verb to act.
       * @var {Object} adventurejs.Verb#player_must_be
       * @default {}
       */
      this.player_must_be = {
        not_constrained: true,
        not_on_floor: false,
        not_under: false,
        not_behind: false,
        not_nested_elsewhere: false,
        //not_on_target: false, // used for from/to
        //on_origin: false, // used for from/to
      };

      /**
       * Setting this to true allows you to write your own
       * disambiguation script. Warning: going off road!
       * Recommended for experienced Javascript users.
       * @var {Boolean} adventurejs.Verb#let_verb_handle_disambiguation
       * @default false
       */
      this.let_verb_handle_disambiguation = false;

      /**
       * When input is parsed, parse the verb and then pass the
       * remainder of the input to the verb as a string, for the
       * verb to act on. Chief example is: "oops xxx" where we don't
       * want to parse xxx, we just want to let oops use it as a
       * substitute for last turn's unknown input.
       * @var {Boolean} adventurejs.Verb#let_verb_handle_remaining_input
       * @default false
       */
      this.let_verb_handle_remaining_input = false;

      /**
       * Some types of objects can accept 'in' for 'on'
       * interchangeably, such as 'sit in chair' / 'sit on chair',
       * or 'lie in bed' / 'lie on bed'.
       * @var {Boolean} adventurejs.Verb#in_can_mean_on
       * @default false
       */
      this.in_can_mean_on = false;

      /**
       * Set whether verb is a direction verb.
       * @var {Boolean} adventurejs.Verb#is_direction
       * @default false
       */
      this.is_direction = false;

      /**
       * Set whether direction verb is a compass direction,
       * meaning, it can be found on a compass rose.
       * @var {Boolean} adventurejs.Verb#is_compass_direction
       * @default false
       */
      this.is_compass_direction = false;

      /**
       * Set whether direction verb is a relative direction
       * such as those used on ships: port, starboard, etc.
       * Also applies to left, right, forward, back, etc.
       * @var {Boolean} adventurejs.Verb#is_spatial_direction
       * @default false
       */
      this.is_spatial_direction = false;

      /**
       * Set whether a direction can be referred to with an
       * article, as in "there is a door to the north" vs
       * "there is a door to starboard". This is a bit of mixed
       * purpose because this property doesn't apply to the verb,
       * but is stored in directionLookup for reference with
       * directions.
       * @var {Boolean} adventurejs.Verb#article
       * @default false
       */
      this.article = "";

      /**
       * When player travels, this string may be prepended before
       * the verb name, such as "you walk to the north"
       * @var {Boolean} adventurejs.Verb#direction_preposition
       * @default ""
       */
      this.direction_preposition = "";

      this.phrase1 = new adventurejs.Phrase();
      this.phrase2 = new adventurejs.Phrase();
      this.phrase3 = new adventurejs.Phrase();

      this.accepts_structures = [];

      this.accepts_adverb = false;
      this.accepts_adverbs = [];

      /**
       * To simplify identifying verbs in input,
       * specifically with regards to adverbs & prepositions,
       * we can provide a list of synonyms for the verb.
       * The parser will look for these synonyms in the input
       * and replace them with the verb name. Then, the verb
       * can handle the adverb/preposition as it sees fit.
       * @var {Object} adventurejs.Verb#input_substitutions
       * @default {}
       */
      this.input_substitutions = {};

      /**
       * Provides a simple method for an author to override all failure messages
       * for a verb with one generic string.
       * @var {String} adventurejs.Verb#override_verb_failure_msg
       * @default undefined
       *
       */
      this.override_verb_failure_msg = "";

      /**
       * Provides a simple method for an author to override success messages
       * for a verb with one generic string.
       * @var {String} adventurejs.Verb#override_verb_success_msg
       * @default undefined
       *
       */
      this.override_verb_success_msg = "";

      this.msgNoObject = "";
      this.msgNoAspect = "";

      /**
       * <code>related</code> is an array of related verbs, intended for use
       * with tryToInferIndirectObject. Depending on a game's settings, some
       * verbs may be applied automatically, but only when a user has already
       * applied the verb themselves. For example, an author might not want a
       * door to be opened automatically because the player should bring
       * intention to the action of opening it, in order to appreciate the
       * consequences. tryToInferIndirectObject considers whether a verb has
       * previously been applied to an asset. In some cases, the verb's
       * opposing verb may also be considered. For example, whether the player
       * unlocked a door, or picked it, or locked it themselves, we consider
       * them to have interacted with it.
       * @var {Array} adventurejs.Verb#related
       */
      this.related = [];

      /**
       * <code>enqueue_collections</code> if true allows a verb to
       * unbundle the members of a collection in order to queue up
       * separate actions for each. For example, "gems" is a collection
       * that refers to three unique assets; "diamond", "emerald"
       * and "ruby". If take.enqueue_collections is true, "take gems"
       * will act individually on the diamond, the emerald and the ruby.
       * Only applies to direct object.
       * @var {Array} adventurejs.Verb#enqueue_collections
       * @default false
       */
      this.enqueue_collections = false;

      return this;
    }

    /**
     * Return uppercase name of the verb.
     * @var {Getter} adventurejs.Verb#Name
     * @default []
     */
    get Name() {
      return A.propercase(this.name);
    }

    /**
     * Returns "try[Verb]This" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#tryVerbThis
     */
    get tryVerbThis() {
      return "try" + this.Name + "This";
    }

    /**
     * Returns "try[Verb]WithThis" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#tryVerbWithThis
     */
    get tryVerbWithThis() {
      return "try" + this.Name + "WithThis";
    }

    /**
     * Returns "try[Verb]FromThis" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#tryVerbFromThis
     */
    get tryVerbFromThis() {
      return "try" + this.Name + "FromThis";
    }

    /**
     * Returns "try[Verb]ThisWithThat" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#tryVerbThisWithThat
     */
    get tryVerbThisWithThat() {
      return "try" + this.Name + "ThisWithThat";
    }

    /**
     * Returns "try[Verb]ThatWithThis" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#tryVerbThatWithThis
     */
    get tryVerbThatWithThis() {
      return "try" + this.Name + "ThatWithThis";
    }

    /**
     * Returns "try[Verb]ThisFromThat" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#tryVerbThisFromThat
     */
    get tryVerbThisFromThat() {
      return "try" + this.Name + "ThisFromThat";
    }

    /**
     * Returns "try[Verb]ThatFromThis" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#tryVerbThatFromThis
     */
    get tryVerbThatFromThis() {
      return "try" + this.Name + "ThatFromThis";
    }

    /**
     * Returns "do[Verb]This" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#doVerb
     */
    get doVerb() {
      return `do${this.Name}`;
    }

    /**
     * Returns "do[Verb]This" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#doVerbThis
     */
    get doVerbThis() {
      return `do${this.Name}This`;
    }

    /**
     * Returns "do[Verb]FromThis" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#doVerbFromThis
     */
    get doVerbFromThis() {
      return `do${this.Name}FromThis`;
    }

    /**
     * Returns "do[Verb]WithThis" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#doVerbWithThis
     */
    get doVerbWithThis() {
      return `do${this.Name}WithThis`;
    }

    /**
     * Returns "do[Verb]ThisWithThat" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#doVerbThisWithThat
     */
    get doVerbThisWithThat() {
      return `do${this.Name}ThisWithThat`;
    }

    /**
     * Returns "do[Verb]ThatWithThis" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#doVerbThatWithThis
     */
    get doVerbThatWithThis() {
      return `do${this.Name}ThatWithThis`;
    }

    /**
     * Returns "do[Verb]ThisFromThat" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#doVerbThisFromThat
     */
    get doVerbThisFromThat() {
      return `do${this.Name}ThisFromThat`;
    }

    /**
     * Returns "do[Verb]ThatFromThis" for consistency with callAction()
     * @var {Getter} adventurejs.Verb#doVerbThatFromThis
     */
    get doVerbThatFromThis() {
      return `do${this.Name}ThatFromThis`;
    }

    /**
     * <strong>synonyms</strong> provide alternate words for verbs,
     * such as "get" for "take".
     * @var {Getter/Setter} adventurejs.Verb#synonyms
     * @default []
     */
    get synonyms() {
      return this._synonyms;
    }
    set synonyms(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (false === Array.isArray(this._synonyms)) {
        this._synonyms = [];
      }

      // apply new words
      this._synonyms = arr;

      // ensure verb name is in synonyms
      if (-1 === this._synonyms.indexOf(this.name)) {
        this._synonyms.push(this.name);
      }
    }

    /**
     * For phrases like "jump from branch to vine" or
     * "look at sun with glasses", where we have a verb + preposition
     * followed by a noun and then another preposition
     * @var {Array} adventurejs.Verb#verb_prep_noun_prep_noun
     * @default []
     */
    get verb_prep_noun_prep_noun() {
      return this._verb_prep_noun_prep_noun;
    }
    set verb_prep_noun_prep_noun(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (!Array.isArray(this._verb_prep_noun_prep_noun)) {
        this._verb_prep_noun_prep_noun = [];
      }

      // remove all prior words from dictionary,
      // in case this verb is being redefined
      if (0 < this._verb_prep_noun_prep_noun.length) {
        for (var i = this._verb_prep_noun_prep_noun.length; i > -1; i--) {
          var pair = [this._verb_prep_noun_prep_noun[i], this.name];
          var index = A.indexOfSubarray(
            pair,
            this.dictionary.verb_prep_noun_prep_nouns
          );
          if (-1 !== index) {
            this.dictionary.verb_prep_noun_prep_nouns.splice(index, 1);
          }
        }
      }

      // add new words to lookup
      if (arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
          this.dictionary.verb_prep_noun_prep_nouns.push([arr[i], this.name]);
        }
      }

      // apply new words
      this._verb_prep_noun_prep_noun = arr;
    }

    /**
     * For verb/noun pairs with a trailing preposition,
     * or more likely a direction, such as "push bed north".
     *
     * When player input is parsed, they'll be concatenated,
     * eg to "pushnorth bed".
     * @var {Array} adventurejs.Verb#verb_noun_prep
     * @default []
     */
    get verb_noun_prep() {
      return this._verb_noun_prep;
    }
    set verb_noun_prep(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (false === Array.isArray(this._verb_noun_prep)) {
        this._verb_noun_prep = [];
      }

      // remove all prior words from dictionary,
      // in case this verb is being redefined
      if (0 < this._verb_noun_prep.length) {
        for (var i = this._verb_noun_prep.length; i > -1; i--) {
          var pair = [this._verb_noun_prep[i], this.name];
          var index = A.indexOfSubarray(pair, this.dictionary.verb_noun_preps);
          if (-1 !== index) {
            this.dictionary.verb_noun_preps.splice(index, 1);
          }
        }
      }

      // add new words to lookup
      if (arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
          this.dictionary.verb_noun_preps.push([arr[i], this.name]);
        }
      }

      // apply new words
      this._verb_noun_prep = arr;
    }

    /**
     * For verb/preposition pairs separated by a space,
     * such as "go to" or "look at".
     *
     * When player input is parsed, they'll be concatenated,
     * eg "go to" to "goTo".
     * @var {Array} adventurejs.Verb#verb_prep_noun
     * @default []
     */
    get verb_prep_noun() {
      return this._verb_prep_noun;
    }
    set verb_prep_noun(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (false === Array.isArray(this._verb_prep_noun)) {
        this._verb_prep_noun = [];
      }

      // remove all prior words from dictionary,
      // in case this verb is being redefined
      if (0 < this._verb_prep_noun.length) {
        for (var i = this._verb_prep_noun.length; i > -1; i--) {
          var pair = [this._verb_prep_noun[i], this.name];
          var index = A.indexOfSubarray(pair, this.dictionary.verb_prep_nouns);
          if (-1 !== index) {
            this.dictionary.verb_prep_nouns.splice(index, 1);
          }
        }
      }

      // add new words to lookup
      if (arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
          this.dictionary.verb_prep_nouns.push([arr[i], this.name]);
        }
      }

      // apply new words
      this._verb_prep_noun = arr;
    }

    /**
     * For compound preps separated by spaces, verb/prep/prep,
     * such as "get out of"
     * @var {Array} adventurejs.Verb#verb_prep_prep_noun
     * @default []
     */
    get verb_prep_prep_noun() {
      return this._verb_prep_prep_noun;
    }
    set verb_prep_prep_noun(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (false === Array.isArray(this._verb_prep_prep_noun)) {
        this._verb_prep_prep_noun = [];
      }

      // remove all prior words from dictionary,
      // in case this verb is being redefined
      if (0 < this._verb_prep_prep_noun.length) {
        for (var i = this._verb_prep_prep_noun.length; i > -1; i--) {
          var pair = [this._verb_prep_prep_noun[i], this.name];
          var index = A.indexOfSubarray(
            pair,
            this.dictionary.verb_prep_prep_nouns
          );
          if (-1 !== index) {
            this.dictionary.verb_prep_prep_nouns.splice(index, 1);
          }
        }
      }

      // add new words to lookup
      if (arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
          this.dictionary.verb_prep_prep_nouns.push([arr[i], this.name]);
        }
      }

      // apply new words
      this._verb_prep_prep_noun = arr;
    }

    /**
     * For three part compound preps, verb/prep/prep/prep,
     * such as "get out from behind"
     * @var {Array} adventurejs.Verb#verb_prep_prep_prep_noun
     * @default []
     */
    get verb_prep_prep_prep_noun() {
      return this._verb_prep_prep_prep_noun;
    }
    set verb_prep_prep_prep_noun(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (false === Array.isArray(this._verb_prep_prep_prep_noun)) {
        this._verb_prep_prep_prep_noun = [];
      }

      // remove all prior words from dictionary,
      // in case this verb is being redefined
      if (0 < this._verb_prep_prep_prep_noun.length) {
        for (var i = this._verb_prep_prep_prep_noun.length; i > -1; i--) {
          var pair = [this._verb_prep_prep_prep_noun[i], this.name];
          var index = A.indexOfSubarray(
            pair,
            this.dictionary.verb_prep_prep_prep_nouns
          );
          if (-1 !== index) {
            this.dictionary.verb_prep_prep_prep_nouns.splice(index, 1);
          }
        }
      }

      // add new words to lookup
      if (arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
          this.dictionary.verb_prep_prep_prep_nouns.push([arr[i], this.name]);
        }
      }

      // apply new words
      this._verb_prep_prep_prep_noun = arr;
    }

    /**
     * For verb/preposition pairs separated by another word,
     * usually a noun,
     * such as "lock door with key" or "take sword from stone".
     * When player input is parsed, they'll be concatenated,
     * eg to "lockwith door key" or "takefrom sword stone".
     * <br><br>
     * Though verb_prep_noun and verb_noun_prep_noun look similar, the reason
     * they are separate fields is because we have to use
     * different regex patterns to find each type in user input.
     * @var {Array} adventurejs.Verb#verb_noun_prep_noun
     * @default []
     */
    get verb_noun_prep_noun() {
      return this._verb_noun_prep;
    }
    set verb_noun_prep_noun(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (false === Array.isArray(this._verb_noun_prep_noun)) {
        this._verb_noun_prep_noun = [];
      }
      // remove all prior words from dictionary,
      // in case this verb is being redefined
      if (0 < this._verb_noun_prep_noun.length) {
        for (var i = this._verb_noun_prep_noun.length; i > -1; i--) {
          var pair = [this._verb_noun_prep_noun[i], this.name];
          var index = A.indexOfSubarray(
            pair,
            this.dictionary.verb_noun_prep_nouns
          );
          if (-1 !== index) {
            this.dictionary.verb_noun_prep_nouns.splice(index, 1);
          }
        }
      }

      // add new words to lookup
      if (arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
          this.dictionary.verb_noun_prep_nouns.push([arr[i], this.name]);
        }
      }

      // apply new words
      this._verb_noun_prep_noun = arr;
    }

    /**
     * For a verb phrase with two nouns and two prepositions.
     * For example, in the phrase "take skateboard from under bed",
     * we're looking for "take" and "from" and "under",
     * and we would parse the phrase as "takefromunder skateboard bed"
     * @var {Array} adventurejs.Verb#verb_noun_prep_prep_noun
     * @default []
     */
    get verb_noun_prep_prep_noun() {
      return this._verb_noun_prep;
    }
    set verb_noun_prep_prep_noun(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (false === Array.isArray(this._verb_noun_prep_prep_noun)) {
        this._verb_noun_prep_prep_noun = [];
      }
      // remove all prior words from dictionary,
      // in case this verb is being redefined
      if (0 < this._verb_noun_prep_prep_noun.length) {
        for (var i = this._verb_noun_prep_prep_noun.length; i > -1; i--) {
          var pair = [this._verb_noun_prep_prep_noun[i], this.name];
          var index = A.indexOfSubarray(
            pair,
            this.dictionary.verb_noun_prep_prep_nouns
          );
          if (-1 !== index) {
            this.dictionary.verb_noun_prep_prep_nouns.splice(index, 1);
          }
        }
      }

      // add new words to lookup
      if (arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
          this.dictionary.verb_noun_prep_prep_nouns.push([arr[i], this.name]);
        }
      }

      // apply new words
      this._verb_noun_prep_prep_noun = arr;
    }

    /**
     * For a verb phrase with three nouns and two prepositions.
     * For example, in the phrase "tie boat to pier with rope",
     * we're looking for "tie" and "to" and "with",
     * and we would parse the phrase as "tietowith boat pier rope"
     * @var {Array} adventurejs.Verb#verb_noun_prep_noun_prep_noun
     * @default []
     */
    get verb_noun_prep_noun_prep_noun() {
      return this._verb_noun_prep_noun_prep_noun;
    }
    set verb_noun_prep_noun_prep_noun(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (false === Array.isArray(this._verb_noun_prep_noun_prep_noun)) {
        this._verb_noun_prep_noun_prep_noun = [];
      }

      // remove all prior words from dictionary,
      // in case this verb is being redefined
      if (0 < this._verb_noun_prep_noun_prep_noun.length) {
        for (var i = this._verb_noun_prep_noun_prep_noun.length; i > -1; i--) {
          var pair = [this._verb_noun_prep_noun_prep_noun[i], this.name];
          var index = A.indexOfSubarray(
            pair,
            this.dictionary.verb_noun_prep_noun_prep_nouns
          );
          if (-1 !== index) {
            this.dictionary.verb_noun_prep_noun_prep_nouns.splice(index, 1);
          }
        }
      }

      // add new words to lookup
      if (arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
          this.dictionary.verb_noun_prep_noun_prep_nouns.push([
            arr[i],
            this.name,
          ]);
        }
      }

      // apply new words
      this._verb_noun_prep_noun_prep_noun = arr;
    }

    /**
     * For a verb phrase with three nouns and three prepositions.
     * For example, in the phrase
     * "swing from branch to tree on vine", we're looking for "swing from with on".
     * @var {Array} adventurejs.Verb#verb_prep_noun_prep_noun_prep_noun
     * @default []
     */
    get verb_prep_noun_prep_noun_prep_noun() {
      return this._verb_prep_noun_prep_noun_prep_noun;
    }
    set verb_prep_noun_prep_noun_prep_noun(arr) {
      // don't know how to initialize Object.defineProperty as an array
      if (false === Array.isArray(this._verb_prep_noun_prep_noun_prep_noun)) {
        this._verb_prep_noun_prep_noun_prep_noun = [];
      }

      // remove all prior words from dictionary,
      // in case this verb is being redefined
      if (0 < this._verb_prep_noun_prep_noun_prep_noun.length) {
        for (
          var i = this._verb_prep_noun_prep_noun_prep_noun.length;
          i > -1;
          i--
        ) {
          var pair = [this._verb_prep_noun_prep_noun_prep_noun[i], this.name];
          var index = A.indexOfSubarray(
            pair,
            this.dictionary.verb_prep_noun_prep_noun_prep_nouns
          );
          if (-1 !== index) {
            this.dictionary.verb_prep_noun_prep_noun_prep_nouns.splice(
              index,
              1
            );
          }
        }
      }

      // add new words to lookup
      if (arr.length > 0) {
        for (var i = 0; i < arr.length; i++) {
          this.dictionary.verb_prep_noun_prep_noun_prep_nouns.push([
            arr[i],
            this.name,
          ]);
        }
      }

      // apply new words
      this._verb_prep_noun_prep_noun_prep_noun = arr;
    }

    /**
     * <strong>Verb.do</strong> is a coordinating method that
     * sequences six other submethods in a series. In the case of
     * Verb instances that can act on a collection of
     * {@link adventurejs.Asset|Assets} in a single turn, Verb.do
     * only fires once, but it loops through the Asset collection
     * and calls each submethod for every Asset in the collection.
     * The sequence is:
     * <br><br>
     * do ->
     * <ul>
     * <li><a href="#doBeforeTry">doBeforeTry</a> (hook for authors)</li>
     * <li><a href="#doTry">doTry</a></li>
     * <li><a href="#doAfterTry">doAfterTry</a> (hook for authors)</li>
     * <li><a href="#doBeforeSuccess">doBeforeSuccess</a> (hook for authors)</li>
     * <li><a href="#doSuccess">doSuccess</a></li>
     * <li><a href="#doAfterSuccess">doAfterSuccess</a> (hook for authors)</li>
     * </ul>
     * The two key submethods are Verb.doTry and Verb.doSuccess.
     * For most Verb instances, these two methods contain the bulk
     * of the logic particular to this Verb. Verb.doTry determines
     * whether a Verb can act on an Asset, and if it can't,
     * prints an error message
     * to {@link adventurejs.Display|Display}.
     * Verb.doSuccess applies the Verb to the Asset: updates the game
     * state, assembles dynamic output, and prints the results to Display.
     * <br><br>
     * A Verb instance isn't required to use all of these methods.
     * Some Verbs may bypass Verb.doTry
     * because no special conditions are required to apply the Verb.
     * Some specialized Verbs such as {@link oops} and {@link undo}
     * override Verb.do entirely and don't use any submethods.
     * <br><br>
     * The other four submethods â Verb.doBeforeTry, Verb.doAfterTry,
     * Verb.doBeforeSuccess, and Verb.doAfterSuccess â exist to
     * provide optional hooks for authors to add custom interactions
     * with individual Assets.
     * For more information about Verb Actions and Verb Phases, see
     * <a href="/doc/Scripting_VerbActions.html">Verb Actions</a>
     * and
     * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.
     * <br><br>
     * And so, the first thing Verb.do does is to verify that each
     * method exists on the Verb instance. If the submethod exists,
     * it is called. Each submethod sends a return to Verb.do.
     * <br><br>
     * If the Verb is acting on a collection,
     * a false return means that the Asset currently being acted
     * on has responded in a way that blocks further parsing, and
     * brings this turn to a halt.
     * A null return means that the Asset currently being acted
     * on has concluded its own parsing, but not in such a way as
     * to block further parsing, and Verb.do moves on to the next Asset.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#do
     */
    do() {
      this.game.log("log", "high", "Verb.js > do " + this.name, "Verb");

      var input = this.game.getInput();
      var input_copy;
      var msg = "";

      if (
        -1 < input.verb_chain.indexOf(this.name) &&
        !input.allow_circular_verb
      ) {
        msg = "Error: Circular verb call! See console for more information. ";
        if (msg) this.game.print(msg, "error");
        msg = msg + "Circular verb call:";
        for (var i = 0; i < input.verb_chain.length; i++) {
          msg += "\n - " + input.verb_chain[i];
        }
        this.game.log("warn", "critical", msg, "Verb");
        return false;
      } else {
        input.allow_circular_verb = false;
        input.verb_chain.push(this.name);
      }

      var qualifiedCount = 1;
      if (input.parsedNoun1) {
        qualifiedCount = input.parsedNoun1.matches.qualified.length;
      }

      // "take all" for example will iterate through all available assets
      // because verbs can mutate input, if we're iterating,
      // make a copy of the original input
      // to use as a base for each iteration
      if (qualifiedCount > 1) {
        input_copy = new adventurejs.Input({ game_name: this.game.game_name });
        input_copy = Object.assign(input_copy, input);
      }

      for (var i = 0; i < qualifiedCount; i++) {
        if (i > 0) {
          // push a new input to the input history...
          this.game.parser.input_history.unshift(
            new adventurejs.Input({ game_name: this.game.game_name })
          );
          // and copy the original input onto it
          this.game.parser.input_history[0] = Object.assign(
            this.game.parser.input_history[0],
            input_copy
          );
        }

        let results;
        if (input.parsedNoun1) {
          input.parsedNoun1.matches.qualifiedIndex = i;
        }

        msg = this.name + ".js > doBeforeTry. ";
        this.game.log("log", "high", msg, "Verb");
        results = this.tryPhaseHook("doBeforeTry");
        if (false === results) return false; // end turn
        if (null === results) continue; // advance to next object
        // advance to next step

        msg = this.name + ".js > handleActions('try'). ";
        this.game.log("log", "high", msg, "Verb");
        results = this.handleActions("try");
        //if ("undefined" !== typeof results) return results;
        if (false === results) return false; // end turn
        if (null === results) continue; // advance to next object

        msg = this.name + ".js > Try. ";
        this.game.log("log", "high", msg, "Verb");
        results = this.doTry();
        if (false === results) return false; // end turn
        if (null === results) continue; // advance to next object
        // advance to next step

        msg = this.name + ".js > doAfterTry. ";
        this.game.log("log", "high", msg, "Verb");
        results = this.tryPhaseHook("doAfterTry");
        if (false === results) return false; // end turn
        if (null === results) continue; // advance to next object
        // advance to next step

        msg = this.name + ".js > doBeforeSuccess. ";
        this.game.log("log", "high", msg, "Verb");
        results = this.tryPhaseHook("doBeforeSuccess");
        if (false === results) return false; // end turn
        if (null === results) continue; // advance to next object
        // advance to next step

        msg = this.name + ".js > handleActions('do'). ";
        this.game.log("log", "high", msg, "Verb");
        results = this.handleActions("do");
        if (false === results) return false; // end turn
        if (null === results) continue; // advance to next object

        msg = this.name + ".js > Success. ";
        this.game.log("log", "high", msg, "Verb");
        results = this.doSuccess();
        if (false === results) return false; // end turn
        if (null === results) continue; // advance to next object
        // advance to next step

        msg = this.name + ".js > doAfterSuccess. ";
        this.game.log("log", "high", msg, "Verb");
        // results = this.doAfterSuccess();
        results = this.tryPhaseHook("doAfterSuccess");
        if (false === results) return false; // end turn
        if (null === results) continue; // advance to next object
        // complete handling for this object
      } // forloop qualifiedCount
    } // do

    /**
     * <strong>doTry</strong> typically contains all the specific
     * logic needed to determine if this Verb can act on the specified
     * {@link adventurejs.Asset|Asset}. (We already applied
     * some general logic supplied by
     * {@link adventurejs.NounMustBe|NounMustBe} before arriving here.)
     * For information about modifying verbs, see
     * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#doTry
     */
    doTry() {
      return true;
    }

    /**
     * <strong>handleActions</strong> attempts to call any
     * <a href="Scripting_VerbActions.html">verb actions</a>
     * that match the current assets and sentence structure.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#handleActions
     */
    handleActions(dotry) {
      let input = this.game.getInput();
      let Input_verb = A.propercase(input.input_verb);
      let player = this.game.getPlayer();
      let direct_object = input.getAsset(1);
      let direct_preposition = input.getPreposition(1);
      let Direct_preposition = A.propercase(direct_preposition);
      let indirect_object = input.getAsset(2);
      let indirect_preposition = input.getPreposition(2);
      let Indirect_preposition = A.propercase(indirect_preposition);
      let indirect_object2 = input.getAsset(3);
      let indirect_preposition2 = A.propercase(input.getPreposition(3));
      let Indirect_preposition2 = A.propercase(indirect_preposition2);
      let hook = "";
      let results;
      switch (input.getStructure()) {
        case "verb":
          // ex player.tryTest
          results = player.callAction(`${dotry}${Input_verb}`);
          break;
        case "verb preposition":
          // ex: player.tryTestIn
          results = player.callAction(
            `${dotry}${Input_verb}${Direct_preposition}`
          );
          break;
        case "verb noun":
          // ex: asset.tryTestThis
          results = direct_object.callAction(`${dotry}${Input_verb}This`);
          break;
        case "verb preposition noun":
          // ex: asset1.tryTestToThis asset2
          results = direct_object.callAction(
            `${dotry}${Input_verb}${Direct_preposition}This`
          );
          break;
        case "verb noun noun":
          // ex: asset1.tryTestThisThat asset2
          results = direct_object.callAction(`${dotry}${Input_verb}ThisThat`);
          if ("undefined" !== typeof results) return results;
          // ex: asset2.tryTestThatThis asset2
          results = indirect_object.callAction(`${dotry}${Input_verb}ThatThis`);
          break;
        case "verb noun preposition noun":
          // ex: asset1.tryTestThisToThat asset2
          results = direct_object.callAction(
            `${dotry}${Input_verb}This${Indirect_preposition}That`
          );
          if ("undefined" !== typeof results) return results;
          break;
        case "verb preposition noun preposition noun":
          // ex: asset1.tryTestThisToThat asset2
          results = direct_object.callAction(
            `${dotry}${Input_verb}${Direct_preposition}This${Indirect_preposition}That`
          );
          if ("undefined" !== typeof results) return results;
          break;
        case "verb noun preposition noun preposition noun":
          // ex: asset1.tryTestThisFromThatToThat asset2
          hook = `${dotry}${Input_verb}This${Indirect_preposition}That${Indirect_preposition2}Other`;
          results = direct_object.callAction(hook);
          if ("undefined" !== typeof results) return results;
          break;
        case "verb preposition noun preposition noun preposition noun":
          // ex: asset1.tryTestFromThisToThatWithThat asset2
          hook = `${dotry}${Input_verb}${Direct_preposition}This${Indirect_preposition}That${Indirect_preposition2}Other`;
          results = direct_object.callAction(hook, indirect_object);
          if ("undefined" !== typeof results) return results;
          break;
      }
      return results;
    }

    /**
     * <strong>doSuccess</strong> typically contains all the code
     * needed to apply this Verb to the specified
     * {@link adventurejs.Asset|Asset} once it has successfully
     * passed through all of our conditional logic. doBeforeSuccess
     * and doAfterSuccess are provided so that authors can
     * apply custom success code on an item-by-item basis,
     * but it is also possible to globally modify doSuccess.
     * For information about modifying verbs, see
     * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#doSuccess
     */
    doSuccess() {
      return true;
    }

    tryPhaseHook(phase) {
      //console.warn("tryPhaseHook", phase);
      var input = this.game.getInput();

      for (var i = 1; i <= 3; i++) {
        var asset = input.getAsset(i);
        if (!asset) continue;
        if (phase === "doBeforeTry") asset.incrementTryVerbCount(this.name, i);

        let fx;

        // does this asset have a verb phase?
        if (
          (i === 2 || i === 3) &&
          asset.iov[this.name] &&
          "function" === typeof asset.iov[this.name][phase]
        ) {
          fx = asset.iov[this.name][phase];
        } else if (
          (i === 2 || i === 1) &&
          asset.dov[this.name] &&
          "function" === typeof asset.dov[this.name][phase]
        ) {
          fx = asset.dov[this.name][phase];
        }

        // no verb phase?
        if (!fx) continue;

        var results = fx.call(asset, { index: i, verb: this.name });
        if ("undefined" !== typeof results) {
          var msg = `Verb.js > ${asset.name} ${this.name} ${[
            phase,
          ]} returned ${results}. `;
          this.game.log("log", "critical", msg, "Verb");
          return results;
        }
      } // for

      return true;
    }

    /**
     * <strong>tryToInferIndirectObject</strong> is called by some verbs
     * when they receive a direct object with no indirect object, to
     * test whether an indirect object can be inferred. In order to be
     * inferred, indirect object must be in player inventory.
     * If player hasn't already interacted with direct object and
     * game.settings.infer_indirect_objects_only_after_interaction
     * is true, tryToInferIndirectObject will fail regardless of other
     * circumstances.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#tryToInferIndirectObject
     * @param {Object} direct_object
     * @param {Boolean} handle_input If true, updates the global input object
     * per standard specs used by most (but not all) of the verb instances
     * that call this method.
     * @returns {Object}
     */
    tryToInferIndirectObject(direct_object, handle_input) {
      if (
        !this.game.settings.try_to_infer_indirect_objects ||
        !direct_object ||
        !(direct_object instanceof adventurejs.Matter)
      ) {
        return { fail: true };
      }
      var input = this.game.getInput();
      var related_verbs = this.related;
      related_verbs.push(this.name);

      var player = this.game.getPlayer();
      var found;
      var prompt = false;

      // player might have an asset, but has never interacted with this
      // in which case game settings determine whether to infer asset
      if (
        this.game.settings.infer_indirect_objects_only_after_interaction &&
        !direct_object.didDoVerbs(related_verbs)
      ) {
        prompt = true;
      }

      // ok to try to infer asset
      // is player carrying a relevant asset?
      found = player.getIOVkeys(this.name, direct_object);

      // player isn't carrying a tool for this
      if (!found || !found.length) {
        prompt = true;
      }

      if (
        found.length > 1 &&
        this.game.settings.if_inferred_multiple_indirect_objects_then_prompt
      ) {
        prompt = true;
      }

      if (prompt && handle_input) {
        input.setPreposition(2, "with");
        input.setSoftPrompt({
          noun2: true,
          structure: "verb noun preposition noun",
        });
        return { prompt: true };
      }

      if (handle_input) {
        input.setNewPhrase({
          asset: found[0],
          preposition: "with",
        });
        input.setStructure("verb noun preposition noun");
      }
      return { success: true, indirect_object: found[0] };
    }

    /**
     * <strong>tryToPutThisInThatAspect</strong>
     * checks to see if a asset can be placed within
     * the specified aspect of another specified asset.
     * For example, "put sword in stone" and
     * "push stone into depression" would both be
     * tested with this function.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#tryToPutThisInThatAspect
     * @param {Object} direct_object
     * @param {String} preposition
     * @param {Object} indirect_object
     * @returns {Object}
     */
    tryToPutThisInThatAspect(direct_object, preposition, indirect_object) {
      var response = { fail: false, msg: "", status: "", end_turn: false };
      var asset_aspect;
      var msg = "";
      var can = true;

      if (
        !direct_object ||
        !(direct_object instanceof adventurejs.Tangible) ||
        !indirect_object ||
        !(indirect_object instanceof adventurejs.Tangible) ||
        !preposition ||
        !indirect_object.hasAspectAt(preposition)
      ) {
        this.game.debug(
          `F1670 | Verb.js via ${this.name}.js | received bad request `
        );
        if (!indirect_object.hasAspectAt(preposition)) {
          msg += `$(We) can't put anything ${preposition} ${indirect_object.articlename}. `;
        } else {
          msg += this.game.parser.getUnparsedMessage(
            this.game.getInput().input
          );
        }
        response = {
          fail: true,
          msg: msg,
          status: "bad_request",
          end_turn: false,
        };
        return response;
      }

      // is indirect_object closed?
      if (
        "in" === preposition &&
        indirect_object.isDOV("close") &&
        indirect_object.is.closed
      ) {
        // @TODO automatically open the thing, if context allows it
        this.game.debug(
          `F1671 | Verb.js via ${this.name}.js | indirect_object.id.is.closed `
        );
        msg += indirect_object.Articlename + " is closed.";
        this.handleFailure(msg);
        return false;
      }

      // does indirect object aspect limit what assets can be put in it?
      var with_classes = indirect_object.aspects[preposition].with_classes;
      if (with_classes.length > 0) {
        can = false;
        for (var i = 0; i < with_classes.length; i++) {
          var clas = with_classes[i];
          if (direct_object instanceof adventurejs[clas]) {
            can = true;
            break;
          }
        }
        if (!can) {
          this.game.debug(
            `F1661 | Verb.js via ${this.name}.js | ${direct_object.id}.class ${direct_object.class} is not among ${indirect_object.id}.aspects.${preposition}.with_classes `
          );
          msg += `${direct_object.Articlename} can't be placed ${preposition} ${indirect_object.articlename}. `;
          response = {
            fail: true,
            msg: msg,
            status: "with_classes",
            end_turn: false,
          };
          return response;
        }
      }

      // does indirect object aspect limit what classes can be put in it?
      var with_assets = indirect_object.aspects[preposition].with_assets;
      if (with_assets.length > 0) {
        can = false;
        for (var i = 0; i < with_assets.length; i++) {
          if (direct_object.id === with_assets[i]) {
            can = true;
            break;
          }
        }
        if (!can) {
          this.game.debug(
            `F1662 | Verb.js via ${this.name}.js | ${direct_object.id} is not among ${indirect_object.id}.aspects.${preposition}.with_assets `
          );
          msg += `${direct_object.Articlename} can't be placed ${preposition} ${indirect_object.articlename}. `;
          response = {
            fail: true,
            msg: msg,
            status: "with_assets",
            end_turn: false,
          };
          return response;
        }
      }

      asset_aspect = indirect_object.getAspectAt(preposition);

      if (
        asset_aspect.maxsize > -1 &&
        direct_object.dimensions.size > asset_aspect.maxsize
      ) {
        this.game.debug(
          `F1667 | Verb.js via ${this.name}.js | ${direct_object.id}.dimensions.size > ${indirect_object.id}.aspects.${preposition}.maxsize `
        );
        msg += `${direct_object.Articlename} doesn't fit ${preposition} ${indirect_object.articlename}. `;
        response = {
          fail: true,
          msg: msg,
          status: "maxsize",
          end_turn: false,
        };
        return response;
      }

      if (
        asset_aspect.maxweight > -1 &&
        direct_object.dimensions.weight > asset_aspect.maxweight
      ) {
        this.game.debug(
          `F1668 | Verb.js via ${this.name}.js | ${direct_object.id}.dimensions.weight > ${indirect_object.id}.aspects.${preposition}.maxweight `
        );
        msg += `${direct_object.Articlename} is too heavy to ${this.name} ${preposition} ${indirect_object.articlename}. `;
        response = {
          fail: true,
          msg: msg,
          status: "maxweight",
          end_turn: false,
        };
        return response;
      }

      if (
        asset_aspect.maxcount > -1 &&
        asset_aspect.contents.length >= asset_aspect.maxcount
      ) {
        this.game.debug(
          `F1669 | Verb.js via ${this.name}.js | ${indirect_object.id}.aspects.${preposition}.contents.length >= ${indirect_object.id}.aspects.${preposition}.maxcount `
        );
        msg += `Nothing ${asset_aspect.maxcount > 0 ? "more " : ""} can be ${
          this.past_tense
        } ${preposition} ${indirect_object.articlename}. `;
        response = {
          fail: true,
          msg: msg,
          status: "maxcount",
          end_turn: true,
        };
        return response;
      }

      return response;
    }

    /**
     * Unused.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#validate
     */
    validate() {}

    /**
     * If Verb is a direction, <strong>initialize</strong> adds
     * it to game.dictionary.directionLookup.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#initialize
     * @todo How does patchVerb handle initialization?
     */
    initialize() {
      if (!this.prettyname) {
        this.prettyname = this.name;
      }

      // TODO how does patch handle this?
      // if(-1 === this.synonyms.indexOf( this.name ) ) {
      // 	this.synonyms.push( this.name );
      // }

      // TODO how does patch handle this?
      if (this.is_direction) {
        // update lookup
        this.dictionary.directionLookup[this.name] = {
          synonyms: this.synonyms,
          adjectives: this.adjectives,
          article: this.article,
        };
      }

      if (this.state_string) {
        this.game.dictionary.verb_state_lookup[this.state_string] = this.name;
      }
      if (this.unstate_string) {
        this.game.dictionary.verb_state_lookup[this.unstate_string] = this.name;
      }
    }

    /**
     * <strong>enqueueCollection</strong> takes a collection of
     * Assets and enqueues them to game.parser for sequential
     * handling.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#enqueueCollection
     */
    enqueueCollection(object) {
      this.game.log("log", "high", "Verb.js.enqueueCollection(, 'Verb' ) ");

      for (var i = 0; i < object.collection.length; i++) {
        var linefeed = i === object.collection.length ? true : undefined;
        this.game.parser.input_queue.push({
          input: this.name + " " + object.collection[i],
          output_class: "concatenate_output",
          linefeed: linefeed,
        });
      }
      return false;

      // alternately
      //var msg = "You'll have to look in " + object.articlename + " individually.";
      //if(msg) this.game.print( msg, output_class );
      //return null;
    }

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#set
     * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
     * @returns {adventurejs.Verb} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(props) {
      return A.deepSet.call(this.game, props, this);
    }

    /**
     * <strong>handleFailure</strong> prints either a given fail message
     * or a generic fail msg if one is specified.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#handleFailure
     */
    handleFailure(msg) {
      var input = this.game.getInput();
      var noun1 = input.getAsset(1);
      var noun2 = input.getAsset(2);
      var noun3 = input.getAsset(3);
      var results;

      msg = A.getSAF.call(this.game, this.override_verb_failure_msg) || msg;

      if (noun1?.dov[this.name]) {
        if (
          1 >= noun1.DOVdidTryCount(this.name) &&
          noun1.dov[this.name].on_first_failure
        ) {
          results = A.getSAF.call(
            this.game,
            noun1.dov[this.name].on_first_failure,
            noun1
          );
        } else {
          results = A.getSAF.call(
            this.game,
            noun1.dov[this.name].on_failure,
            noun1
          );
        }
        if (results && "string" === typeof results) msg += results;
      }

      if (noun2?.iov[this.name]) {
        if (
          1 >= noun2.IOVdidTryCount(this.name) &&
          noun2.iov[this.name].on_first_failure
        ) {
          results = A.getSAF.call(
            this.game,
            noun2.iov[this.name].on_first_failure,
            noun2
          );
        } else {
          results = A.getSAF.call(
            this.game,
            noun2.iov[this.name].on_failure,
            noun2
          );
        }
        if (results && "string" === typeof results) msg += results;
      } else if (noun2?.dov[this.name]) {
        if (
          1 >= noun2.DOVdidTryCount(this.name) &&
          noun2.dov[this.name].on_first_failure
        ) {
          results = A.getSAF.call(
            this.game,
            noun2.dov[this.name].on_first_failure,
            noun2
          );
        } else {
          results = A.getSAF.call(
            this.game,
            noun2.dov[this.name].on_failure,
            noun2
          );
        }
        if (results && "string" === typeof results) msg += results;
      }

      if (noun3?.iov[this.name]) {
        if (
          1 >= noun3.IOVdidTryCount(this.name, 3) &&
          noun3.iov[this.name].on_first_failure
        ) {
          results = A.getSAF.call(
            this.game,
            noun3.iov[this.name].on_first_failure,
            noun3
          );
        } else {
          results = A.getSAF.call(
            this.game,
            noun3.iov[this.name].on_failure,
            noun3
          );
        }
        if (results && "string" === typeof results) msg += results;
      }

      if (msg) {
        this.game.print(msg, this.game.getInput().output_class);
      }
    }

    /**
     * <strong>handleSuccess</strong> prints the provided
     * success message or a generic one that has been
     * defined by author. It also checks direct and indirect
     * objects for custom verb subscription on_success
     * results and tryDestroy results.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#handleSuccess
     */
    handleSuccess(msg, object) {
      var input = this.game.getInput();
      var noun1 = input.getAsset(1);
      var noun2 = input.getAsset(2);
      var noun3 = input.getAsset(3);
      var results;

      msg = A.getSAF.call(this.game, this.override_verb_success_msg) || msg;

      if (noun1) {
        noun1.incrementDoVerbCount(this.name, 1);
        if (noun1.dov[this.name]) {
          // if( !noun1.DOVdidDo(this.name)
          if (
            1 === noun1.DOVdidDoCount(this.name) &&
            noun1.dov[this.name].on_first_success
          ) {
            results = A.getSAF.call(
              this.game,
              noun1.dov[this.name].on_first_success,
              noun1
            );
          } else {
            results = A.getSAF.call(
              this.game,
              noun1.dov[this.name].on_success,
              noun1
            );
          }
          if (results && "string" === typeof results) msg += results;

          // then disable?
          if (noun1.dov[this.name].then_disable) {
            noun1.dov[this.name].enabled = false;
          }

          // destroy after using?
          results = noun1.tryDestroyDirectObjectAfterUsing(this.name);
          if (results.destroy)
            msg += results.msg
              ? results.msg
              : `${noun1.Articlename} snaps into pieces. `;
        } else {
          // warn because we probably shouldn't have got here without this
          this.game.log(
            "warn",
            0,
            `${noun1.id} is not direct subscribed to ${this.name}`,
            "Verb"
          );
        }
      } // noun1

      if (noun2) {
        noun2.incrementDoVerbCount(this.name, 2);
        // usually noun2 is indirect object
        if (noun2.iov[this.name]) {
          // if( !noun2.IOVdidDo(this.name)
          if (
            1 === noun2.IOVdidDoCount(this.name) &&
            noun2.iov[this.name].on_first_success
          ) {
            results = A.getSAF.call(
              this.game,
              noun2.iov[this.name].on_first_success,
              noun2
            );
          } else {
            results = A.getSAF.call(
              this.game,
              noun2.iov[this.name].on_success,
              noun2
            );
          }
          if (results && "string" === typeof results) msg += results;

          // then disable?
          if (noun2.iov[this.name].then_disable) {
            noun2.iov[this.name].enabled = false;
          }

          // destroy after using?
          results = noun2.tryDestroyIndirectObjectAfterUsing(this.name);
          if (results.destroy)
            msg += results.msg
              ? results.msg
              : `${noun2.Articlename} crumbles to pieces. `;
        }
        // but some verbs, like attach, treat noun1 && noun2 as direct
        else if (noun2.dov[this.name]) {
          // if( !noun2.DOVdidDo(this.name)
          if (
            1 === noun2.DOVdidDoCount(this.name) &&
            noun2.dov[this.name].on_first_success
          ) {
            results = A.getSAF.call(
              this.game,
              noun2.dov[this.name].on_first_success,
              noun2
            );
          } else {
            results = A.getSAF.call(
              this.game,
              noun2.dov[this.name].on_success,
              noun2
            );
          }
          if (results && "string" === typeof results) msg += results;

          // then disable?
          if (noun2.dov[this.name].then_disable) {
            noun2.dov[this.name].enabled = false;
          }

          // destroy after using?
          results = noun2.tryDestroyDirectObjectAfterUsing(this.name);
          if (results.destroy)
            msg += results.msg
              ? results.msg
              : `${noun2.Articlename} crumbles to pieces. `;
        } else {
          // warn because we probably shouldn't have got here without this
          this.game.log(
            "warn",
            0,
            `${noun2.id} is not indirect or direct subscribed to ${this.name}`,
            "Verb"
          );
        }
      } // noun2

      if (noun3) {
        noun3.incrementDoVerbCount(this.name, 3);
        if (noun3.iov[this.name]) {
          // if( !noun3.IOVdidDo(this.name)
          if (
            1 === noun3.IOVdidDoCount(this.name) &&
            noun3.iov[this.name].on_first_success
          ) {
            results = A.getSAF.call(
              this.game,
              noun3.iov[this.name].on_first_success,
              noun3
            );
          } else {
            results = A.getSAF.call(
              this.game,
              noun3.iov[this.name].on_success,
              noun3
            );
          }
          if (results && "string" === typeof results) msg += results;

          // then disable?
          if (noun3.iov[this.name].then_disable) {
            noun3.iov[this.name].enabled = false;
          }

          // destroy after using?
          results = noun3.tryDestroyIndirectObjectAfterUsing(this.name);
          if (results.destroy)
            msg += results.msg
              ? results.msg
              : `${noun3.Articlename} crumbles to pieces. `;
        } else {
          // warn because we probably shouldn't have got here without this
          this.game.log(
            "warn",
            0,
            `${noun3.id} is not indirect subscribed to ${this.name}`,
            "Verb"
          );
        }
      } // noun3

      if (msg) this.game.print(msg, this.game.getInput().output_class);
    } // handleSuccess

    /**
     * Verb can be intransitive if it doesn't require a noun.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#canBeIntransitive
     */
    canBeIntransitive() {
      return !this.phrase1.requires_noun;
    }

    /**
     * Does this verb have state or unstate?
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#hasState
     */
    hasState() {
      return this.state || this.unstate;
    }

    /**
     * Get this verb's state or unstate.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#getState
     */
    getState() {
      return this.state || this.unstate;
    }

    /**
     * Apply this verb's state or unstate to an asset.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#setState
     */
    setState(asset, bool) {
      if (this.getState()) asset.setState(this.getState(), bool);
    }

    /**
     * Connect two assets that share a connection when acted upon by this verb.
     * For example, in the case of 'plug computer into socket',
     * each asset has the other asset's ID saved to its verb subscription like this:
     * <br><br>
     * <code class="property">computer.dov.plugIn.with_params.connections = ['socket']</code>
     * <br>
     * <code class="property">socket.iov.plugIn.with_params.connections = ['computer']</code>
     * <br><br>
     * This is one of two verb subscription properties that are related and very similar,
     * and it's important to understand the distinction between them.
     * <code class="property">...with_assets</code>
     * defines which assets <strong>CAN BE</strong> connected.
     * <code class="property">...with_params.connections</code>
     * stores which assets <strong>ARE</strong> connected.
     * <br><br>
     * <strong>with_assets</strong>:
     * <code class="property">computer.dov.plugIn.with_assets = ['socket']</code>
     * <br>
     * <strong>connections</strong>:
     * <code class="property">computer.dov.plugIn.with_params.connections = ['socket']</code>
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#setVerbSubscriptionConnection
     */
    setVerbSubscriptionConnection(direct_object, indirect_object) {
      //console.warn(this.name,'setVerbSubscriptionConnection',direct_object.id,indirect_object.id);

      if (
        direct_object &&
        direct_object.dov[this.name] &&
        direct_object.dov[this.name].with_params.connections
      ) {
        // some verbs allow direct objects to connect to nothing
        let indirect_value =
          indirect_object && indirect_object.id ? indirect_object.id : null;
        if (
          -1 ===
          direct_object.dov[this.name].with_params.connections.indexOf(
            indirect_value
          )
        ) {
          direct_object.dov[this.name].with_params.connections.push(
            indirect_value
          );
        }
      }

      if (
        indirect_object &&
        indirect_object.iov[this.name] &&
        indirect_object.iov[this.name].with_params.connections
      ) {
        // I don't think indirect objects can connect to nothing, but for completionism
        let direct_value =
          direct_object && direct_object.id ? direct_object.id : null;
        if (
          -1 ===
          indirect_object.iov[this.name].with_params.connections.indexOf(
            direct_value
          )
        ) {
          indirect_object.iov[this.name].with_params.connections.push(
            direct_value
          );
        }
      }
    }

    /**
     * Disconnect two assets that share a connection when acted upon by this verb.
     * For example, in the case of 'plug computer into socket',
     * each asset has the other asset's ID saved to its verb subscription like this:
     * <br><br>
     * <code class="property">computer.dov.plugIn.with_params.connections = ['socket']</code>
     * <br>
     * <code class="property">socket.iov.plugIn.with_params.connections = ['computer']</code>
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#unsetVerbSubscriptionConnection
     */
    unsetVerbSubscriptionConnection(direct_object, indirect_object) {
      if (
        direct_object &&
        direct_object.dov[this.name] &&
        direct_object.dov[this.name].with_params.connections
      ) {
        // some verbs allow direct objects to connect to nothing
        let indirect_value =
          indirect_object && indirect_object.id ? indirect_object.id : null;
        if (
          -1 !==
          direct_object.dov[this.name].with_params.connections.indexOf(
            indirect_value
          )
        ) {
          direct_object.dov[this.name].with_params.connections =
            direct_object.dov[this.name].with_params.connections.filter(
              (item) => item !== indirect_value
            );
        }
      }

      if (
        indirect_object &&
        indirect_object.iov[this.name] &&
        indirect_object.iov[this.name].with_params.connections
      ) {
        // I don't think indirect objects can connect to nothing, but for completionism
        let direct_value =
          direct_object && direct_object.id ? direct_object.id : null;
        if (
          -1 !==
          indirect_object.iov[this.name].with_params.connections.indexOf(
            direct_value
          )
        ) {
          indirect_object.iov[this.name].with_params.connections =
            indirect_object.iov[this.name].with_params.connections.filter(
              (item) => item !== direct_value
            );
        }
      }
    }

    /**
     * Test whether two assets are connected by this verb, for example
     * a rope tied to a tree, or a computer plugged into a socket.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#hasVerbSubscriptionConnection
     */
    hasVerbSubscriptionConnection(direct_object, indirect_object) {
      let dconnect = true;
      let iconnect = true;

      if (
        !direct_object.dov[this.name] ||
        !direct_object.dov[this.name].with_params.connections ||
        -1 ===
          direct_object.dov[this.name].with_params.connections.indexOf(
            indirect_object.id
          )
      ) {
        dconnect = false;
      }

      if (
        !indirect_object.iov[this.name] ||
        !indirect_object.iov[this.name].with_params.connections ||
        -1 ===
          indirect_object.iov[this.name].with_params.connections.indexOf(
            direct_object.id
          )
      ) {
        iconnect = false;
      }

      // we should never have a one-way connection, and if we do, something is broken
      if (dconnect && !iconnect) {
        this.game.log(
          "warn",
          "high",
          `${direct_object.id}.dov.${this.name}.with_params.connections contains ${indirect_object.id} but ${indirect_object.id}.iov${this.name}.with_params.connections does not contain ${direct_object.id}`,
          "Verb"
        );
        return false;
      }
      if (!dconnect && iconnect) {
        this.game.log(
          "warn",
          "high",
          `${indirect_object.id}.iov.${this.name}.with_params.connections contains ${direct_object.id} but ${direct_object.id}.dov${this.name}.with_params.connections does not contain ${indirect_object.id}`,
          "Verb"
        );
        return false;
      }

      return true;
    }

    /* *
     * Test whether player can reach an asset from position on nest asset.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Verb#canPlayerGoThereFromNest
     */
    canPlayerGoThereFromNest(direct_preposition, direct_object) {
      let response = { failure: false, return: null, msg: "" };
      let input = this.game.getInput();
      let player = this.game.getPlayer();
      let nest_asset = player.getNestAsset();
      let nest_preposition = player.getNestPreposition();

      let reachable = true; // default = reachable

      if (this.game.settings.xz_determines_reachability) {
        // is distance between assets greater than jump_length?
        let distance = A.getHorizontalDistance(
          nest_asset.position,
          direct_object.position
        );
        reachable = distance <= this.game.settings.jump_length;
        // @TODO doSuccess handling for this
      }
      if (!reachable) {
        this.game.debug(
          `F1027 | ${this.name}.js | ${player.id} is nested ${nest_preposition} ${nest_asset.id} `
        );
        response.msg += `$(We) can't ${this.name} ${direct_preposition} ${
          direct_object.articlename
        } while ${player.getPostureGerund()} ${nest_preposition} ${
          nest_asset.articlename
        }. `;
        response.failure = true;
        return response;
      }

      return response;
    }
  } // class Verb

  adventurejs.Verb = Verb;
})();

// jump_across.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class jump_across
   * @ajsnode game.dictionary.verbs.jump_across
   * @ajsconstruct MyGame.createVerb({ "name": "jump_across", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @ajssynonyms jump across, hop across
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; jump across light years</span>
   * You jump across the light years, spanning entire constellations
   * of stars. Gaseous nebulae stream past, coating you in sparkling
   * particles. Here, a new civilization rises in your wake.
   * There, another is destroyed by your passing shadow. Worlds
   * come to know you as creator and destroyer, yin and yang,
   * alpha and omega. You arrive at your destination, refreshed,
   * and brush away multicolored crystals of frozen liquids.
   * </pre>
   * <p>
   * <strong>Jump across</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be jumped across has its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_can_jump_across">can.jump_across</a>
   * property set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   */
  A.Preverbs.jump_across = {
    name: "jump_across",
    prettyname: "jump across",
    synonyms: [],
    verb_prep_noun: ["hop across", "jump across"],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      // can't jump across object
      if (false === direct_object.can.jump_across) {
        var msg = "$(We) can't jump over " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);

      var msg = "$(We) jump across " + direct_object.articlename + ". ";

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // jump_across

// jump_aspect.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class jump
   * @ajsnode game.dictionary.verbs.jump
   * @ajsconstruct MyGame.createVerb({ "name": "jump", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; jump over threshold</span>
   * You jump over the threshold, carrying your new bride, careful to
   * avoid tripping over your own comically large feet. Your bride runs
   * her gloved hand through your rainbow colored perm, tickling your nose
   * with her colorful yellow and fuscia frill. She raises her head for
   * a kiss, and you mash your brightly painted red lips into hers,
   * commingling both your makeups into smears of red and white pancake.
   * You part breathlessly, and she honks your foam nose in connubial bliss.
   * </pre>
   * <p>
   * When used with a preposition,
   * <strong>jump</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}
   * has an enabled
   * {@link adventurejs.Aspect|Aspect}
   * matching the player's preposition, with its
   * aspect.player.can.jump</a>
   * property set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   */
  A.Preverbs.jump_aspect = {
    name: "jumpover",
    prettyname: "jump",
    synonyms: ["jumpover"],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    doTry: function () {
      var input, direct_object, direct_preposition, fail, msg;
      input = this.game.getInput();

      // player entered verb without aspect or noun
      // in which case we've already passed qualifiers via mustBe
      if (
        input.found_word &&
        this.canBeIntransitive() &&
        true !== input.soft_prompt.satisfied
      )
        return true;

      // we won't have got here with direct_object undefined
      direct_object = input.getAsset(1);

      // but preposition might be
      direct_preposition = input.getPreposition(1);

      // this can be a travel verb - is noun a direction?
      if (!direct_preposition && direct_object.direction) {
        this.game.tryTravel(direct_object.direction);
        return null;
      }

      /* we received an asset with no preposition and asset can't respond directly to verb */
      if (!direct_preposition) {
        fail = true;
      } else if (
        /* asset hasn't got or doesn't allow verb at the specified preposition */
        direct_preposition &&
        (!direct_object.hasAspectAt(direct_preposition) ||
          !direct_object.aspects[direct_preposition].player.can.jump)
      ) {
        fail = true;
      }
      if (fail) {
        msg =
          "$(We) can't jump " +
          (direct_preposition ? direct_preposition : "") +
          (direct_object ? " " + direct_object.articlename : "") +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input, direct_object, direct_preposition, msg;
      input = this.game.getInput();

      if (input.found_word && true !== input.soft_prompt.satisfied) {
        msg = "$(We) jump. ";
      } else {
        direct_object = input.getAsset(1);
        direct_preposition = input.getPreposition(1);

        msg =
          "$(We) jump " +
          (direct_preposition ? direct_preposition : "") +
          " " +
          direct_object.articlename +
          ". ";
      }

      this.handleSuccess(msg, direct_object);
      return true;
    },
  }; // END jump
})();

// jumpFrom_to.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class jumpFrom_to
   * @ajsnode game.dictionary.verbs.jumpFrom_to
   * @ajsconstruct MyGame.createVerb({ "name": "jumpFrom_to", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; jump from golden bough to silver spoon</span>
   * You jump from the golden bough to the silver spoon, enjoying
   * your life of privilege. Money falls into your deserving hands!
   * </pre>
   * <p>
   * <strong>Jump from</strong> one
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}
   * to another. Requires that the object to jump from has its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_can_jump_from">can.jump_from</a>
   * property set to true, and that the object to jump to has its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_can_jump_to">can.jump_to</a>
   * property set to true. May also requires that the source
   * Asset has the destination Asset id listed in its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_things_player_can_jump_to_from_this">things_player_can_jump_to_from_this</a>
   * property.
   * </p>
   */
  A.Preverbs.jumpFrom_to = {
    name: "jumpFrom_to",
    prettyname: "jump",
    synonyms: [],
    verb_prep_noun_prep_noun: ["jump from to"],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
      not_on_target: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        player_parent: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        tangible: true,
        known: true,
        present: true,
        visible: true,
        not_player_parent: true,
        //reachable: true, // @TODO check can.jump_to and things_player_can_jump_to_from_this
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      // player not on thing they asked to jump from
      if (false === player.isNested() || nest_parent_id !== direct_object.id) {
        var msg = "$(We're) not on " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // prevent jump from under/behind
      if (
        player.isNested() &&
        ("under" === nest_preposition ||
          "behind" === nest_preposition ||
          (false === nest_parent_object.quirks.in_means_on &&
            "in" === nest_preposition))
      ) {
        var msg =
          "$(We) can't jump from " +
          nest_preposition +
          " " +
          direct_object.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // can't jump to
      if (false === indirect_object.can.jump_to) {
        var msg = "$(We) can't jump to " + indirect_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // can't jump from
      if (false === direct_object.can.jump_from) {
        var msg = "$(We) can't jump from " + direct_object.articlename + ". ";

        if (direct_object.can.swing_from) {
          msg +=
            "$(We) might be able to swing from " +
            direct_object.articlename +
            ". ";
        }

        this.handleFailure(msg);
        return null;
      }

      // no jumping between these objects
      if (
        player.isNested() &&
        -1 ===
          direct_object.things_player_can_jump_to_from_this.indexOf(
            indirect_object.id
          ) &&
        -1 ===
          direct_object.things_player_can_do_all_verbs_to_from_this.indexOf(
            indirect_object.id
          )
      ) {
        var msg =
          "$(We) can't jump from " +
          direct_object.articlename +
          " to " +
          indirect_object.articlename +
          ". ";

        if (
          direct_object.can.swing_from &&
          (-1 !==
            direct_object.things_player_can_swing_to_from_this.indexOf(
              indirect_object.id
            ) ||
            -1 !==
              direct_object.things_player_can_do_all_verbs_to_from_this.indexOf(
                indirect_object.id
              ))
        ) {
          msg +=
            "$(We) might be able to swing from " +
            direct_object.articlename +
            " to " +
            indirect_object.articlename +
            ". ";
        }

        this.handleFailure(msg);
        return null;
      }

      // figure out y overlap
      var range = indirect_object.getYRange();

      // is player close enough on y?
      if (player.position.y < range.min) {
        var msg =
          "$(We) can't jump up to " +
          indirect_object.articlename +
          " from your position on " +
          direct_object.articlename +
          ". ";
        if (msg) this.game.print(msg, input.output_class);
        return null;
      }

      // TODO:
      // is object an exit? eg "jump to hatch"
      // for now just redirect to the exit
      // this might need to be revisited
      if (
        indirect_object instanceof adventurejs.Exit ||
        indirect_object instanceof adventurejs.Aperture
      ) {
        this.game.dictionary.doVerb(indirect_object.direction);
        return null;
      }

      // player is on floor
      // if( false === player.isNested()
      //   && player.isOnFloor()
      // ) {
      //   var msg = "$(We'll) have to get up off the floor first.";
      //   if(msg) this.game.print( msg, input.output_class );
      //   return null;
      // }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var results;

      // If direct_object is an exit/aperture, we already shunted to "enter".

      /**
       * We check default_aspect_for_go_on
       * and default_posture_for_go_on for context.
       */

      var posture;
      if (indirect_object.can_stand_on) {
        posture = "stand";
      } else {
        posture = indirect_object.default_posture_for_go_on;
      }
      var preposition = indirect_object.default_aspect_for_go_on;

      var msg = "$(We) ";
      if (player.isOnFloor()) {
        msg += "get up and ";
      }
      msg += "jump to " + indirect_object.articlename + ". ";

      // DO THE THING!
      if (player.isNested()) {
        results = player.onUnnestThisFromThat(direct_object);
        if ("undefined" !== typeof results) return results;
      }
      results = player.onNestThisToThat(indirect_object, preposition);
      if ("undefined" !== typeof results) return results;

      player.posture = posture;

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // jumpFrom_to

// jumpOff.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class jumpOff
   * @ajsnode game.dictionary.verbs.jumpOff
   * @ajsconstruct MyGame.createVerb({ "name": "jumpOff", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @ajssynonyms hop off, jump from, jump off, leap from, leap off
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; jump off bridge</span>
   * You jump off the bridge. Spoosh! You land in the thin
   * creek, which sweeps you under the bridge. The troll swipes
   * at you from the steep embankment but its hairy arms can't
   * quite reach you.
   * </pre>
   * <p>
   * <strong>Jump off</strong> aka <strong>jump from</strong>
   * requires that the player be nested in a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * The results are similar to those of {@link go_off}.
   * </p>
   */
  A.Preverbs.jumpOff = {
    name: "jumpOff",
    prettyname: "jump off",
    synonyms: [],
    verb_prep_noun: [
      "hop off",
      "jump from",
      "jump off",
      "leap from",
      "leap off",
    ],

    player_must_be: {
      //not_on_floor: true,
      not_constrained: true,
      //not_under: true,
      //not_behind: true,
      //not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /*
     * "jump off" can work with or without a direct object.
     */
    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();
      var direct_object = input.getAsset(1);

      /**
       * jump off is uncommon in that it requires a noun
       * but can be called without one, in which case we try to
       * assume an implicit noun - anything the player is nested
       * in, or the current room.
       */
      if (!direct_object) {
        // was jumpoff called without noun?
        if (player.isNested()) {
          // if player is nested assume they're trying to leave nest
          direct_object = nest_parent_object;
        } else {
          // otherwise try to exit the room
          direct_object = this.game.world[this.game.world._currentRoom];
        }
        input.setAsset(1, direct_object);
      }

      // if thing can't be gotten off
      if (nest_parent_id === direct_object.id && direct_object.is.unleavable) {
        var msg =
          "$(We) can't leave " + direct_object.articlename + " that way.";
        this.handleFailure(msg);
        return null;
      }

      // player has tried to jump out of room that is not container
      if (
        direct_object.id === this.game.world._currentRoom &&
        false === direct_object.can_go_off
      ) {
        var msg = "How would $(we) do that?";
        this.handleFailure(msg);
        return null;
      }

      // what if player is sitting in a chair in, eq, a submarine?
      if (
        direct_object.id === this.game.world._currentRoom &&
        player.getPlaceAspect().player.can.exit &&
        player.isNested()
      ) {
        var msg =
          "$(We) can't do that from $(our) position " +
          player.getPostureGerund() +
          nest_preposition +
          " " +
          nest_parent_object.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // player is on floor in, eg, a submarine?
      if (
        direct_object.id === this.game.world._currentRoom &&
        direct_object.getPlaceAspect().player.can.exit &&
        false === player.isNested() &&
        player.isOnFloor()
      ) {
        var msg =
          "$(We) can't do that from $(our) position " +
          player.getPostureGerund() +
          " on the floor.";
        this.handleFailure(msg);
        return null;
      }

      // nested in some other way
      if (
        false === direct_object instanceof adventurejs.Room &&
        direct_object.id === nest_parent_id &&
        "on" !== nest_preposition &&
        (false === direct_object.quirks.in_means_on ||
          "in" !== nest_preposition)
      ) {
        var msg =
          "$(We're) " +
          nest_preposition +
          " " +
          direct_object.articlename +
          ", not on it.";
        this.handleFailure(msg);
        return null;
      }

      // not even in the thing
      if (
        false === direct_object instanceof adventurejs.Room &&
        direct_object.id !== nest_parent_id
      ) {
        var msg = "$(We're) not even on " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // not something you could be on anyway
      if (
        false === direct_object instanceof adventurejs.Room &&
        false === direct_object.can_go_on
      ) {
        var msg =
          "$(We're) not on, and can't get on, " +
          direct_object.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // TODO:
      // what other conditions prevent player from getting out?
      // tied down?

      // TODO: what if player is in body of water?

      // what if player is on, eg, a branch up a tree?
      // redirect to exit verb
      if (
        direct_object.id === this.game.world._currentRoom &&
        direct_object.can_jump_off
      ) {
        this.game.dictionary.doVerb("exit");
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();
      var results;

      var msg =
        "$(We) jump " +
        player.getPrettyUnnestPreposition() +
        " " +
        direct_object.articlename +
        ". ";

      results = player.onUnnestThisFromThat(nest_parent_object);
      if ("undefined" !== typeof results) return results;

      player.position.y = 0;
      player.posture = "stand";

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // jumpOff

// jumpOn.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class jumpOn
   * @ajsnode game.dictionary.verbs.jumpOn
   * @ajsconstruct MyGame.createVerb({ "name": "jumpOn", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @ajssynonyms hop on, jump on, jump onto
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; jump on pedestal</span>
   * You jump on to the floating crystal pedestal. It rises slowly
   * into the air, carrying you toward the top of the tall fluted chamber.
   * </pre>
   * <p>
   * <strong>Jump on</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} has an <strong>on</strong>
   * {@link adventurejs.Aspect|Aspect}.
   * See
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>
   * to learn more.
   * </p>
   */
  A.Preverbs.jumpOn = {
    name: "jumpOn",
    prettyname: "jump on",
    synonyms: [],
    verb_prep_noun: ["hop on", "jump on"],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      // TODO:
      // is object an exit? eg "jump on stage"
      // for now just redirect to the exit
      // this might need to be revisited
      if (
        direct_object instanceof adventurejs.Exit ||
        direct_object instanceof adventurejs.Aperture
      ) {
        this.game.dictionary.doVerb(direct_object.direction);
        return null;
      }

      // player is already in/on target
      if (
        direct_object.id === nest_parent_id &&
        ("on" === nest_preposition ||
          (direct_object.quirks.in_means_on && "in" === nest_preposition))
      ) {
        // var msg = "$(We're) already "
        //   + nest_preposition
        //   + " "
        //   + direct_object.articlename
        //   + ". ";
        var msg =
          "$(We) jump up and down a bit " +
          nest_preposition +
          " " +
          direct_object.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // player is nested some other way with target
      // and needs to unnest first
      if (
        direct_object.id === nest_parent_id &&
        ((false === direct_object.quirks.in_means_on &&
          "on" !== nest_preposition) ||
          (direct_object.quirks.in_means_on &&
            "on" !== nest_preposition &&
            "in" !== nest_preposition))
      ) {
        var msg =
          "$(We) can't do that from $(our) position " +
          player.getPostureGerund() +
          " " +
          nest_preposition +
          " " +
          nest_parent_object.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // player can't nest in/on object at all
      if (
        (false === direct_object.quirks.in_means_on &&
          false === direct_object.can.jump_on) ||
        (direct_object.quirks.in_mean._on &&
          false === direct_object.can.jump_on &&
          false === direct_object.can.jump_in)
      ) {
        var msg = "$(We) can't get on " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var results;

      // If direct_object is an exit/aperture, we already shunted to "enter".

      /**
       * We check default_aspect_for_go_on
       * and default_posture_for_go_on for context.
       */

      var posture = direct_object.default_posture_for_go_on;
      var preposition = direct_object.default_aspect_for_go_on;
      var msg = "";

      if (direct_object.is.climbable) {
        msg += "$(Our) start y is " + player.position.y + ". ";
      }

      msg +=
        "$(We) jump up and " +
        posture +
        " " +
        preposition +
        " " +
        direct_object.articlename +
        ". ";

      // DO THE THING!
      results = player.onNestThisToThat(direct_object, preposition);
      if ("undefined" !== typeof results) return results;

      player.posture = posture;

      if (direct_object.is.climbable) {
        player.position.y++;
        msg += "$(Our) end y is " + player.position.y + ". ";
      }

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // jumpOn

// jumpTo.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class jumpTo
   * @ajsnode game.dictionary.verbs.jumpTo
   * @ajsconstruct MyGame.createVerb({ "name": "jumpTo", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @todo check can.jump_to and things_player_can_jump_to_from_this
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; jump to parapet</span>
   * You jump to the parapet. Beyond the low wall sprawls a rolling
   * landscape of fields and dells. Deer graze in the fields.
   * A nearby path leads to distant foothills.
   * </pre>
   * <p>
   * <strong>Jump to</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}
   * <strong>Jump to</strong> is a catchall that redirects to
   * {@link jumpOn} or
   * {@link jumpFrom_to}
   * depending on whether player is nested in another Asset.
   * </p>
   */
  A.Preverbs.jumpTo = {
    name: "jumpTo",
    prettyname: "jump to",
    synonyms: [],
    verb_prep_noun: ["jump to"],
    verb_prep_prep_noun: ["jump over to"],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var output_class = input.output_class;
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      if (false === player.isNested()) {
        this.game.dictionary.doVerb("jumpOn");
        return null;
      }

      // if player is nested, redirect to jumpfromto
      if (player.isNested()) {
        input.parsedNoun2 = A.clone.call(this.game, input.parsedNoun1);
        input.parsedNoun1 = new adventurejs.ParsedNoun(nest_parent_object);
        input.input_verb = "jumpTo";
        this.game.dictionary.doVerb("jumpFrom_to");
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var output_class = input.output_class;
      var player = this.game.getPlayer();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      // If direct_object is an exit/aperture, we already shunted to "enter".

      /**
       * The phrase "get on" is less vague than its partner phrase
       * "get in", but still a bit vague about the preposition,
       * which could mean "in" or "on" in the case of a chair,
       * and the posture which could mean "sit" or "lie" or "stand"
       * in the case of a bed.
       * So we check default_aspect_for_go_on
       * and default_posture_for_go_on for context.
       */

      // var posture;
      // if( direct_object.can_stand_on ) {
      //   posture = "stand";
      // }
      // else {
      //   posture = direct_object.default_posture_for_go_on.toLowerCase();
      // }
      // var preposition = direct_object.default_aspect_for_go_on.toLowerCase();

      // var msg = "$(We) ";
      // if( player.isOnFloor() ) {
      //   msg += "get up and ";
      // }
      //   msg += "jump to "
      //   + direct_object.articlename
      //   + ". ";

      // // DO THE THING!
      // var results;
      // if( player.isNested() )
      // {
      //   results = player.onUnnestThisFromThat( nest_parent_object );
      //   if( false === results ) { return false; }
      //   else if ( null === results ) { return null; }
      //   }
      // results = player.onNestThisToThat( direct_object, preposition );
      // if( false === results ) { return false; }
      // else if ( null === results ) { return null; }

      // player.posture = posture;

      // this.handleSuccess( msg, direct_object );
      // return params
    },
  };
})(); // jumpTo

// swing_across_on.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_across_on
   * @ajsnode game.dictionary.verbs.swing_across_on
   * @ajsconstruct MyGame.createVerb({ "name": "swing_across_on", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swing across shaft on rope</span>
   * You grab the Princess. She kisses you for good luck. You leap
   * into space, swing across the bottomless shaft, and land on
   * the ledge on the other side.
   * </pre>
   * <p>
   * <strong>Swing across</strong> one
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} on another.
   * Requires that the direct object has its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_can_swing_across">can.swing_across</a>
   * property set to true, and the indirect object has its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_can_swing_on">can_swing.on</a>
   * property set to true.
   * The verb is intended for statements like
   * <code class="property">swing across chasm on vine<code>,
   * but no special logic is provided.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   */
  A.Preverbs.swing_across_on = {
    name: "swing_across_on",
    prettyname: "swing across",
    synonyms: [],
    verb_prep_noun_prep_noun: ["swing across on", "swing across over"],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      not_under: true,
      not_behind: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'across', 'over', 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        //reachable: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true /* @todo this goes away on consolidate swing */,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'on', 'with' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      // not something you could be on anyway
      if (false === direct_object.can.swing_across) {
        var msg =
          "$(We) can't swing across " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // not something you could be on anyway
      if (false === indirect_object.can.swing_on) {
        var msg = "$(We) can't swing on " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // nested
      //if( player.isNested() )
      // {
      // is player's nest in direct_object's list of
      //}

      // not nested

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();
      var results;

      var msg =
        "$(We) swing across " +
        direct_object.articlename +
        " on " +
        indirect_object.articlename +
        ". ";
      //var msg = "Perhaps $(we) should try swinging to or from something. ";

      // nested
      // results = player.onUnnestThisFromThat( nest_parent_object );
      // if( false === results ) { return false; }
      // else if ( null === results ) { return null; }

      // not nested

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // swing_across_on

// swing_across.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_across
   * @ajsnode game.dictionary.verbs.swing_across
   * @ajsconstruct MyGame.createVerb({ "name": "swing_across", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swing across marsh</span>
   * You swing across the crocodile infested marsh. The crocodiles
   * grumpf with disappointment.
   * </pre>
   * <p>
   * <strong>Swing across</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_can_swing_across">can.swing_across</a>
   * property set to true.
   * The verb is intended for statements like
   * <code class="property">swing across chasm<code>,
   * but no special logic is provided.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   */
  A.Preverbs.swing_across = {
    name: "swing_across",
    prettyname: "swing across",
    synonyms: [],
    verb_prep_noun: ["swing across", "swing over"],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      not_under: true,
      not_behind: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'across', 'over', 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        //reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      // not something you could be on anyway
      if (false === direct_object.can.swing_across) {
        var msg =
          "$(We) can't swing across " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // nested
      //if( player.isNested() )
      // {
      // is player's nest in direct_object's list of
      //}

      // not nested

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();
      var results;

      var msg = "$(We) swing across " + direct_object.articlename + ". ";
      //var msg = "Perhaps $(we) should try swinging swinging to or from something. ";

      // nested
      // results = player.onUnnestThisFromThat( nest_parent_object );
      // if( false === results ) { return false; }
      // else if ( null === results ) { return null; }

      // not nested

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // swing_across

// swing_at.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_at
   * @ajsnode game.dictionary.verbs.swing_at
   * @ajsconstruct MyGame.createVerb({ "name": "swing_at", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; </span>
   *
   * </pre>
   * <p>
   * Description of the verb.
   * </p>
   */
  A.Preverbs.swing_at = {
    name: "swing_at",
    prettyname: "swing",
    synonyms: [],
    verb_noun_prep_noun: ["swing at"],

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        in_hands: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true /* @todo kill on consolidation */,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'at' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        //reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();

      if (false === direct_object.can.be_swung) {
        var msg = "$(We) can't swing " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return false;
      }

      if (false === indirect_object.can.be_swung_at) {
        var msg =
          "$(We) can't swing anything at " + indirect_object.articlename + ". ";
        this.handleFailure(msg);
        return false;
      }

      // TODO
      // is some special condition preventing player from dropping item?
      // underwater
      // zero gravity

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      console.log("swingat.doSuccess");
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var currentRoom = this.game.getCurrentRoom();

      var msg =
        "$(We) swing " +
        direct_object.articlename +
        " at " +
        indirect_object.articlename +
        ", and it bounces off. ";

      direct_object.incrementDoVerbCount("swing");
      indirect_object.incrementDoVerbCount("swing");
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // swing_at

// swing_from_to_on.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_from_to_on
   * @ajsnode game.dictionary.verbs.swing_from_to_on
   * @ajsconstruct MyGame.createVerb({ "name": "swing_from_to_on", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swing from branch to cliff on vine</span>
   * You grab the vine and swing from the branch to the cliff.
   * </pre>
   * <p>
   * <strong>Swing from</strong> one
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to another on a third.
   * Requires that
   * <li>
   * player is holding noun3
   * </li>
   * <li>
   * noun1 has its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_can_swing_from">can.swing_from</a>
   * property set to true
   * </li>
   * <li>
   * noun2 has its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_can_swing_to">can.swing_to</a>
   * </li>
   * <li>
   * noun2's ID is listed in noun1's
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_things_player_can_swing_to_from_this">things_player_can_swing_to_from_this</a>
   * </li>
   * </p>
   */
  A.Preverbs.swing_from_to_on = {
    name: "swing_from_to_on",
    prettyname: "swing",
    synonyms: [],
    verb_prep_noun_prep_noun_prep_noun: [
      "swing from to with",
      "swing from to on",
    ],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      not_under: true,
      not_behind: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'from' ], /* @todo */
      noun_must_be: {
        player_parent: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        not_player_parent: true,
      },
    },

    phrase3: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'on' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true, // TODO check can.swing_to and things_player_can_swing_to_from_this
        in_hands: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();

      var fromObject = this.game.world[input.parsedNoun1.qualified_object_id];
      var toObject = this.game.world[input.parsedNoun2.qualified_object_id];
      var onObject = this.game.world[input.parsedNoun3.qualified_object_id];

      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      // can't swing to
      if (false === toObject.can.swing_to) {
        console.log(
          "swingto failed because " + toObject.name + ".can.swing_to is false."
        );
        var msg = "$(We) can't swing to " + toObject.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // can't swing to thing being held
      if (toObject.id === onObject.id) {
        var msg =
          "$(We) can't swing to " +
          toObject.articlename +
          " on " +
          onObject.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // can't swing from
      if (false === fromObject.can.swing_from) {
        var msg = "$(We) can't swing from " + fromObject.articlename + ". ";
        if (
          -1 <
          fromObject.things_player_can_jump_to_from_this.indexOf(toObject.id)
        ) {
          msg +=
            "$(We) might be able to jump from " +
            fromObject.articlename +
            " to " +
            toObject.articlename +
            ". ";
        }
        this.handleFailure(msg);
        return null;
      }

      // no swinging between these objects
      if (
        -1 ===
          fromObject.things_player_can_swing_to_from_this.indexOf(
            toObject.id
          ) &&
        -1 ===
          fromObject.things_player_can_do_all_verbs_to_from_this.indexOf(
            toObject.id
          )
      ) {
        var msg = "$(We) can't swing from " + fromObject.articlename + " to ";
        +toObject.articlename + ". ";

        if (
          fromObject.can.jump_from &&
          (-1 !==
            fromObject.things_player_can_jump_to_from_this.indexOf(
              toObject.id
            ) ||
            -1 !==
              fromObject.things_player_can_do_all_verbs_to_from_this.indexOf(
                toObject.id
              ))
        ) {
          msg +=
            "$(We) might be able to jump from " +
            fromObject.articlename +
            " to " +
            toObject.articlename +
            ". ";
        }

        this.handleFailure(msg);
        return null;
      }

      // figure out y overlap
      var range = toObject.getYRange();

      // is player close enough on y?
      if (player.position.y > range.max || player.position.y < range.min) {
        var msg =
          toObject.Articlename +
          " is too far " +
          (player.position.y > range.max ? "below" : "above") +
          " your position on " +
          (player.isNested() ? nest_parent_object.articlename : "the floor") +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // TODO:
      // is object an exit? eg "jump to hatch"
      // for now just redirect to the exit
      // this might need to be revisited
      if (
        toObject instanceof adventurejs.Exit ||
        toObject instanceof adventurejs.Aperture
      ) {
        this.game.dictionary.doVerb(toObject.direction);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();

      var fromObject = this.game.world[input.parsedNoun1.qualified_object_id];
      var toObject = this.game.world[input.parsedNoun2.qualified_object_id];
      var onObject = this.game.world[input.parsedNoun3.qualified_object_id];
      var currentRoom = this.game.getCurrentRoom();

      var player = this.game.getPlayer();
      var nest_parent_id = player.getNestId();
      var posture = toObject.default_posture_for_swing_to;
      var preposition = toObject.default_aspect_for_swing_to;
      var results;

      // if player is nested, unnest
      results = player.onUnnestThisFromThat(fromObject);
      if ("undefined" !== typeof results) return results;

      // if it isn't already nested, nest it
      results = player.onNestThisToThat(toObject, preposition);
      if ("undefined" !== typeof results) return results;
      player.posture = posture;

      // var msg = "$(We) swing from "
      //   + fromObject.articlename
      //   + " to "
      //   + toObject.articlename
      //   + " and "
      //   + posture
      //   + " "
      //   + preposition
      //   + " it.";

      var msg =
        "$(We) swing from " +
        fromObject.articlename +
        " and land, " +
        player.getPostureGerund() +
        " " +
        preposition +
        " " +
        toObject.articlename +
        ". ";

      // must.let_go_after_swing
      if (
        player.IOVisConnectedToAsset("hold", onObject) &&
        onObject.must.let_go_after_swing
      ) {
        results = onObject.onReleaseThis(player);
        if ("undefined" !== typeof results) return results;

        msg += onObject.Articlename + " slips out of $(our) hands. ";
      }

      // must.let_go_after_swing
      else if (player.$has(onObject) && onObject.must.let_go_after_swing) {
        msg += onObject.Articlename + " slips out of $(our) hands. ";

        results = player.onRemoveThatFromThis(onObject);
        if ("undefined" !== typeof results) return results;

        results = currentRoom.onMoveThatToThis(onObject, "in");
        if ("undefined" !== typeof results) return results;
      }

      if (toObject.position.y !== player.position.y) {
        player.position.y = toObject.position.y;
      }

      // check if there's a custom msg
      this.handleSuccess(msg, fromObject);
      return true;
    },
  };
})(); // swing_from_to_on

// swing_from_to.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_from_to
   * @ajsnode game.dictionary.verbs.swing_from_to
   * @ajsconstruct MyGame.createVerb({ "name": "swing_from_to", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swing from flagpole to antenna</span>
   * Using the grapple, you swing from the flagpole to the antenna.
   * </pre>
   * <p>
   * <strong>Swing from</strong> one
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to another.
   * This verb is a catchall for the specific phrasing of
   * "swing from thing to thing", and has no success logic of its
   * own, but tries to redirect to
   * {@link swing_to_on} or
   * {@link swing_from_to_on}.
   * </p>
   * Figure out what player is swinging on then forward to swingFromToOn
   */
  A.Preverbs.swing_from_to = {
    name: "swing_from_to",
    prettyname: "swing from",
    synonyms: [],
    verb_prep_noun_prep_noun: ["swing from to"],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      not_under: true,
      not_behind: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'from' ], /* @todo */
      noun_must_be: {
        player_parent: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        //reachable: true, // TODO check can.swing_to and things_player_can_swing_to_from_this
        not_player_parent: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();

      /**
       * There are only a couple of conditions under which a
       * player can swing, so let's see if either of those are true.
       * Player must either:
       * - be ON a thing they can swing on
       * - or HOLDING a thing they can swing on
       */

      var player_can_swing = false;

      // see if player is nested, ex: on a vine
      // and they're trying "swing from vine to x"
      if (player.isNested() && player.getNestAsset().can.swing_on_if_nested) {
        var onObject = A.clone.call(this.game, input.parsedNoun1);
        var toObject = A.clone.call(this.game, input.parsedNoun2);
        input.parsedNoun1 = A.clone.call(this.game, toObject);
        input.parsedNoun2 = A.clone.call(this.game, onObject);
        this.game.dictionary.doVerb("swing_to_on");
        return null;
      }

      // see if player is holding a rope that's supports swinging
      var swingobject;
      if (false === player_can_swing) {
        var holding = player.IOVgetConnections("hold");
        for (var i = 0; i < holding.length; i++) {
          swingobject = this.game.getAsset(holding[i]);
          if (
            swingobject.can.swing_on_if_holding ||
            (swingobject.can.swing_on_if_holding_and_supported &&
              swingobject.is.supported)
          ) {
            player_can_swing = true;
            break;
          }
        }
      }

      if (player_can_swing) {
        input.parsedNoun3 = new adventurejs.ParsedNoun(swingobject);
        this.game.dictionary.doVerb("swing_from_to_on");
        return null;
      }

      var msg = "$(We're) not holding anything $(we) can swing on. ";
      this.handleFailure(msg);
      return null;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var msg = "$(We) swing! ";
      if (msg) this.game.print(msg, input.output_class);
      return null;
    },
  };
})(); // swing_from_to

// swing_from.js

/**
 * Figure out what player is swinging on then forward to swingFromToOn
 */
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_from
   * @ajsnode game.dictionary.verbs.swing_from
   * @ajsconstruct MyGame.createVerb({ "name": "swing_from", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swing from tree</span>
   * What would you like to swing to
   * </pre>
   * <p>
   * <strong>Swing from</strong> is a catchall that soft prompts for a
   * second noun, with a redirect to
   * {@link swing_from_to}.
   * </p>
   */
  A.Preverbs.swing_from = {
    name: "swing_from",
    prettyname: "swing from",
    synonyms: [],
    verb_prep_noun: ["swing from"],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      not_under: true,
      not_behind: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'from' ], /* @todo */
      noun_must_be: {
        player_parent: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var nest_parent_object = player.getNestAsset();

      var msg = "What would you like to swing to? ";

      // soft prompt for untiewith object
      input.setSoftPrompt({ noun2: true, verb: "swing_from_to" });
      this.handleFailure(msg);
      return null;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();

      var msg = "$(We) swing from " + input.parsedNoun1.articlename + ". ";
      if (msg) this.game.print(msg, input.output_class);
      return null;
    },
  };
})(); // swing_from

// swing_on_to.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_on_to
   * @ajsnode game.dictionary.verbs.swing_on_to
   * @ajsconstruct MyGame.createVerb({ "name": "swing_on_to", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swing on vine to branch</span>
   * You swing on the vine to the branch.
   * </pre>
   * <p>
   * <strong>Swing on to</strong> is a catchall that redirects to
   * {@link swing_to_on}.
   * </p>
   */
  A.Preverbs.swing_on_to = {
    name: "swing_on_to",
    prettyname: "swing",
    synonyms: [],
    verb_prep_noun_prep_noun: ["swing on to"],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      not_under: true,
      not_behind: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'on' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        //reachable: true,
        not_player_parent: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var parsedNoun1 = A.clone.call(this.game, input.parsedNoun2);
      var parsedNoun2 = A.clone.call(this.game, input.parsedNoun1);
      input.parsedNoun1 = A.clone.call(this.game, parsedNoun1);
      input.parsedNoun2 = A.clone.call(this.game, parsedNoun2);
      this.game.dictionary.doVerb("swing_to_on");
      return null;
    },
  };
})(); // swing_on_to

// swing_on.js

/**
 */
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_on
   * @ajsnode game.dictionary.verbs.swing_on
   * @ajsconstruct MyGame.createVerb({ "name": "swing_on", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swing on rope</span>
   * You swing on the rope.
   * </pre>
   * <p>
   * <strong>Swing on</strong> has two distinct interpretations:
   * <li>
   * Player is nested on a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} that swings,
   * such as hanging from a vine<br>
   * ex: swing on vine
   * </li>
   * <li>
   * Player is holding a Tangible Asset that can be swung on
   * (which needs to be tested)<br>
   * ex: "hold vine then swing on vine"
   * </li>
   * No special logic is provided on success.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * <!--
   * swingOn doesn't change state so it never results in success.
   * Print faux-success if player is holding a supported rope.
   * Print faux-success if player is nested on swingable.
   * -->
   */
  A.Preverbs.swing_on = {
    name: "swing_on",
    prettyname: "swing on",
    synonyms: [],
    verb_prep_noun: ["swing on"],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      not_under: true,
      not_behind: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'on' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();

      if (false === direct_object.can.swing_on) {
        var msg = "$(We) can't swing on " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      if (
        !player.IOVisConnectedToAsset("hold", direct_object) &&
        direct_object.id !== player.getNestId()
      ) {
        var msg = "$(We're) not holding " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // player is nested on directobject
      if (
        direct_object.can.swing_on &&
        direct_object.id === player.getNestId()
      ) {
        var msg =
          "$(We) swing back and forth " +
          player.getNestPreposition() +
          " " +
          direct_object.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      if (player.IOVisConnectedToAsset("hold", direct_object)) {
        var can_be_swung = false;
        var msg = "";
        if (direct_object.can.swing_on_if_holding) {
          can_be_swung = true;
        } else if (
          direct_object.can.swing_on_if_holding_and_supported &&
          direct_object.is.supported
        ) {
          can_be_swung = true;
        }
        if (can_be_swung) {
          msg =
            "$(We) swing on " +
            direct_object.articlename +
            " and then land back at your original position.";
        } else {
          msg = "$(We) can't swing on " + direct_object.articlename + ". ";
        }
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var msg = "";

      // check if there's a custom msg
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // swing_on

// swing_to_on.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_to_on
   * @ajsnode game.dictionary.verbs.swing_to_on
   * @ajsconstruct MyGame.createVerb({ "name": "swing_to_on", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swing to stalactite on root</span>
   * You swing to the stalactite on the hanging root.
   * </pre>
   * <p>
   * <strong>swing_to_on</strong> has two distinct interpretations:
   * <li>Player is nested on a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} that swings,
   * such as hanging from a vine<br>
   * ex: swing to branch on vine</li>
   * <li>Player is holding a Tangible Asset that can be swung on
   * (which needs to be tested)<br>
   * ex: "hold vine then swing to branch on vine"</li>
   * If player is nested on something other
   * than the swingable, the verb redirects to
   * {@link swing_from_to_on}.
   * </p>
   */
  A.Preverbs.swing_to_on = {
    name: "swing_to_on",
    prettyname: "swing",
    synonyms: [],
    verb_prep_noun_prep_noun: ["swing to on"],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      not_under: true,
      not_behind: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        //reachable: true,
        not_player_parent: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'on' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true, // TODO check can.swing_to and things_player_can_swing_to_from_this
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);

      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      // is player nested and did player input object
      // for "on" that player is not on?
      // forward to swingfromtoon
      if (player.isNested() && nest_parent_id !== indirect_object.id) {
        input.parsedNoun3 = A.clone.call(this.game, input.parsedNoun2);
        input.parsedNoun2 = A.clone.call(this.game, input.parsedNoun1);
        input.parsedNoun1 = new adventurejs.ParsedNoun(nest_parent_object);
        this.game.dictionary.doVerb("swing_from_to_on");
        return null;
      }

      /**
       * There are only a couple of conditions under which a
       * player can swing, so let's see if either of those are true.
       * Player must either:
       * - or HOLDING a thing they can swing on
       * - be ON a thing they can swing on
       */

      var player_can_swing = false;

      // is player is nested on swingable thing?
      if (
        player.isNested() &&
        nest_parent_id === indirect_object.id &&
        indirect_object.can.swing_on_if_nested
      ) {
        player_can_swing = true;
      }

      // is player holding a swingable thing?
      if (player.IOVisConnectedToAsset("hold", indirect_object)) {
        if (indirect_object.can.swing_on_if_holding) {
          player_can_swing = true;
        } else if (
          indirect_object.can.swing_on_if_holding_and_supported &&
          indirect_object.is.supported
        ) {
          player_can_swing = true;
        }
      }

      // can't swing at all
      if (false === player_can_swing) {
        console.log(
          "swingto failed because player is not nested on nor holding swingable."
        );
        var msg =
          "$(We) can't swing to " +
          direct_object.articlename +
          " on " +
          indirect_object.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // can't swing to
      if (false === direct_object.can.swing_to) {
        console.log(
          "swingto failed because " +
            direct_object.name +
            ".can.swing_to is false."
        );
        var msg = "$(We) can't swing to " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // no swinging between these objects
      if (
        player.isNested() &&
        -1 ===
          nest_parent_object.things_player_can_swing_to_from_this.indexOf(
            direct_object.id
          ) &&
        -1 ===
          nest_parent_object.things_player_can_do_all_verbs_to_from_this.indexOf(
            direct_object.id
          )
      ) {
        var msg =
          "$(We) can't swing to " + direct_object.articlename + " from ";
        if (player.isNested()) {
          msg += " " + nest_parent_object.articlename;
        } else {
          msg += " here";
        }
        msg += ". ";

        if (
          nest_parent_object.can.jump_from &&
          (-1 !==
            nest_parent_object.things_player_can_jump_to_from_this.indexOf(
              direct_object.id
            ) ||
            -1 !==
              nest_parent_object.things_player_can_do_all_verbs_to_from_this.indexOf(
                direct_object.id
              ))
        ) {
          msg +=
            "$(We) might be able to jump from " +
            nest_parent_object.articlename +
            " to " +
            direct_object.articlename +
            ". ";
        }

        this.handleFailure(msg);
        return null;
      }

      // figure out y overlap
      var range = direct_object.getYRange();

      // is player close enough on y?
      if (player.position.y > range.max || player.position.y < range.min) {
        var msg =
          direct_object.Articlename +
          " is too far " +
          (player.position.y > range.max ? "below" : "above") +
          " your position on " +
          (player.isNested() ? nest_parent_object.articlename : "the floor") +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // TODO:
      // is object an exit? eg "jump to hatch"
      // for now just redirect to the exit
      // this might need to be revisited
      if (
        direct_object instanceof adventurejs.Exit ||
        direct_object instanceof adventurejs.Aperture
      ) {
        this.game.dictionary.doVerb(direct_object.direction);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var nest_parent_id = player.getNestId();
      var posture = direct_object.default_posture_for_swing_to;
      var preposition = direct_object.default_aspect_for_swing_to;
      var results;

      // if player is nested, unnest
      if (player.isNested() && nest_parent_id !== direct_object.id) {
        results = player.onUnnestThisFromThat(direct_object);
        if ("undefined" !== typeof results) return results;
      }

      // if it isn't already nested, nest it
      if (nest_parent_id !== direct_object.id) {
        results = player.onNestThisToThat(direct_object, preposition);
        if ("undefined" !== typeof results) return results;
        player.posture = posture;
      }

      var msg =
        "$(We) swing to " +
        direct_object.articlename +
        " and land, " +
        player.getPostureGerund() +
        " " +
        preposition +
        " it. ";

      // must.let_go_after_swing
      if (
        player.IOVisConnectedToAsset("hold", indirect_object) &&
        indirect_object.must.let_go_after_swing
      ) {
        results = indirect_object.onReleaseThis(player);
      }
      msg += indirect_object.Articlename + " slips out of $(our) hands. ";

      if (direct_object.position.y !== player.position.y) {
        player.position.y = direct_object.position.y;
      }

      // check if there's a custom msg
      this.handleSuccess(msg, direct_object);

      return true;
    },
  };
})(); // swing_to_on

// swing_to.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swing_to
   * @ajsnode game.dictionary.verbs.swing_to
   * @ajsconstruct MyGame.createVerb({ "name": "swing_to", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swing to Chrysler Building</span>
   * You swing to the Chrysler Building.
   * </pre>
   * <p>
   * <strong>Swing to</strong> is the simplest form of <strong>swing</strong>
   * and doesn't contain enough information to act on,
   * but depending on context, it will redirect to
   * {@link swing_to_on} or
   * {@link swing_from_to_on}.
   *
   * <li>
   * If player is nested on a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} that swings,
   * such as hanging from a vine, verb will redirect to
   * {@link swing_to_on}.
   * </li>
   *
   * <li>
   * If player is not nested on one Tangible Asset and holding
   * another that can be swung on, verb will also redirect to
   * {@link swing_to_on}.
   * </li>
   *
   * <li>
   * If player is nested on a Tangible Asset and holding
   * another Asset that can be swung on,
   * verb will redirect to
   * {@link swing_from_to_on}.
   * </li>
   *
   * </p>
   * Description of the verb.
   * IDEAL FORM: swing from x to y with z
   * swing to y
   * swing from x to y
   * Use cases:
   *
   * <li>player is on a thing that swings, ex: hanging from a vine</li>
   *
   * <li>player is holding a thing that swings and is also tied at one end
   * to a suspension, ex: "hold vine. swing to x"</li>
   */
  A.Preverbs.swing_to = {
    name: "swing_to",
    prettyname: "swing to",
    synonyms: [],
    verb_prep_noun: ["swing to"],
    verb_prep_prep_noun: ["swing over to"],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      not_under: true,
      not_behind: true,
      not_nested_elsewhere: true,
    },

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        //reachable: true,
        not_player_parent: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();

      /**
       * There are only a couple of conditions under which a
       * player can swing, so let's see if either of those are true.
       * Player must either:
       * - be ON a thing they can swing on
       * - or HOLDING a thing they can swing on
       */

      var player_can_swing = false;

      // see if player is nested, ex: on a vine
      if (player.isNested() && nest_parent_object.can.swing_on_if_nested) {
        input.parsedNoun2 = new adventurejs.ParsedNoun(nest_parent_object);
        this.game.dictionary.doVerb("swing_to_on");
        return null;
      }

      // see if player is holding/carrying a rope that supports swinging
      var swingobject;
      if (false === player_can_swing) {
        var holding = player
          .IOVgetConnections("hold")
          .concat(player.getContentsAt("in"));
        console.warn(holding);
        for (var i = 0; i < holding.length; i++) {
          swingobject = this.game.getAsset(holding[i]);
          if (
            swingobject.can.swing_on_if_holding ||
            (swingobject.can.swing_on_if_holding_and_supported &&
              swingobject.is.supported)
          ) {
            player_can_swing = true;
            break;
          }
        }
      }

      if (player_can_swing && false === player.isNested()) {
        input.parsedNoun2 = new adventurejs.ParsedNoun(swingobject);
        this.game.dictionary.doVerb("swing_to_on");
        return null;
      }

      if (player_can_swing && player.isNested()) {
        input.parsedNoun2 = A.clone.call(this.game, input.parsedNoun1);
        input.parsedNoun1 = new adventurejs.ParsedNoun(nest_parent_object);
        input.parsedNoun3 = new adventurejs.ParsedNoun(swingobject);
        this.game.dictionary.doVerb("swing_from_to_on");
        return null;
      }

      // can't swing at all
      if (false === player_can_swing) {
        console.log(
          "swingto failed because player is not nested on nor holding swingable."
        );
        var msg = "$(We're) not holding anything $(we) can swing on. ";
        this.handleFailure(msg);
        return null;
      }

      // we've shunted to swingToOn or errored - no need to proceed
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var msg = "$(We) swing! ";
      if (msg) this.game.print(msg, input.output_class);
      return true;
    },
  };
})(); // swing_to

// tie_to_and.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class tie_to_and
   * @ajsnode game.dictionary.verbs.tie_to_and
   * @ajsconstruct MyGame.createVerb({ "name": "tie_to_and", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; tie rope to boat and bollard</span>
   * You tie the rope to the boat and the bollard.
   * </pre>
   * <p>
   * <strong>Tie</strong> one
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to two other Tangible Assets.
   * Requires that the tying Asset has its
   * <code class="property">asset.dov.tie.enabled</code>
   * set to true and that the target Assets have their
   * <code class="property">asset.iov.tie.enabled</code>
   * set to true.
   * </p>
   */
  A.Preverbs.tie_to_and = {
    name: "tie_to_and",
    prettyname: "tie",
    synonyms: ["tieto"],
    verb_prep_prep_noun: [],
    verb_noun_prep_noun: ["tie to"],
    verb_noun_prep_noun_prep_noun: ["tie to and"],

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        //in_inventory: true,
        /**
         * Normally we'd want direct object to be in inventory,
         * but for tie to we might find a case such as a rope
         * that's tied to a bollard and needs to be tied to a boat.
         */
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    phrase3: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object1 = input.getAsset(2);
      var indirect_object2 = input.getAsset(3);
      var player = this.game.getPlayer();

      // example: tie rope to table
      // rope is direct_object
      // table is indirect_object1

      // can't tie if not holding direct_object
      if (
        false === direct_object.can.tie_this_to_things_without_holding &&
        false === player.$has(direct_object)
      ) {
        var msg = "$(We)'re not holding " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // can't tie with direct_object
      if (!direct_object.isDOV("tie")) {
        var msg =
          "$(We) can't tie anything with " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // can't tie to indirect_object1
      if (false === indirect_object1.can_tie_things_to_this) {
        var msg =
          "$(We) can't tie anything to " + indirect_object1.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // can't tie to indirect_object2
      if (indirect_object2 && !indirect_object2.can_tie_things_to_this) {
        var msg =
          "$(We) can't tie anything to " + indirect_object2.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // direct_object already tied to both indirectObjects
      if (
        indirect_object2 &&
        -1 !==
          direct_object.dov.tie?.with_params.connections.indexOf(
            indirect_object1.id
          ) &&
        -1 !==
          direct_object.dov.tie?.with_params.connections.indexOf(
            indirect_object2.id
          )
      ) {
        var msg =
          direct_object.Articlename +
          " is already tied to both " +
          indirect_object1.articlename +
          " and " +
          indirect_object2.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // direct_object already tied to indirect_object1
      if (
        -1 !==
        direct_object.dov.tie?.with_params.connections.indexOf(
          indirect_object1.id
        )
      ) {
        var msg =
          direct_object.Articlename +
          " is already tied to " +
          indirect_object1.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // direct_object already tied to indirect_object2
      if (
        indirect_object2 &&
        -1 !==
          direct_object.dov.tie?.with_params.connections.indexOf(
            indirect_object2.id
          )
      ) {
        var msg =
          direct_object.Articlename +
          " is already tied to " +
          indirect_object2.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      // direct_object is maxed out
      if (
        direct_object.dov.tie?.with_params.connections.length >=
        direct_object.dov.tie.with_params.max_connections
      ) {
        var msg =
          direct_object.Articlename + " can't be tied to any more things.";
        this.handleFailure(msg);
        return null;
      }

      // indirect_object1 is maxed out
      if (
        indirect_object1.iov.tie.with_params.connections.length >=
        indirect_object1.iov.tie.with_params.max_connections
      ) {
        var msg =
          indirect_object1.Articlename +
          " can't have any more things tied to it.";
        this.handleFailure(msg);
        return null;
      }

      // indirect_object1 is maxed out
      if (
        indirect_object2 &&
        indirect_object2.iov.tie.with_params.connections.length >=
          indirect_object2.iov.tie.with_params.max_connections
      ) {
        var msg =
          indirect_object2.Articlename +
          " can't have any more things tied to it.";
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object1 = input.getAsset(2);
      var indirect_object2 = input.getAsset(3);
      var player = this.game.getPlayer();
      var results;

      results = direct_object.onTieThisToThat(indirect_object1);
      if ("undefined" !== typeof results) return results;

      if (indirect_object2) {
        results = direct_object.onTieThisToThat(indirect_object2);
        if ("undefined" !== typeof results) return results;
      }

      var msg =
        "$(We) tie " +
        direct_object.articlename +
        " to " +
        indirect_object1.articlename;

      if (indirect_object2) {
        msg += " and to " + indirect_object2.articlename;
      }

      /**
       * If indirect_object1 is takeable, move it into player's
       * inventory. This may lead to undesired side effects.
       * If you find that to be the case, set
       * game.settings.on_tie_rope_to_takeable_object_take_object
       * to false.
       */
      /*if( this.game.settings.on_tie_rope_to_takeable_object_take_object*/
      if (
        false === indirect_object1.isIn(player) &&
        indirect_object1.isDOV("take") &&
        indirect_object1.on_tie_to_this_take_this
      ) {
        results = player.onMoveThatToThis(indirect_object1, "in");
        if ("undefined" !== typeof results) return results;

        msg += ", and take " + indirect_object1.articlename;
      }

      if (
        indirect_object2 &&
        !indirect_object2.isIn(player) &&
        indirect_object2.isDOV("take") &&
        indirect_object1.on_tie_to_this_take_this
      ) {
        /*&& this.game.settings.on_tie_rope_to_takeable_object_take_object*/
        results = player.onMoveThatToThis(indirect_object2, "in");
        if ("undefined" !== typeof results) return results;

        msg += ", and take " + indirect_object2.articlename;
      }

      /**
       * If tying rope to its max number of items, and
       * the items are not in player's inventory, remove
       * rope from inventory. This may lead to undesired side
       * effects. If you find that to be the case, set
       * game.settings.onTieRopeToMaxPointsRemoveFromInventory
       * to false.
       */
      var tiedObjectsNotInInventory = 0;
      var ropeIsTiedToMaxObjects =
        direct_object.dov.tie?.with_params.connections.length ===
        direct_object.dov.tie?.with_params.max_connections;
      if (ropeIsTiedToMaxObjects) {
        for (
          var i = 0;
          i < direct_object.dov.tie?.with_params.connections.length;
          i++
        ) {
          var tiedObject = this.game.getAsset(
            direct_object.dov.tie?.with_params.connections[i]
          );
          if (false === tiedObject.isIn(player)) {
            tiedObjectsNotInInventory++;
          }
        }
      }
      var noTiedObjectsInInventory =
        tiedObjectsNotInInventory ===
        direct_object.dov.tie?.with_params.max_connections;
      if (
        this.game.settings.on_tie_rope_to_max_objects_drop_rope &&
        direct_object.isIn(player) &&
        ropeIsTiedToMaxObjects &&
        noTiedObjectsInInventory
      ) {
        var currentRoom = this.game.getCurrentRoom();

        results = player.onRemoveThatFromThis(direct_object);
        if ("undefined" !== typeof results) return results;

        // set thing's new location to player's location
        results = currentRoom.onMoveThatToThis(direct_object, "in");
        if ("undefined" !== typeof results) return results;

        msg += ", and let go of " + direct_object.articlename;
      }

      msg += ". ";

      this.handleSuccess(msg, direct_object);

      return true;
    },
  };
})(); // tie_to_and

// tie_to_with.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class tie_to_with
   * @ajsnode game.dictionary.verbs.tie_to_with
   * @ajsconstruct MyGame.createVerb({ "name": "tie_to_with", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @todo revisit tie x to y with z
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; tie boat to bollard with rope</span>
   * You tie the rope to the boat and the bollard.
   * </pre>
   * <p>
   * <strong>tie_to_with</strong> is a catchall that
   * redirects to {@link tie_to_and}.
   * </p>
   */
  A.Preverbs.tie_to_with = {
    name: "tie_to_with", // tie x to y with z
    prettyname: "tie",
    synonyms: [],
    verb_noun_prep_noun_prep_noun: ["tie to with"],

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'to' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    phrase3: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'with' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    do: function () {
      var input = this.game.getInput();
      var parsedNoun1 = A.clone.call(this.game, input.parsedNoun3);
      var parsedNoun2 = A.clone.call(this.game, input.parsedNoun1);
      var parsedNoun3 = A.clone.call(this.game, input.parsedNoun2);
      input.parsedNoun1 = A.clone.call(this.game, parsedNoun1);
      input.parsedNoun2 = A.clone.call(this.game, parsedNoun2);
      input.parsedNoun3 = A.clone.call(this.game, parsedNoun3);
      this.game.dictionary.doVerb("tie_to_and");
      return null;
    },
  };
})(); // tie_to_with

// unscrew_from.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class unscrew_from
   * @ajsnode game.dictionary.verbs.unscrew_from
   * @ajsconstruct MyGame.createVerb({ "name": "unscrew_from", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; unscrew widget from gewgaw</span>
   * You unscrew the widget from the gewgaw. The framistat starts
   * blinking.
   * </pre>
   * <p>
   * <strong>Unscrew</strong> one {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} from another.
   * Requires that the unscrewed Asset has
   * asset.dov.unscrew.enabled set to true.
   * </p>
   */
  A.Preverbs.unscrew_from = {
    name: "unscrew_from",
    synonyms: ["unscrew"],
    prettyname: "unscrew",
    verb_noun_prep_noun: ["unscrew from"],

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'from' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);

      // player didn't enter a second noun
      if (!indirect_object) {
        var parent = direct_object.getPlaceAsset();
        input.setAsset(2, parent);
        input.setAssumed(2);
      }

      // can't unscrew
      if (!direct_object.isDOV("unscrew")) {
        var msg = "$(We) can't unscrew " + direct_object.articlename;
        if (!input.getAssumed(2)) {
          msg += " from " + indirect_object.articlename;
        }
        msg += ". ";

        this.handleFailure(msg);
        return null;
      }

      // not attached to anything
      if (
        !direct_object.is.screwed ||
        !direct_object.isPlacedAtAspect("attached")
      ) {
        var msg = direct_object.Articlename + " isn't screwed ";
        if (input.getAssumed(2)) {
          msg += " to anything";
        } else {
          // ... to specified thing
          msg += " to " + indirect_object.articlename;
        }
        msg += ". ";
        this.handleFailure(msg);
        return null;
      }

      // not screwed to specified thing
      if (
        direct_object.isPlacedAtAspect("attached") &&
        !input.getAssumed(2) &&
        direct_object.getPlaceAssetId() !== indirect_object.id
      ) {
        var msg =
          direct_object.Articlename +
          " isn't screwed to " +
          indirect_object.articlename +
          ". ";
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var msg = "";
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var doParent = direct_object.getPlaceAsset();
      var results;

      if (doParent.id !== indirect_object.id) {
        // remove thing from current parent
        //results = parent.onRemoveThatFromThis( direct_object );
        results = direct_object.moveFrom(doParent);
        if ("undefined" !== typeof results) return results;

        // add thing to new parent
        //results = indirect_object.onMoveThatToThis( direct_object, "attached" );
        results = direct_object.moveTo("attached", indirect_object);
        if ("undefined" !== typeof results) return results;
      }

      var msg =
        "$(We) unscrew " +
        direct_object.articlename +
        " from " +
        indirect_object.articlename +
        ". ";

      direct_object.is.screwed = false;
      direct_object.incrementDoVerbCount("unscrew");

      this.handleSuccess(msg, direct_object);

      return true;
    },
  };
})(); // unscrew_from

// untie_from.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class untie_from
   * @ajsnode game.dictionary.verbs.untie_from
   * @ajsconstruct MyGame.createVerb({ "name": "untie_from", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DeprecatedVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; untie leash from tree</span>
   * You untie the leash from the tree, releasing your pal Fido.
   * Fido runs across the field and disappears into the trees,
   * chasing rabbits and barking all the way.
   * </pre>
   * <p>
   * <strong>Untie</strong> one {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} from another.
   * Requires that the untied Asset has
   * asset.dov.untie.enabled set to true.
   * </p>
   */
  A.Preverbs.untie_from = {
    name: "untie_from",
    prettyname: "untie",
    synonyms: [],
    verb_noun_prep_noun: ["untie from"],

    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      //accepts_preposition: true,
      //requires_preposition: true,
      //accepts_these_prepositions: [ 'from' ], /* @todo */
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();

      // example: untie rope from table
      // rope is direct_object
      // table is indirect_object

      // is the rope tied to the thing?
      if (
        direct_object.dov.tie?.with_params.connections.indexOf(
          indirect_object.id
        ) === -1
      ) {
        var msg = direct_object.Articlename + " isn't";
        if (!direct_object.dov.tie || !indirect_object.iov.tie) {
          (", and can't be,");
        }
        msg += " tied to " + indirect_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      // can't be untied, which might be true even if it's a rope
      if (false === direct_object.isDOV("untie")) {
        var msg = "$(We) can't untie " + direct_object.articlename + ". ";
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var results;

      var msg =
        "$(We) untie " +
        direct_object.articlename +
        " from " +
        indirect_object.articlename;

      results = direct_object.onUntieThisFromThat(indirect_object);
      if ("undefined" !== typeof results) return results;

      if (
        this.game.settings
          .on_untie_rope_from_object_outside_inventory_take_rope &&
        false === direct_object.isIn(player) &&
        0 === direct_object.dov.tie?.with_params.connections.length
      ) {
        // set thing's new location to player
        results = player.onMoveThatToThis(direct_object, "in");
        if ("undefined" !== typeof results) return results;

        msg += ", and take " + direct_object.articlename;
      }

      msg += ". ";

      this.handleSuccess(msg, direct_object);

      return true;
    },
  };
})(); // untie_from

// again.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class again
   * @ajsnode game.dictionary.verbs.again
   * @ajsconstruct MyGame.createVerb({ "name": "again", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb meaning repeat last turn's input.
   * @ajssynonyms again, g
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; jump on bed</span>
   * You jump up and down on the bed for a bit.
   *
   * <span class="input">&gt; again</span>
   * You jump up and down on the bed for a bit.
   * </pre>
   * <p>
   * <strong>again</strong> repeats the last turn. It has no
   * executable code of its own and is only used by the parser.
   * It does not support verb subscriptions.
   * </p>
   */
  A.Preverbs.again = {
    name: "again",
    synonyms: ["again", "g"],
    // again.do should never execute.
    // sanitizeInput.js looks for "again" in input
    // and replaces it with the prior turn's input.

    /**
     * @ajsverbstructures
     * @memberof again
     */
    accepts_structures: ["verb"],

    do: function () {
      this.game.log(
        "error",
        "high",
        "again.do fired, but it never should because again is handled by parser.",
        "verbs"
      );
      return null;
    },
  };
})(); // again

// aim.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class aim
   * @ajsnode game.dictionary.verbs.aim
   * @ajsconstruct MyGame.createVerb({ "name": "aim", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading GesticulationVerbs
   * @summary Verb meaning aim a tangible asset.
   * @ajssynonyms aim
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; aim cannon at barge</span>
   * You aim the cannon at the barge. Now if only we had some powder!
   * </pre>
   * <p>
   * Aim a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}. Asset must have
   * asset.dov.aim.enabled
   * set to true. There's no particular
   * code to handle aiming, so any special results will need
   * to be custom coded through a method such as setting a
   * verb override for the Asset. To learn about verb hooks,
   * see <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.aim = {
    name: "aim",
    prettyname: "aim",
    past_tense: "aimed",
    synonyms: ["aim"],
    state: "aimed",

    /**
     * @ajsverbstructures
     * @memberof aim
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof aim
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof aim
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      accepts_preposition: true,
      requires_preposition: true,
      // accepts_these_prepositions: ["with"],
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
      },
    },

    /**
     * @memberof aim
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1767 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state? skip it
      // if( this.hasState() && direct_object.isState(this.name) )
      // {
      //   this.game.debug(`XXXX | ${this.name}.js | ${
      //   direct_object.id
      // }.is.${this.getState()} is ${direct_object.isState(this.name)}`);
      //   msg += `${direct_object.Articlename} is already ${this.getState()}. `;
      //   this.handleFailure(msg);
      //   return false;
      // }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1802 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1796 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1797 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1768 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1801 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1894 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1803 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } ) `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1769 | ${this.name}.js | print doSuccess `);

      // apply state changes
      // none

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // aim

// ask.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class ask
   * @ajsnode game.dictionary.verbs.ask
   * @ajsconstruct MyGame.createVerb({ "name": "ask", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading Conversation Verbs
   * @summary Verb meaning ask something of a character.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; ask large duck about crackers</span>
   * The large duck shrugs guiltily, snorting cracker crumbs from its beak.
   * </pre>
   * <p>
   * <strong>Ask {@link adventurejs.NPC|NPC} about thing</strong>.
   * A useful return requires that the NPC be programmed with
   * "knowledge" of the thing through a method such as a verb override.
   * To learn about verb hooks,
   * see <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @todo logic if player inputs "ask about thing" without noun
   * @todo most everything, this is a stub
   */
  A.Preverbs.ask = {
    name: "ask",
    prettyname: "ask about",
    synonyms: ["ask about"],
    verb_prep_noun: ["ask about"], // ask about thing
    verb_noun_prep_noun: ["ask about"], // ask person about thing

    /**
     * @memberof ask
     * @ajsverbphrase
     * phrase1:{
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     present: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        present: true,
      },
    },

    /**
     * @memberof ask
     * @ajsverbphrase
     * phrase2:{
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
      },
    },

    /**
     * @memberof ask
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var output_class = input.output_class;
      var msg = "";

      // can't talk to non-characters
      if (!(direct_object instanceof adventurejs.Character)) {
        this.game.debug(
          `F1231 | ${this.name}.js | ${direct_object.id} is not class Character`
        );
        msg += `${direct_object.Articlename} doesn't answer. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var output_class = input.output_class;
      var msg = "";

      // ask x about y
      this.game.debug(`F1232 | ${this.name}.js | print success`);
      msg += `$(We) ask ${direct_object.articlename} about ${indirect_object.articlename}. `;

      // @TODO transfer of knowledge

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // ask

// attach.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class attach
   * @ajsnode game.dictionary.verbs.attach
   * @ajsconstruct MyGame.createVerb({ "name": "attach", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning attach one tangible asset to another.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; attach crank to chicken</span>
   * You attach the crank to the chicken, creating an eggan grinder.
   * </pre>
   * <p>
   * Attach one {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to another.
   * Requires that the receiving Asset has an <code>attach</code>
   * {@link adventurejs.Aspect|Aspect}.
   * To learn about Aspects, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   * <h3>Logic Notes</h3>
   * <code>Attach</code> tries to move an asset into an aspect
   * (aka aspects.attached) of another asset.
   * @ajseventhooks
   * tryAttachThis
   * tryAttachThis[Preposition]That
   * tryAttachThat[Preposition]This
   * tryAttachThis[Preposition]That[Preposition]That
   * tryAttachThat[Preposition]This[Preposition]That
   * tryAttachThat[Preposition]That[Preposition]This
   * doAttachThis
   * doAttachThis[Preposition]That
   * doAttachThat[Preposition]This
   * doAttachThis[Preposition]That[Preposition]That
   * doAttachThat[Preposition]This[Preposition]That
   * doAttachThat[Preposition]That[Preposition]This
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */

  A.Preverbs.attach = {
    name: "attach",
    prettyname: "attach",
    past_tense: "attached",
    synonyms: ["attach", "connect"],
    //state: "attached", // state should be determined by place

    /**
     * @ajsverbstructures
     * @memberof attach
     */
    accepts_structures: [
      "verb noun",
      "verb noun preposition noun",
      "verb noun preposition noun preposition noun",
    ],

    /**
     * @memberof attach
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   // accepts_plural_noun: true, // @TODO allow "attach A and B"
     *   noun_must_be:
     *   {
     *     in_inventory_if_takeable: true,
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        in_inventory_if_takeable: true,
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof attach
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory_if_takeable: true,
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["to","with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory_if_takeable: true,
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["to", "with"],
    },

    /**
     * @memberof attach
     * @ajsverbphrase
     * phrase3:
     * {
     * },
     */
    phrase3: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory_if_takeable: true,
        known: true,
        tangible: true,
        present: true,
        reachable: true,
        //visible: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with", "to"],
    },

    /**
     * @memberof attach
     * @ajsverbparams
     * Unlike other verbs that make attachments, like plug and tie,
     * attach doesn't use verb param connections. Instead it results
     * in putting one asset inside another asset.aspects.attached.
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();

      var object1 = input.getAsset(1);
      var object2, object2_preposition;
      var tool, tool_preposition;

      var results, results2;
      var msg = "";

      // can direct_object be tied?
      if (object1.isDOV("tie")) {
        this.game.debug(`F1234 | ${this.name}.js | infer verb tie `);
        this.game.print(msg);
        this.game.dictionary.doVerb("tie");
        return null;
      }

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // prompt for object2, object to attach to
        input.setPreposition(2, "to");
        input.setSoftPrompt({
          noun2: true,
          structure: "verb noun preposition noun",
        });
        this.game.debug(`F1233 | ${this.name}.js | soft prompt for noun2 `);
        msg += `What would $(we) like to ${this.name} ${object1.articlename} to? `;
        this.handleFailure(msg);
        return null;
      } // verb noun

      // did player input with/with or to/to ?
      if (input.getPreposition(2) === input.getPreposition(3)) {
        // we don't understand that
        this.game.debug(
          `F1638 | ${this.name}.js | expected A to B with C, received two identical prepositions `,
        );
        msg += this.game.parser.getUnparsedMessage(this.game.getInput().input);
        this.handleFailure(msg);
        return null;
      }

      // did player input 'attach A with B to C'?
      if (
        "with" === input.getPreposition(2) &&
        "to" === input.getPreposition(3)
      ) {
        // swap B with C
        input.swapPhrases(2, 3);
      }

      // did player input 'attach A with B'?
      if ("with" === input.getPreposition(2) && !input.hasPhrase(3)) {
        // change 'with B' to 'with C' and prompt for 'to B'
        input.swapPhrases(2, 3);
        input.setPreposition(2, "to");
        input.setSoftPrompt({
          noun2: true,
          structure: "verb noun preposition noun preposition noun",
        });
        this.game.debug(`F1523 | ${this.name}.js | soft prompt for noun2 `);
        msg += `What would $(we) like to ${this.name} ${object1.articlename} to? `;
        this.handleFailure(msg);
        return null;
      }

      // at this point we should have 'attach A to B' or 'attach A to B with C'
      object2 = input.getAsset(2);
      object2_preposition = input.getPreposition(2);

      // these things apply to 'verb noun preposition noun' and 'verb noun preposition noun preposition noun'

      // verb enabled for one or the other?
      if (!object1.isDOV(this.name) && !object2.isDOV(this.name)) {
        this.game.debug(
          `F1349 | ${this.name}.js | neither ${object1.id} nor ${object2.id}.dov.${this.name}.enabled `,
        );
        msg += `${object1.Articlename} and ${object2.articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      // can either of these assets be attached to the other?
      if (
        !object1.canBePut("attached", object2) &&
        !object2.canBePut("attached", object1)
      ) {
        this.game.debug(
          `F1235 | ${this.name}.js | neither asset is listed in the other's .aspects.attached.with_assets/with_classes `,
        );
        msg += `${object1.Articlename} and ${object2.articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      // does object2 actually go in object1?
      if (
        !object1.canBePut("attached", object2) &&
        object2.canBePut("attached", object1)
      ) {
        input.swapNouns(1, 2);
        object1 = input.getAsset(1);
        object2 = input.getAsset(2);
      }

      // sentence structure: verb noun preposition noun
      // we put this way down here after all the object swapping is done
      if (input.hasStructure("verb noun preposition noun")) {
        // call actions
      }

      // already attached to something (else?)
      // TODO multiple attachments
      if (object1.isPlacedAtAspectAndAsset("attached", object2.id)) {
        this.game.debug(
          `F1236 | ${this.name}.js | ${object1.id} is attached to ${object2.id} `,
        );
        msg = `${object1.Articlename} is already attached to ${object2.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // tool, maybe?
      tool = input.getAsset(3);
      tool_preposition = input.getPreposition(3);

      // no tool?
      if (!tool) {
        // is a tool needed?
        if (
          !object1.DOVallowWithNothing(this.name) &&
          !object2.DOVallowWithNothing(this.name)
        ) {
          // tool needed
          results = this.tryToInferIndirectObject(object1);
          results2 = this.tryToInferIndirectObject(object2);
          if (results.success || results2.success) {
            // found a tool
            var either_one = results.success
              ? results.success
              : results2.success;
            tool = either_one.indirect_object;
            tool_preposition = "with";
            input.setNewPhrase({
              asset: tool,
              preposition: tool_preposition,
            });
            input.setStructure("verb noun preposition noun preposition noun");
          } else if (results.prompt || results2.prompt) {
            // prompt for tool
            // restructure sentence for next turn
            input.setPreposition(3, "with");
            input.setSoftPrompt({
              noun3: true,
              structure: "verb noun preposition noun preposition noun",
            });
            this.game.debug(`F1672 | ${this.name}.js | soft prompt for noun3 `);
            msg += `What would $(we) like to ${this.name} ${object1.articlename} to ${object2.articlename} with? `;
            this.handleFailure(msg);
            return false;
          }
        } // tool needed?
      } // no tool

      // by now we should have an input tool or an inferred tool or no tool needed

      // sentence structure: verb noun preposition noun preposition noun
      // ie: 'attach male pipe to female pipe with wrench'
      if (input.hasStructure("verb noun preposition noun preposition noun")) {
        // works with any indirect object?
        if (
          object1.DOVallowWithAnything(this.name) ||
          object2.DOVallowWithAnything(this.name)
        ) {
          return true;
        }

        // indirect object not required?
        if (
          object1.DOVallowWithNothing(this.name) &&
          object2.DOVallowWithNothing(this.name)
        ) {
          this.game.debug(
            `F1753 | ${this.name}.js | ${object1.id} and ${object2.id}.dov.${this.name}.with_nothing `,
          );
          msg += `${object1.Articlename} and ${object2.articlename} don't need another object to ${this.name} them. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (
          !object1.DOVallowWithAsset(this.name, tool) &&
          !object2.DOVallowWithAsset(this.name, tool)
        ) {
          this.game.debug(
            `F1750 | ${this.name}.js | neither ${object1.id} nor ${object2.id}.dov.${this.name}.with_assets/with_classes includes ${tool.id} `,
          );
          msg += `${tool.Articlename} can't be used to ${this.name} ${object1.articlename} to ${object2.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // single use indirect object?
        if (tool && tool.IOVallowOnce(this.name) && tool.IOVdidDo(this.name)) {
          this.game.debug(
            `F1820 | ${this.name}.js | ${tool.id}.iov.${this.name}.once and ${
              tool.id
            }.iov.${this.name}.do_count is ${tool.iov[this.name].do_count} `,
          );
          msg += `${tool.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun preposition noun

      return true;
    }, // doTry

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();

      var object1 = input.getAsset(1);
      var object1_parent = object1.getPlaceAsset();

      var object2 = input.getAsset(2);
      var object2_preposition = input.getPreposition(2);

      var tool = input.getAsset(3);
      var tool_preposition = input.getPreposition(3);

      var results;
      var msg = "";

      this.game.debug(`F1237 | ${this.name}.js | print doSuccess `);

      // set direct object place
      if (object1_parent.id !== object2.id) {
        // remove direct object from current parent
        results = object1.moveFrom(object1_parent);
        if ("undefined" !== typeof results) return results;

        // add direct object to new parent
        results = object1.moveTo("attached", object2);
        if ("undefined" !== typeof results) return results;
      }

      // apply state changes
      // object1.is[this.getState()] = true;

      // compose output
      msg += `$(We) ${this.name} ${object1.articlename}`;
      msg += object2 ? ` to ${object2.articlename}` : ``;
      msg += tool ? ` with ${tool.articlename}` : ``;
      msg += `. `;

      // print output
      this.handleSuccess(msg, object1);
      return true;
    },
  };
})(); // attach

// break.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class break
   * @ajsnode game.dictionary.verbs.break
   * @ajsconstruct MyGame.createVerb({ "name": "break", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning break a tangible asset.
   * @ajssynonyms break, smash, destroy
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; break Faberge egg</span>
   * You break the Faberge egg. Inside is a Kinder toy!
   * </pre>
   * <p>
   * Break a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}. Asset must have
   * asset.dov.break.enabled
   * set to true. There's no particular
   * code to handle breaking, so any special results will need
   * to be custom coded through a method such as setting a
   * verb override for the Asset. To learn about verb hooks,
   * see <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.break = {
    name: "break",
    prettyname: "break",
    past_tense: "broke",
    synonyms: ["break", "smash", "destroy"],
    state: "broken",

    /**
     * @ajsverbstructures
     * @memberof break
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof break
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof break
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof break
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1238 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1791 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.Articlename} is already ${this.getState()}. `;
        this.handleFailure(msg);
        return false;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1821 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1836 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1836 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1147 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1839 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1896 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1804 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";

      this.game.debug(`F1239 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // break

// brief.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class brief
   * @ajsnode game.dictionary.verbs.brief
   * @ajsconstruct MyGame.createVerb({ "name": "brief", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb meaning show brief room descriptions.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; brief</span>
   * Ok, I'll show shorter room descriptions.
   * </pre>
   * <p>
   * <strong>brief</strong> displays short {@link adventurejs.Room|Room}
   * descriptions if the author has provided them.
   * </p>
   */
  A.Preverbs.brief = {
    name: "brief",
    synonyms: ["brief"],

    /**
     * @ajsverbstructures
     * @memberof brief
     */
    accepts_structures: ["verb"],

    do: function () {
      var input = this.game.getInput();
      if (this.game.settings.verbosity > this.game.settings.min_verbosity) {
        this.game.settings.verbosity -= 1;
      }
      var msg = "Ok, I'll try to show shorter room descriptions. ";
      if (msg) this.game.print(msg, input.output_class);
      return true;
    },
  };
})();

// button.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class button
   * @ajsnode game.dictionary.verbs.button
   * @ajsconstruct MyGame.createVerb({ "name": "button", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb that means button, as in "button shirt".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; button shirt</span>
   * You button up your rumpled shirt, trying to make yourself presentable.
   * </pre>
   * <p>
   * <strong>Button</strong> a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has
   * asset.dov.button.enabled set to true.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.button = {
    name: "button",
    synonyms: ["button"],
    past_tense: "buttoned",
    prettyname: "button",
    state: "buttoned",

    /**
     * @ajsverbstructures
     * @memberof button
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof button
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     not_global: true,
     *     tangible: true,
     *     present: true,
     *     // visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        not_global: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof button
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof button
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1489 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1491 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.Articlename} is already ${this.getState()}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1492 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1493 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1508 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1509 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1931 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1897 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1615 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1616 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // button

// catch.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class catch
   * @ajsnode game.dictionary.verbs.catch
   * @ajsconstruct MyGame.createVerb({ "name": "catch", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning catch a tangible asset.
   * @ajssynonyms catch
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; catch Faberge egg</span>
   * You catch the Faberge egg. Whew!
   * </pre>
   * <p>
   * Catch a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}. Asset must have
   * asset.dov.catch.enabled
   * set to true. There's no particular
   * code to handle catching, so any special results will need
   * to be custom coded through a method such as setting a
   * verb override for the Asset. To learn about verb hooks,
   * see <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.catch = {
    name: "catch",
    prettyname: "catch",
    past_tense: "caught",
    synonyms: ["catch"],
    state: "caught",

    /**
     * @ajsverbstructures
     * @memberof catch
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof catch
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof catch
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
    },

    /**
     * @memberof catch
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1770 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1094 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1095 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1771 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1792 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1898 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1805 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1772 | ${this.name}.js | print doSuccess `);

      // move direct object from parent
      results = direct_object.moveFrom(direct_object.getPlaceAsset());
      if ("undefined" !== typeof results) return results;

      // move direct object to player
      results = direct_object.moveTo("in", player);
      if ("undefined" !== typeof results) return results;

      // apply state changes
      // none

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // catch

// climb.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class climb
   * @ajsnode game.dictionary.verbs.climb
   * @ajsconstruct MyGame.createVerb({ "name": "climb", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning climb, as in "climb tree"; or, travel in specified direction.
   * @ajssynonyms climb onto, climb on, climb up
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; climb tree</span>
   * You climb a good way into the tree before your climbing
   * is interrupted by an angry squirrel. Apparently you've
   * put a foot into the knot in which it stores its nuts.
   * </pre>
   * <p>
   * <strong>Climb</strong> can operate with or without
   * a noun, inferring from context whether the action can succeed.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.climb = {
    name: "climb",
    prettyname: "climb",
    past_tense: "climbed",
    synonyms: ["climb"],
    type: { locomotion: true, travel: true },

    verb_prep_noun: [
      // parse climb up / climb down as climb
      // to prevent up/down being treated as nouns
      //"climb down",
      //"climb up",
    ],

    /**
     * @ajsverbstructures
     * @memberof climb
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
      "verb preposition noun preposition noun",
      // "verb preposition noun preposition noun preposition noun",
    ],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      //not_under: true,
      //not_behind: true,
    },

    /**
     * @memberof climb
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   accepts_direction: true,
     *   noun_must_be:
     *   {
     *     not_global: true,
     *     tangible: true,
     *     known: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      accepts_direction: true,
      noun_must_be: {
        tangible: true,
        known: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof climb
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     known: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        tangible: true,
        known: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      accepts_these_prepositions: ["with", "to"],
    },

    /**
     * @memberof climb
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_asset = player.getNestAsset();
      var msg = "";
      var try_go, up, down, fromto;

      if (direct_object?.is.global) {
        // @TODO floor handling
        this.game.debug(
          `F1724 | ${this.name}.js | ${direct_object.id}.is.global `,
        );
        msg += `$(We) can't climb ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // doVerb go
      // @TODO what if you're half way up a wall and try to climb east on the wall?

      try_go = direct_object?.direction;
      if (
        direct_preposition &&
        -1 !== ["in", "out", "under", "behind"].indexOf(direct_preposition)
      ) {
        // ie climb in, climb under, climb behind
        try_go = true;
      }
      if (try_go) {
        this.game.debug(`F1190 | ${this.name}.js | infer 'go', doVerb go`);
        this.game.dictionary.doVerb("go");
        //this.game.tryTravel(direct_preposition);
        return null;
      }

      // sentence structure: verb ----------
      // ex: climb
      if (input.hasStructure("verb")) {
        // if climb was entered without any preposition or object,
        // assume up and try to get an object
        if (nest_asset) {
          // up or down?
          let h = nest_asset.dimensions.height;
          let y = nest_asset.position.y;
          let py = player.position.y;
          if (py >= y + h) input.setPreposition(1, "down");
          else input.setPreposition(1, "up");

          // update input
          input.setAsset(1, nest_asset);
          input.setStructure("verb preposition noun");
          direct_object = input.getAsset(1);
          direct_preposition = input.getPreposition(1);
        } else {
          // prompt for a direct object
          input.setSoftPrompt({ noun1: true });
          this.game.debug(
            `F1177 | ${this.name}.js | no noun provided or inferrable, soft prompt noun1`,
          );
          msg += `What would $(we) like to climb? `;
          this.handleFailure(msg);
          return null;
        }
      } // verb

      down =
        (direct_object && direct_object.direction === "down") ||
        direct_preposition === "off" ||
        direct_preposition === "down" ||
        (direct_preposition === "from" && !indirect_preposition);

      up =
        (direct_object && direct_object.direction === "up") ||
        (direct_object && !direct_preposition) ||
        direct_preposition === "up" ||
        direct_preposition === "on" ||
        direct_preposition === "over";

      // sentence structure: verb preposition ----------
      // climb down, climb up
      // try to get a noun
      if (input.hasStructure("verb preposition")) {
        // was nest asset the implied noun?
        if (nest_asset) {
          input.setAsset(1, nest_asset);
          input.setStructure(input.getStructure() + " noun");
          direct_object = input.getAsset(1);

          if (down && !nest_asset.is.climbable) {
            input.setPreposition(1, "off");
            direct_preposition = "off";
            this.game.debug(
              `F1206 | ${this.name}.js | infer 'climb down ${nest_asset.id} `,
            );
          }
        }

        if (!nest_asset) {
          if (down) {
            // if player is not nested then "climb down" means "down"
            this.game.debug(
              `F1186 | ${this.name}.js | infer 'go down', tryTravel down`,
            );
            this.game.tryTravel("down");
            return null;
          }

          if (up) {
            this.game.debug(
              `F1193 | ${this.name}.js | infer 'go up', tryTravel up`,
            );
            this.game.tryTravel("up");
            return null;
          }
        }
      } // verb preposition

      // sentence structure: verb noun ----------
      // ex: climb tree, climb east
      // try to get a preposition
      if (input.hasStructure("verb noun")) {
        // is player already on noun?
        // set preposition to nest_preposition
        if (nest_asset && nest_asset.id === direct_object.id) {
          direct_preposition = nest_preposition;
          input.setPreposition(1, direct_preposition);
          input.setStructure("verb preposition noun");
        }

        // is player not on noun?
        if (nest_asset && nest_asset.id !== direct_object.id) {
          input.swapPhrases(1, 2);
          input.setPreposition(1, "from");
          input.setPreposition(2, "to");
          input.setAsset(1, nest_asset);
          input.setStructure("verb preposition noun preposition noun");
          direct_object = input.getAsset(1);
          indirect_object = input.getAsset(2);
          direct_preposition = "from";
          indirect_preposition = "to";
        }
      } // verb noun

      // sentence structure: verb preposition noun ----------
      // ex: climb on tree
      // verify preposition and noun
      if (input.hasStructure("verb preposition noun")) {
        if (direct_preposition === "to") {
          // "climb to" is used for climbing from one
          // nest to another. If player isn't nested,
          // it's just regular "climb".
          if (!nest_asset) {
            input.setInPhrase(1, "preposition", "on");
            if (direct_object.position.y >= player.position.y) up = true;
            else down = true;
          }

          if (nest_asset && nest_asset.id === direct_object.id) {
            this.game.debug(
              `F1192 | ${this.name}.js | player is nested on ${direct_object.id} `,
            );
            msg += `$(We're) already on ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          if (nest_asset) {
            input.swapPhrases(1, 2);
            input.setPreposition(1, "from");
            input.setAsset(1, nest_asset);
            direct_object = input.getAsset(1);
            direct_preposition = input.getPreposition(1);
            indirect_object = input.getAsset(2);
            indirect_preposition = input.getPreposition(2);
            fromto = true;
            input.setStructure("verb preposition noun preposition noun");
          }
        } // to

        if (down && !nest_asset) {
          // @TODO this is a quick patch - need more handling here
          // could be my favorite example of a ladder in a hole

          if (direct_object.position.y >= player.position.y) {
            this.game.debug(
              `F1718 | ${this.name}.js | player is not on ${direct_object.id} `,
            );
            msg += `$(We're) not on ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // @TODO should this return true? do we still have more checking to do?
        }

        if (down && nest_asset) {
          if (
            direct_object.id === nest_asset.id &&
            direct_object.is.unleavable
          ) {
            this.game.debug(
              `F1184 | ${this.name}.js | ${direct_object.id}.is.unleavable is true `,
            );
            msg += `$(We) can't leave ${direct_object.articlename} that way. `;
            this.handleFailure(msg);
            return null;
          }
          // player is not on direct_object
          if (direct_object.id !== nest_asset.id) {
            this.game.debug(
              `F1185 | ${this.name}.js | player is not on ${direct_object.id} `,
            );
            msg += `$(We're) not on ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        } // down

        if (up && nest_asset && nest_asset.id !== direct_object.id) {
          // it's fromto
          input.swapPhrases(1, 2);
          input.setPreposition(1, "from");
          input.setPreposition(2, "to");
          input.setAsset(1, nest_asset);
          input.setStructure("verb preposition noun preposition noun");
          direct_object = input.getAsset(1);
          indirect_object = input.getAsset(2);
          direct_preposition = "from";
          indirect_preposition = "to";
        }

        if (up && nest_asset && nest_asset.id === direct_object.id) {
          if (
            "on" === nest_preposition &&
            player.position.y >= nest_asset.getYTop()
          ) {
            // player is already on target
            // and can't climb any higher
            this.game.debug(
              `F1178 | ${this.name}.js | player.position.y >= ${direct_object.id}.dimensions.height `,
            );
            msg += `$(We) can't climb any higher on ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        }

        // player is nested some other way with target
        // and needs to unnest first
        if (up && nest_asset && "on" !== nest_preposition) {
          this.game.debug(
            `F1179 | ${this.name}.js | player is ${nest_preposition} ${nest_asset.id} `,
          );
          msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} ${nest_preposition} ${
            nest_asset.articlename
          }. `;
          this.handleFailure(msg);
          return null;
        }

        // player can't nest in/on object at all
        if (
          (up && !direct_object.isDOV(this.name)) ||
          !direct_object.canPlayerNest("on")
        ) {
          this.game.debug(
            `F1196 | ${this.name}.js | !${direct_object.id}.dov.${this.name} or !${direct_object.id}.aspects.on.player.can.enter `,
          );
          msg += `$(We) can't climb ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        } // up
      } // verb preposition noun

      // sentence structure: verb noun preposition noun ----------
      if (input.hasStructure("verb noun preposition noun")) {
        // example: 'climb cliff with pick'
        if ("with" !== indirect_preposition && "to" !== indirect_preposition) {
          // already accounted for this in accepts_these_prepositions
          this.game.debug(`F1856 | ${this.name}.js | irregular phrase `);
          msg += this.game.parser.getUnparsedMessage(input.input);
          this.handleFailure(msg);
          return null;
        }

        // to ----------

        if ("to" === indirect_preposition) {
          // we got something like "climb tree to window"
          // we're going to treat it like "climb from tree to window"
          input.setPreposition(1, "from");
          direct_preposition = "from";
          input.setStructure("verb preposition noun preposition noun");
        }

        // with ----------

        if ("with" === indirect_preposition) {
          input.verb_params.with = true;

          // works with any indirect object?
          if (direct_object.DOVallowWithAnything(this.name)) {
            return true;
          }

          // indirect object not required?
          if (direct_object.DOVallowWithNothing(this.name)) {
            this.game.debug(
              `F1857 | ${this.name}.js | ${direct_object.id} can't be ${this.state} with ${indirect_object.id} `,
            );
            msg += `${indirect_object.Articlename} won't help $(us) ${this.name} ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // indirect object usable with direct object?
          if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
            this.game.debug(
              `F1858 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets does not include ${indirect_object.id} `,
            );
            msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // single use indirect object?
          if (
            indirect_object.IOVallowOnce(this.name) &&
            indirect_object.IOVdidDo(this.name)
          ) {
            this.game.debug(
              `F1859 | ${this.name}.js | ${indirect_object.id}.iov.${
                this.name
              }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
                indirect_object.iov[this.name].do_count
              } `,
            );
            msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
            this.handleFailure(msg);
            return null;
          }
        } // with
      } // verb noun preposition noun

      // sentence structure: verb preposition noun preposition noun
      // ex: climb from tree to roof
      if (input.hasStructure("verb preposition noun preposition noun")) {
        // climb from a to b is the only phrase we accept in this form

        if (direct_preposition === "to" && indirect_preposition === "from") {
          // reverse them
          var phrase2 = Object.assign({}, input.getPhrase(2));
          var phrase1 = Object.assign({}, input.getPhrase(1));

          input.setPhrase(1, phrase2);
          input.setPhrase(2, phrase1);

          direct_object = input.getAsset(1);
          direct_preposition = input.getPreposition(1);

          indirect_object = input.getAsset(2);
          indirect_preposition = input.getPreposition(2);
        }

        if (!fromto)
          fromto =
            direct_preposition === "from" && indirect_preposition === "to";

        if (!fromto) {
          // "climb from to" is the only variant that can handle 2 nouns
          this.game.debug(
            `F1180 | ${this.name}.js | this phrase and sentence structure not supported `,
          );
          msg += this.game.parser.getUnparsedMessage(input.input);
          this.handleFailure(msg);
          return null;
        }

        if (fromto && (!nest_asset || nest_asset.id !== direct_object.id)) {
          // from noun must be the nest
          this.game.debug(
            `F1187 | ${this.name}.js | ${nest_asset.id} !== ${direct_object.id}`,
          );
          msg += `$(We're) not on ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        } // fromto

        // @TODO can player reach iobj from nest?
        if (fromto /*&& direct_object.id !== indirect_object.id*/) {
          this.game.debug(`F1853 | ${this.name}.js | change to fromto `);
          msg += `$(We) can't climb to ${indirect_object.articlename} from ${nest_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb preposition noun preposition noun

      // save our findings for doSuccess so we don't have to repeat this logic
      if (up) input.verb_params.up = true;
      else if (down) input.verb_params.down = true;
      else if (fromto) input.verb_params.fromto = true;

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var nest_asset = player.getNestAsset();
      var top = direct_object.getYTop();
      var bottom = direct_object.getYBottom();
      var direct_preposition = input.getPreposition(1);
      var indirect_preposition = input.getPreposition(2);
      var preposition = "on";
      var posture = direct_object.aspects[preposition].player.posture;
      var newY = 0;
      var newPoint = { y: 0 };
      var grounded;
      var msg = "";
      var results;

      this.game.debug(`F1181 | ${this.name}.js | doSuccess `);
      this.game.debug(
        `F1340 | ${this.name}.js | start y is ${player.position.y} `,
      );

      // up ----------

      if (input.verb_params.up) {
        this.game.debug(`F1374 | ${this.name}.js | climb up `);

        if (
          direct_object.dimensions.height <= this.game.settings.reach_height
        ) {
          // default posture for "climb on [short thing like furniture]" is stand
          posture = direct_object.aspects[preposition].player.can.stand
            ? "stand"
            : direct_object.aspects[preposition].player.posture;
          msg += `$(We) ${
            input.verb_params.with
              ? "use " + indirect_object.articlename + " to"
              : ""
          } climb up ${
            direct_object.articlename
          } and ${posture} ${preposition} it. `;
        } else {
          newY =
            top - player.position.y >= this.game.settings.reach_height
              ? player.position.y + this.game.settings.reach_height
              : top;
          msg += `$(We) ${
            input.verb_params.with
              ? "use " + indirect_object.articlename + " to"
              : ""
          } climb `;

          let percent = newY / top;
          if (percent === 1) msg += "to the top of ";
          else if (percent > 0.5) msg += "further up ";
          else msg += "part way up ";

          msg += `${direct_object.articlename}. `;
        }

        // if it isn't already nested, nest it
        if (nest_asset.id !== direct_object.id) {
          results = player.onNestThisToThat(direct_object, preposition);
          if ("undefined" !== typeof results) return results;
          player.posture = posture;
        }

        player.position.y = newY;
      } // up

      // down ----------

      if (input.verb_params.down) {
        this.game.debug(`F1123 | ${this.name}.js | climb down `);

        // climbing down a thing with its bottom above the ground, like a stalactite
        if (bottom > 0 && player.position.y > bottom) {
          newY =
            player.position.y - bottom >= this.game.settings.reach_height
              ? player.position.y - this.game.settings.reach_height
              : bottom;

          msg += `$(We) ${
            input.verb_params.with
              ? "use " + indirect_object.articlename + " to"
              : ""
          } climb downward on ${direct_object.articlename}. `;
        }

        // player is already at bottom of thing that is above the ground
        else if (bottom > 0 && player.position.y === bottom) {
          msg += `$(We) fall to the ground. `;
          newY = 0;
          grounded = true;
          // TODO gravity
        }

        // climbing down a thing rooted to the ground
        else if (bottom === 0) {
          newY =
            player.position.y - bottom >= this.game.settings.reach_height
              ? player.position.y - this.game.settings.reach_height
              : bottom;

          msg += `$(We) ${
            input.verb_params.with
              ? "use " + indirect_object.articlename + " to"
              : ""
          } climb `;

          if (newY > 0) {
            msg += `downward on `;
          } else {
            msg += `down off `;
            grounded = true;
          }

          msg += `${direct_object.articlename}. `;
        }

        // climbing down a thing below ground level
        // @todo what happens at the bottom?
        // at the moment we're left, stuck at the bottom of the thing
        else if (0 > bottom) {
          newY =
            player.position.y - bottom >= this.game.settings.reach_height
              ? player.position.y - this.game.settings.reach_height
              : bottom;

          msg += `$(We) ${
            input.verb_params.with
              ? "use " + indirect_object.articlename + " to"
              : ""
          } climb ${newY > bottom ? "further down " : "to the bottom of "}`;

          if (newY > bottom) {
            msg += `further down `;
          } else {
            msg += `to the bottom of `;
          }

          msg += `${direct_object.articlename}. `;
        }

        player.position.y = newY;
        if (grounded) {
          results = player.onUnnestThisFromThat(nest_asset);
          if ("undefined" !== typeof results) return results;
          player.posture = "stand";
        }
      } // down

      // from/to ----------

      if (input.verb_params.fromto) {
        this.game.debug(`F1373 | ${this.name}.js | climb from to `);

        posture = indirect_object.aspects.on.player.posture;

        // msg += `$(We) ${
        //   input.verb_params.with
        //     ? "use " + indirect_object.articlename + " to"
        //     : ""
        // } climb from ${direct_object.articlename} to ${
        //   indirect_object.articlename
        // } and ${posture} ${preposition} it. `;
        msg += `$(We) climb from ${direct_object.articlename} to ${indirect_object.articlename} and ${posture} ${preposition} it. `;

        // if player is nested, unnest
        if (nest_asset.id !== direct_object.id) {
          results = player.onUnnestThisFromThat(direct_object);
          if ("undefined" !== typeof results) return results;
        }

        // if it isn't already nested, nest it
        if (nest_asset.id !== indirect_object.id) {
          results = player.onNestThisToThat(indirect_object, preposition);
          if ("undefined" !== typeof results) return results;
          player.posture = posture;
        }

        let range = indirect_object.getYRange();
        if (newY < range.min) newY = range.min;
        else if (newY > range.max) newY = range.max;
        player.setY(newY);
      } // fromto

      this.game.debug(`F1694 | climb.js | end y is ${player.position.y} `);

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  }; // END p.preverbs.push
})();

// close.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class close
   * @ajsnode game.dictionary.verbs.close
   * @ajsconstruct MyGame.createVerb({ "name": "close", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading OpenCloseVerbs
   * @ajscaninferdirect true
   * @ajsstate closed
   * @summary Verb meaning close a tangible asset.
   * @ajssynonyms close, shut
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; close can of snakes</span>
   * You close the can of snakes, though you can never put the snakes back in the can.
   * </pre>
   * <p>
   * Close a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has
   * asset.dov.close.enabled set to true
   * and asset.is.closed is false.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @ajsdemo OpenGame, SittingRoom, Library, Playground, Objects
   */
  A.Preverbs.close = {
    name: "close",
    prettyname: "close",
    past_tense: "closed",
    synonyms: ["close", "shut"],
    state: "closed",
    related: ["open"],
    state_strings: { state: "closed", unstate: "open" },
    state_string: "closed",
    unstate_string: "open",
    enqueue_collections: true,

    /**
     * @ajsverbstructures
     * @memberof close
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof close
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof close
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof close
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // has direct object got a registered drain asset?
      // if so use that as direct object
      if (direct_object.registered_parts?.Drain) {
        direct_object = this.game.getAsset(
          direct_object.registered_parts.Drain,
        );
        if (!direct_object) return null;
        input.setAsset(1, direct_object);
        input.setAssumed(1, true);
      }

      // if it's a drain, did player input "close drain"?
      if (direct_object.isDOV("plug") && !direct_object.is.plugged) {
        this.game.debug(
          `F1368 | ${this.name}.js | ${direct_object.id}.dov.plug, doVerb plug `,
        );
        this.game.dictionary.doVerb("plug");
        return null;
      }

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1241 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.state}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1242 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.Articlename} is already ${this.getState()}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1822 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1403 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1704 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return null;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1691 | ${this.name}.js | ${direct_object.id} can't be ${this.state} by ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1693 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1899 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1806 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1244 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // close

// crawl.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class crawl
   * @ajsnode game.dictionary.verbs.crawl
   * @ajsconstruct MyGame.createVerb({ "name": "crawl", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning crawl on an asset or travel in specified direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; crawl</span>
   * You crawl on the floor. You find a pea!
   * </pre>
   * Crawl extends core verb <a href="go.html">go</a>.
   * It checks whether "crawl" is contextually available
   * before forwarding to "go" for further handling.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.crawl = {
    name: "crawl",
    prettyname: "crawl",
    past_tense: "crawled",
    synonyms: ["crawl"],
    type: { locomotion: true, travel: true },
    extends: { go: true },

    in_can_mean_on: true,

    player_must_be: {
      not_constrained: true,
      able_to_crawl: true,
    },

    /**
     * @ajsverbstructures
     * @memberof crawl
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof crawl
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   noun1_must_be: {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun1_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof crawl
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun1_must_be: {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun1_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof crawl
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    do: function () {
      this.game.dictionary.doVerb("go");
    },
  }; // END p.preverbs.push
})();

// cut.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class cut
   * @ajsnode game.dictionary.verbs.cut
   * @ajsconstruct MyGame.createVerb({ "name": "cut", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning cut a tangible.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; cut rope</span>
   * You cut the rope. It's too bad you were hanging from it.
   * </pre>
   * <p>
   * <strong>Cut</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be cut has
   * asset.dov.cut.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.cut = {
    name: "cut",
    prettyname: "cut",
    past_tense: "cut",
    synonyms: ["cut"],

    /**
     * @ajsverbstructures
     * @memberof cut
     */
    accepts_structures: [
      "verb noun",
      "verb preposition noun", // cut off head
      "verb noun preposition", // cut head off
      "verb noun preposition noun",
    ],

    /**
     * @memberof cut
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof cut
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   //accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      //accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof cut
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var direct_preposition = input.getPreposition(1);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1247 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state? skip

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1823 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      if (input.hasStructure("verb noun preposition")) {
        if (["off", "out"].indexOf(indirect_preposition) > -1) {
          // ex: cut head off, cut heart out
          direct_preposition = indirect_preposition;
          input.setPreposition(1, indirect_preposition);
          input.deletePhrase(2);
          input.setStructure("verb preposition noun");
        } else {
          this.game.debug(
            `F1946 | ${this.name}.js | ${this.name} ${indirect_preposition} not handled `
          );
          msg += `$(We) don't know how to ${this.name} ${direct_object.articlename} ${indirect_preposition}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      if (input.hasStructure("verb preposition noun")) {
        if (direct_preposition === "off" || direct_preposition === "out") {
          // ex: cut off head, cut out heart - just do it
          return true;
        } else {
          this.game.debug(
            `F1948 | ${this.name}.js | ${this.name} ${direct_preposition} not handled `
          );
          msg += `$(We) don't know how to ${this.name} ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1834 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1835 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        if (indirect_preposition !== "with") {
          this.game.debug(
            `F1955 | ${this.name}.js | no handling for ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename} `
          );
          msg += `$(We) don't know how to ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1093 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1837 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1900 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1838 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1248 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // cut

// debug.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class debug
   * @ajsnode game.dictionary.verbs.debug
   * @ajsconstruct MyGame.createVerb({ "name": "debug", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Toggle game.settings.print_debug_messages.
   * @ajssynonyms debug
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; debug</span>
   * Debug messages enabled.
   * </pre>
   * <strong>debug</strong> toggles game.settings.print_debug_messages.
   */
  A.Preverbs.debug = {
    name: "debug",
    synonyms: ["debug"],

    /**
     * @ajsverbstructures
     * @memberof debug
     */
    accepts_structures: ["verb", "verb preposition"],

    /**
     * @memberof debug
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: false,
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_preposition_without_noun: true,
     *   accepts_these_prepositions: ["on","off"],
     * },
     */
    phrase1: {
      accepts_noun: false,
      accepts_preposition: true,
      requires_preposition: true,
      accepts_preposition_without_noun: true,
      accepts_these_prepositions: ["on", "off"],
    },

    do: function () {
      let input = this.game.getInput();
      let preposition = input.getPreposition(1);
      let structure = input.verified_sentence_structure;
      let msg = "";

      if (structure === "verb") {
        this.game.settings.print_debug_messages =
          !this.game.settings.print_debug_messages;
      }
      if (structure === "verb preposition") {
        this.game.settings.print_debug_messages =
          preposition === "on" ? true : false;
      }
      msg = `Debug messages ${
        this.game.settings.print_debug_messages ? "on" : "off"
      }. `;
      this.game.print(msg);
      return null;
    },
  };
})(); // debug

// detach.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class detach
   * @ajsnode game.dictionary.verbs.detach
   * @ajsconstruct MyGame.createVerb({ "name": "detach", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning detach one asset from another.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; detach anglerfish from head</span>
   * You detach the anglerfish from your head. It wriggles angrily
   * in your hand.
   * </pre>
   * <p>
   * <strong>Detach</strong> one
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} from another.
   * Requires that the Asset to be removed from has an <code>attach</code>
   * {@link adventurejs.Aspect|Aspect}.
   * To learn about Aspects, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.detach = {
    name: "detach",
    prettyname: "detach",
    past_tense: "detached",
    synonyms: ["detach", "disconnect"],
    unstate: "attached", // state should be determined by place

    /**
     * @ajsverbstructures
     * @memberof detach
     */
    accepts_structures: [
      "verb noun",
      "verb noun preposition noun",
      "verb noun preposition noun preposition noun",
    ],

    /**
     * @memberof detach
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *     //visible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
        //visible: true,
      },
    },

    /**
     * @memberof detach
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *     //visible: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["from","with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
        //visible: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["from", "with"],
    },

    /**
     * @memberof detach
     * @ajsverbphrase
     * phrase3:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     in_inventory_if_takeable: true,
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["from","with"],
     * },
     */
    phrase3: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory_if_takeable: true,
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["from", "with"],
    },

    /**
     * @memberof detach
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();

      var object1 = input.getAsset(1);
      var object2, object2_preposition;
      var tool, tool_preposition;

      var results, results2;
      var msg = "";

      // is direct object worn?
      if (object1.is.worn) {
        this.game.debug(
          `F1522 | ${this.name}.js | ${object1.id}.is.worn, infer verb remove `,
        );
        this.game.dictionary.doVerb("remove");
        return null;
      }

      // is direct object tied?
      if (object1.dov.tie?.with_params.connections.length) {
        this.game.debug(
          `F1249 | ${this.name}.js | ${object1.id}.dov.tie, infer verb untie `,
        );
        this.game.dictionary.doVerb(
          input.getAssumed(2) ? "untie" : "untie_from",
        );
        return null;
      }

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // is object1 attached?
        if (object1.isPlacedAtAspect("attached")) {
          // infer indirect object
          object2 = object1.getPlaceAsset();
          input.setAsset(2, object2);
          input.setPreposition(2, "from");
          input.setStructure("verb noun preposition noun");
        } else {
          // prompt for indirect object
          input.setPreposition(2, "from");
          input.setSoftPrompt({
            noun2: true,
            structure: "verb noun preposition noun",
          });
          this.game.debug(`F1520 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${object1.articlename} from? `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun

      // did player input with/with or from/from ?
      if (input.getPreposition(2) === input.getPreposition(3)) {
        // we don't understand that
        this.game.debug(
          `F1251 | ${this.name}.js | expected A from B with C, received two identical prepositions `,
        );
        msg += this.game.parser.getUnparsedMessage(this.game.getInput().input);
        this.handleFailure(msg);
        return null;
      }

      // did player input 'detach A with B from C'?
      if (
        "with" === input.getPreposition(2) &&
        "from" === input.getPreposition(3)
      ) {
        // swap B with C
        input.swapPhrases(2, 3);
      }

      // 'detach A with C'? try to infer 'from B'
      // this is where detach differs from attach
      if ("with" === input.getPreposition(2) && !input.hasPhrase(3)) {
        input.swapPhrases(2, 3);
        input.setPreposition(2, "from");
        tool = input.getAsset(3);
        tool_preposition = "from";

        // is object1 attached?
        if (object1.isPlacedAtAspect("attached")) {
          // infer indirect object
          input.setAsset(2, object1.getPlaceAsset());
          input.setStructure("verb noun preposition noun preposition noun");
        } else {
          // prompt for indirect object
          input.setSoftPrompt({
            noun2: true,
            structure: "verb noun preposition noun preposition noun",
          });
          this.game.debug(`F1520 | ${this.name}.js | soft prompt for noun3 `);
          msg += `What would $(we) like to ${this.name} ${object1.articlename} from with ${tool.articlename}? `;
          this.handleFailure(msg);
          return null;
        }
      }

      // at this point we should have 'detach A from B' or 'detach A from B with C'
      object2 = input.getAsset(2);
      object2_preposition = input.getPreposition(2);

      // these things apply to 'verb noun preposition noun' and 'verb noun preposition noun preposition noun'

      // verb enabled for one or the other?
      if (!object1.isDOV(this.name) && !object2.isDOV(this.name)) {
        this.game.debug(
          `F1250 | ${this.name}.js | neither ${object1.id} nor ${object2.id}.dov.${this.name}.enabled `,
        );
        msg += `${object1.Articlename} can't be ${this.past_tense} from ${object2.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // are neither of these assets be attached to the other?
      if (
        !object1.isPlacedAtAspect("attached", object2) &&
        !object2.isPlacedAtAspect("attached", object1)
      ) {
        this.game.debug(
          `F1353 | ${this.name}.js | neither asset is in the other's .aspects.attached.contents `,
        );
        msg += `${object1.Articlename} and ${object2.articlename} aren't ${this.unstate}. `;
        this.handleFailure(msg);
        return null;
      }

      // is object2 actually in object1?
      if (
        !object1.isPlacedAtAspect("attached", object2) &&
        object2.isPlacedAtAspect("attached", object1)
      ) {
        input.swapNouns(1, 2);
        object1 = input.getAsset(1);
        object2 = input.getAsset(2);
      }

      // sentence structure: verb noun preposition noun
      // we put this way down here after all the object swapping is done
      if (input.hasStructure("verb noun preposition noun")) {
      }

      // tool, maybe?
      tool = input.getAsset(3);
      tool_preposition = input.getPreposition(3);

      // no tool?
      if (!tool) {
        // is a tool needed?
        if (
          !object1.DOVallowWithNothing(this.name) &&
          !object2.DOVallowWithNothing(this.name)
        ) {
          // tool needed
          results = this.tryToInferIndirectObject(object1);
          results2 = this.tryToInferIndirectObject(object2);
          if (results.success || results2.success) {
            // found a tool
            var either_one = results.success
              ? results.success
              : results2.success;
            tool = either_one.indirect_object;
            tool_preposition = "with";
            input.setNewPhrase({
              asset: tool,
              preposition: tool_preposition,
            });
            input.setStructure("verb noun preposition noun preposition noun");
          } else if (results.prompt || results2.prompt) {
            // prompt for tool
            // restructure sentence for next turn
            input.setPreposition(3, "with");
            input.setSoftPrompt({
              noun3: true,
              structure: "verb noun preposition noun preposition noun",
            });
            this.game.debug(`F1720 | ${this.name}.js | soft prompt for noun3 `);
            msg += `What would $(we) like to ${this.name} ${object1.articlename} from ${object2.articlename} with? `;
            this.handleFailure(msg);
            return false;
          }
        } // tool needed?
      } // no tool

      // by now we should have an input tool or an inferred tool or no tool needed

      // sentence structure: verb noun preposition noun preposition noun
      // ie: 'attach male pipe to female pipe with wrench'
      if (input.hasStructure("verb noun preposition noun preposition noun")) {
        // works with any indirect object?
        if (object1.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (
          object1.DOVallowWithNothing(this.name) &&
          object2.DOVallowWithNothing(this.name)
        ) {
          this.game.debug(
            `F1518 | ${this.name}.js | ${object1.id} and ${object2.id}.dov.${this.name}.with_nothing `,
          );
          msg += `${object1.Articlename} and ${object2.articlename} don't need another object to ${this.name} them. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (
          !object1.DOVallowWithAsset(this.name, tool) &&
          !object2.DOVallowWithAsset(this.name, tool)
        ) {
          this.game.debug(
            `F1521 | ${this.name}.js | neither ${object1.id} nor ${object2.id}.dov.${this.name}.with_assets/with_classes includes ${tool.id} `,
          );
          msg += `${tool.Articlename} can't be used to ${this.name} ${object1.articlename} from ${object2.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();

      var object1 = input.getAsset(1);
      var object1_parent = object1.getPlaceAsset();

      var object2 = input.getAsset(2);
      var object2_preposition = input.getPreposition(2);

      var tool = input.getAsset(3);
      var tool_preposition = input.getPreposition(3);

      var results;
      var msg = "";

      this.game.debug(`F1253 | ${this.name}.js | print doSuccess `);

      // set direct object place
      if (object2.id !== player.id) {
        // remove direct object from current parent
        results = object1.moveFrom(object2);
        if ("undefined" !== typeof results) return results;

        // add direct object to new parent
        var target = object1.isDOV("take") ? player : object2.getPlaceAsset();
        var targetprep = object1.isDOV("take")
          ? "in"
          : object2.getPlacePreposition();
        results = object1.moveTo(targetprep, target);
        if ("undefined" !== typeof results) return results;
        // @TODO object1 may need to be placed in the room
        // and what about water rooms?
      }

      // apply state changes
      //object1.is[this.getState()] = false;

      // compose output
      msg += `$(We) ${this.name} ${object1.articlename}`;
      msg += object2 ? ` from ${object2.articlename}` : ``;
      msg += tool ? ` with ${tool.articlename}` : ``;
      msg +=
        target.id === player.id
          ? ` and take it`
          : ` and set it ${targetprep} ${target.articlename}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, object1);
      return true;
    },
  };
})(); // detach

// dip.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class dip
   * @ajsnode game.dictionary.verbs.dip
   * @ajsconstruct MyGame.createVerb({ "name": "dip", [
   * .] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning dip one asset into another.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; dip doughnut in coffee</span>
   * You dip the doughnut in the cup of coffee.
   * </pre>
   * <p>
   * <strong>Dip</strong> one {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} in another.
   * Requires that the Asset to be dipped has
   * <code>asset.dov.dip.enabled</code>
   * set to true, and that the Asset to be dipped in has
   * <code>asset.iov.dip.enabled</code>
   * set to true.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.dip = {
    name: "dip" /* @todo handle 'in' via prep */,
    prettyname: "dip",
    past_tense: "dipped",
    synonyms: [],
    verb_noun_prep_noun: ["dip in", "dunk in"],

    /**
     * @memberof dip
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *     in_inventory: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        tangible: true,
        present: true,
        reachable: true,
        in_inventory: true,
      },
    },

    /**
     * @memberof dip
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   // requires_preposition: true,
     *   // accepts_these_prepositions: [ 'in' ],
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        tangible: true,
        present: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof dip
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var msg = "";

      // check locations for substances
      // aspect probably always going to be "in"
      // but we've made it possible to store substances
      // in any aspect, so we gotta check
      var aspect = indirect_object.getAspectWithVessel();

      if (
        !aspect ||
        !direct_object.isDOV("dip") ||
        !indirect_object.isIOV("dip")
      ) {
        this.game.debug(
          `F1840 | ${this.name}.js | ${direct_object.id}.dov.dip.enabled is false or ${indirect_object.id}.iov.dip.enabled is false or doesn't have aspects.${aspect} aspect`,
        );
        msg += `$(We) can't dip ${direct_object.articlename} in ${indirect_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (0 === indirect_object.aspects[aspect].vessel.getVolume()) {
        this.game.debug(
          `F1841 | ${this.name}.js | ${indirect_object.id}.${aspect}.vessel.getVolume is 0`,
        );
        msg += `${indirect_object.Articlename} is empty. `;
        this.handleFailure(msg);
        return null;
      }

      if (aspect == "in" && indirect_object.is.closed) {
        this.game.debug(
          `F1842 | ${this.name}.js | ${indirect_object.id}.is.closed`,
        );
        msg += `${indirect_object.Articlename} is closed. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";
      var aspect = indirect_object.getAspectWithVessel();

      this.game.debug(`F1843 | ${this.name}.js | print doSuccess `);

      // apply state changes
      if (direct_object.is.absorbent && !direct_object.is.damp) {
        var newvol =
          indirect_object.aspects[aspect].vessel.getVolume() -
          direct_object.absorption_quantity;
        indirect_object.aspects[aspect].vessel.setVolume(newvol);
        direct_object.is.damp = true;
      }

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, indirect_object);
      return true;
    },
  };
})(); // dip

// drink.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class drink
   * @ajsnode game.dictionary.verbs.drink
   * @ajsconstruct MyGame.createVerb({ "name": "drink", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ConsumptionVerbs
   * @summary Verb meaning drink substance.
   * @todo finish writing
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; drink milk</span>
   * You drink milk from the carton. It does a body good.
   * </pre>
   * <p>
   * <strong>Drink</strong> a {@link adventurejs.Substance|Substance}
   * {@link adventurejs.Asset|Asset}.
   * Requires that a quantity of the Substance be present and reachable.
   * Parser will search for the specified Substance among available
   * Assets.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.drink = {
    name: "drink",
    prettyname: "drink",
    past_tense: "drank",
    synonyms: ["drink", "sip"],

    /**
     * @ajsverbstructures
     * @memberof drink
     */
    accepts_structures: [
      "verb noun",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof drink
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     *   accepts_preposition: true,
     *   accepts_these_prepositions: ["from"],
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
      accepts_preposition: true,
      accepts_these_prepositions: ["from"],
    },

    /**
     * @memberof drink
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: [ "from" ],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["from"],
    },

    /**
     * @memberof drink
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var currentRoom = this.game.getCurrentRoom();
      var containers;
      var msg = "";
      var results, hook;

      var find_container_for_direct_object = false;
      var find_substance_for_direct_object = false;

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (input.hasStructure("verb preposition noun")) {
      }

      // has player entered "drink asset"?
      if (
        input.hasStructure("verb noun") ||
        input.hasStructure("verb preposition noun")
      ) {
        // is asset a substance? > get container
        if (direct_object instanceof adventurejs.Substance) {
          find_container_for_direct_object = true;
        } else if (direct_object.doesContainAnySubstance()) {
          find_substance_for_direct_object = true; // check open / reachable etc
        } else if (direct_object.canContainAnySubstance()) {
          this.game.debug(
            `F1575 | ${this.name}.js | ${direct_object.id} is empty `,
          );
          msg += `${direct_object.Articlename} is empty. `;
          this.handleFailure(msg);
          return null;
        } else if (direct_object.isDOV("drink")) {
          // is player carrying the thing?
          if (direct_object.isDOV("take") && !direct_object.isIn(player)) {
            this.game.debug(
              `F1748 | ${this.name}.js | ${direct_object.id} is not in player `,
            );
            msg += `$(We're) not carrying ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // special handling for things that are not substance containers
          // but which can be drunk, as in a case like "drink potion"
          // where potion asset responds directly to drink
          input.verb_params.can_be_drunk = true;
          return true;
        } else {
          this.game.debug(
            `F1171 | ${this.name}.js | ${direct_object.id}.dov.drink.enabled is false `,
          );
          msg += `${direct_object.Articlename} can't be drunk from. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun

      // player input "drink substance" and we need to infer container
      if (find_container_for_direct_object) {
        containers = this.game.findSubstanceContainers(direct_object.id, [
          "Present",
          "Known",
          "Visible",
          "Reachable",
        ]);
        switch (containers.length) {
          case 0:
            this.game.debug(`F1576 | ${this.name}.js | no containers found `);
            msg += `There's no ${direct_object.name} available. `;
            this.handleFailure(msg);
            return null;
          case 1:
            // set indirect object to the container
            // ie "drink water" becomes "drink water from bowl"
            indirect_object = this.game.getAsset(containers[0]);
            input.setAsset(2, indirect_object);
            input.setPreposition(2, "from");
            input.setAssumed(2, true);
            input.setStructure("verb noun preposition noun");
            break;
          default:
            var asset, room;
            for (var i = 0; i < containers.length; i++) {
              asset = this.game.getAsset(containers[i]);
              if (asset.id === currentRoom.id) {
                room = true;
                break;
              }
            }
            // if room is among multiple sources, always prefer room
            // meant for environmental substances, like standing by a lake
            if (room) {
              // set indirect object to the room
              // ie "drink water" becomes "drink water from room"
              indirect_object = asset;
              input.setAsset(2, indirect_object);
              input.setPreposition(2, "from");
              input.setAssumed(2, true);
              input.verb_params.drink_from_room = true;
              input.setStructure("verb noun preposition noun");
              break;
            } else {
              // disambiguate - set parsedNoun.matches for next turn
              this.game.debug(
                `F1578 | ${this.name}.js | multiple containers found, disambiguate `,
              );
              // set preposition to "from" for disambiguation
              // because we're asking player to choose a container
              input.setPreposition(1, "from");
              // save containers back to input for next turn disambiguation
              input.setParsedNounMatchesQualified(1, containers);
              this.game.parser.printNounDisambiguation({
                parsedNoun: input.getParsedNoun(1),
                nounIndex: 1,
              });
              return null;
            }
        } // switch
      } // find_container_for_direct_object

      // player input "drink container" and we need to infer substance
      if (find_substance_for_direct_object) {
        indirect_object = direct_object;
        direct_object = this.game.getAsset(
          indirect_object.getAnySubstanceThisContains(),
        );
        input.setAsset(1, direct_object);
        input.setPreposition(1, "");
        input.setAsset(2, indirect_object);
        input.setPreposition(2, "from");
        input.setStructure("verb noun preposition noun");
      } // find_substance_for_direct_object

      // now we can get into verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // is substance unpotable? for instance could be sand
        if (!direct_object.isDOV("drink")) {
          this.game.debug(
            `F1577 | ${this.name}.js | ${direct_object.id}.dov.drink.enabled is false `,
          );
          msg += `$(We) can't drink ${direct_object.name}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object contain substance?
        if (!indirect_object.canContainAnySubstance()) {
          this.game.debug(
            `F1582 | ${this.name}.js | ${indirect_object.id} has no substance container `,
          );
          msg += `${indirect_object.Articlename} can't be drunk from. `;
          this.handleFailure(msg);
          return null;
        }

        // DOES indirect object contain substance?
        if (!indirect_object.doesContainAnySubstance()) {
          if (indirect_object instanceof adventurejs.SubstanceEmitter) {
            this.game.debug(
              `F1580 | ${this.name}.js | "+${indirect_object.id}+" is class SubstanceEmitter and .is_emitting is false `,
            );
            msg += `Nothing is coming out of ${indirect_object.articlename}. `;
          } else {
            this.game.debug(
              `F1581 | ${this.name}.js | ${indirect_object.id}.aspects.in.vessel.volume is 0 `,
            );
            msg += `${indirect_object.Articlename} is empty. `;
          }
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be drunk from?
        if (!indirect_object.can.drink_from) {
          this.game.debug(
            `F1173 | ${this.name}.js | ${indirect_object.id}.can.drink_from is false `,
          );
          msg += `$(We) can't drink from ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // Is indirect object takeable but not in player?
        if (indirect_object.isDOV("take") && !indirect_object.isIn(player)) {
          this.game.debug(
            `F1579 | ${this.name}.js | ${indirect_object.id} is not in player `,
          );
          msg += `$(We're) not holding ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // Is indirect object closed?
        if (
          indirect_object.getAspectWithVessel() === "in" &&
          indirect_object.isDOV("open")
        ) {
          this.game.debug(
            `F1571 | ${this.name}.js | ${indirect_object.id}.is.closed `,
          );
          msg += `${indirect_object.Articlename} is closed. `;
          this.handleFailure(msg);
          return null;
        }

        if (!indirect_object.doesContainSubstance(direct_object.id)) {
          this.game.debug(
            `F1583 | ${this.name}.js | ${indirect_object.id} does not contain "+${direct_object.id}+" `,
          );
          msg += `${indirect_object.Articlename} contains ${
            this.game.getAsset(indirect_object.getAnySubstanceThisContains())
              .name
          }. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();

      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;
      var source_aspect;
      var source_vessel;
      var substance;

      if (input.verb_params.can_be_drunk) {
        this.game.debug(
          `F1172 | ${this.name}.js | doSuccess ${direct_object.name}.dov.drink.enabled `,
        );
        // we only arrive here if the object can be direct object of drink but
        // no substance involved. For simple things like "drink potion"

        // parsed sentence structure: verb
        if (input.hasStructure("verb")) {
        }

        // parsed sentence structure: verb noun
        if (input.hasStructure("verb noun")) {
        } // verb noun

        msg += `$(We) drink ${direct_object.articlename}. `;

        if (direct_object && direct_object.on_drink_destroy) {
          direct_object.destroy();
        }
      } else if (input.hasStructure("verb noun")) {
        // shouldn't happen because we inferred verb noun preposition noun
      } else if (input.hasStructure("verb preposition noun")) {
        // shouldn't happen because we inferred verb noun preposition noun
      } else if (input.hasStructure("verb noun preposition noun")) {
        this.game.debug(
          `F1170 | ${this.name}.js | doSuccess dObj = ${direct_object.name}, iObj = ${indirect_object?.name} `,
        );

        source_aspect = indirect_object.getAspectWithVessel();
        source_vessel = indirect_object.getVesselAt(source_aspect);
        substance = this.game.getAsset(source_vessel.substance_id);

        if (indirect_object.on_drink_empty) {
          source_vessel.setVolume(0);
        } else {
          source_vessel.subtractVolume(this.game.settings.mouthful);
        }

        msg += `$(We) drink some ${substance.name} from ${indirect_object.articlename}`;
        if (0 >= source_vessel.getVolume()) {
          msg += `, emptying it in one gulp`;
        }
        msg += `. `;
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // drink

// drop.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class drop
   * @ajsnode game.dictionary.verbs.drop
   * @ajsconstruct MyGame.createVerb({ "name": "drop", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning drop asset.
   * @ajssynonyms drop, put
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; drop flugelhorn</span>
   * You drop the jewel encrusted flugelhorn. It emits a sad little blat.
   * </pre>
   * <p>
   * <strong>Drop</strong> a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}. Requires that the Asset is
   * in player's inventory.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.drop = {
    name: "drop",
    prettyname: "drop",
    past_tense: "dropped",
    synonyms: ["drop"],
    verb_prep_noun: ["put down"],
    enqueue_collections: true,

    /**
     * @ajsverbstructures
     * @memberof close
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof drop
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   accepts_plural_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     in_inventory: true,
     *     not_worn_if_all: true,
     *     not_nested_inventory_if_all: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      accepts_plural_noun: true,
      noun_must_be: {
        known: true,
        in_inventory: true,
        not_worn_if_all: true,
        not_nested_inventory_if_all: true,
      },
    },

    /**
     * @memberof drop
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        singular: false,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof drop
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        this.game.dictionary.doVerb("put");
        return null;
      }

      if (
        "all" === input.parsedNoun1.deserialized_input &&
        direct_object.is.worn
      ) {
        this.game.debug(
          `F1263 | ${this.name}.js | ${direct_object}.is.worn, not dropping it `
        );
        return null;
      }

      if (
        "all" === input.parsedNoun1.deserialized_input &&
        direct_object.getPlaceAssetId() !== this.game.world._player
      ) {
        this.game.debug(
          `F1264 | ${this.name}.js | ${direct_object} is not direct child of player, not dropping it `
        );
        return null;
      }

      // player is holding it, not carrying it, like a rope
      if (player.IOVisConnectedToAsset("hold", direct_object)) {
        this.game.debug(
          `F1265 | ${this.name}.js | player is holding ${direct_object}, infer release `
        );
        this.game.dictionary.doVerb("release");
        return null;
      }

      if (!direct_object.isIn(player)) {
        this.game.debug(
          `F1266 | ${this.name}.js | ${direct_object.id}+" is not child of player `
        );
        msg += `$(We're) not carrying ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (player.isNested() && player.getNestAsset().id === direct_object.id) {
        this.game.debug(
          `F1267 | ${this.name}.js | player is nested on ${direct_object.id}`
        );
        msg += `$(We) can't let go of ${
          direct_object.articlename
        } while $(we're) ${player.getPostureGerund()} ${player.getNestPreposition()} it. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var currentRoom = this.game.getCurrentRoom();
      var nest_asset = player.getNestAsset();
      var nest_preposition = player.getNestPreposition();
      var msg = "";
      var removedItem = false;
      var results;

      this.game.debug(`F1268 | ${this.name}.js | print doSuccess`);

      if (direct_object.is.worn) {
        results = direct_object.unfasten();
        msg += results ? `$(We) ${results}, remove, ` : `$(We) remove `;
        msg += `and drop ${direct_object.articlename}. `;
        direct_object.incrementDoVerbCount("remove", 1);
        direct_object.is.worn = false;
      } else {
        // compose output
        msg += `$(We) drop ${direct_object.articlename}. `;
      }

      // remove thing from player
      results = player.onRemoveThatFromThis(direct_object);
      if ("undefined" !== typeof results) return results;

      // set thing's new location to player's location
      // if nested, try to put there, otherwise in room
      if (nest_asset) {
        results = this.tryToPutThisInThatAspect(
          direct_object,
          player.getNestPreposition(),
          nest_asset
        );
      }
      if (nest_asset && !results.fail) {
        results = nest_asset.onMoveThatToThis(direct_object, nest_preposition);
        if ("undefined" !== typeof results) return results;
      } else {
        results = currentRoom.onMoveThatToThis(direct_object, "in");
        if ("undefined" !== typeof results) return results;
      }

      if (
        (1 < input.parsedNoun1.matches.qualified.length ||
          this.game.parser.isParsingMultiple()) &&
        -1 === input.output_class.indexOf("concatenate_output")
      ) {
        input.output_class += " concatenate_output ";
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // drop

// eat.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class eat
   * @ajsnode game.dictionary.verbs.eat
   * @ajsconstruct MyGame.createVerb({ "name": "eat", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ConsumptionVerbs
   * @summary Verb meaning eat asset.
   * @todo should handle solid/slurry substances
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; eat flapjacks</span>
   * You eat the mountainous pile of flapjacks. You've won the
   * flapjack eating contest! You're awarded with a blue ribbon.
   * </pre>
   * <p>
   * <strong>Eat</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be eaten has
   * asset.dov.eat.enabled
   * set to true. If Asset's
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_on_eat_destroy">on_eat_destroy</a>
   * property is set to true, Asset will be destroyed.
   * No other special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.eat = {
    name: "eat",
    prettyname: "eat",
    past_tense: "ate",
    synonyms: ["eat"],

    /**
     * @ajsverbstructures
     * @memberof eat
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof eat
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true, // @TODO matter // eat dirt?
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true, // @TODO matter // eat dirt?
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof eat
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],  // @TODO from
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"], // @TODO from
    },

    /**
     * @memberof eat
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (!direct_object.isDOV("eat")) {
        this.game.debug(
          `F1269 | ${this.name}.js | ${direct_object.id}.dov.eat.enabled is false `,
        );
        msg += `$(We) can't eat ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (input.hasStructure("verb noun")) {
      }

      if (input.hasStructure("verb noun preposition noun")) {
        if (!indirect_object.isIOV("eat")) {
          this.game.debug(
            `F1148 | ${this.name}.js | ${indirect_object.id}.iov.eat.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1270 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      var msg = "$(We) eat " + direct_object.articlename;
      if (indirect_object) {
        msg += " with " + indirect_object.articlename;
      }
      msg += ". ";

      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (input.hasStructure("verb noun preposition noun")) {
      } // verb noun preposition noun

      if (direct_object.on_eat_destroy) {
        direct_object.destroy();
      }

      // TODO
      // was food in a container? does it leave container behind?
      // was food one of many, like a grape

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // eat

// empty.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class empty
   * @ajsnode game.dictionary.verbs.empty
   * @ajsconstruct MyGame.createVerb({ "name": "empty", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning empty asset of other assets and/or substances.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; empty satchel on desk</span>
   * You empty the contents of the leather satchel on the desk.
   * </pre>
   * <p>
   * <strong>Pour</strong> is a special case that also doubles
   * for <strong>empty</strong>. Because
   * {@link adventurejs.Aspect|Aspects} can contain both
   * {@link adventurejs.Tangible|Tangibles} and
   * {@link adventurejs.Substance|Substances}, pouring or emptying
   * means that both the Tangibles and the Substances will fall out
   * of the source {@link adventurejs.Asset|Asset}
   * and into the destination Asset. If the target is a Tangible,
   * depending on its capacity, it may not be able to hold all of the
   * contents of the source Asset. In this case, excess Tangibles and
   * Substances will overflow onto the floor.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.empty = {
    name: "empty",
    prettyname: "empty",
    past_tense: "emptied",
    synonyms: ["empty"],

    /**
     * @ajsverbstructures
     * @memberof empty
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof empty
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
    },

    /**
     * @memberof empty
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof empty
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var substance = "";
      var msg = "";
      var empty_means_take_all;
      var empty_means_unplug;
      var empty_means_take_plug;

      if (direct_object instanceof adventurejs.Tangible) {
        // true of verb noun and verb noun preposition noun

        // is direct_object closed?
        if (direct_object.isDOV("open")) {
          this.game.debug(
            `F1741 | ${this.name}.js | ${direct_object.id}.is.closed `
          );
          msg += `${direct_object.Articlename} is closed. `;
          this.handleFailure(msg);
          return null;
        }

        // is direct_object empty?
        if (
          !direct_object.doesContainAnySubstance() &&
          !direct_object.doesContainAnyAsset()
        ) {
          this.game.debug(
            `F1551 | ${this.name}.js | ${direct_object.id}.doesContainAnySubstance and .doesContainAnyAsset are false `
          );
          msg += `${direct_object.Articlename} is empty. `;
          this.handleFailure(msg);
          return null;
        }
      }

      if (input.hasStructure("verb noun")) {
        // empty knapsack
        if (direct_object instanceof adventurejs.Substance) {
          // can't empty a substance
          this.game.debug(
            `F1742 | ${this.name}.js | ${direct_object.id} is a substance rather than a container `
          );
          msg += `$(We) don't know how to empty ${direct_object.name}. `;
          this.handleFailure(msg);
          return null;
        }

        // already done closed and empty

        // is it not takeable? we'll allow input
        // like "empty drawer" to mean "take all from drawer"
        if (!direct_object.isDOV("take")) {
          if (direct_object.doesContainAnyAssetAt("in")) {
            var takeable_assets = [];
            for (var i = 0; i < direct_object.aspects.in.contents.length; i++) {
              var asset = this.game.getAsset(
                direct_object.aspects.in.contents[i]
              );
              if (asset.isDOV("take")) {
                takeable_assets.push(asset);
              }
              if (takeable_assets.length) {
                empty_means_take_all = true;
                input.verb_params.empty_means_take_all = true;
                input.verb_params.takeable_assets = takeable_assets;
              }
            }
          }

          if (
            !empty_means_take_all
            /* && !empty_means_unplug
          && !empty_means_take_plug */
          ) {
            this.game.debug(
              `F1744 | ${this.name}.js | ${direct_object.id}.dov.take.enabled is false and .aspects.in.contents is empty `
            );
            msg += `$(We) don't know how to empty ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        } else {
          // find target - player parent / room
          indirect_object = player.getNestOrPlaceAsset();
          indirect_preposition = player.getNestOrPlacePreposition();
          input.setAsset(2, indirect_object);
          input.setPreposition(2, indirect_preposition);
          input.setAssumed(2, true);
          input.setStructure("verb noun preposition noun");
        }
      }

      if (input.hasStructure("verb noun preposition noun")) {
        // empty suitcase onto bed
        // "empty water from bottle" is a thing you could say

        // is target the floor? set to room
        if (indirect_object instanceof adventurejs.Floor) {
          indirect_object = this.game.getCurrentRoom();
          input.setAsset(2, indirect_object);
        }

        if (!direct_object.isDOV("take")) {
          // we don't handle "empty a onto b" where a is not carried
          this.game.debug(
            `F1745 | ${this.name}.js | ${direct_object.id}.dov.take.enabled is false `
          );
          msg += `$(We) don't know how to empty ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // is direct_object in player?
        // is it takeable? asking because "empty drawer" should mean take all from drawer
        if (direct_object.isDOV("take") && !direct_object.isIn(player)) {
          this.game.debug(
            `F1743 | ${this.name}.js | ${direct_object.id}.place not in player `
          );
          msg += `$(We're) not carrying ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;
      var room = indirect_object instanceof adventurejs.Room;
      var target_object, target_preposition;
      var emptied_count = 0;
      var transferred = [];
      var spillover = [];
      var overflow = false;
      var substance_asset;
      var empty_this = false;
      var mixer;

      this.game.debug(`F1746 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        if (input.verb_params.empty_means_take_all) {
          // take all from direct object
          var takeable_assets = input.verb_params.takeable_assets;
          for (var i = 0; i < takeable_assets.length; i++) {
            var asset = takeable_assets[i];
            // remove thing from its current container
            //results = asset_parent.onRemoveThatFromThis( direct_object );
            results = asset.moveFrom(direct_object);
            if ("undefined" !== typeof results) return results;

            // add thing to player's contents
            //results = player.onMoveThatToThis( direct_object, "in" );
            results = asset.moveTo("in", player);
            if ("undefined" !== typeof results) return results;
          }
          this.game.debug(`F1746 | ${this.name}.js | empty means take `);
          msg += `$(We) take ${this.game.getPrintableObjectList({
            objects: takeable_assets,
          })} from ${direct_object.articlename}. `;
        }

        // if(input.verb_params.empty_means_unplug)
        // {
        //   // unplug direct object
        // }
        // if(input.verb_params.empty_means_take_plug)
        // {
        //   // take plug from direct object
        // }

        this.handleSuccess(msg, direct_object);
        return true;
      }

      if (input.hasStructure("verb noun preposition noun")) {
        this.game.debug(`F1747 | ${this.name}.js | empty means pour `);
        msg += `$(We) empty ${direct_object.articlename}`;
        if (
          "under" === indirect_preposition ||
          "behind" === indirect_preposition
        ) {
          msg += ` ${indirect_preposition} ${indirect_object.articlename}`;
        } else {
          msg += ` over ${room ? "the floor" : indirect_object.articlename}`;
        }
        msg += `. `;

        // handle substances
        if (direct_object.hasVesselAtAspect("in")) {
          if (0 < direct_object.aspects.in.vessel.getVolume()) {
            // direct_object has substance
            substance_asset = this.game.getAsset(
              direct_object.aspects.in.vessel.substance_id
            );

            if (
              room ||
              "under" === indirect_preposition ||
              "behind" === indirect_preposition
            ) {
              // if indirect_object is room, substance just spills out
              msg += `${substance_asset.Name} spills to the floor. `;
              empty_this = true;
            } else if (
              "on" === indirect_preposition &&
              !indirect_object.hasVesselAtAspect(indirect_preposition)
            ) {
              // player said "pour on" and target has no on aspect
              msg += `${substance_asset.Name} pours over ${indirect_object.articlename} and then drains away. `;
              empty_this = true;
            } else if (
              indirect_object.hasVesselAtAspect(indirect_preposition)
            ) {
              mixer = new adventurejs.SubstanceMixer(this.game.game_name).set({
                source_input: direct_object.id,
                source_aspect: "in",
                source_substance_id:
                  direct_object.aspects.in.vessel.substance_id,
                target_input: indirect_object.id,
                target_aspect: indirect_preposition,
              });
              results = mixer.mix();
              if (A.isFalseOrNull(results)) return results;
              mixer.target_vessel.vessel_is_known = true;

              msg += `${mixer.source_substance_asset.Name} pours from 
              ${mixer.source_asset.articlename} ${indirect_preposition} 
              ${
                indirect_preposition === "in" || indirect_preposition === "on"
                  ? " to"
                  : ""
              } 
              ${mixer.target_asset.articlename}`;

              if (mixer.can_drain_target) {
                msg += `, where it quickly drains away`;
              } else if (mixer.did_overflow_target) {
                msg += `, overflowing ${mixer.target_asset.articlename} with 
                ${
                  mixer.did_mix_substances
                    ? mixer.output_substance_asset.name
                    : mixer.source_substance_asset.name
                }`;
              } else if (mixer.did_fill_target) {
                msg += `, filling ${mixer.target_asset.articlename} with 
                ${
                  mixer.did_mix_substances
                    ? mixer.output_substance_asset.name
                    : mixer.source_substance_asset.name
                }`;
              } else if (mixer.did_mix_substances) {
                msg += `, resulting in ${mixer.output_substance_asset.name}`;
              }
              msg += `. `;
            } else {
              msg += `${substance_asset.Name} pours over ${indirect_object.articlename} and then spills to the floor. `;
              empty_this = true;
            }
          }

          if (
            empty_this &&
            isFinite(direct_object.aspects.in.vessel.getVolume())
          ) {
            direct_object.aspects.in.vessel.setVolume(0);
          }
        } // handle substances

        // handle physical assets
        if (0 < direct_object.aspects.in.contents.length) {
          for (
            var i = direct_object.aspects.in.contents.length - 1;
            i > -1;
            i--
          ) {
            var content_object = this.game.getAsset(
              direct_object.aspects.in.contents[i]
            );
            target_object = indirect_object;
            target_preposition = indirect_preposition;
            overflow = false;
            emptied_count++;

            // if indirect_object is not the room, we need to check
            // if it can hold each object
            // if it can't, objects should fall to the floor

            if (room) {
              transferred.push(content_object);
            } else {
              if (
                indirect_object.canContainAssetAt(
                  content_object,
                  indirect_preposition
                )
              ) {
                transferred.push(content_object);
              } else {
                target_object = this.game.getCurrentRoom();
                target_preposition = "in";
                spillover.push(content_object);
                overflow = true;
              }
            }

            // remove content_object from direct_object
            results = direct_object.onRemoveThatFromThis(content_object);
            if ("undefined" !== typeof results) return results;

            // set content_object's target_object
            // if no target_object was specified, set to player's parent
            results = target_object.onMoveThatToThis(
              content_object,
              target_preposition
            );
            if ("undefined" !== typeof results) return results;

            // msg += "and you succeed. ";
          }
        }

        // print the results of physical assets
        if (room) {
          // everything falls to the floor
          switch (emptied_count) {
            case 0:
              break;
            case 1:
              msg += "A single item tumbles out and falls to the floor. ";
              break;
            case 2:
              msg += "Two items tumble out and fall to the floor. ";
              break;
            case 3:
              msg += "Several items tumble out and fall to the floor. ";
              break;
            default:
              msg += "A number of items tumble out and fall to the floor. ";
              break;
          }
        } else {
          var to_target =
            indirect_preposition +
            (indirect_preposition === "in" || indirect_preposition === "on"
              ? " to "
              : " ") +
            indirect_object.articlename;

          switch (emptied_count) {
            // some items are transferred to target, some may fall to the floor
            case 0:
              break;
            case 1:
              msg += `A single item tumbles ${to_target}`;
              switch (spillover.length) {
                case 0:
                  msg += ". ";
                  break;
                case 1:
                  msg += " then falls to the floor. ";
                  break;
              }
              break;
            case 2:
              msg += `Two items tumble ${to_target}`;
              switch (spillover.length) {
                case 0:
                  msg += ". ";
                  break;
                case 1:
                  msg += ", and one falls to the floor. ";
                  break;
                case 2:
                  msg += " then fall to the floor. ";
                  break;
              }
              break;
            case 3:
              msg += `Several items tumble ${to_target}`;
              switch (spillover.length) {
                case 0:
                  msg += ". ";
                  break;
                case 1:
                  msg += ", and one falls to the floor. ";
                  break;
                case 2:
                  msg += ", and a couple of them fall to the floor. ";
                  break;
                case 3:
                  msg += " then fall to the floor. ";
                  break;
              }
              break;
            default:
              msg += `A number of items tumble ${to_target}`;
              switch (spillover.length) {
                case 0:
                  msg += ". ";
                  break;
                case 1:
                  msg += ", and one falls to the floor. ";
                  break;
                case 2:
                  msg += ", and a couple of them fall to the floor. ";
                  break;
                case 3:
                  msg += ", and several fall to the floor. ";
                  break;
                default:
                  msg += " and some fall to the floor. ";
                  break;
              }
              break;
          }
        }
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // empty

// erase.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class erase
   * @ajsnode game.dictionary.verbs.erase
   * @ajsconstruct MyGame.createVerb({ "name": "erase", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading CompositionVerbs
   * @summary Verb meaning erase asset.
   * @todo Everything. Copied this from write_on and haven't modified yet. Need erase_noun1_with_noun2.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; erase paper</span>
   * You erase the sheet of paper.
   * </pre>
   * <p>
   * <strong>Erase</strong> erases a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}
   * of anything written on it.
   * Requires that the Asset to be erased has
   * asset.dov.erase.enabled
   * set to true and that player is holding an
   * {@link adventurejs.Eraser|Eraser} Asset
   * (aka a Tangible Asset with its
   * asset.iov.erase.enabled set to true).
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.erase = {
    name: "erase",
    prettyname: "erase",
    past_tense: "erased",
    synonyms: ["erase"],
    verb_noun_prep_noun: ["erase with"],

    /**
     * @memberof erase
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     present: true,
     *     known: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        tangible: true,
        present: true,
        known: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof erase
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        in_inventory: true,
      },
      accepts_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof erase
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";
      var allow = true;

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (!direct_object.isDOV("erase")) {
        this.game.debug(
          `F1516 | ${this.name}.js | ${direct_object.id}.dov.erase.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be erased. `;
        this.handleFailure(msg);
        return false;
      }

      if (input.hasStructure("verb noun")) {
        // no asset needed
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1755 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      if (input.hasStructure("verb noun preposition noun")) {
        if (direct_object.DOVallowWithNothing(this.name)) {
          // it doesn't need a tool
          this.game.debug(
            `F1515 | ${this.name}.js | ${direct_object.id}.dov.erase.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return true;
        }

        if (!indirect_object.isIOV("erase")) {
          this.game.debug(
            `F1519 | ${this.name}.js | ${indirect_object.id}.iov.erase.enabled is false `,
          );
          msg += `${indirect_object.Articlename} can't be used as an eraser. `;
          this.handleFailure(msg);
          return null;
        }

        if (!direct_object.DOVAllowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1517 | ${this.name}.js | neither ${direct_object.id} nor ${indirect_object.id} lists the other in .assets_this_can_${this.name}, .assets_that_can_${this.name}_this, .classes_this_can_${this.name}, .classes_that_can_${this.name}_this `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} with ${indirect_object.Articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1514 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
      }

      // apply state changes
      direct_object.set({ written_strings: [] });

      // compose output
      msg += `$(We) erase ${direct_object.articlename} with 
        ${
          indirect_object
            ? indirect_object.articlename
            : "the flat of $(our) hand"
        }. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // erase

// examine.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class examine
   * @ajsnode game.dictionary.verbs.examine
   * @ajsconstruct MyGame.createVerb({ "name": "examine", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading SensationVerbs
   * @summary Verb meaning examine an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; examine foot</span>
   * You examine the elephant's foot. Among the numerous black
   * umbrellas parked in it, one yellow umbrella stands out.
   * </pre>
   * <p>
   * <strong>Examine</strong> an {@link adventurejs.Asset|Asset}
   * returns a description of the Asset.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.examine = {
    name: "examine",
    prettyname: "examine",
    past_tense: "examined",
    synonyms: ["examine", "x"],
    verb_prep_noun: ["carefully examine"],
    verb_noun_prep_noun: ["examine carefully"],

    /**
     * @ajsverbstructures
     * @memberof examine
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof examine
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
      },
    },

    /**
     * @memberof examine
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition:true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof examine
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    msgNoObject: "What did you want to examine?",

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var currentRoom = this.game.getCurrentRoom();
      var player = this.game.getPlayer();
      var msg = "";
      var available;
      var containers;
      var dPlace;
      var dPlacePrep;

      // is direct object a substance?
      // we have a fully different set of rules for examining substances
      if (direct_object instanceof adventurejs.Substance) {
        //if( input.getParsedNoun(1).matches.substance )
        // has user input "examine substance" vs "examine substance in container"?
        if (indirect_object) {
          // is indirect_object also a substance?
          // @TODO there might be situations where this makes sense
          // such as a body of water with sand at its bottom "examine sand in water"
          // or a colloidal suspension - but would that be a new substance?
          if (indirect_object instanceof adventurejs.Substance) {
            this.game.debug(
              `F1589 | ${this.name}.js | ${direct_object.id} and ${indirect_object.id} are both substances `
            );
            msg += `$(We) can't examine "${direct_object.name} in ${indirect_object.name}. `;
            this.handleFailure(msg);
            return null;
          }

          // in order to allow examining substances, we skipped our usual
          // check for "present" and "visible" in the parser
          // so we need to do it here for indirect_object
          available = this.game.parser.selectPresent(indirect_object.id);
          available = this.game.parser.selectVisible(available);

          if (available.length === 0) {
            this.game.debug(
              `F1588 | ${this.name}.js | ${indirect_object.id} is either unknown or not present or not visible `
            );
            msg += `${indirect_object.Articlename} doesn't contain any ${direct_object.name}. `;
            this.handleFailure(msg);
            return null;
          }

          // does indirect_object contain substance?
          if (!indirect_object.doesContainSubstance(direct_object.id)) {
            // does it contain some other substance?
            if (indirect_object.doesContainAnySubstance()) {
              this.game.debug(
                `F1595 | ${this.name}.js | ${
                  indirect_object.id
                }.doesContainAnySubstance is ${indirect_object.getAnySubstanceThisContains()}`
              );
              msg += `${indirect_object.Articlename} contains ${
                this.game.getAsset(
                  indirect_object.getAnySubstanceThisContains()
                ).name
              }. `;
              this.handleFailure(msg);
              return null;
            }

            this.game.debug(
              `F1587 | ${this.name}.js | ${indirect_object.id}.doesContainSubstance ${direct_object.id} is false `
            );
            msg += `${indirect_object.Articlename} doesn't contain any ${direct_object.name}. `;
            this.handleFailure(msg);
            return null;
          }
        } // indirect_object
        else if (!indirect_object) {
          // user has input "examine substance"
          // is any substance present?
          // get a list of available
          containers = this.game.findSubstanceContainers(direct_object.id, [
            "Present",
            "Known",
            "Visible",
          ]);

          switch (containers.length) {
            case 0:
              this.game.debug(`F1585 | ${this.name}.js | no containers found `);
              msg += `There's no ${
                this.game.getAsset(direct_object.id).name
              } available. `;
              this.handleFailure(msg);
              return null;
            case 1:
              // set container as indirect_object
              // and treat like "examine water in bowl"
              input.setPreposition(2, "in");
              input.setAsset(2, this.game.getAsset(containers[0]));
              input.setAssumed(2, true);
              indirect_object = input.getAsset(2);
              indirect_preposition = input.getPreposition(2);
              break;
            default:
              var asset, body;
              for (var i = 0; i < containers.length; i++) {
                asset = this.game.getAsset(containers[i]);
                //if( asset.id === currentRoom.id )
                if (asset.$is("body")) {
                  body = true;
                  break;
                }
              }
              // if body is among multiple sources, always prefer body
              // meant for situations like player is on a beach,
              // where sand is always available
              if (body) {
                // set input phrase1 to the body
                // ie "examine sand" becomes "examine sand in beach"
                // doSuccess will handle the rest
                input.setPreposition(2, "in");
                input.setAsset(2, asset);
                input.setAssumed(2, true);
                indirect_object = input.getAsset(2);
                break;
              } // body
              else if (!body) {
                // disambiguate - need to set parsedNoun.matches ?
                this.game.print(
                  `F1586 | ${this.name}.js | multiple containers found, disambiguate `
                );
                // set preposition to "from" for disambiguation
                // because we're asking player to choose a container
                input.setAsset(2, direct_object);
                input.setPreposition(2, "in");
                // save containers back to input for next turn disambiguation
                input.setParsedNounMatchesQualified(2, containers);
                this.game.parser.printNounDisambiguation({
                  parsedNoun: input.getParsedNoun(2),
                  nounIndex: 2,
                });
                return null;
              } // !body
          } // switch
        } // !indirect_object

        // if we get here, we have a substance and a container
        return true;
      } // substance

      // NOT A SUBSTANCE

      // is direct_object present and visible?
      available = this.game.parser.selectPresent(direct_object.id);
      available = this.game.parser.selectVisible(available);

      if (!available.length) {
        this.game.debug(
          `F1591 | ${this.name}.js | ${direct_object.id} either is not present or not visible `
        );
        msg += `$(We) don't see any ${direct_object.name}. `;
        this.handleFailure(msg);
        return null;
      }

      // has user input "examine object in substance"?
      // can imagine situations like "examine boat in water"
      if (input.hasStructure("verb noun preposition noun")) {
        if (indirect_object instanceof adventurejs.Substance) {
          // need to find a container that contains indirect_object
          // and also has direct_object in it
          // may just be able to get direct_object's parent
          // and see if that contains Substance
          dPlace = this.game.getAsset(direct_object.getPlaceAssetId());
          dPlacePrep = direct_object.getPlacePreposition();
          // if( !dPlace.doesContainSubstance(indirect_object.id) )
          if (dPlace.getSubstanceAt(dPlacePrep) !== indirect_object.id) {
            this.game.debug(
              `F1590 | ${this.name}.js | ${direct_object.id}.place is ${dPlace.id} which doesn't contain ${indirect_object.id} `
            );
            msg += `${direct_object.Articlename} doesn't appear to be in  ${indirect_object.name}. `;
            this.handleFailure(msg);
            return null;
          }
        } // indirect_object is Substance
        else if (!(indirect_object instanceof adventurejs.Substance)) {
          // is indirect_object present and visible?
          available = this.game.parser.selectPresent(indirect_object.id);
          available = this.game.parser.selectVisible(available);

          if (available.length === 0) {
            this.game.debug(
              `F1592 | ${this.name}.js | ${indirect_object.id} either is not present or not visible `
            );
            msg += `$(We) don't see any ${indirect_object.name}. `;
            this.handleFailure(msg);
            return null;
          }

          // is direct_object in indirect_object?
          if (
            indirect_preposition !== direct_object.getPlacePreposition() ||
            indirect_object.id !== direct_object.getPlaceAssetId()
          ) {
            // did player input "on" but thing is attached? allow it
            if (
              indirect_preposition === "on" &&
              direct_object.getPlacePreposition() === "attached"
            ) {
              // allowed - do nothing
            } else if (
              indirect_preposition === "in" &&
              direct_object.getPlacePreposition() === "on" &&
              indirect_object.quirks.in_means_on
            ) {
              // allowed - do nothing
            } else if (
              direct_object.hasIndirectDescription(
                "look",
                indirect_preposition,
                indirect_object
              )
            ) {
              // allowed - do nothing
              input.verb_params.hasIndirectDescription = true;
            } else {
              this.game.debug(
                `F1593 | ${this.name}.js | ${direct_object.id} is not ${indirect_preposition} ${indirect_object.id} `
              );
              msg += `${direct_object.Articlename} doesn't appear to be ${indirect_preposition} ${indirect_object.articlename}. `;
              this.handleFailure(msg);
              return null;
            }
          }
        } // indirect_object is not Substance
      } // verb noun preposition noun

      return true;
    }, // doTry

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var currentRoom = this.game.getCurrentRoom();
      var player = this.game.getPlayer();
      var msg = "";
      var room = indirect_object && indirect_object.id === currentRoom.id;
      var careful = "";

      if (input.verb_params.hasIndirectDescription) {
        this.game.debug(
          `F1844 | ${this.name}.js | doSuccess >  ${direct_object.id} ${indirect_preposition} ${indirect_object.id} `
        );
        msg += direct_object.getIndirectDescription(
          "look",
          indirect_preposition,
          indirect_object
        );
        this.handleSuccess(msg, direct_object);
        return true;
      }

      if (direct_object instanceof adventurejs.Substance) {
        // indirect_object will be set regardless if one was entered
        this.game.debug(
          `F1594 | ${this.name}.js | doSuccess >  ${direct_object.id} ${indirect_preposition} ${indirect_object.id} `
        );
        msg += `$(We) look at ${direct_object.articlename}`;
        msg += !room ? ` in ${indirect_object.articlename}` : ``;
        msg += `. `;

        msg += direct_object.getDescription("look");
        this.handleSuccess(msg, direct_object);
        return true;
      }

      if (direct_object.id === currentRoom.id) {
        this.game.printCurrentRoom();
        return true;
      } else if (direct_object.is.global) {
        /**
         * direct_object.is.global applies to global
         * floor, ceiling, walls, sun & sky, etc
         * See Game.getGlobalAssetDescription
         * for more info.
         */
        let global_description =
          this.game.getGlobalAssetDescription(direct_object);
        if (global_description) {
          msg = A.getSAF.call(this.game, global_description);
        }
      } // is.global
      else if (
        input.parsedNoun1.matches.direction ||
        direct_object instanceof adventurejs.Exit
      ) {
        var exit = direct_object;

        if ("undefined" === typeof exit) {
          msg += `$(We) don't see any exit in that direction. `;
          this.handleFailure(msg);
          return true;
        }

        var exitDescription = exit.getDescription("look");
        if (exitDescription) {
          // if the exit has a description, print that
          msg += exitDescription;
        } else {
          // otherwise print this
          msg += `It's a passage ${exit.direction}`;
          msg +=
            exit.destination && exit.is.used
              ? ` to the ${exit.destination}`
              : ``;
          msg += `. `;
        }

        if (msg) this.game.print(msg, input.output_class);
        return true;
      } // if(input.parsedNoun1.matches.direction)

      // it's not global, just use its description
      if (!direct_object.is.global) {
        msg += direct_object.getDescription("look");
      }

      if (
        direct_object.isDOV("write") &&
        direct_object.written_strings.length &&
        direct_object.append_written_strings_to_description
      ) {
        msg += `Written on ${direct_object.articlename}`;

        if (1 === direct_object.written_strings.length) {
          msg += ` is a phrase: ${direct_object.written_strings[0]}`;
        } else {
          msg += ` are several phrases: `;
          for (var i = 0; i < direct_object.written_strings.length; i++) {
            msg += direct_object.written_strings[i];
            if (direct_object.written_strings.length > i + 1) msg += `, `;
          }
        }
        msg += `. `;
      }

      if (
        direct_object.is.typing_target &&
        direct_object.written_strings.length &&
        direct_object.append_written_strings_to_description
      ) {
        if (1 === direct_object.written_strings.length) {
          msg += `A line of input has been entered on the screen: `;
          msg += `<br> ${direct_object.written_strings[0]}`;
        } else {
          msg += `Several lines of input have been entered on the screen: `;
          for (var i = 0; i < direct_object.written_strings.length; i++) {
            msg += `<br> ${direct_object.written_strings[i]}`;
          }
        }
      }

      if (direct_object.hasAspectAt) {
        for (var i = 0; i < this.game.dictionary.prepositions.length; i++) {
          var preposition = this.game.dictionary.prepositions[i];
          if (direct_object.hasAspectAt(preposition)) {
            // if( preposition === "attached" )
            // {
            //   // important for attached - getCountOfListableContentsAt
            //   // may be inaccurate until attachments are known
            //   // direct_object.setAttachmentsKnown();
            //   direct_object.setAspectContentsKnown("attached",true);
            // }
            direct_object.setAspectContentsKnown(preposition, true);

            // 2023.04.06 not sure why this was here, it was preventing
            // printing descriptions of substances in containers
            // if( 0 >= direct_object.getCountOfListableContentsAt(preposition) )
            // {
            //   continue;
            // }

            if (!direct_object.aspects[preposition].list_in_examine) {
              continue;
            }
            if (
              preposition === "in" &&
              direct_object.isDOV("open") &&
              direct_object.dimensions.opacity === 1
            ) {
              // it's closed and opaque
              continue;
            }
            msg += direct_object.getPrintableListOfContentsAt(preposition);
          }
        }
      }

      // connections
      //if( direct_object.dov.tie?.with_params.connections.length )
      if (direct_object.DOVisConnectedToAnything("tie")) {
        let objects = { objects: direct_object.DOVgetConnections("tie") };
        msg += `${direct_object.Articlename} is tied to `;
        msg += this.game.getPrintableObjectList(objects);
        msg += direct_object.isIn(player)
          ? `, while $(we) hold an end of it`
          : ``;
        msg += `. `;
      }

      if (direct_object.IOVisConnectedToAnything("tie")) {
        let connections = direct_object.DOV.getConnections();
        for (let r = 0; r < connections.length; r++) {
          let rope = this.game.getAsset(connections[r]);
          msg += `Tied to ${direct_object.articlename} is a ${rope.name}`;
          if (1 < rope.DOVgetConnectionCount()) {
            let objects = {
              objects: rope.DOVgetConnections(),
              exclusions: direct_object.id,
            };
            msg += `, which is also tied to ${this.game.getPrintableObjectList(
              objects
            )}`;
          }
          msg += rope.isIn(player) ? `, while $(we) hold an end of it` : ``;
          msg += `. `;
        }
      }

      // if player input carefully examine
      if (-1 !== input.input_verb.indexOf("carefully")) {
        msg += direct_object.hasDescription("careful")
          ? direct_object.getDescription("careful")
          : `Careful examination reveals nothing new. `;
      }

      msg = msg || `${direct_object.Articlename} hasn't got a description. `;

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // examine

// exits.js
// OK 09 2023
/**
 *
 */
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class exits
   * @ajsnode game.dictionary.verbs.exits
   * @ajsconstruct MyGame.createVerb({ "name": "exits", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb that returns a list of available verbs.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; exits</span>
   * You can go out to the Playground, north to the
   * North Room, down through the hole in the ground,
   * south, east to the East Room, or west.
   * </pre>
   * <p>
   * <strong>Exits</strong> prints a list of available Exits.
   * </p>
   */
  A.Preverbs.exits = {
    name: "exits",
    synonyms: ["exits"],

    /**
     * @ajsverbstructures
     * @memberof exits
     */
    accepts_structures: ["verb"],

    do: function () {
      var input = this.game.getInput();
      var exits = this.game.getCurrentRoomExits();
      if (exits) {
        this.game.print(exits, input.output_class);
      }
      return true;
    },
  };
})();

// feed.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class feed
   * @ajsnode game.dictionary.verbs.feed
   * @ajsconstruct MyGame.createVerb({ "name": "feed", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ConsumptionVerbs
   * @summary Verb meaning feed a character.
   * @todo Full logic, this is just a skeleton.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; feed lettuce to turtle</span>
   * You feed the lettuce to the turtle. It chews contemplatively.
   * </pre>
   * <p>
   * <strong>Feed</strong> a
   * {@link adventurejs.Tangible|Tangible} or
   * {@link adventurejs.Substance|Substance}
   * {@link adventurejs.Asset|Asset} to an
   * {@link adventurejs.NPC|NPC} Asset. Requires
   * that the first Asset is in player's inventory.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.feed = {
    name: "feed",
    prettyname: "feed",
    past_tense: "fed",
    synonyms: [],
    verb_noun_prep_noun: ["feed to"], // @todo move 'to' to preposition

    /**
     * @memberof feed
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     in_inventory: true, // @todo doesn't work with "feed thing"
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        in_inventory: true,
      },
    },

    /**
     * @memberof feed
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     *   // accepts_preposition: true,
     *   // requires_preposition: true,
     *   // accepts_these_prepositions: ["to"], // @todo
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof feed
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var output_class = input.output_class;
      var msg = "";

      // can't feed to non-characters
      if (!(direct_object instanceof adventurejs.Character)) {
        this.game.debug(
          `F1280 | ${this.name}.js | ${direct_object.id} is not class Character`,
        );
        msg += `$(We) can't feed ${direct_object.articlename} to ${indirect_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var output_class = input.output_class;
      var msg = "";

      // feed x to y
      this.game.debug(`F1279 | ${this.name}.js | print doSuccess`);
      msg += `$(We) feed ${direct_object.articlename} to ${indirect_object.articlename}. `;

      // transfer of knowledge

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // feed_to

// fill.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class fill
   * @ajsnode game.dictionary.verbs.fill
   * @ajsconstruct MyGame.createVerb({ "name": "fill", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning fill an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; fill goblet with wine from cask</span>
   * You fill the stone goblet with foul smelling wine
   * from the goblin's cask.
   * </pre>
   * <p>
   * <strong>Fill</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} with a
   * {@link adventurejs.Substance|Substance} Asset
   * from another Tangible Asset.
   * Requires that both Tangible Assets have
   * {@link adventurejs.Vessel|Vessels}
   * and that the second actually contains the specified Substance.
   * </p>
   * <p>Substances are a unique subclass of Matter that have
   * no location, but only exist as properties in Tangible Assets,
   * ie Tangible.Aspect.Vessel.
   * Players may refer directly to a
   * substance, and we infer its container if we're able.
   * </p>
   * <p>
   * Ex: the player can input something like "fill jug with water",
   * as opposed to "fill jug from sink".
   * In such cases, instead of an object id, we get a ':' delimited
   * string in the form of tangible id : aspect id : substance id.
   * Ex: sink:in:water
   * If we did receive a triplet, we'll use that pre-parsed info
   * to get the aspect and substance.
   * If we did not receive a triplet, we'll get aspect and substance
   * via methods on the tangible object.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.fill = {
    name: "fill",
    prettyname: "fill",
    past_tense: "filled",
    synonyms: ["fill"],

    /**
     * @ajsverbstructures
     * @memberof fill
     */
    accepts_structures: [
      "verb noun preposition noun",
      "verb noun preposition noun preposition noun",
    ],

    /**
     * @memberof fill
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    // phrase2 can be either substance or tangible which
    // means we're not going to check present/visible/reachable
    // though we may have to in doTry
    /**
     * @memberof fill
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     // may be a substance or tangible and we
     *     // don't run these checks on substances
     *     //present: true,
     *     //visible: true,
     *     //reachable: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: [ "with", "from" ],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with", "from"],
    },

    /**
     * @memberof fill
     * @ajsverbphrase
     * phrase3:
     * {
     *   accepts_noun:true,
     *   accepts_preposition:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   requires_preposition: true,
     *   accepts_these_prepositions: [ "from" ],
     * },
     */
    phrase3: {
      accepts_noun: true,
      accepts_preposition: true,
      noun_must_be: {
        known: true,
        matter: true,
        present: true,
        visible: true,
        reachable: true,
      },
      requires_preposition: true,
      accepts_these_prepositions: ["from"],
    },

    /**
     * @memberof fill
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var target_asset = input.getAsset(1);
      var source_asset = input.getAsset(2);
      var preposition2 = input.getPreposition(2);
      var source_asset2 = input.getAsset(3);
      var preposition3 = input.getPreposition(3);
      var player = this.game.getPlayer();
      var substance_id = "";
      var containers;
      var msg = "";
      var source_volume;
      var source_vessel, target_vessel;
      var source_aspect, target_aspect;

      // player input "fill asset with substance from asset"
      if ("with" === preposition2 && "from" === preposition3) {
        // is source_asset a substance?
        substance_id = input.getParsedNoun(2).matches.substance;
        if (!substance_id) {
          this.game.debug(
            `F1559 | ${this.name}.js | ${source_asset.id} is not a substance `,
          );
          msg += `$(We) can't fill ${target_asset.articlename} with ${source_asset.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // does source_asset2 contain same substance?
        if (!source_asset2.doesContainSubstance(substance_id)) {
          this.game.debug(
            `F1563 | ${this.name}.js | ${source_asset2.id} does not contain ${substance_id} `,
          );
          msg += `${source_asset2.articlename} doesn't contain ${substance_id}. `;
          this.handleFailure(msg);
          return null;
        }

        // we've established that source_asset2 contains substance
        // so we can simplify the input to "fill target_asset from source_asset2"
        input.setPhrase(2, input.getPhrase(3));
        input.setPhrase(3, {});
        source_asset = input.getAsset(2);
        preposition2 = input.getPreposition(2);
      } else if ("with" === preposition2) {
        // is source_asset a substance?
        substance_id = input.getParsedNoun(2).matches.substance;
        if (substance_id) {
          // if source_asset is a substance, need to find a container
          containers = this.game.findSubstanceContainers(substance_id, [
            "Present",
            "Known",
            "Visible",
            "Reachable",
          ]);
          switch (containers.length) {
            case 0:
              this.game.debug(`F1565 | ${this.name}.js | no containers found `);
              msg += `There's no ${
                this.game.getAsset(substance_id).name
              } to fill ${target_asset.articlename} with. `;
              this.handleFailure(msg);
              return null;
            case 1:
              // set input phrase2 to the container
              input.setPhrase(2, {});
              input.setPreposition(2, "from");
              input.setAsset(2, this.game.getAsset(containers[0]));
              input.setAssumed(2, true);
              source_asset = input.getAsset(2);
              preposition2 = "from";
              break;
            default:
              var asset, room;
              for (var i = 0; i < containers.length; i++) {
                asset = this.game.getAsset(containers[i]);
                if (asset.id === this.game.getCurrentRoom().id) {
                  room = true;
                  break;
                }
              }
              if (room) {
                input.setPhrase(2, {});
                input.setPreposition(2, "from");
                input.setAsset(2, asset);
                input.setAssumed(2, true);
                source_asset = input.getAsset(2);
                preposition2 = "from";
                break;
              } else {
                // disambiguate - need to set parsedNoun.matches ?
                this.game.debug(
                  `F1564 | ${this.name}.js | multiple containers found, disambiguate `,
                );
                input.setPreposition(2, "from");
                // save containers back to input for next turn disambiguation
                input.setParsedNounMatchesQualified(2, containers);
                this.game.parser.printNounDisambiguation({
                  parsedNoun: input.getParsedNoun(2),
                  nounIndex: 2,
                });
                return null;
              }
          } // switch
        } // if substance // not substance
        else {
          // @TODO should be able to say things like
          // "fill printer with paper"
          // source_asset is not a substance, so it must be a container
          // does source_asset contain anything to fill with?
          if (!source_asset.doesContainAnySubstance()) {
            this.game.debug(
              `F1566 | ${this.name}.js | "+${source_asset.id}+" does not contain anything `,
            );
            msg += `${source_asset.Articlename} doesn't contain anything with which to fill ${target_asset.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // change preposition2 to "from"
          input.setPreposition(2, "from");
          preposition2 = "from";
        } // else
      } // if with
      else if ("from" === preposition2) {
        // does asset contain anything to fill with?
        if (source_asset && !source_asset.doesContainAnySubstance()) {
          this.game.debug(
            `F1560 | ${this.name}.js | ${source_asset.id} does not contain anything `,
          );
          msg += `${source_asset.Articlename} doesn't contain anything with which to fill ${target_asset.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      // can target_asset be filled?
      if (!target_asset.hasVessel()) {
        this.game.debug(
          `F1566 | ${this.name}.js | ${target_asset.id} has no substance container `,
        );
        msg += `${target_asset.Articlename} can't be filled. `;
        this.handleFailure(msg);
        return null;
      }

      // is player holding neither asset?
      if (!target_asset.isIn(player) && !source_asset.isIn(player)) {
        // If player is holding neither asset, we need
        // to consider the takeability of each asset.

        // Are both assets takeable?
        if (target_asset.isDOV("take") && source_asset.isDOV("take")) {
          this.game.debug(
            `F1567 | ${this.name}.js | neither ${target_asset.id} nor ${source_asset.id} are in player `,
          );
          msg += `$(We're) holding neither ${target_asset.articlename} nor ${source_asset.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // Are neither assets takeable?
        if (!target_asset.isDOV("take") && !source_asset.isDOV("take")) {
          this.game.debug(
            `F1569 | ${this.name}.js | both ${target_asset.id} and ${source_asset.id} are stationary `,
          );
          msg += `$(We) try transferring ${
            this.game.getAsset(source_asset.getAnySubstanceThisContains()).name
          } 
              from ${target_asset.articlename} to ${
                source_asset.articlename
              } by hand, to little effect. `;
          this.handleFailure(msg);
          return null;
        }

        // Is only one asset takeable?
        if (target_asset.isDOV("take") || source_asset.isDOV("take")) {
          var unheld = target_asset.isDOV("take") ? target_asset : source_asset;
          this.game.debug(
            `F1570 | ${this.name}.js | ${unheld.id}.dov.take.enabled is true, but is unheld `,
          );
          msg += `$(We're) not holding ${unheld.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      // Is either asset closed?
      if (
        (target_aspect === "in" &&
          target_asset.isDOV("close") &&
          target_asset.is.closed) ||
        (source_aspect === "in" &&
          source_asset.isDOV("close") &&
          source_asset.is.closed)
      ) {
        var closed = target_asset.is.closed ? target_asset : source_asset;
        this.game.debug(
          `F1471 | ${this.name}.js | ${closed.id}.is.closed is true `,
        );
        msg += `${closed.Articlename} is closed. `;
        this.handleFailure(msg);
        return null;
      }

      // practically vessels are always 'in'
      // but in theory we support substances at any aspect
      target_aspect = target_asset.getAspectWithVessel();
      source_aspect = source_asset.getAspectWithVessel();
      target_vessel = target_asset.getVesselAt(target_aspect);
      source_vessel = source_asset.getVesselAt(source_aspect);

      // has source got volume?
      source_volume = source_vessel.getVolume();

      // Is source asset empty?
      if (0 >= source_volume) {
        if (source_asset instanceof adventurejs.SubstanceEmitter) {
          this.game.debug(
            `F1572 | ${this.name}.js | ${source_asset.id} is class SubstanceEmitter, but .is_emitting is false `,
          );
          msg += `Nothing is coming out of ${source_asset.articlename}. `;
          this.handleFailure(msg);
          return null;
        } else {
          this.game.debug(
            `F1573 | ${this.name}.js | ${source_asset.id}.aspects.in.vessel.volume is 0 `,
          );
          msg += `Nothing is coming out of ${source_asset.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      if (
        target_vessel.getVolume() === target_vessel.maxvolume &&
        target_vessel.substance_id === source_vessel.substance_id
      ) {
        this.game.debug(
          `F1574 | ${this.name}.js | ${target_asset.id}.aspects.${target_aspect}.vessel.volume is equal to .maxvolume `,
        );
        msg += `${target_asset.Articlename} is already full of ${
          this.game.getAsset(target_vessel.substance_id).name
        }. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var target_asset = input.getAsset(1);
      var source_asset = input.getAsset(2);
      var room = source_asset instanceof adventurejs.Room;
      var msg = "";
      var results;
      var mixer;

      this.game.debug(`F1558 | ${this.name}.js | print doSuccess `);

      // instantiate a SubstanceMixer to handle the transfer
      mixer = new adventurejs.SubstanceMixer(this.game.game_name).set({
        can_overflow_target: false,
        source_input: source_asset.id,
        source_aspect: source_asset.getAspectWithVessel(),
        source_substance_id: source_asset.getAspectWithVessel().substance_id,
        target_input: target_asset.id,
        target_aspect: target_asset.getAspectWithVessel(),
      });
      results = mixer.mix();
      if (A.isFalseOrNull(results)) return results;
      mixer.target_vessel.vessel_is_known = true;

      msg = `$(We) fill ${mixer.target_asset.articlename} with ${
        mixer.source_substance_asset.name
      }${room ? "" : " from " + mixer.source_asset.articlename}`;
      // if source_asset is the room, don't say "from the room"

      // does the target drain?
      if (mixer.can_drain_target) {
        msg += `, but it quickly drains away`;
      }

      // was there a mixwith?
      else if (mixer.did_mix_substances) {
        msg += `, resulting in ${mixer.output_substance_asset.name}`;
      }

      // did source displace content of target?
      else if (mixer.did_displace_substance) {
        msg += `, displacing the ${
          this.game.getAsset(mixer.target_substance_id).name
        } that was already there`;
      }

      msg += `. `;

      // print output
      this.handleSuccess(msg, target_asset);
      return true;
    },
  };
})(); // fill

// fix.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class fix
   * @ajsnode game.dictionary.verbs.fix
   * @ajsconstruct MyGame.createVerb({ "name": "fix", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading RestorationVerbs
   * @summary Verb meaning fix a tangible asset.
   * @ajssynonyms fix, repair
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; fix clock</span>
   * You fail to fix the clock. At least it's right twice a day.
   * </pre>
   * <p>
   * Fix a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}. Asset must have
   * asset.dov.fix.enabled
   * set to true. There's no particular
   * code to handle fixing, so any special results will need
   * to be custom coded through a method such as setting a
   * verb override for the Asset. To learn about verb hooks,
   * see <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.fix = {
    name: "fix",
    prettyname: "fix",
    past_tense: "fixed",
    synonyms: ["fix", "repair"],
    unstate: "broken",

    /**
     * @ajsverbstructures
     * @memberof fix
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof fix
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof fix
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof fix
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1945 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1936 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.Articlename} is not ${this.getState()}. `;
        this.handleFailure(msg);
        return false;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1937 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1938 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1939 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1940 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1941 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1942 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1943 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";

      this.game.debug(`F1944 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // fix

// flick.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class flick
   * @ajsnode game.dictionary.verbs.flick
   * @ajsconstruct MyGame.createVerb({ "name": "flick", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning flick an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; flick wyvern's snout</span>
   * You flick the wyvern's snout. It sneezes out a tiny fireball.
   * </pre>
   * <p>
   * <strong>Flick</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be flicked has
   * asset.dov.flick.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.flick = {
    name: "flick",
    prettyname: "flick",
    past_tense: "flicked",
    synonyms: ["flick"],

    /**
     * @ajsverbstructures
     * @memberof flick
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof flick
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *     visible_if_tangible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        // tangible: true,
        // present: true,
        // visible: true,
        // reachable: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
        visible_if_tangible: true,
      },
    },

    /**
     * @memberof flick
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof flick
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";
      var containers;
      var inhands;
      var direct_object_vessel;

      // verb enabled?
      if (!direct_object.isDOV("flick")) {
        this.game.debug(
          `F1281 | ${this.name}.js | ${direct_object.id}.dov.flick.enabled is false`
        );
        msg += `$(We) can't flick ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1823 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // did player input something like "throw sand" ?
      // if so it must come from a substance container that
      // is either in hands, or in a reachable substance body
      if (direct_object instanceof adventurejs.Substance) {
        // get a list of available vessels
        // this includes only things in inventory and nearby bodies of substance

        containers = this.game.findSubstanceBodyOrHeld(direct_object.id);

        switch (containers.length) {
          case 0:
            this.game.debug(` | ${this.name}.js | no valid vessel found `);
            msg += `There doesn't appear to be any ${
              this.game.getAsset(direct_object.id).name
            } to throw. `;
            this.handleFailure(msg);
            return null;
          default:
            // use the first container, regardless of how many are found
            direct_object_vessel = this.game.getAsset(containers[0]);
            input.setAssumed(1, true);
            input.setVessel(1, direct_object_vessel);
            break;
        } // switch containers.length
      } // direct_object is substance // not substance
      // else {
      //   // we bypassed the usual in_hands check to allow
      //   // substance handling so we need to check that now
      //   inhands = this.game.parser.selectInHands(direct_object.id);
      //   if (!inhands.length) {
      //     this.game.debug(
      //       ` | ${this.name}.js | ${direct_object.id} not in player's hands `
      //     );
      //     msg += `$(We're) not holding ${direct_object.articlename}. `;
      //     this.handleFailure(msg);
      //     return null;
      //   }
      // }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1949 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1950 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        if (indirect_preposition === "with" && !indirect_object.isIn(player)) {
          this.game.debug(
            `F1947 | ${this.name}.js | ${direct_object.id} is not in player `
          );
          msg += indirect_object.isDOV("take")
            ? `$(We're) not carrying ${indirect_object.articlename}. `
            : `$(We) can't use ${indirect_object.articlename} that way. `;
          this.handleFailure(msg);
          return null;
        }

        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1951 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1952 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1953 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1954 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var direct_object_vessel = this.game.getAsset(input.getVessel(1));
      var currentRoom = this.game.getCurrentRoom();
      var results;
      var msg = "";

      this.game.debug(`F1282 | ${this.name}.js | print doSuccess`);

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // flick thing
        if (direct_object_vessel) {
          msg += `$(We) flick a bit of ${direct_object.articlename} from ${direct_object_vessel.articlename}. `;
        } else {
          msg += `$(We) flick ${direct_object.articlename}. `;
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        if (direct_object_vessel) {
          msg += `$(We) flick a bit of ${direct_object.articlename} from ${direct_object_vessel.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        } else {
          if ("with" !== indirect_preposition) {
            results = player.onRemoveThatFromThis(direct_object);
            if ("undefined" !== typeof results) return results;

            results = currentRoom.onMoveThatToThis(direct_object, "in");
            if ("undefined" !== typeof results) return results;
          }
          msg += `$(We) flick ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        }
      } // verb noun preposition noun

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // flick

// flip.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class flip
   * @ajsnode game.dictionary.verbs.flip
   * @ajsconstruct MyGame.createVerb({ "name": "flip", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning flip an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; flip griddlecake</span>
   * You flip the griddlecake on the grill.
   * Ahh, it's a perfect golden brown.
   * </pre>
   * <p>
   * <strong>Flip</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be flipped has
   * asset.dov.flip.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.flip = {
    name: "flip",
    prettyname: "flip",
    past_tense: "flipped",
    synonyms: ["flip"],
    verb_prep_noun: ["turn over"],

    /**
     * @memberof flip
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof flip
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (!direct_object.isDOV("flip")) {
        this.game.debug(
          `F1283 | ${this.name}.js | ${direct_object.id}.dov.flip.enabled is false`
        );
        msg += `$(We) can't flip ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var msg = "";

      this.game.debug(`F1284 | ${this.name}.js | print doSuccess`);
      msg += `$(We) flip ${direct_object.articlename}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // flip

// float.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class float
   * @ajsnode game.dictionary.verbs.float
   * @ajsconstruct MyGame.createVerb({ "name": "float", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning float, as in "float in lake"; or, travel in specified direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; float over London</span>
   * You float over London, pooting along on little puffs of mist.
   * It's a pleasant day to be a cloud.
   * </pre>
   * Float extends core verb <a href="go.html">go</a>.
   * It checks whether "float" is contextually available
   * before forwarding to "go" for further handling.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.float = {
    name: "float",
    prettyname: "float",
    past_tense: "floated",
    synonyms: ["float"],
    type: { locomotion: true, travel: true },
    extends: { go: true },

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
      able_to_float: true,
    },

    /**
     * @ajsverbstructures
     * @memberof float
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof float
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof float
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof float
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    do: function () {
      return this.game.dictionary.doVerb("go");
    },
  }; // END float
})();

// fly.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class fly
   * @ajsnode game.dictionary.verbs.fly
   * @ajsconstruct MyGame.createVerb({ "name": "fly", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning fly, as in "fly over lake"; or, travel in specified direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; fly through mountain</span>
   * You fire up your primitive oscillation overthruster,
   * slip off your shoes and set your feet to the pedals,
   * try to align the three beams... and fail completely,
   * scraping against the mountain and spilling a shower of
   * sparks and spaceship parts.
   * </pre>
   * Fly extends core verb <a href="go.html">go</a>.
   * It checks whether "fly" is contextually available
   * before forwarding to "go" for further handling.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.fly = {
    name: "fly",
    prettyname: "fly",
    past_tense: "flew",
    synonyms: ["fly"],
    type: { locomotion: true, travel: true },
    extends: { go: true },

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
      able_to_fly: true,
    },

    /**
     * @ajsverbstructures
     * @memberof fly
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof fly
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof fly
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof fly
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    do: function () {
      return this.game.dictionary.doVerb("go");
    },
  }; // END fly
})();

// get.js - Use this file as a template to create new verbs.

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class get
   * @ajsnode game.dictionary.verbs.get
   * @ajsconstruct MyGame.createVerb({ "name": "get", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * <pre class="display border outline">
   * <span class="input">&gt; get out</span>
   * You climb out of the transmogrifier box. You're a tiger!
   * </pre>
   * <pre class="display border outline">
   * <span class="input">&gt; get box</span>
   * You fold up the transmogrifier box into a compact square
   * and tuck it in your satchel.
   * </pre>
   * <strong>Get</strong> extends two verbs:
   * <a href="take.html">take</a> and
   * <a href="go.html">go</a>; and forwards
   * to one or the other depending on context.
   * @ajsverbphases
   */
  A.Preverbs.get = {
    name: "get",
    prettyname: "get",
    past_tense: "got",
    synonyms: ["get"],
    extends: { go: true, take: true },

    /**
     * @ajsverbstructures
     * @memberof get
     */
    accepts_structures: [
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
      "verb preposition noun preposition noun",
      "verb preposition noun preposition noun preposition noun",
    ],

    /**
     * @memberof verb
     * @ajsverbphrase
     * phrase1: {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   accepts_preposition_without_noun: true,
     *   noun_must_be: {
     *     known: true,
     *     not_global: true,
     *     not_scenery: true,
     *     not_exit: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     not_in_hands: true,
     *     not_worn: true,
     *     not_nested_inventory_if_all: true,
     *   },
     * },
     */

    phrase1: {
      accepts_noun: true,
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      noun_must_be: {
        known: true,
        not_global: true,
        not_scenery: true,
        not_exit: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        //not_in_hands: true, // this breaks "get off bike"
        not_worn: true,
        not_nested_inventory_if_all: true,
      },
    },

    /**
     * @memberof verb
     * @ajsverbphrase
     * phrase1: {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   noun_must_be: {
     *     known: true,
     *     not_global: true,
     *     not_scenery: true,
     *     not_exit: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */

    phrase2: {
      accepts_noun: true,
      accepts_preposition: true,
      requires_preposition: true,
      noun_must_be: {
        known: true,
        not_global: true,
        not_scenery: true,
        not_exit: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    let_verb_handle_disambiguation: false,

    do: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var indirect_object2 = input.getAsset(3);
      var indirect_preposition2 = input.getPreposition(3);
      var msg = "",
        target = "";

      // sentence structure: verb noun ----------
      if (input.hasStructure("verb noun")) {
        target =
          direct_object.direction || direct_object.is.exit ? "go" : "take";
        this.game.debug(
          `F1037 | ${this.name}.js | ${this.name} ${direct_object.name}: infer ${target}`,
        );
      }

      // sentence structure: verb preposition ----------
      if (input.hasStructure("verb preposition")) {
        target = direct_preposition === "up" ? "stand" : "go";
        this.game.debug(
          `F1038 | ${this.name}.js | ${this.name} ${direct_preposition}: infer ${target}`,
        );
      }

      // sentence structure: verb preposition noun ----------
      if (input.hasStructure("verb preposition noun")) {
        target = direct_preposition === "from" ? "take" : "go";
        this.game.debug(
          `F1039 | ${this.name}.js | ${this.name} ${direct_preposition} ${direct_object.name}: infer ${target}`,
        );
      }

      // sentence structure: verb noun preposition noun ----------
      if (input.hasStructure("verb noun preposition noun")) {
        target = direct_object.direction ? "go" : "take";
        this.game.debug(
          `F1040 | ${this.name}.js | ${this.name} ${direct_object.name} ${indirect_preposition} ${indirect_object.name}: infer ${target}`,
        );
      }

      // sentence structure: verb preposition noun preposition noun ----------
      if (input.hasStructure("verb preposition noun preposition noun")) {
        target = "go";
        this.game.debug(
          `F1872 | ${this.name}.js | ${this.name} ${direct_preposition} ${direct_object.name} ${indirect_preposition} ${indirect_object.name}: infer ${target}`,
        );
      }

      // sentence structure: verb preposition noun preposition noun preposition noun ----------
      if (
        input.hasStructure(
          "verb preposition noun preposition noun preposition noun",
        )
      ) {
        target = "go";
        this.game.debug(
          `F1873 | ${this.name}.js | ${this.name} ${direct_preposition} ${direct_object.name} ${indirect_preposition} ${indirect_object.name} ${indirect_preposition2} ${indirect_object2.name}: infer ${target}`,
        );
      }

      this.game.dictionary.doVerb(target);
      return null;
    },
  };
})(); // get

// give.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class give
   * @ajsnode game.dictionary.verbs.give
   * @ajsconstruct MyGame.createVerb({ "name": "give", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning give asset to character.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; give incriminating evidence to butler</span>
   * You give the piece of incriminating evidence to the butler.
   * He blanches, then turns to flee. The chase is on!
   * </pre>
   * <strong>Give</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to an
   * {@link adventurejs.NPC|NPC} Asset. Requires
   * that the Tangible Asset is in player's inventory.
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.give = {
    name: "give",
    prettyname: "give",
    past_tense: "gave",
    synonyms: [],
    //verb_noun_prep_noun: ["give to"],

    /**
     * @ajsverbstructures
     * @memberof close
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof give
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        in_inventory: true,
      },
    },

    /**
     * @memberof give
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["to"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        character: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["to"],
    },

    /**
     * @memberof give
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      // can't give this thing
      if (!direct_object.isDOV("give")) {
        this.game.debug(
          `F1292 | ${this.name}.js | ${direct_object.id}.dov.give.enabled is false`,
        );
        msg += `$(We) can't give ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // can't remove this thing
      if (direct_object.is.worn && !direct_object.isDOV("remove")) {
        this.game.debug(
          `F1294 | ${this.name}.js | ${direct_object.id}.dov.remove.enabled is false`,
        );
        msg += `$(We) can't remove ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // find a character in the room
        let chars = this.game.getCurrentRoom().findClassInThis("Character", {
          exclude: [player.id],
        });
        for (let i = chars.length - 1; i > -1; i--) {
          if (!this.game.getAsset(chars[i]).isIOV("give")) {
            chars.splice(i, 1);
          }
        }
        switch (chars.length) {
          case 1:
            indirect_object = this.game.getAsset(chars[0]);
            indirect_preposition = "to";
            input.setAsset(2, indirect_object);
            input.setPreposition(2, "to");
            input.setAssumed(2);
            input.setStructure("verb noun preposition noun");
            break;
          default:
            input.setPreposition(2, "to");
            input.setSoftPrompt({
              noun2: true,
              structure: "verb noun preposition noun",
            });
            this.game.debug(`F1924 | ${this.name}.js | soft prompt for noun2 `);
            msg += `To whom would $(we) like to ${this.name} ${direct_object.articlename}? `;
            this.handleFailure(msg);
            return null;
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // give to only works with characters
        if (!(indirect_object instanceof adventurejs.Character)) {
          this.game.debug(
            `F1290 | ${this.name}.js | ${indirect_object.id} is not class Character`,
          );
          msg += `$(We) can't give anything to ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can't give to this character
        if (!indirect_object.isIOV("give")) {
          this.game.debug(
            `F1291 | ${this.name}.js | ${indirect_object.id}.iov.give is unset`,
          );
          msg += `$(We) can't give anything to ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }
      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var closedAnscestors = [];
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var parent = direct_object.getPlaceAsset();
      var results;
      var msg = "";

      this.game.debug(`F1293 | ${this.name}.js | print doSuccess`);
      // if player is giving thing that is nested in inventory,
      // we'll auto-open any containers if necessary
      if (direct_object.isIn(player) && direct_object.areAnscestorsClosed()) {
        closedAnscestors = direct_object.getClosedAnscestors();
        for (var i = 0; i < closedAnscestors.length; i++) {
          this.game.getAsset(closedAnscestors[i]).is.closed = false;
          closedAnscestors[i] = this.game.getAsset(closedAnscestors[i]).name;
        }
      }

      if (closedAnscestors.length > 0) {
        msg += "$(We) open the ";
        for (var i = 0; i < closedAnscestors.length; i++) {
          if (closedAnscestors.length > 2 && i < closedAnscestors.length - 2) {
            msg += ", ";
          }
          if (
            closedAnscestors.length > 1 &&
            i === closedAnscestors.length - 1
          ) {
            msg += " and the ";
          }
          msg += closedAnscestors[i];
        }
        msg += ". ";
      }

      // if it's an article of clothing, remove it
      if (direct_object.is.worn) {
        results = direct_object.unfasten();
        msg += results ? `$(We) ${results}, then remove, ` : `$(We) remove `;
        msg += `${direct_object.articlename}. `;
        direct_object.incrementDoVerbCount("remove", 1);
        direct_object.is.worn = false;
      }

      // remove thing from its current container
      results = parent.onRemoveThatFromThis(direct_object);
      if ("undefined" !== typeof results) return results;

      // set thing's new location to indirect_object
      results = indirect_object.onMoveThatToThis(direct_object, "in");
      if ("undefined" !== typeof results) return results;

      // compose output
      msg += `$(We) give ${direct_object.articlename} to ${indirect_object.articlename}. `;

      if (
        (1 < input.parsedNoun1.matches.qualified.length ||
          this.game.parser.isParsingMultiple()) &&
        -1 === input.output_class.indexOf("concatenate_output")
      ) {
        input.output_class += " concatenate_output ";
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // give

// go.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class go
   * @ajsnode game.dictionary.verbs.go
   * @ajsconstruct MyGame.createVerb({ "name": "go", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning go [preposition] asset or travel [direction].
   * @ajssynonyms go
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; go in wardrobe</span>
   * You go in the wardrobe. Hey, it's cold in here! Better put
   * on a coat.
   * </pre>
   * <p>
   * <strong>Go</strong> can accept
   * directions and tangible assets.
   * For example, <strong>go east</strong> is equivalent
   * to entering just <strong>east</strong>;
   * <strong>go bed</strong> is equivalent to
   * <strong>get on bed</strong> and requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} has an <strong>on</strong>
   * {@link adventurejs.Aspect|Aspect}.
   * See
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>
   * to learn more.
   * </p>
   * <p>
   * <strong>Go</strong> can be triggered via the verb
   * <strong>get</strong>, as in <strong>get down</strong>
   * or <strong>get on bed</strong> or
   * <strong>get out from under bed</strong>.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.go = {
    name: "go",
    prettyname: "go",
    past_tense: "went",
    synonyms: ["go", "come"],
    type: { locomotion: true, travel: true },
    extensions: [
      "bounce",
      "crawl",
      "fly",
      "float",
      "hop",
      "hover",
      "jump",
      "ride",
      "run",
      "slither",
      "swim",
      "walk",
    ],

    /**
     * @ajsverbstructures
     * @memberof go
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
      "verb preposition noun preposition noun",
      "verb preposition noun preposition noun preposition noun",
    ],

    player_must_be: {
      not_on_floor: true,
      not_constrained: true,
      //not_nested_elsewhere: true,
    },

    /**
     * @memberof go
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   //requires_noun: true, // because we allow 'get down' and similar
     *   accepts_preposition: true,
     *   accepts_preposition_without_noun: true,
     *   noun_must_be: {
     *     not_global: true,
     *     tangible: true,
     *     known: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      noun_must_be: {
        //not_global: true,
        tangible: true,
        known: true,
        //present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof go
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     known: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   //requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        tangible: true,
        known: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      //requires_preposition: true,
    },

    /**
     * @memberof go
     * @ajsverbphrase
     * phrase3:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     known: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase3: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        tangible: true,
        known: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof go
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    in_can_mean_on: true,

    // the ways GO can be used
    // no object, no preposition - go
    // no object, preposition - go off
    // object, no preposition - go east, go bed
    // object, preposition - go on bed, go on east
    doTry: function () {
      var input = this.game.getInput();
      var input_verb = input.input_verb;
      var Input_verb = A.propercase(input_verb);
      var dictionary_verb = input.getDictionaryVerb();
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_asset = player.getNestAsset();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var prep_exit = this.game.getExitFromDirection(direct_preposition);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var indirect_object2 = input.getAsset(3);
      var indirect_preposition2 = input.getPreposition(3);
      var msg = "";
      var results;
      var outfrombehind = direct_preposition === "outfrombehind";
      var outfromunder = direct_preposition === "outfromunder";
      if (outfrombehind || outfromunder) {
        input.verb_params[
          outfromunder ? "outfromunder" : "outfrombehind"
        ] = true;
        input.setPreposition(1, "out");
        direct_preposition = "out";
      }
      input.verb_params.found = {
        up: false,
        down: false,
        off: false,
        out: false,
        in: false,
        fromto: false,
        with: false,
        goto: false,
      };

      if (direct_object?.is.global && direct_object.id !== "global_floor") {
        // @TODO floor handling
        this.game.debug(
          `F1725 | ${this.name}.js | ${direct_object.id}.is.global `
        );
        msg += `$(We) can't go to ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // check for extensions
      if (dictionary_verb.extends.go) {
        // @TODO and do what?
        // We got here by a verb other than go,
        // such as crawl, slither, fly, etc.
        // That verb went through qualifyParsedVerb on its
        // way here so we ought to be able to act on it.
      }

      if (indirect_object && indirect_object instanceof adventurejs.Floor) {
        // if (
        //   indirect_preposition &&
        //   ["to", "on"].indexOf(indirect_preposition) > -1
        // ) {
        //   if (direct_preposition) {
        //     direct_preposition = "off";
        //     input.setPreposition(1, "off");
        //     input.deletePhrase(2);
        //   }
        // }
      }

      if (direct_object && direct_object instanceof adventurejs.Floor) {
        // "go floor" means "get off", delete phrase1
        //input.deletePhrase(1);
      }

      if (input.hasStructure("verb")) {
        // go doesn't handle "verb"
        // though other locomotion verbs do
        if (dictionary_verb.accepts_structures.indexOf("verb") === -1) {
          this.game.debug(
            `F1182 | ${dictionary_verb.name}.js | no direct_object, soft prompt noun1`
          );
          msg += `Where did $(we) want to ${input.input}? `;
          input.setSoftPrompt({
            noun1: true,
            input_verb: input.input_verb,
            verb: input.input_verb,
            structure: "verb noun",
          });
          this.handleFailure(msg);
          return null;
        } // else return true;
      }

      if (input.hasStructure("verb preposition noun")) {
        if (input.input_verb === "go" && direct_preposition === "to") {
          if (direct_object instanceof adventurejs.Room)
            input.verb_params.found.goto = true;
          if (!(direct_object instanceof adventurejs.Room)) {
            let destination = direct_object.getRoomId();
            let current_room = this.game.getCurrentRoom();
            if (destination !== current_room.id)
              input.verb_params.found.goto = true;
          }
          if (input.verb_params.found.goto) {
            // is player nested?
            if (nest_asset && !nest_asset.isIn(player)) {
              this.game.debug(
                `F1210 | ${
                  this.name
                }.js | player is nested ${player.getNestPreposition()} ${
                  nest_asset.id
                }`
              );
              msg += `$(We'll) have to get ${player.getPrettyUnnestPreposition()} ${
                nest_asset.articlename
              } first. `;
              this.handleFailure(msg);
              return null;
            }
            if (this.game.dictionary.verbs.goTo) {
              this.game.debug(
                `F1295 | ${this.name}.js | destination is not in current room, doVerb goTo `
              );
              this.game.dictionary.doVerb("goTo");
              return null;
            } else {
              this.game.debug(
                `F1092 | ${this.name}.js | destination is not in current room and verb goTo is not enabled `
              );
              msg += `$(We) can't get to ${direct_object.articlename} from here. `;
              this.handleFailure(msg);
              return null;
            }
          }
        }
      }
      if (
        direct_object &&
        !this.game.parser.selectPresent([direct_object]).length
      ) {
        this.game.debug(
          `F1201 | ${this.name}.js | ${direct_object.id}.is.global `
        );
        msg += `There doesn't appear to be any ${
          input.replacements[direct_object.id]
            ? input.replacements[direct_object.id].source
            : direct_object.name
        } present. `;
        this.handleFailure(msg);
        return null;
      }

      input.verb_params.found.down =
        (direct_object && direct_object.direction === "down") ||
        direct_preposition === "off" ||
        direct_preposition === "down" ||
        (direct_preposition === "from" && !indirect_preposition);

      input.verb_params.found.up =
        (direct_object && direct_object.direction === "up") ||
        (direct_object && !direct_preposition) ||
        direct_preposition === "up" ||
        direct_preposition === "on" ||
        direct_preposition === "over";

      // sentence structure: verb preposition ----------
      // ex: go up, go down, go in, go out, go off
      if (input.hasStructure("verb preposition")) {
        if (!nest_asset && prep_exit) {
          // this should catch go up, go down, go in, go out
          // while player is not nested, and set a direction
          this.game.debug(
            `F1121 | ${this.name}.js | received preposition ${direct_preposition}, convert to direction`
          );
          this.game.print(msg);
          input.setAsset(1, prep_exit);
          input.setPreposition(1, "");
          input.setStructure("verb noun");
          direct_object = input.getAsset(1);
          direct_preposition = "";
        }
      }

      if (input.hasStructure("verb preposition")) {
        // the only prepositions that can be figured from context are
        // go in, go out, go up, go down, go off

        switch (direct_preposition) {
          case "up":
            if (nest_asset) {
              if (
                nest_asset.is.climbable &&
                player.getY() < nest_asset.getYTop()
              ) {
                // let player go higher
                direct_object = nest_asset;
                input.setAsset(1, nest_asset);
                input.setStructure("verb preposition noun");
              }
              if (player.getY() >= nest_asset.getYTop()) {
                // @TODO reach up exit from nest
                // ex: player is standing on ladder from which they can reach up exit
                if (prep_exit) {
                  this.game.debug(
                    `F1152 | ${this.name}.js | player is at top of ${nest_asset.id}, tryTravel ${prep_exit.direction}`
                  );
                  this.game.tryTravel(prep_exit.direction);
                  return null;
                }
                this.game.debug(
                  `F1047 | ${this.name}.js | player is at top of ${nest_asset.id} `
                );
                msg += `$(We) can't get any higher on ${nest_asset.articlename}. `;
                this.handleFailure(msg);
                return null;
              }
            }
            break;
          case "down": //----------
            if (nest_asset) {
              if (
                player.getY() - nest_asset.getY() <=
                this.game.settings.reach_height
              ) {
                input.setPreposition(1, "off");
                direct_preposition = "off";
              }
              // let player go lower
              direct_object = nest_asset;
              input.setAsset(1, nest_asset);
              input.setStructure("verb preposition noun");
            }
            break;
          case "in": //----------
            input.setAsset(1, prep_exit);
            input.setPreposition(1, "");
            input.setStructure("verb noun");
            direct_object = input.getAsset(1);
            direct_preposition = "";
            break;
          case "out": //----------
            // we'll be generous in inferring what "out" means
            if (
              nest_asset &&
              ["on", "in", "under", "behind"].indexOf(nest_preposition) > -1
            ) {
              // player is nested and input "get out", infer "get out of nest"
              this.game.debug(
                `F1129 | ${this.name}.js | infer 'get out of ${nest_asset.id}'`
              );
              direct_object = nest_asset;
              input.setAsset(1, nest_asset);
              input.setStructure("verb preposition noun");
            } else if (nest_asset) {
              // this is unlikely to happen
              this.game.debug(
                `F1130 | ${this.name}.js | player nested  ${nest_preposition} ${nest_asset.id} `
              );
              msg += `$(We) can't get out of ${nest_asset.articlename}. `;
              this.handleFailure(msg);
              return null;
            }
            break;
          case "off": //----------
            if (nest_asset) {
              this.game.debug(
                `F1205 | ${this.name}.js | infer 'get off of ${nest_asset.id}'`
              );
              direct_object = nest_asset;
              input.setAsset(1, nest_asset);
              input.setStructure("verb preposition noun");
            } else {
              // @TODO what if player is riding a bus?
              this.game.debug(`F1046 | ${this.name}.js | nothing to get off `);
              msg += `$(We're) not on anything to ${input.input_verb} off. `;
              this.handleFailure(msg);
              return null;
            }
            break;
        }
      } // go in, go out, go up, go down, go off

      // still no direct object? prompt player
      if (input.hasStructure("verb preposition")) {
        if (!direct_object) {
          this.game.debug(
            `F1001 | ${this.name}.js | no direct_object, soft prompt noun1`
          );
          msg += `Where did $(we) want to ${input.input}? `;
          input.setSoftPrompt({
            noun1: true,
            structure: "verb preposition noun",
          });
          this.handleFailure(msg);
          return null;
        }
      }

      // sentence structure: verb noun ----------

      // ex: climb tree, climb east
      // try to get a preposition
      if (input.hasStructure("verb noun")) {
        // direct_object is a direction
        if (direct_object.direction) {
          // for example, "go down"

          // direct_object is direction - down and player is on climbable
          if ("down" === direct_object.direction) {
            if (nest_asset) {
              // is it climbable?
              if (
                nest_asset.is.climbable &&
                player.position.y > nest_asset.position.y
              ) {
                // player may be able to go lower on nest parent
                // or get off it
                this.game.debug(
                  `F1124 | ${this.name}.js | noun is direction/down and nest is climbable, doVerb climb`
                );
                input.setAsset(1, nest_asset);
                input.setPreposition(1, "down");
                input.setVerb("climb");
                this.game.dictionary.doVerb("climb");
                return null;
              }

              // otherwise treat it as ordinary get down
              else {
                return true; // just do it
              }
            } // down & nest_asset // tryTravel down
            else {
              this.game.debug(
                `F1861 | ${this.name}.js | ${direct_object.id}.direction is ${direct_object.direction}, tryTravel ${direct_object.direction}`
              );
              this.game.tryTravel(direct_object.direction);
              return null;
            }
          } // down

          // direct_object is direction - up and player is on climbable
          else if (
            "up" === direct_object.direction &&
            nest_asset &&
            nest_asset.is.climbable
          ) {
            this.game.debug(
              `F1125 | ${this.name}.js | noun is direction/up and nest is climbable, doVerb climb`
            );
            // player may be able to go higher on nest parent
            //input.parsedNoun1 = new adventurejs.ParsedNoun( nest_asset );
            input.setAsset(1, nest_asset);
            this.game.dictionary.doVerb("climb");
            return null;
          }

          // direct_object is any other direction - tryTravel
          else {
            this.game.debug(
              `F1131 | ${this.name}.js | ${direct_object.id}.direction is ${direct_object.direction}, tryTravel ${direct_object.direction}`
            );
            this.game.tryTravel(direct_object.direction);
            return null;
          }
        } // direct_object is direction

        if (
          !nest_asset &&
          direct_object.is.climbable &&
          0 < direct_object.dimensions.height
        ) {
          this.game.debug(
            `F1208 | ${this.name}.js | ${direct_object.id}.is.climbable, doVerb climb`
          );
          this.game.dictionary.doVerb("climb");
          return null;
        }

        if (!nest_asset && direct_object.default_aspect) {
          direct_preposition = direct_object.default_aspect;
          input.setPreposition(1, direct_preposition);
          input.setStructure("verb preposition noun");
        }

        // for example, "go bed"
        if (
          (nest_asset && nest_asset.id === direct_object.id) ||
          (!nest_asset && direct_object instanceof adventurejs.Floor)
        ) {
          // player already nested in this asset
          this.game.debug(
            `F1209 | ${this.name}.js | player nested  ${nest_preposition} ${direct_object.id} `
          );
          msg += `$(We're) already ${
            nest_preposition ? nest_preposition : direct_object.default_aspect
          } ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // for example, "go bed"
        if (nest_asset && nest_asset.id !== direct_object.id) {
          input.swapPhrases(1, 2);
          input.setPreposition(1, "from");
          input.setPreposition(2, "to");
          input.setAsset(1, nest_asset);
          direct_object = input.getAsset(1);
          direct_preposition = input.getPreposition(1);
          indirect_object = input.getAsset(2);
          indirect_preposition = input.getPreposition(2);
          input.verb_params.found.fromto = true;
          input.setStructure("verb preposition noun preposition noun");
        }
      } // verb noun

      // sentence structure: verb preposition noun ----------

      // ex: get on bed, go up tree
      // verify preposition and noun
      if (input.hasStructure("verb preposition noun")) {
        if (direct_object.direction) {
          // for example, "go down"
          if (-1 !== ["through", "out", "in"].indexOf(direct_preposition)) {
            // we'll accept these prepositions for exits
            this.game.debug(
              `F1230 | ${this.name}.js | ${direct_object.id}.direction is ${direct_object.direction}, tryTravel ${direct_object.direction}`
            );
            this.game.tryTravel(direct_object.direction);
            return null;
          }

          // otherwise, direct_preposition is not understood
          this.game.debug(
            `F1375 | ${this.name}.js | ${direct_preposition} ${direct_object.id} not understood `
          );
          msg += `$(We're) not sure how to <em class='unparsed'>${input.input}</em>. `;
          this.handleFailure(msg);
          return null;
        }

        if (direct_preposition === "to") {
          if (!nest_asset) {
            // try to find an aspect on the direct_object
            if (
              direct_object.aspects[direct_object.default_aspect] &&
              direct_object.aspects[direct_object.default_aspect].player.can
                .enter
            ) {
              direct_preposition = direct_object.default_aspect;
              input.setPreposition(1, direct_preposition);
            } else {
              this.game.debug(
                `F1726 | ${this.name}.js | ${direct_object.id} is present in room`
              );
              msg += `$(We) can't get any closer to  ${direct_object.articlename}. `;
              this.handleFailure(msg);
              return null;
            }
          }

          // is player trying to go to the thing they're already in?
          if (nest_asset && nest_asset.id === direct_object.id) {
            this.game.debug(
              `F1728 | ${
                this.name
              }.js | player is nested ${player.getNestPreposition()} ${
                direct_object.id
              }`
            );
            msg += `$(We're) already ${player.getNestPreposition()} ${
              direct_object.articlename
            }. `;
            this.handleFailure(msg);
            return null;
          }

          // upgrade to "go from a to b"
          if (nest_asset) {
            input.swapPhrases(1, 2);
            input.setPreposition(1, "from");
            input.setAsset(1, nest_asset);
            direct_object = input.getAsset(1);
            direct_preposition = input.getPreposition(1);
            indirect_object = input.getAsset(2);
            indirect_preposition = input.getPreposition(2);
            input.verb_params.found.fromto = true;
            input.setStructure("verb preposition noun preposition noun");
          }
        }

        // player has input "get off [asset]"
        // or we've resolved to off from another preposition

        if ("off" === direct_preposition) {
          if (!nest_asset) {
            this.game.debug(
              `F1045 | ${this.name}.js | player not on ${direct_object.id} `
            );
            msg += `$(We're) not on ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
          if (nest_asset && "on" !== nest_preposition) {
            this.game.debug(
              `F1511 | ${this.name}.js | ${nest_preposition} ${nest_asset.id} `
            );
            msg += `$(We're) ${nest_preposition} ${nest_asset.articlename}, not on it. `;
            this.handleFailure(msg);
            return null;
          }

          if (nest_asset.id === direct_object.id) {
            // player can't get off, which can happen with platforms
            if (direct_object.is.unleavable) {
              this.game.debug(
                `F1002 | ${this.name}.js | ${direct_object.id}.is.unleavable is true`
              );
              msg += `$(We) can't exit ${direct_object.articlename} that way. `;
              this.handleFailure(msg);
              return null;
            }

            if (
              direct_object.is.climbable &&
              0 < direct_object.dimensions.height
            ) {
              this.game.debug(
                `F1126 | ${this.name}.js | ${direct_object.id}.is.climbable, doVerb climb`
              );
              input.input_verb = "climb";
              input.setPreposition(1, "down");
              input.setStructure("verb preposition");
              this.game.dictionary.doVerb("climb");
              return null;
            }
          }
        } // direct_preposition is off

        if ("out" === direct_preposition) {
          // did player input "get out from under" or "get out from behind"
          // but is not actually under or behind?
          if (
            (outfrombehind && "behind" !== nest_preposition) ||
            (outfromunder && "under" !== nest_preposition)
          ) {
            var p = outfromunder ? "under" : "behind";
            this.game.debug(
              `F1000 | ${this.name}.js | player is ${nest_preposition} ${nest_asset.id} not ${p} ${direct_object.id}`
            );
            msg += `$(We're) not ${p} ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
          input.verb_params.found.out = true;
        }

        if ("off" === direct_preposition || "out" === direct_preposition) {
          if (nest_asset.id !== direct_object.id) {
            // player not in/on direct object
            var p = "off" === direct_preposition ? "on" : "in";
            this.game.debug(
              `F1140 | ${this.name}.js | player is ${nest_preposition} ${nest_asset.id} not ${p} ${direct_object.id}`
            );
            msg += `$(We're) not ${p} ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // what if player is sitting in a chair in, eq, a submarine?
          if (direct_object.id === this.game.world._currentRoom) {
            if (direct_object.player.can.exit && nest_asset) {
              this.game.debug(`F1003 | ${this.name}.js | player.isNested`);
              msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} ${nest_preposition} ${
                nest_asset.articlename
              }. `;
              this.handleFailure(msg);
              return null;
            }

            // player is on floor in, eg, a submarine?
            if (
              direct_object.player_can_exit &&
              /*&& !nest_asset*/
              player.isOnFloor()
            ) {
              this.game.debug(`F1004 | ${this.name}.js | player.isOnFloor `);
              msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} on the floor. `;
              this.handleFailure(msg);
              return null;
            }

            // what if player is in, eg, a submarine?
            // redirect to exit verb
            if (direct_object.player_can_exit) {
              this.game.debug(
                `F1127 | ${this.name}.js | ${direct_object.id}.player_can_exit, doVerb exit`
              );
              this.game.dictionary.doVerb("exit");
              return null;
            }
          }
        } // direct_preposition is off or out

        // player is sitting/lying on something else
        // @todo need to consider reachability
        // as is this prevents all movement between nests
        if (nest_asset && nest_asset.id !== direct_object.id) {
          // upgrade to "go from a to b"
          input.swapPhrases(1, 2);
          input.setAsset(1, nest_asset);
          input.setPreposition(1, "from");
          input.setPreposition(2, "to");
          direct_object = input.getAsset(1);
          direct_preposition = input.getPreposition(1);
          indirect_object = input.getAsset(2);
          indirect_preposition = input.getPreposition(2);
          input.verb_params.found.fromto = true;
          input.setStructure("verb preposition noun preposition noun");

          // this.game.debug(`F1005 | ${this.name}.js | player.isNested ${nest_preposition} ${nest_asset.id} <br/> @todo add reachability check`);
          // msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} ${nest_preposition} ${
          //   nest_asset.articlename
          // }. `;
          // this.handleFailure(msg);
          // return null;
        }
      }

      // ask this again because we may have changed structure
      if (input.hasStructure("verb preposition noun")) {
        // not off or out
        if (
          "down" === direct_preposition &&
          direct_object.is.climbable &&
          0 < direct_object.dimensions.height
        ) {
          this.game.debug(
            `F1208 | ${this.name}.js | ${direct_object.id}.is.climbable, doVerb climb`
          );
          this.game.dictionary.doVerb("climb");
          return null;
        }

        if (
          ("on" === direct_preposition || "up" === direct_preposition) &&
          direct_object.is.climbable &&
          0 < direct_object.dimensions.height
        ) {
          this.game.debug(
            `F1128 | ${this.name}.js | ${direct_object.id}.is.climbable, doVerb climb`
          );
          if ("on" === direct_preposition) input.setPreposition(1, "up");
          this.game.dictionary.doVerb("climb");
          return null;
        } else if ("up" === direct_preposition) {
          input.setPreposition(1, "on");
          direct_preposition = "on";
        }

        // player is on floor
        if (!player.isNested() && player.isOnFloor()) {
          this.game.debug(`F1006 | ${this.name}.js | player.isOnFloor `);
          msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} on the floor. `;
          this.handleFailure(msg);
          return null;
        }

        // player is already nested within target
        if (
          (direct_object.id === nest_asset.id &&
            direct_preposition === nest_preposition) ||
          (!nest_asset && direct_object instanceof adventurejs.Floor)
        ) {
          this.game.debug(
            `F1007 | ${this.name}.js | player.isNested ${nest_preposition} ${nest_asset.id}`
          );
          msg += `$(We're) already ${
            nest_preposition ? nest_preposition : direct_object.default_aspect
          } ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if ("from" === direct_preposition) {
          direct_preposition = "off";
          input.setPreposition(1, "off");
        }

        if (["off", "out"].indexOf(direct_preposition) === -1) {
          // player is nested some other way with target
          // and needs to unnest first
          if (
            direct_object.id === nest_asset.id &&
            direct_preposition !== nest_preposition
          ) {
            this.game.debug(
              `F1008 | ${this.name}.js | player.isNested ${nest_preposition} ${nest_asset.id} not ${direct_preposition}`
            );
            msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} ${nest_preposition} ${
              nest_asset.articlename
            }. `;
            this.handleFailure(msg);
            return null;
          }

          // player can't nest in/on object at all
          if (direct_preposition) {
            if (
              "in" === direct_preposition &&
              direct_object.quirks.in_means_on
            ) {
              direct_preposition = "on";
              input.setPreposition(1, "on");
            }

            if (
              !direct_object.hasAspectAt(direct_preposition) ||
              !direct_object.aspects[direct_preposition].player.can.enter
            ) {
              this.game.debug(
                `F1009 | ${this.name}.js | ${direct_object.id}.aspects.${direct_preposition} is undefined or .player.can.enter is false`
              );
              msg += `$(We) can't go ${direct_preposition} ${direct_object.articlename}. `;
              this.handleFailure(msg);
              return null;
            }
          }
        } // off or out, else
      } // verb preposition noun

      // sentence structure: verb noun preposition noun ----------
      // ex: go east on bridge, go east on bike
      // go up with piton, go up with jetpack

      if (input.hasStructure("verb noun preposition noun")) {
        // accepts "go east on ob", "go east in ob", "go east with ob"
        if (["with", "in", "on"].indexOf(indirect_preposition) === -1) {
          this.game.debug(`F1867 | ${this.name}.js | irregular phrase `);
          msg += this.game.parser.getUnparsedMessage(input.input);
          this.handleFailure(msg);
          return null;
        }

        if (direct_object.direction && indirect_object.is.rideable) {
          // player input something like "go east on bike"
          // is player on the bike?
          // @TODO what about something like "go east on bridge"
          // where bridge is a thing you can travel on?
          if (!nest_asset || nest_asset.id !== indirect_object.id) {
            this.game.debug(
              `F1042 | ${this.name}.js | player is not on ${indirect_object.name} `
            );
            msg += `$(We're) not on ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
          // else ok
        }
        // are there any other valid uses for verb noun preposition noun?
        // ex: go east under bridge?
        else {
          this.game.debug(`F1871 | ${this.name}.js | irregular phrase `);
          msg += this.game.parser.getUnparsedMessage(input.input);
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      // sentence structure: verb preposition noun preposition noun ----------
      // ex: go from bed to bath
      // go up cliff with piton

      if (input.hasStructure("verb preposition noun preposition noun")) {
        // 'go from a to b' and 'go up a with b' are the only
        // phrases we accept in this form

        // with ----------

        if ("with" === indirect_preposition) {
          input.verb_params.with = true;

          results = this.checkWith(
            direct_preposition,
            direct_object,
            indirect_object
          );
          if (results.failure) {
            this.handleFailure(results.msg);
            return null;
          }
          if (results.return) return true;
          input.verb_params.found.with = true;

          // is player nested?
          if (nest_asset && nest_asset.id !== direct_object.id) {
            input.swapPhrases(2, 3);
            input.swapPhrases(1, 2);
            input.setAsset(1, nest_asset);
            input.setPreposition(1, "from");
            direct_preposition = "from";
            direct_object = input.getAsset(1);
            indirect_preposition = input.getPreposition(2);
            indirect_object = input.getAsset(2);
            indirect_preposition2 = input.getPreposition(3);
            indirect_object2 = input.getAsset(3);
            input.setStructure(
              "verb preposition noun preposition noun preposition noun"
            );
            input.verb_params.found.fromto = true;
          }
        } // with

        // to from ----------

        if (direct_preposition === "to" && indirect_preposition === "from") {
          // reverse them
          var phrase2 = Object.assign({}, input.getPhrase(2));
          var phrase1 = Object.assign({}, input.getPhrase(1));

          input.setPhrase(1, phrase2);
          input.setPhrase(2, phrase1);

          direct_object = input.getAsset(1);
          direct_preposition = input.getPreposition(1);

          indirect_object = input.getAsset(2);
          indirect_preposition = input.getPreposition(2);
        }

        // from to ----------

        if (!input.verb_params.found.fromto)
          input.verb_params.found.fromto =
            direct_preposition === "from" && indirect_preposition === "to";

        if (input.verb_params.found.fromto) {
          results = this.canPlayerGoFromThisToThat(
            direct_object,
            indirect_object
          );
          if (results.failure) {
            this.handleFailure(results.msg);
            return null;
          }
          if (results.return) return true;
          input.verb_params.found.fromto = true;
        }
      } // verb preposition noun preposition noun

      // sentence structure: verb preposition noun preposition noun preposition noun
      // ex: go from ramp to ledge with grapple (this is a stretch)

      if (
        input.hasStructure(
          "verb preposition noun preposition noun preposition noun"
        )
      ) {
        if (indirect_preposition2 === "with" && !input.verb_params.found.with) {
          results = this.checkWith(
            indirect_preposition,
            indirect_object,
            indirect_object2
          );
          if (results.failure) {
            this.handleFailure(results.msg);
            return null;
          }
          if (results.return) return true;
          input.verb_params.found.with = true;
        }

        if (
          direct_preposition === "from" &&
          indirect_preposition === "to" &&
          !input.verb_params.found.fromto
        ) {
          if (nest_asset && nest_asset.id !== direct_object.id) {
            this.game.debug(
              `F1874 | ${this.name}.js | player is ${nest_preposition} ${nest_asset.id} not on ${direct_object.id}`
            );
            msg += `$(We're) not on ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        }
      }

      // save our findings for doSuccess so we don't have to repeat this logic

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var input_verb = input.input_verb;
      var player = this.game.getPlayer();
      var nest_asset = player.getNestAsset();
      var posture, preposition;
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var indirect_object2 = input.getAsset(3);
      var indirect_preposition2 = input.getPreposition(3);
      var msg = "";
      var results;
      var newY = 0;
      var newPoint = { y: 0 };

      this.game.debug(
        `F1189 | ${
          this.name
        }.js | doSuccess sentence structure ${input.getStructure()}`
      );

      // ---------- sentence structure: verb

      if (input.hasStructure("verb")) {
        this.game.debug(
          `F1875 | ${this.name}.js | ${input.input_verb} given with no object or preposition`
        );
        msg += `$(We) ${input.input_verb} about for a bit. `;
      }

      // ---------- sentence structure: verb preposition noun

      if (input.hasStructure("verb preposition noun")) {
        // If direct_object is an exit/aperture, we already shunted to "enter".

        // out ----------
        if ("out" === direct_preposition) {
          this.game.debug(`F1339 | ${this.name}.js | preposition is out`);

          msg += `$(We) ${
            input.input_verb
          } ${player.getPrettyUnnestPreposition()} ${nest_asset.articlename}. `;

          results = player.onUnnestThisFromThat(nest_asset);
          if ("undefined" !== typeof results) return results;

          player.posture = "stand";
        } // out

        // off or down ----------
        else if (
          "off" === direct_preposition ||
          "down" === direct_object.direction
        ) {
          this.game.debug(
            `F1122 | ${this.name}.js | preposition is off or direction is down`
          );

          msg += `$(We) ${
            input.getVerb() === "release" ? "let go" : "climb off"
          } of ${nest_asset.articlename} and ${
            player.position.y > 1 ? "fall" : "drop"
          } to the ground. `;

          results = player.onUnnestThisFromThat(nest_asset);
          if ("undefined" !== typeof results) return results;

          if (direct_object.getY() < 0) player.setY(direct_object.getY());
          else player.setY(0);

          player.posture = "stand";
        } // off or down

        // up ----------
        // @TODO does this ever fire?
        else if (direct_object && "up" === direct_object.direction) {
          // do we need to climb?

          this.game.debug(`F1135 | ${this.name}.js | preposition is up`);
          msg += `$(We) climb ${player.getPrettyUnnestPreposition()} ${
            direct_object.articlename
          }. `;

          results = player.onUnnestThisFromThat(nest_asset);
          if ("undefined" !== typeof results) return results;

          player.posture = "stand";
        } // up

        // not off or out or up or down ----------
        else {
          /**
           * The phrase "get in" is vague about both the preposition,
           * which could mean "in" or "on", and the posture,
           * which could mean "sit" or "lie" or "stand".
           * So we check player.preposition
           * and player.posture for context.
           */

          posture = direct_object.aspects[direct_preposition].player.posture;
          preposition =
            direct_object.aspects[direct_preposition].player.preposition;

          this.game.debug(
            `F1139 | ${this.name}.js | preposition is not off or out or up or down`
          );
          msg += `$(We) ${posture} ${preposition} ${direct_object.articlename}. `;

          results = player.onNestThisToThat(direct_object, preposition);
          if ("undefined" !== typeof results) return results;

          player.setY(direct_object.getYTop());
          player.posture = posture;
        } // not off or out or up or down
      } // verb noun

      // sentence structure: verb noun preposition noun ----------
      // ex: go east on bike, go east on ledge
      // go up with piton, go up with jetpack

      if (input.hasStructure("verb noun preposition noun")) {
        // assume that any sentence in this structure is in form of
        // "go east on bike" where noun is a direction

        results = this.game.tryTravel(direct_object.direction, {
          with: [indirect_object.id],
        });
        if (A.isFalseOrNull(results)) return results;
        // no msg because tryTravel handled it
      } // verb noun preposition noun

      // ---------- sentence structure: verb preposition noun preposition noun

      if (
        input.hasStructure("verb preposition noun preposition noun") ||
        input.hasStructure(
          "verb preposition noun preposition noun preposition noun"
        )
      ) {
        // from/to ----------

        if (input.verb_params.found.fromto) {
          this.game.debug(`F1866 | ${this.name}.js | go from to `);

          posture = indirect_object.aspects.on.player.posture;

          msg += `$(We) ${
            input.verb_params.with
              ? "use " +
                (indirect_object2
                  ? indirect_object2.articlename
                  : indirect_object.articlename) +
                " to"
              : ""
          } climb from ${direct_object.articlename} to ${
            indirect_object.articlename
          } and ${posture} ${indirect_object.default_aspect} it. `;

          // if player is nested, unnest
          if (nest_asset.id === direct_object.id) {
            results = player.onUnnestThisFromThat(direct_object);
            if ("undefined" !== typeof results) return results;
          }

          // if it isn't already nested, nest it
          if (nest_asset.id !== indirect_object.id) {
            results = player.onNestThisToThat(
              indirect_object,
              indirect_object.default_aspect
            );
            if ("undefined" !== typeof results) return results;
            player.posture = posture;
          }

          // let range = indirect_object.getYRange();
          // if (newY < range.min) newY = range.min;
          // else if (newY > range.max) newY = range.max;
          // player.setY(newY);
        } // fromto
      } // verb preposition noun preposition noun

      this.handleSuccess(msg, direct_object);
      return true;
    },

    checkWith: function (direct_preposition, direct_object, indirect_object) {
      // if we're here, indirect_preposition is "with"
      let response = { failure: false, return: null, msg: "" };

      // works with any indirect object?
      if (direct_object.DOVallowWithAnything(this.name)) {
        return { return: true };
      }

      // indirect object not required?
      if (direct_object.DOVallowWithNothing(this.name)) {
        this.game.debug(
          `F1868 | ${this.name}.js | ${direct_object.id} can't be ${this.state} with ${indirect_object.id} `
        );
        response.msg += `${indirect_object.Articlename} won't help $(us) ${this.name} ${direct_preposition} ${direct_object.articlename}. `;
        response.failure = true;
        return response;
      }

      // indirect object usable with direct object?
      if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
        this.game.debug(
          `F1869 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets does not include ${indirect_object.id} `
        );
        response.msg += `${indirect_object.Articlename} can't be used to ${
          this.game.getInput().input_verb
        } ${direct_preposition} ${direct_object.articlename}. `;
        response.failure = true;
        return response;
      }

      // single use indirect object?
      if (
        indirect_object.IOVallowOnce(this.name) &&
        indirect_object.IOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1870 | ${this.name}.js | ${indirect_object.id}.iov.${
            this.name
          }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
            indirect_object.iov[this.name].do_count
          } `
        );
        response.msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
        response.failure = true;
        return response;
      }

      return response;
    },

    canPlayerGoFromThisToThat: function (direct_object, indirect_object) {
      // if we're here, direct_preposition is "from" and indirect_preposition is "to"
      let response = { failure: false, return: null, msg: "" };
      let input = this.game.getInput();
      let player = this.game.getPlayer();
      let nest_asset = player.getNestAsset();
      let nest_preposition = player.getNestPreposition();

      if (!nest_asset || nest_asset.id !== direct_object.id) {
        // from noun must be the nest
        this.game.debug(
          `F1183 | ${this.name}.js | ${nest_asset.id} !== ${direct_object.id}`
        );
        response.msg += `$(We're) not ${
          direct_object.default_aspect &&
          direct_object.aspects[direct_object.default_aspect].player.can.enter
            ? direct_object.default_aspect
            : "on"
        } ${direct_object.articlename}. `;
        response.failure = true;
        return response;
      } // input.verb_params.found.fromto

      let reachable = true; // default = reachable

      if (this.game.settings.xz_determines_reachability) {
        // is distance between assets greater than jump_length?
        let distance = A.getHorizontalDistance(
          direct_object.position,
          indirect_object.position
        );
        reachable = distance <= this.game.settings.jump_length;
        // @TODO doSuccess handling for this
      }
      if (!reachable) {
        this.game.debug(
          `F1864 | ${this.name}.js | player is nested ${nest_preposition} ${nest_asset.id}, infer "go from to" `
        );
        response.msg += `$(We) can't ${input.input_verb} ${
          indirect_object.default_aspect
        } ${
          indirect_object.articlename
        } while ${player.getPostureGerund()} ${nest_preposition} ${
          direct_object.articlename
        }. `;

        response.failure = true;
        return response;
      }

      return response;
    },
  };
})(); // go

// goTo.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class goTo
   * @ajsnode game.dictionary.verbs.goTo
   * @ajsconstruct MyGame.createVerb({ "name": "goTo", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning go to location, or location of asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; go to grand ballroom</span>
   * You go up to the mezzanine. You go south to the Grand Ballroom.
   *
   * <strong>Grand Ballroom</strong>
   * Balls everywhere. Literally. More of a ball pit, really.
   * </pre>
   * <p>
   * <strong>goTo</strong> is not called directly by the parser.
   * When a player enters <string>"go to"</string>, the verb
   * <code>go</code> is called, and forwards to <code>goTo</code>
   * if it's contextually suitable.
   * <code>goTo</code> is a special verb that will attempt
   * to map a path from the player's location to the specified
   * {@link adventurejs.Room|Room},
   * or the Room containing a specified
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * The target asset must be known by player.
   * </p>
   * <p>
   * <code>goTo</code> will not open or unlock doors that the
   * player has not already opened or unlocked. It will open
   * doors the player has already opened, and it will unlock
   * doors the player has already unlocked providing the player
   * is carrying a key.
   * </p>
   * @ajsverbphases
   */
  A.Preverbs.goTo = {
    name: "goTo",
    prettyname: "go to",
    //synonyms: ["goto"],
    //verb_prep_noun: ["go to"],

    player_must_be: {
      not_constrained: true,
      not_nested_elsewhere: true,
    },

    /**
     * @ajsverbstructures
     * @memberof goTo
     */
    accepts_structures: ["verb noun"],

    /**
     * @memberof goTo
     * @ajsverbphrase
     * phrase1:
     * {
     *   not_global: true,
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
      },
    },

    /**
     * @memberof goTo
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    msgNoObject: "Where did you want to go?",

    doTry: function () {
      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var destination = input.getNoun(1);
      var current_room = this.game.world._currentRoom;
      var player = this.game.getPlayer();
      var msg = "";

      if (!(direct_object instanceof adventurejs.Room)) {
        destination = direct_object.getRoomId();
      }

      if (destination === current_room) {
        this.game.debug(
          `F1296 | ${this.name}.js | destination is current room `
        );
        msg += `Look around. `;
        this.game.print(msg);
        return false;
      }

      /**
       * We use layout to build a list of rooms and their connections.
       */
      var layout = {};
      for (var i = 0; i < this.game.room_lookup.length; i++) {
        var room = this.game.getAsset(this.game.room_lookup[i]);
        if (!room) {
          continue;
        }
        if (!room.player_has_visited) {
          // exclude rooms that player hasn't visited yet
          this.game.log(
            "log",
            "high",
            "${this.name}.js > " + room.id + ".player_has_visited is false",
            "verbs"
          );
          continue;
        }
        var nodes = [];
        var exits = room.exits;
        var keys = Object.keys(exits);
        for (var k = 0; k < keys.length; k++) {
          var exit = exits[keys[k]];
          exit = this.game.getAsset(exit);
          if (!exit) {
            continue;
          }
          var destination_room = this.game.getAsset(exit.destinationID);
          if (!destination_room) {
            continue;
          }
          var aperture = exit.aperture;

          // exclude exits that player hasn't used
          if (!exit.is.used) {
            this.game.log(
              "log",
              "high",
              `${this.name}.js > excluded ${exit.id}.is.used is false`,
              "verbs"
            );
            continue;
          }

          // exclude exits that have no destination
          if (!exit.destinationID) {
            continue;
          }

          // exclude destinations that player hasn't visited
          if (!destination_room.player_has_visited) {
            this.game.log(
              "log",
              "high",
              `${this.name}.js > ${destination_room.id}.player_has_visited is false`,
              "verbs"
            );
            continue;
          }

          // test exits for locked doors
          if (aperture) {
            var key_assets;
            aperture = this.game.getAsset(aperture);

            //
            // LOCKED
            //
            if (aperture.isDOV("unlock") && aperture.is.locked) {
              key_assets = player.getIOVkeys("unlock", aperture);

              // if door is locked and player hasn't got key, pass
              if (
                !aperture.DOVallowWithNothing("unlock") &&
                !key_assets.length
              ) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${aperture.id}.is.locked and player has no key`,
                  "verbs"
                );
                continue;
              }

              // if door is locked and it wasn't locked by player, pass
              // 6/30/22 CHANGE: if aperture is locked and player didn't lock it
              if (
                !aperture.didDoVerbs({
                  related_verbs: ["lock", "unlock", "pick"],
                })
              ) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${aperture.id}.is.locked and has never been unlocked by player`,
                  "verbs"
                );
                continue;
              }

              // if door was locked by player,
              // check this aperture's can.auto_unlock
              if (!aperture.can.auto_unlock) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${aperture.id}.can.auto_unlock is false`,
                  "verbs"
                );
                continue;
              }

              // if door was locked by player,
              // check settings.can_auto_unlock_apertures
              if (
                true !== aperture.can.auto_unlock &&
                !this.game.settings.can_auto_unlock_apertures
              ) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${this.game.name}.settings.can_auto_unlock_apertures is false`,
                  "verbs"
                );
                continue;
              }
            }

            //
            // SEALED
            //
            if (aperture.isDOV("unseal") && aperture.is.sealed) {
              key_assets = player.getIOVkeys("unseal", aperture);

              // has player got a key?
              if (
                !aperture.DOVallowWithNothing("unseal") &&
                !key_assets.length
              ) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${aperture.id}.is.sealed and player has no key`,
                  "verbs"
                );
                continue;
              }

              // never auto-unseal apertures the player hasn't already unsealed
              // 6/30/22 CHANGE: if aperture is sealed and player didn't seal it
              if (!aperture.didDoVerbs({ related_verbs: ["seal", "unseal"] })) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${aperture.id}.is.sealed and has never been unsealed by player`,
                  "verbs"
                );
                continue;
              }

              // check aperture settings for auto unlock
              if (!aperture.can.auto_unseal) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${aperture.id}.can.auto_unseal is false`,
                  "verbs"
                );
                continue;
              }

              // check game settings for auto unseal
              if (
                !aperture.can.auto_unseal &&
                !this.game.settings.can_auto_unseal_apertures
              ) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${this.game.name}.settings.can_auto_unseal_apertures is false`,
                  "verbs"
                );
                continue;
              }
            }

            //
            // CLOSED
            //
            if (aperture.isDOV("open") && aperture.is.closed) {
              key_assets = player.getIOVkeys("open", aperture);

              // has player got a key?
              if (!aperture.DOVallowWithNothing("open") && !key_assets.length) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${aperture.id}.is.closed and player has no key`,
                  "verbs"
                );
                continue;
              }

              // if door is closed and it wasn't closed by player, pass
              // 6/30/22 CHANGE: if aperture is closed and player didn't close it
              if (!aperture.didDoVerbs({ related_verbs: ["open", "close"] })) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${aperture.id}.is.closed and was not closed by player`,
                  "verbs"
                );
                continue;
              }

              // check aperture settings for auto open
              if (!aperture.can.auto_open) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${aperture.id}.can.auto_open is false`,
                  "verbs"
                );
                continue;
              }

              // check game settings for auto open
              if (
                !aperture.can.auto_open &&
                !this.game.settings.can_auto_open_apertures
              ) {
                this.game.log(
                  "log",
                  "high",
                  `${this.name}.js > ${this.game.name}.settings.can.auto_open_apertures is false`,
                  "verbs"
                );
                continue;
              }
            }

            if (aperture.is.hidden) {
              this.game.log(
                "log",
                "high",
                `${this.name}.js > ${aperture.id}.is.hidden`,
                "verbs"
              );
              continue;
            }
          } // if aperture

          // good to go!
          nodes.push(exit.destinationID);
        }
        layout[room.id] = nodes;
      }
      this.game.log("log", "low", ["layout:", layout], "verbs");

      /**
       * We use graph to convert uni-directional to bi-directional.
       * needs to look like: where: { a: { b: cost of a->b }
       */
      var graph = {};
      for (var id in layout) {
        if (!graph[id]) {
          graph[id] = {};
        }
        layout[id].forEach(function (aid) {
          graph[id][aid] = 1;
          if (!graph[aid]) {
            graph[aid] = {};
          }
          graph[aid][id] = 1;
        });
      }

      this.game.log("log", "low", ["graph:", graph], "verbs");

      //choose start node
      var start = this.game.world._currentRoom;

      //get all solutions
      var solutions = A.dijkstra(graph, start);

      this.game.log(
        "log",
        "low",
        ["solutions[destination]:", solutions[destination]],
        "verbs"
      );

      if (
        "undefined" === typeof solutions[destination] ||
        0 === solutions[destination].length
      ) {
        this.game.debug(
          `F1297 | ${this.name}.js | No path was found. Blockers may include locked/sealed/closed doors which player has not opened or does not have a key for, or destination unknown to / unvisited by player. `
        );
        msg += "$(We) don't know of a route between here and there";
        if (!destination || !destination.is || !destination.is.known) {
          msg += ", or even if there is a there there";
        }
        msg += ".";
        this.handleFailure(msg);
        return false;
      } else {
        var len = solutions[destination].length;
        for (var i = 0; i < len; i++) {
          var thisRoom, nextRoom;

          if (0 === i) {
            thisRoom = start;
          } else {
            thisRoom = solutions[destination][i - 1];
          }
          nextRoom = solutions[destination][i];

          thisRoom = this.game.world[thisRoom];
          nextRoom = this.game.world[nextRoom];

          // cycle through the room's exits
          for (var direction in thisRoom.exits) {
            var exit = this.game.world[thisRoom.id + "_" + direction];
            var dest = exit.destinationID;

            // no destination? probably just a description
            if ("undefined" === typeof dest) {
              continue;
            }

            //
            if (nextRoom.id === dest) {
              this.game.log(
                "log",
                "low",
                ["nextRoom.id", nextRoom.id, "dest", dest],
                "verbs"
              );
              var output = "";

              var aperture = exit.aperture;
              if (aperture) aperture = this.game.getAsset(aperture);

              if (aperture && (aperture.is.locked || aperture.is.closed)) {
                // THIS METHOD MAY SIDESTEP AUTHOR SIDE EFFECTS
                //   output = "You ";
                //   if( aperture.is.locked ) {
                //     output += "unlock and open ";
                //     aperture.setLocked(false);//is.locked = false;
                //     aperture.setClosed(false);//is.closed = false;
                //   }
                //   else if( aperture.is.closed ) {
                //     output = "open ";
                //     aperture.setClosed(false);//is.closed = false;
                //   }
                //   output += " "
                //     + aperture.articlename
                //     + ". ";
                //this.game.print( output, "concatenate_output" );

                // THIS METHOD INVOKES OPEN VERB
                this.game.parser.input_queue.push({
                  input: "open " + aperture.id,
                  printInput: false,
                  excludeRoomDescriptions: true,
                  output_class: "concatenate_output",
                  linefeed: linefeed,
                });
              }

              /**
               * printing this output results in double output with tryTravel ie
               * You go west to the Eastern Room. $(We) move west.
               * You go west to the East Room. $(We) move west.
               * You go west to the Standing Room. $(We) move west.
               */
              output =
                "$(We) go " +
                direction +
                " to " +
                (nextRoom.use_definite_article_in_lists
                  ? nextRoom.definite_article + " "
                  : "") +
                nextRoom.name +
                ". ";

              // print a linefeed after the last item only
              var linefeed = i === len - 1 ? true : undefined;

              this.game.parser.input_queue.push({
                // print output: output,
                /* output was doubling "you move etc" messages
                  because tryTravel prints them too
                  leaving this here for now as an option 
                  for future dev */

                input: direction,
                printInput: false,
                excludeRoomDescriptions: true,
                output_class: "concatenate_output",
                linefeed: linefeed,
              });
              continue;
            }
          }
        }
      }

      //display solutions
      // console.log("From '"+start+"' to");
      // for(var s in solutions) {
      //   if(!solutions[s]) continue;
      //   if( s !== destination ) continue;
      //   console.log(" -> " + s + ": [" + solutions[s].join(", ") + "]   (dist:" + solutions[s].dist + ")");
      // }

      return true;
    },
  };
})(); // goTo

// hang.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class hang
   * @ajsnode game.dictionary.verbs.hang
   * @ajsconstruct MyGame.createVerb({ "name": "hang", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading PositionVerbs
   * @summary Verb meaning hang, as in "hang hat on hook" or "hang from branch".
   * @todo make bridge and ledge examples
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; hang from catwalk</span>
   * You crawl over the railing and hang from the catwalk,
   * dangling over the vat of bubbling green chemicals below.
   * Oh no! You're slipping... SPLASH.
   *
   * AHH, IT BURNS! AHH... AHHHH...
   *
   * AHH HAH HAH HAAH HAAH HAAAAH!
   * </pre>
   * <p>
   * <strong>Hang on</strong>, or also (and more likely)
   * <strong>hang from</strong>,
   * understands the player to mean that they want to hang from a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} such as a
   * {@link adventurejs.Stalactite|Stalactite} or a branch or ledge.
   * The results are similar to {@link climb_to}.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.hang = {
    name: "hang",
    prettyname: "hang",
    past_tense: "hung",
    synonyms: [],

    /**
     * @ajsverbstructures
     * @memberof hang
     */
    accepts_structures: [
      "verb", // player can hang from nest
      "verb preposition", // hang on, hang out - both meaning wait?
      "verb preposition noun", // hang from branch, hang on tree, hang up painting
      "verb noun preposition noun", // hang painting on wall
    ],

    player_must_be: {
      not_constrained: true,
    },

    /**
     * @memberof hang
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   accepts_preposition_without_noun: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      //requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
    },

    /**
     * @memberof hang
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof hang
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_asset = player.getNestAsset();
      var msg = "";
      var results;

      if ("from" === direct_preposition) {
        input.setPreposition(1, "on");
        direct_preposition = "on";
      }

      if ("from" === indirect_preposition) {
        input.setPreposition(2, "on");
        indirect_preposition = "on";
      }

      // sentence structure: verb
      // ex: hang
      if (input.hasStructure("verb")) {
        // can player hang here?
        let parent = player.getNestOrPlaceAsset();
        direct_object = parent;
        direct_preposition = player.getNestOrPlacePreposition();
        input.setAsset(1, direct_object);
        input.setPreposition(1, direct_preposition);
        input.setStructure("verb preposition noun");
      }

      // sentence structure: verb preposition
      // ex: hang out, hang on - both mean wait
      if (input.hasStructure("verb preposition")) {
        if (["out", "on"].indexOf(direct_preposition) > -1) {
          return true;
        }
        if ("up" === direct_preposition) {
          let phones = player.findClassInThis("Phone");
          if (!phones.length) {
            this.game.debug(
              `F1303 | ${this.name}.js | ${player.id} has no phone `
            );
            msg += `$(We) slam down $(our) imaginary phone. `;
            this.handleFailure(msg);
            return null;
          }
          if (phones.length) {
            for (let i = 0; i < phones.length; i++) {
              let phone = this.game.getAsset(phones[i]);
              if (phone && phone.is.connected) {
                direct_object = phone;
                input.setAsset(1, direct_object);
                input.setStructure("verb preposition noun");
              }
            }
            if (!direct_object) {
              this.game.debug(
                `F1262 | ${this.name}.js | ${player.id} has phone but no connection `
              );
              msg += `$(We) don't appear to be on a call. `;
              this.handleFailure(msg);
              return null;
            }
          }
        } else {
          this.game.debug(
            `F1245 | ${this.name}.js | ${this.name} ${direct_preposition} is unsupported `
          );
          msg += `$(We) don't know how to ${input.input_verb} ${direct_preposition}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      // sentence structure: verb preposition noun
      // ex: hang from rope, hang up phone
      if (input.hasStructure("verb preposition noun")) {
        // can't hang on
        if (!direct_object.isDOV("hang")) {
          this.game.debug(
            `F1305 | ${this.name}.js | ${direct_object.id}.dov.hang is unset `
          );
          msg += `$(We) see no way to hang ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (
          "up" === direct_preposition &&
          direct_object instanceof adventurejs.Phone
        ) {
          this.game.debug(
            `F1246 | ${this.name}.js | ${direct_object.id} is ${
              direct_object.is.connected ? "" : "un"
            }connected phone `
          );
          if (!direct_object.is.connected) {
            msg += `${direct_object.Articlename} doesn't appear to be connected. `;
            this.handleFailure(msg);
            return null;
          }
          return true;
        }

        // is player already on it?
        if (
          nest_asset &&
          direct_object.id === nest_asset.id &&
          direct_preposition === nest_preposition
        ) {
          // @TODO posture check for hanging
          this.game.debug(
            `F1338 | ${this.name}.js | player is ${direct_preposition} ${direct_object.id} `
          );
          msg += `$(We're) already ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (direct_object.is.climbable) {
          `F1285 | ${this.name}.js | ${direct_object.id}.is.climbable, doVerb climb `;
          this.game.dictionary.doVerb("climb");
          return null;
        }

        // if you can hang on it, you should be able to climb it,
        // and so we're done, but just in case

        // figure out y overlap
        var range = direct_object.getYRange();

        // is player close enough on y?
        if (player.position.y > range.max || player.position.y < range.min) {
          this.game.debug(
            `F1306 | ${this.name}.js | ${player.id}.position.y out of range of ${direct_object.id} `
          );
          msg += `${direct_object.Articlename} is too far ${
            player.position.y > range.max ? "below" : "above"
          } your position on ${
            player.isNested() ? nest_asset.articlename : "the floor"
          }. `;
          this.handleFailure(msg);
          return null;
        }
      }

      // sentence structure: verb noun preposition noun
      // ex: hang portrait on wall
      if (input.hasStructure("verb noun preposition noun")) {
        if (!indirect_object.isIOV("hang")) {
          this.game.debug(
            `F1298 | ${this.name}.js | ${indirect_object.id}.iov.hang is unset `
          );
          msg += `$(We) can't hang anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (!indirect_object.hasAspectAt(indirect_preposition)) {
          this.game.debug(
            `F1299 | ${this.name}.js | ${indirect_object.id}.aspects.${indirect_preposition} is unset `
          );
          msg += `$(We) can't hang anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        results = this.tryToPutThisInThatAspect(
          direct_object,
          indirect_preposition,
          indirect_object
        );
        if (results.fail) {
          msg = results.msg;
          this.handleFailure(msg);
          if (results.end_turn) return false;
          return null;
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var nest_parent_id = player.getNestId();
      var nest_asset = player.getNestAsset();
      var msg = "";
      var results;

      this.game.debug(`F1304 | ${this.name}.js | print doSuccess `);

      // sentence structure: verb
      // ex: hang
      if (input.hasStructure("verb")) {
      }

      // sentence structure: verb preposition
      // ex: hang out, hang on - both mean wait
      if (input.hasStructure("verb preposition")) {
        if ("out" === direct_preposition) {
          msg += `$(We) chillax for a moment. `;
        }
        if ("on" === direct_preposition) {
          msg += `$(We) cling desperately to life. `;
        }
        if ("up" === direct_preposition) {
          msg += `$(We) do have $(ours). `;
        }
        msg += ``;
      }

      // sentence structure: verb preposition noun
      // ex: hang from rope, hang up phone
      if (input.hasStructure("verb preposition noun")) {
        // hang up phone
        if (
          "up" === direct_preposition &&
          direct_object instanceof adventurejs.Phone
        ) {
          // compose output
          msg += `$(We) hang up ${direct_object.articlename}. `;

          // apply state changes
          direct_object.is.connected = false;
        } else {
          // compose output
          msg += `$(We) hang ${direct_preposition} ${direct_object.articlename}. `;

          // if player is nested, unnest
          if (nest_asset && nest_asset.id !== direct_object.id) {
            results = player.onUnnestThisFromThat(nest_asset);
            if ("undefined" !== typeof results) return results;
          }
          results = player.onNestThisToThat(direct_object, direct_preposition);
          if ("undefined" !== typeof results) return results;

          // apply state changes
          player.posture = "hang";
        }
      }

      // sentence structure: verb noun preposition noun
      // ex: hang portrait on wall
      if (input.hasStructure("verb noun preposition noun")) {
        // remove noun1 from player
        results = player.onRemoveThatFromThis(direct_object);
        if ("undefined" !== typeof results) return results;

        results = indirect_object.onMoveThatToThis(direct_object, "on");
        if ("undefined" !== typeof results) return results;

        // compose output
        msg += `$(We) hang ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;

        // apply state changes
        direct_object.posture_position = this.game.dictionary.getStringLookup(
          "posture_positions",
          "hanging"
        );
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // hang

// hit.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class hit
   * @ajsnode game.dictionary.verbs.hit
   * @ajsconstruct MyGame.createVerb({ "name": "hit", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning hit asset.
   * @ajssynonyms hit, attack
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; hit dragon</span>
   * You hit the dragon. It's a curious way to commit suicide.
   * The dragon lunges to bite you while at the same time whipping
   * its tail in your direction, and clumsily manages to latch onto
   * its own tail instead of you. The dragon screams in pain!
   * </pre>
   * <p>
   * <strong>Hit</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset to be hit has
   * asset.dov.hit.enabled
   * set to true.  No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * </div>
   */
  A.Preverbs.hit = {
    name: "hit",
    prettyname: "hit",
    past_tense: "hit",
    synonyms: ["hit", "attack"],

    /**
     * @ajsverbstructures
     * @memberof hit
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof hit
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof hit
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     *   // @todo what about "hit person on nose"?
     *   // also possessive: "hit person's nose"
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof hit
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1307 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state? skip

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1957 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      if (input.hasStructure("verb noun")) {
        // can verb act without an indirect object?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1697 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1701 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        // if( direct_object.DOVallowWithNothing(this.name) )
        // {
        //   this.game.debug(` | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `);
        //   msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        //   this.handleFailure(msg);
        //   return null;
        // }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1309 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1958 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1959 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1308 | ${this.name}.js | print doSuccess `);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // hit

// hold.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class hold
   * @ajsnode game.dictionary.verbs.hold
   * @ajsconstruct MyGame.createVerb({ "name": "hold", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning hold asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; hold railing</span>
   * You hold the woven rope railing. It doesn't make the rotted
   * slat bridge look any less frightening.
   * </pre>
   * <p>
   * <strong>Hold</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset to be held has
   * asset.dov.hold.enabled set to true.
   * <strong>Hold</strong> exists as a variation of
   * <strong>take</strong> that doesn't move the held
   * Asset into player inventory. This is intended for
   * holding onto fixed Assets such as railings or
   * {@link adventurejs.Rope|Ropes}. Player is fixed in
   * place while holding a stationary Asset and must
   * {@link drop} or {@link release}
   * the Asset to move. Though hold takes an indirect object,
   * technically the player is the indirect object. If an
   * indirect object is provided, we expect to be able to
   * treat it like a worn item, as in "hold pan with oven mitt".
   * Verb connections will be drawn between held item and
   * player.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.hold = {
    name: "hold",
    prettyname: "hold",
    past_tense: "held",
    synonyms: ["hold", "grab"],
    verb_prep_prep_noun: ["hold on to", "grab on to"],

    /**
     * @ajsverbstructures
     * @memberof close
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof hold
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     //in_inventory: true,
     *     // If we were carrying we'd limit to in_inventory
     *     // but "let go of" can also apply to things player
     *     // is holding on to.
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof close
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof hold
     * @ajsverbparams
     * with_params: {
     *   connections: [],
     *   max_connections: 1,
     * },
     */
    with_params: {
      connections: [],
      max_connections: 1,
    },

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // example: hold pen (take)
      // example: hold railing (hold on to)

      // is object takeable? do take
      // be careful here because we also want take to redirect to hold
      // don't want to get caught in a loop
      if (!direct_object.isDOV("hold") && direct_object.isDOV("take")) {
        this.game.debug(
          `F1311 | ${this.name}.js | inferring take, doVerb take `,
        );
        this.game.dictionary.doVerb("take");
        return null;
      }

      // can't hold it
      if (!direct_object.isDOV("hold")) {
        this.game.debug(
          `F1313 | ${this.name}.js | ${direct_object.id}.dov.hold.enabled is false `,
        );
        msg += `$(We) can't hold on to ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // already holding object
      if (player.IOVisConnectedtoAsset(this.name, direct_object)) {
        this.game.debug(
          `F1314 | ${this.name}.js | ${player.id}.iov.hold.with_params.connections contains ${direct_object.id} `,
        );
        msg += `$(We're) already holding ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // already holding max
      if (player.IOVhasMaxConnections(this.name)) {
        this.game.debug(
          `F1315 | ${this.name}.js | ${player.id}.iov.${this.name}.with_params.connections.length >= ${player.id}.iov.${this.name}.with_params.max_connections `,
        );
        msg += `$(We're) holding on to as many things as $(we) can. `;
        this.handleFailure(msg);
        return null;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1787 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1788 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // call actions

        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1790 | ${this.name}.js | ${direct_object.id} can't be ${this.state} by ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1789 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1901 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1807 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1312 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // state change
      this.setVerbSubscriptionConnection(direct_object, player);
      //player.IOVsetConnection(this.name, direct_object);

      // compose output
      msg +=
        "take" === input.input_verb
          ? `$(We) can't take ${direct_object.articlename}, but $(we) can hold it, so $(we) do that instead`
          : `$(We) grab hold of ${direct_object.articlename}`;
      msg += indirect_object ? `, using ${indirect_object}` : ``;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // hold

// hop.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class hop
   * @ajsnode game.dictionary.verbs.hop
   * @ajsconstruct MyGame.createVerb({ "name": "hop", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning hop, as in "hop over lake"; or, travel in specified direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; hop through mountain</span>
   * You fire up your primitive oscillation overthruster,
   * slip off your shoes and set your feet to the pedals,
   * try to align the three beams... and fail completely,
   * scraping against the mountain and spilling a shower of
   * sparks and spaceship parts.
   * </pre>
   * Hop extends core verb <a href="go.html">go</a>.
   * It checks whether "hop" is contextually available
   * before forwarding to "go" for further handling.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.hop = {
    name: "hop",
    prettyname: "hop",
    past_tense: "flew",
    synonyms: ["hop"],
    type: { locomotion: true, travel: true },
    extends: { go: true },

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
      able_to_hop: true,
    },

    /**
     * @ajsverbstructures
     * @memberof hop
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof hop
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof hop
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof hop
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    do: function () {
      return this.game.dictionary.doVerb("go");
    },
  }; // END hop
})();

// hover.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class hover
   * @ajsnode game.dictionary.verbs.hover
   * @ajsconstruct MyGame.createVerb({ "name": "hover", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning hover over an asset, or travel in specified direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; hover over glassy field</span>
   * You scoot your little hoverboard over the rapidly cooling lava,
   * coughing through the billowing steam clouds and flushed from
   * the rising heat.
   * </pre>
   * Hover extends core verb <a href="go.html">go</a>.
   * It checks whether "hover" is contextually available
   * before forwarding to "go" for further handling.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.hover = {
    name: "hover",
    prettyname: "hover",
    past_tense: "hovered",
    synonyms: ["hover"],
    type: { locomotion: true, travel: true },
    extends: { go: true },

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
      able_to_hover: true,
    },

    /**
     * @ajsverbstructures
     * @memberof hover
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof hover
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof hover
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof hover
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    do: function () {
      return this.game.dictionary.doVerb("go");
    },
  }; // END hover
})();

// inventory.js
// OK 09 2023
/**
 *
 */
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class inventory
   * @ajsnode game.dictionary.verbs.inventory
   * @ajsconstruct MyGame.createVerb({ "name": "inventory", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb meaning list player's inventory.
   * @ajssynonyms inventory, inv, i
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; inventory</span>
   * You're carrying a brass lantern, a stick of chewing gum,
   * a Faberge egg, a Kinder toy, a book of matches, a lipstick
   * a slightly dented frog, an umbrella, a tire iron,
   * a bubbling cauldron of cheese, a packet of croutons,
   * a fondue fork, a pristine frog, and a tube of strawberry icing.
   * </pre>
   * <p>
   * Return the player's <code>inventory</code>.
   * </p>
   */
  A.Preverbs.inventory = {
    name: "inventory",
    synonyms: ["inventory", "inv", "i"],

    /**
     * @ajsverbstructures
     * @memberof inventory
     */
    accepts_structures: ["verb"],

    do: function () {
      this.game.printPlayerInventory();
      return true;
    },
  };
})();

// jump.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class jump
   * @ajsnode game.dictionary.verbs.jump
   * @ajsconstruct MyGame.createVerb({ "name": "jump", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning jump [preposition] asset, or travel [direction].
   * @ajssynonyms jump, hop
   * @todo if nested on thing like vine, let go/fall
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; jump</span>
   * You take a small jump!
   * </pre>
   * <p>
   * <strong>Jump</strong> behaves differently depending on player's
   * context, whether they're nested in another object.
   * Authors wanting to make use of it may want to modify the verb
   * to offer different results.
   * See
   * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.jump = {
    name: "jump",
    prettyname: "jump",
    past_tense: "jumped",
    synonyms: ["jump", "hop"],
    verb_prep_noun: ["hop up", "jump up"],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      //not_nested_elsewhere: true,
      able_to_jump: true,
    },

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var current_room = this.game.getCurrentRoom();
      var msg = "";

      // if( player.is.standing ) {
      //   var msg = "$(We're) already standing!";
      //   this.handleFailure(msg);
      //   return null;
      // }

      // room doesn't allow jumping
      // maybe it's a low ceiling?
      if (!player.can.jump || !player.getNestOrPlaceAspect().player.can.jump) {
        this.game.debug(
          `F1319 | jump.js | player.can.jump is false or ${player.getNestOrPlaceAsset()}.aspects.${player.getNestOrPlacePreposition()} }.player.can.jump is false`
        );
        msg += `$(We) can't jump here. `;
        this.handleFailure(msg);
        return null;
      }

      // nested and sitting lying kneeling ?

      // // object player is seated in doesn't allow standing
      // // maybe it's a wheelchair?
      // nest or place?
      // if( !player.getPlaceAssetId().player.can.stand ) {
      //   var msg = "$(We) can't get up.";
      //   this.handleFailure(msg);
      //   return null;
      // }

      // TODO:
      // what other conditions prevent player from standing?
      // tied down?
      //

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object;
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();
      var msg = "";
      var results;

      // DO THE THING!
      this.game.debug(`F1320 | jump.js | print doSuccess `);
      if (
        player.isNested() &&
        ("on" === nest_preposition ||
          ("in" === nest_preposition &&
            nest_parent_object.quirks.in_means_on)) &&
        nest_parent_object.quirks.jump_means_jump_off
      ) {
        direct_object = nest_parent_object;
        input.parsedNoun1 = new adventurejs.ParsedNoun(direct_object);
        this.game.dictionary.doVerb("jumpOff");
        return null;
      }

      // if player is seated IN something, have them stand up in it
      else if (
        player.isNested() &&
        "in" === nest_preposition &&
        "stand" !== player.posture &&
        nest_parent_object.can_stand_in
      ) {
        msg +=
          "$(We) jump up to stand in " + nest_parent_object.articlename + ". ";
      }

      // if player is on something they can stand on, have them stand
      else if (
        player.isNested() &&
        "on" === nest_preposition &&
        (("stand" !== player.posture && nest_parent_object.can_stand_on) ||
          "stand" === player.posture)
      ) {
        msg += "$(We) ";
        if ("stand" !== player.posture) {
          msg += "stand up on " + nest_parent_object.articlename + " and ";
        }
        if (player.isNested() && nest_parent_object.can_bounce_upon) {
          msg += "jump up and down a few times";
        } else {
          msg += "take a small jump";
        }
        if ("stand" === player.posture) {
          msg += " on " + nest_parent_object.articlename;
        }
        msg += ". ";
      }

      // otherwise have them exit the thing
      else if (
        player.isNested() &&
        nest_parent_object.quirks.jump_means_jump_off
      ) {
        msg +=
          "$(We) jump " +
          player.getPrettyUnnestPreposition() +
          " " +
          nest_parent_object.articlename +
          ". ";

        results = player.onUnnestThisFromThat(nest_parent_object);
        if ("undefined" !== typeof results) return results;
      }
      // otherwise just stand up
      else {
        msg += "$(We) take a small jump!";
      }

      player.posture = "stand";
      if (msg) this.game.print(msg, input.output_class);

      return true;
    },
  }; // jump
})();

// kick.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class kick
   * @ajsnode game.dictionary.verbs.kick
   * @ajsconstruct MyGame.createVerb({ "name": "kick", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning kick asset.
   * @ajssynonyms kick, punt
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; kick tires</span>
   * You kick the used car's tires. They seem a little soft.
   * The old Mustang rocks a bit from the contact, causing
   * something under the hood to rattle.
   * </pre>
   * <p>
   * <strong>Kick</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be kicked has
   * <code>dov.kick</code> set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.kick = {
    name: "kick",
    prettyname: "kick",
    past_tense: "kicked",
    synonyms: ["kick", "punt"],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
    },

    /**
     * @ajsverbstructures
     * @memberof kick
     */
    accepts_structures: ["verb noun"],

    /**
     * @memberof kick
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     not_worn: true,
     *     //not_in_inventory: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        not_worn: true,
      },
    },

    /**
     * @memberof kick
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV("kick")) {
        this.game.debug(
          `F1321 | ${this.name}.js | ${direct_object.id}.dov.kick.enabled is false `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state? skip

      if (
        direct_object.getPlaceAssetId() === player.id &&
        !direct_object.can.kick_while_held
      ) {
        this.game.debug(
          `F1322 | ${this.name}.js | ${direct_object.id}.can.kick_while_held is false `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename} while holding it. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1960 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1323 | ${this.name}.js | print doSuccess `);

      // compose output
      msg += `$(We) ${this.name} ${direct_object.articlename}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // kick

// kill.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class kill
   * @ajsnode game.dictionary.verbs.kill
   * @ajsconstruct MyGame.createVerb({ "name": "kill", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning kill character.
   * @ajssynonyms kill, murder
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; kill roach</span>
   * You slam your hand on the counter, killing the roach. As you scrape
   * the roachy remains from your hand, a chill runs across the back of
   * your neck. Suddenly you feel sure you're being watched. You glance
   * around the room. No one else is here. And then you look up...
   * </pre>
   * <p>
   * <strong>Kill</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be killed has
   * asset.dov.kill.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.kill = {
    name: "kill",
    prettyname: "kill",
    past_tense: "killed",
    synonyms: ["kill", "murder"],
    state: "dead",
    //unstate: "alive",

    /**
     * @ajsverbstructures
     * @memberof kill
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof kill
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof kill
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     in_inventory: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition:true,
     *   accepts_these_prepositions: ['with'],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof kill
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV("kill")) {
        this.game.debug(
          `F1324 | ${this.name}.js | ${direct_object.id}.dov.kill.enabled is false `,
        );
        msg += `$(We) can't kill ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1961 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.propername} is already ${this.getState()}. `;
        this.handleFailure(msg);
        return false;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1962 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      if (input.hasStructure("verb noun")) {
        // can verb act without an indirect object?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1963 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1964 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        // if( direct_object.DOVallowWithNothing(this.name) )
        // {
        //   this.game.debug(` | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `);
        //   msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        //   this.handleFailure(msg);
        //   return null;
        // }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1965 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1966 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1967 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      }
      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1325 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    }, // kill
  };
})();

// kneel.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class kneel
   * @ajsnode game.dictionary.verbs.kneel
   * @ajsconstruct MyGame.createVerb({ "name": "kneel", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading PositionVerbs
   * @summary Verb meaning kneel in place, or on asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; kneel</span>
   * You kneel on the floor.
   * </pre>
   * <p>
   * If input without an object,
   * <strong>kneel</strong> tries to put player into a kneeling
   * position wherever they happen to be. If player is not nested in a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}, <strong>kneel</strong> uses
   * the {@link adventurejs.Floor|Floor}. Requires that the
   * Asset has an
   * {@link adventurejs.Aspect|Aspect} with its
   * aspect.player.can.kneel</a>
   * property set to true.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.kneel = {
    name: "kneel",
    prettyname: "kneel",
    past_tense: "knelt",
    //synonyms: ["kneel down"] /* @todo take direction / preposition */,
    //verb_prep_noun: ["kneel down"],

    /**
     * @ajsverbstructures
     * @memberof lie
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
    ],

    player_must_be: {
      not_constrained: true,
      //not_on_floor: true,
      //not_nested_elsewhere: true,
    },

    /**
     * @memberof kneel
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     not_direction: true,
     *     not_in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   // accepts_these_prepositions: ["on"],
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        not_direction: true,
        not_in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof kneel
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    in_can_mean_on: true,

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var nest_asset = player.getNestAsset();
      var nest_preposition = player.getNestPreposition();
      var msg = "";
      var results;

      // sentence structure: verb
      if (input.hasStructure("verb")) {
        // is player already kneeling?
        if (player.is.kneeling) {
          this.game.debug(
            `F1326 | ${this.name}.js | ${player.id}.is.kneeling `,
          );
          msg += `$(We're) already kneeling! `;
          this.handleFailure(msg);
          return null;
        }
        if (nest_asset) {
          direct_preposition = player.getNestOrPlacePreposition();
          direct_object = nest_asset;
        } else {
          direct_preposition = "on";
          direct_object = this.game.getCurrentRoomFloor();
        }
        input.setAsset(1, direct_object);
        input.setPreposition(1, direct_preposition);
        input.setStructure("verb preposition noun");
      } // verb

      // sentence structure: verb preposition
      if (input.hasStructure("verb preposition")) {
        if (direct_preposition === "down") {
          if (player.is.kneeling) {
            this.game.debug(
              `F1088 | ${this.name}.js | ${player.id}.is.kneeling`,
            );
            msg += `$(We) shift weight from knee to knee. `;
            this.handleFailure(msg);
            return null;
          }
          // kneel down is still an option but we need a direct object
          if (nest_asset) {
            direct_object = nest_asset;
            direct_preposition = nest_preposition;
          } else {
            // see if the room has its own floor
            direct_object = this.game.getCurrentRoomFloor();
            direct_preposition = "on";
          }
          if (direct_object) {
            input.setAsset(1, direct_object);
            input.setPreposition(1, direct_preposition);
            input.setAssumed(1, true);
            input.setStructure("verb preposition noun");
          }
        } else {
          this.game.debug(
            `F1021 | ${this.name}.js | no direct object received or inferred`,
          );
          msg += `$(We) try to kneel ${direct_preposition}, and fail. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb preposition

      // sentence structure: verb preposition noun
      if (input.hasStructure("verb preposition noun")) {
        // is player allowed to kneel here?
        if (
          !player.can.kneel ||
          !direct_object.aspects[direct_preposition].player.can.kneel
        ) {
          // nested in an object that can't be kneeled in
          this.game.debug(
            `F1327 | ${this.name}.js | player.can.kneel is false or ${direct_object.id}.aspects.${direct_preposition} }.player.can.kneel is false`,
          );
          msg += `$(We) can't kneel ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can player reach it?
        if (nest_asset && nest_asset.id !== direct_object.id) {
          results = this.canPlayerGoThereFromNest(
            direct_preposition,
            direct_object,
          );
          if (results.failure) {
            this.handleFailure(results.msg);
            return null;
          }
          if (results.return) return true;
        }

        // player is nested some other way with target
        // and needs to get up first
        if (
          nest_asset &&
          nest_asset.id === direct_object.id &&
          nest_preposition !== direct_preposition
        ) {
          this.game.debug(
            `F1614 | ${this.name}.js | player is otherwise nested ${nest_preposition} ${nest_asset.id} `,
          );
          msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} ${nest_preposition} ${
            nest_asset.articlename
          }. `;
          this.handleFailure(msg);
          return null;
        }

        if (player.is.kneeling) {
          var already_on_it;

          if (
            nest_asset &&
            nest_asset.id === direct_object.id &&
            nest_preposition === direct_preposition
          )
            already_on_it = true;

          if (!nest_asset && direct_object instanceof adventurejs.Floor)
            already_on_it = true;

          if (already_on_it) {
            this.game.debug(
              `F1613 | ${this.name}.js | ${player.id}.is.kneeling ${direct_preposition} ${direct_object.id} `,
            );
            msg += `$(We're) already kneeling ${direct_preposition} ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        }
      } // verb preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var nest_asset = player.getNestAsset();
      var nest_preposition = player.getNestPreposition();
      var do_nest, do_unnest;
      var fromfloor;
      var tofloor;
      var results;
      var msg = "";

      // DO THE THING!
      this.game.debug(`F1328 | ${this.name}.js | print doSuccess `);

      tofloor = direct_object instanceof adventurejs.Floor;
      fromfloor = !nest_asset || nest_asset instanceof adventurejs.Floor;

      // floor to floor
      if (fromfloor && tofloor) {
        do_nest = true;
        this.game.debug(`F1621 | ${this.name}.js | from floor to floor `);
        msg += `$(We) ${
          player.isOnFloor() ? "shift positions to" : ""
        } kneel on the floor. `;
      }

      // floor to nest or change positions on nest
      else if (
        (fromfloor && !tofloor) ||
        (nest_asset && nest_asset.id === direct_object.id)
      ) {
        do_nest = fromfloor && !tofloor;
        this.game.debug(
          `F1622 | ${this.name}.js | from floor to asset or change position on asset `,
        );
        msg += `$(We) climb to a kneeling position ${direct_preposition} ${direct_object.articlename}. `;
      }

      // nest_asset to floor - unnest
      else if (!fromfloor && tofloor) {
        do_unnest = true;
        this.game.debug(`F1623 | ${this.name}.js | from asset to floor `);
        msg += `$(We) hop ${player.getPrettyUnnestPreposition()} ${
          nest_asset.articlename
        } and kneel ${direct_preposition} ${direct_object.articlename}. `;
      }

      // nest_asset to same nest_asset
      else if (!fromfloor && !tofloor && direct_object.id === nest_asset.id) {
        if (player.is.lying || player.is.sitting || player.is.standing) {
          this.game.debug(`F1624 | ${this.name}.js | change posture on floor `);
          msg += `$(We) kneel ${nest_preposition} ${direct_object.articlename}. `;
        }
      }

      // nest_asset to other nest_asset
      else if (!fromfloor && !tofloor && direct_object.id !== nest_asset.id) {
        do_nest = true;
        do_unnest = true;
        this.game.debug(
          `F1625 | ${this.name}.js | move from one asset to another `,
        );
        msg += `$(We) climb over to ${direct_object.articlename} and kneel ${direct_preposition} it. `;
      }

      if (do_unnest && nest_asset) {
        results = player.onUnnestThisFromThat(nest_asset);
        if ("undefined" !== typeof results) return results;
      }

      if (do_nest && direct_object) {
        results = player.onNestThisToThat(direct_object, direct_preposition);
        if ("undefined" !== typeof results) return results;
      }

      player.posture = "kneel";

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  }; // END p.preverbs.push
})();

// lasso.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class lasso
   * @ajsnode game.dictionary.verbs.lasso
   * @ajsconstruct MyGame.createVerb({ "name": "lasso", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning lasso asset with rope.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; lasso crocagator with rope</span>
   * You lasso the crocagator with the woven grass rope. The rope
   * slips over the croc's long mouth. You pull, and the croc's
   * mouth slams shut. The crocagator thrashes angrily and whips
   * its jewel-tipped tail and pulls you off balance. You dig in
   * and pull. Step by step, you drag the bellowing crocagator out
   * of its watering hole. Soon its magic emerald will be yours.
   * </pre>
   * <p>
   * <strong>Lasso</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} with a
   * {@link adventurejs.Rope|Rope}. Asset to be lassoed must have
   * asset.dov.lasso.enabled
   * set to true. If successful, Rope is tied to other Asset.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.lasso = {
    name: "lasso",
    prettyname: "lasso",
    past_tense: "lassoed",
    synonyms: ["lasso"],
    verb_noun_prep_noun: ["lasso with"],

    player_must_be: {
      //not_on_floor: true,
      not_constrained: true,
      //not_under: true,
      //not_behind: true,
    },

    /**
     * @memberof lasso
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
      },
    },

    /**
     * @memberof lasso
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     in_inventory: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        in_inventory: true,
      },
    },

    /**
     * @memberof lasso
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var msg = "";

      var player = this.game.getPlayer();

      if (!indirect_object) {
        input.setSoftPrompt({ noun2: true, verb: "lasso" });
        this.game.debug(
          `F1330 | ${this.name}.js | no indirect object provided, soft prompt noun2 `
        );
        msg += "What shall $(we) lasso " + direct_object.articlename + " with?";
        this.handleFailure(msg);
        return null;
      }

      if (!direct_object.isDOV("lasso") || !direct_object.isDOV("tie")) {
        this.game.debug(
          `F1330 | ${this.name}.js | ${direct_object.id}.dov.lasso.enabled and dov.tie.enabled are false `
        );
        msg += `$(We) can't lasso ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (!indirect_object.isIOV("lasso") || !indirect_object.isDOV("tie")) {
        this.game.debug(
          `F1331 | ${this.name}.js | ${indirect_object.id}.iov.lasso.enabled or .dov.tie.enabled is false `
        );
        msg += `$(We) can't lasso anything with ${indirect_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1329 | ${this.name}.js | print doSuccess `);
      msg += `$(We) lasso ${direct_object.articlename} with ${indirect_object.articlename}. `;

      // if( player.$has( indirect_object ) ) {
      //   // remove thing from player
      //   results = player.onRemoveThatFromThis( indirect_object );
      //   if( false === results ) { return false; }
      //   else if ( null === results ) { return null; }
      //   // is the rope tied to player?
      // }
      //results = currentRoom.onMoveThatToThis( direct_object, "in" );
      // results = direct_object.onMoveThatToThis( direct_object, "attached" );
      // if( false === results ) { return false; }
      // else if ( null === results ) { return null; }
      results = indirect_object.onTieThisToThat(direct_object);
      if ("undefined" !== typeof results) return results;

      direct_object.can.support_swinging = true;
      indirect_object.is.supported = true;

      // if the rope is in inventory, switch to holding

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  }; // END p.preverbs.push
})();

// lick.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class lick
   * @ajsnode game.dictionary.verbs.lick
   * @ajsconstruct MyGame.createVerb({ "name": "lick", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading SensationVerbs
   * @summary Verb meaning lick asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; lick toad</span>
   * You lick the toad. It tastes disgusting, like wet dirt,
   * but nothing happ... Oh. Oh. Something's definitely happening.
   * It comes in a rush: a feeling of anxiety, followed by a lack
   * of balance, things start spinning. Uh oh. This might have been
   * the wrong trip. And then. And then. And then... ah, it's alright.
   * You've settled in now. It's going to be an interesting night.
   * </pre>
   * <p>
   * <strong>Lick</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be licked has asset.dov.lick.enabled set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * <p>
   * Lick and {@link taste|taste} behave identically if they're
   * not given any special reactions.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.lick = {
    name: "lick",
    prettyname: "lick",
    past_tense: "licked",
    synonyms: ["lick"],

    /**
     * @ajsverbstructures
     * @memberof lick
     */
    accepts_structures: ["verb noun"],

    /**
     * @memberof lick
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof lick
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (!direct_object.isDOV("lick")) {
        this.game.debug(
          `F1332 | ${this.name}.js | ${direct_object.id}.dov.lick.enabled is false `
        );
        msg += `$(We) can't lick ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1993 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `
        );
        msg += `$(We've) already ${this.past_tense} ${direct_object.articlename} enough. `;
        this.handleFailure(msg);
        return false;
      }

      if (!direct_object.hasDescription("taste")) {
        this.game.debug(
          `F1333 | ${this.name}.js | ${direct_object.id}.descriptions.taste is unset `
        );
        msg += `${direct_object.Articlename} has no particular taste. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1334 | ${this.name}.js | print doSuccess `);

      // compose output
      msg += `$(We) lick ${direct_object.articlename}. `;
      if (direct_object.hasDescription("taste")) {
        msg += direct_object.getDescription("taste");
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})();

// lie.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class lie
   * @ajsnode game.dictionary.verbs.lie
   * @ajsconstruct MyGame.createVerb({ "name": "lie", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading PositionVerbs
   * @summary Verb meaning lie down in place or on asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; lie down</span>
   * You lie down, and let your mind drift. Though you would prefer they
   * not, your thoughts turn to the mademoiselle of Mairie Ste Cloud,
   * as they so often do. Perhaps you never will forget that
   * fateful kiss beneath the statue of Santos Dumont, stolen at
   * such great cost and never returned.
   * </pre>
   * <p>
   * <strong>Lie</strong> or more likely <strong>lie down</strong>
   * tries to put player into a lying
   * position wherever they happen to be. If player is not nested in a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}, <strong>lie</strong> uses
   * the {@link adventurejs.Floor|Floor}. Requires that the
   * Asset has an {@link adventurejs.Aspect|Aspect} with its
   * player.can.lie
   * property set to true.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.lie = {
    name: "lie",
    prettyname: "lie",
    past_tense: "lay",
    //synonyms: ["lie down"],
    //verb_prep_noun: ["lie down"],

    /**
     * @ajsverbstructures
     * @memberof lie
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
    ],

    player_must_be: {
      not_constrained: true,
      //not_on_floor: true,
      //not_nested_elsewhere: true,
    },

    /**
     * @memberof lie
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     not_direction: true,
     *     not_in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        not_direction: true,
        not_in_inventory: true,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      requires_preposition: true,
    },

    /**
     * @memberof lie
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    in_can_mean_on: true,

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var nest_asset = player.getNestAsset();
      var nest_preposition = player.getNestPreposition();
      var msg = "";
      var results;

      //@todo add distinction for "lie to"
      // or even contextual clue for just "lie"
      // if player has been conversing

      // sentence structure: verb
      if (input.hasStructure("verb")) {
        // already lying
        if (player.is.lying) {
          this.game.debug(`F1010 | ${this.name}.js | player.is.lying`);
          msg += "$(We're) already lying! ";
          this.handleFailure(msg);
          return null;
        }
        direct_preposition = player.getNestOrPlacePreposition();
        input.setPreposition(1, direct_preposition);
        direct_object = player.getNestOrPlaceAsset();
        input.setStructure("verb preposition noun");
      } // verb

      // sentence structure: verb preposition
      if (input.hasStructure("verb preposition")) {
        if (direct_preposition === "down") {
          if (player.is.lying) {
            this.game.debug(`F1153 | ${this.name}.js | ${player.id}.is.lying`);
            msg += `$(We) roll over fitfully. `;
            this.handleFailure(msg);
            return null;
          }
          if (nest_asset) {
            direct_object = nest_asset;
            direct_preposition = nest_preposition;
          } else {
            // see if the room has its own floor
            direct_object = this.game.getCurrentRoomFloor();
            direct_preposition = "on";
          }
          if (direct_object) {
            input.setAsset(1, direct_object);
            input.setPreposition(1, direct_preposition);
            input.setAssumed(1, true);
            input.setStructure("verb preposition noun");
          }
        } else {
          this.game.debug(
            `F1240 | ${this.name}.js | no direct object received or inferred`
          );
          msg += `$(We) try to lie ${direct_preposition}, and fail. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb preposition

      // sentence structure: verb preposition noun
      if (input.hasStructure("verb preposition noun")) {
        // is player allowed to lie here?
        if (
          !player.can.lie ||
          !direct_object.aspects[direct_preposition].player.can.lie
        ) {
          // nested in an object that can't be stood in
          this.game.debug(
            `F1011 | ${this.name}.js | player.can.lie is false or ${direct_object.id}.aspects.${direct_preposition} }.player.can.lie is false`
          );
          msg += `$(We) can't lie ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can player reach it?
        if (nest_asset && nest_asset.id !== direct_object.id) {
          results = this.canPlayerGoThereFromNest(
            direct_preposition,
            direct_object
          );
          if (results.failure) {
            this.handleFailure(results.msg);
            return null;
          }
          if (results.return) return true;
        }

        // player is nested some other way with target
        // and needs to get up first
        if (
          nest_asset &&
          nest_asset.id === direct_object.id &&
          nest_preposition !== direct_preposition
        ) {
          this.game.debug(
            `F1013 | ${this.name}.js | player is otherwise nested ${nest_preposition} ${nest_asset.id}`
          );
          msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} ${nest_preposition} ${
            nest_asset.articlename
          }. `;
          this.handleFailure(msg);
          return null;
        }

        // player is already lying [preposition] target
        if (player.is.lying) {
          var already_on_it;

          if (
            nest_asset &&
            nest_asset.id === direct_object.id &&
            nest_preposition === direct_preposition
          )
            already_on_it = true;

          if (!nest_asset && direct_object instanceof adventurejs.Floor)
            already_on_it = true;

          if (already_on_it) {
            this.game.debug(
              `F1090 | ${this.name}.js | ${player.id}.is.lying ${direct_preposition} ${direct_object.id}`
            );
            msg += `$(We're) already lying ${direct_preposition} ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        }
      } // verb preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var nest_asset = player.getNestAsset();
      var nest_preposition = player.getNestPreposition();
      var do_nest, do_unnest;
      var fromfloor;
      var tofloor;
      var results;
      var msg = "";

      this.game.debug(`F1335 | ${this.name}.js | print doSuccess`);

      tofloor = direct_object instanceof adventurejs.Floor;
      fromfloor = !nest_asset || nest_asset instanceof adventurejs.Floor;

      // floor to floor
      if (fromfloor && tofloor) {
        do_nest = true;
        this.game.debug(`F1627 | ${this.name}.js | from floor to floor `);
        msg += `$(We) ${
          player.isOnFloor() ? "shift positions to" : ""
        } lie down on the floor. `;
      }

      // floor to nest or change positions on nest
      else if (
        (fromfloor && !tofloor) ||
        (nest_asset && nest_asset.id === direct_object.id)
      ) {
        do_nest = fromfloor && !tofloor;
        this.game.debug(
          `F1628 | ${this.name}.js | from floor to asset or change position on asset `
        );
        msg += `$(We) lie ${direct_preposition} ${direct_object.articlename}. `;
      }

      // nest_asset to floor - unnest
      else if (!fromfloor && tofloor) {
        do_unnest = true;
        this.game.debug(`F1629 | ${this.name}.js | from asset to floor `);
        msg += `$(We) hop ${player.getPrettyUnnestPreposition()} ${
          nest_asset.articlename
        } and lie ${direct_preposition} ${direct_object.articlename}. `;
      }

      // nest_asset to same nest_asset
      else if (!fromfloor && !tofloor && direct_object.id === nest_asset.id) {
        if (player.is.lying || player.is.sitting || player.is.kneeling) {
          this.game.debug(`F1630 | ${this.name}.js | change posture on floor `);
          msg += `$(We) lie down ${nest_preposition} ${direct_object.articlename}. `;
        }
      }

      // nest_asset to other nest_asset
      else if (!fromfloor && !tofloor && direct_object.id !== nest_asset.id) {
        do_nest = true;
        do_unnest = true;
        this.game.debug(
          `F1631 | ${this.name}.js | move from one asset to another `
        );
        msg += `$(We) climb over to ${direct_object.articlename} and lie down ${direct_preposition} it. `;
      }

      if (do_unnest && nest_asset) {
        results = player.onUnnestThisFromThat(nest_asset);
        if ("undefined" !== typeof results) return results;
      }

      if (do_nest && direct_object) {
        results = player.onNestThisToThat(direct_object, direct_preposition);
        if ("undefined" !== typeof results) return results;
      }

      player.posture = "lie";

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  }; // END p.preverbs.push
})();

// listen.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class listen
   * @ajsnode game.dictionary.verbs.listen
   * @ajsconstruct MyGame.createVerb({ "name": "listen", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading SensationVerbs
   * @summary Verb meaning listen to asset or room.
   * @todo Finish with room tone handling.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; listen</span>
   * You hold still and listen. The chain falls
   * down the stone well, bouncing endlessly from side to side,
   * creating a wince inducing amount of noise. Each time you
   * think it may have reached bottom, there is another loud
   * rattle and clunk... and finally, a splash. You wait, ears
   * straining to catch any residual sounds. After a long pregnant
   * moment, a moan begins far below, slowly rising into a shriek,
   * followed by chants and screams. Uh oh.
   * </pre>
   * <p>
   * <strong>Listen</strong> tries to find a sound description.
   * If no direct object is provided, it looks first at the current
   * room.descriptions.sound and then at the global_sound.description.
   * If a direct object is provided, it looks for
   * asset.descriptions.sound.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.listen = {
    name: "listen",
    synonyms: ["listen"],
    past_tense: "listened",

    /**
     * @ajsverbstructures
     * @memberof listen
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition noun",
      "verb preposition noun preposition noun",
    ],

    /**
     * @memberof listen
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   //requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true, // TODO does a sound need to be known?
     *     //tangible: true, // TODO is a sound intangible?
     *     present: true,
     *   },
     *   accepts_preposition: true,
     *   require_preposition: true,
     *   accepts_these_prepositions: ["to"],
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        present: true,
      },
      accepts_preposition: true,
      require_preposition: true,
      accepts_these_prepositions: ["to"],
    },

    /**
     * @memberof close
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof listen
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var direct_preposition = input.getPreposition(1);
      var indirect_preposition = input.getPreposition(2);
      var currentRoom = this.game.getCurrentRoom();
      var player = this.game.getPlayer();
      var results, hook;
      var msg = "";

      if (player.is.deaf) {
        this.game.debug(`F1336 | ${this.name}.js | player.is.deaf `);
        msg += `$(We) can't hear anything at all. `;
        this.handleFailure(msg);
        return null;
      }

      if (!player.can.hear || !player.getNestOrPlaceAspect().player.can.hear) {
        this.game.debug(
          `F1598 | ${
            this.name
          }.js | player.can.hear is false or ${player.getNestOrPlaceAsset()}.aspects.${player.getNestOrPlacePreposition()} }.player.can.hear is false`
        );
        msg += `$(We) can't hear anything. `;
        this.handleFailure(msg);
        return null;
      }

      // sentence structure: verb
      if (input.hasStructure("verb")) {
        // does current room have sound?
        if (currentRoom.hasDescription("sound")) {
          input.verb_params.source = currentRoom.descriptions.sound;
        } else {
          // try to get global_sound
          input.verb_params.source = this.game.getGlobalAssetDescription(
            "global_sound",
            "sound"
          );
        }
        if (input.verb_params.source) {
          return true;
        } else {
          this.game.debug(`F1782 | ${this.name}.js | no sound found `);
          msg += `$(We) don't hear any particular sound. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1599 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `
        );
        msg += `$(We) can't hear ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (!direct_object.hasDescription("sound")) {
        this.game.debug(
          `F1413 | ${this.name}.js | ${direct_object.id}.descriptions.sound is unset `
        );
        msg += `$(We) can't hear any particular sound from ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      } else {
        input.verb_params.source = direct_object.getDescription("sound");
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1783 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `
          );
          msg += `$(We) don't have any way to ${this.name} to ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1784 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} to ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb preposition noun preposition noun
      if (input.hasStructure("verb preposition noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1785 | ${this.name}.js | ${direct_object.id} can't be ${this.state} by ${indirect_object.id} `
          );
          msg += `$(We) can't ${this.name} ${direct_preposition} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1786 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets does not include ${indirect_object.id} `
          );
          msg += `${indirect_object.Articlename} can't be used to ${this.name} to ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1902 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1808 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1337 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
      }

      // compose output
      msg += direct_object
        ? `$(We) tilt an ear toward ${direct_object.articlename}`
        : ``;
      msg += indirect_object
        ? `${indirect_preposition} ${indirect_object.articlename}}`
        : ``;
      msg += direct_object ? `. ` : ``;
      msg += input.verb_params.source
        ? A.getSAF.call(this.game, input.verb_params.source)
        : `$(We) don't hear anything in particular. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})();

// locations.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class locations
   * @ajsnode game.dictionary.verbs.locations
   * @ajsconstruct MyGame.createVerb({ "name": "locations", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb meaning print a list of available locations.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; locations</span>
   * Places you've visited include the
   * Leavening Room, the Pity Palace, the Kate Cafe,
   * the Umbrella Garden, the Toeholds of the Foothills,
   * and the remembered bank of the River Mnemnesia.
   * </pre>
   * <p>
   * <strong>Locations</strong> prints a list of Rooms that
   * the player has visited.
   * </p>
   */
  A.Preverbs.locations = {
    name: "locations",
    synonyms: ["locations"],

    /**
     * @ajsverbstructures
     * @memberof locations
     */
    accepts_structures: ["verb"],

    do: function () {
      var input = this.game.getInput();
      var rooms = [];
      for (var i = 0; i < this.game.room_lookup.length; i++) {
        var room = this.game.room_lookup[i];
        //this.game.print( room );
        room = this.game.world[room];
        if (room.is.known) {
          rooms.push(room);
        }
      }

      if (0 === rooms.length) {
        // unlikely
        var msg = "$(We) haven't been anywhere. ";
        this.handleFailure(msg);
        return true;
      }

      if (0 < rooms.length) {
        var msg = "Places $(we've) visited include ";

        for (var i = 0; i < rooms.length; i++) {
          var room = rooms[i];
          if (i > 0 && i < rooms.length - 1) {
            msg += ", ";
          }
          if (rooms.length > 1 && i === rooms.length - 1) {
            msg += " and ";
          }
          msg += room.use_definite_article_in_lists
            ? room.definite_article + " "
            : "";
          msg += room.name;
        }
        msg += ". ";

        if (msg) this.game.print(msg, input.output_class);
        return true;
      }

      return true;
    },
  };
})();

// lock.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class lock
   * @ajsnode game.dictionary.verbs.lock
   * @ajsconstruct MyGame.createVerb({ "name": "lock", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading OpenCloseVerbs
   * @ajscaninferindirect true
   * @summary Verb meaning lock an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; lock handcuff with key</span>
   * You lock the pair of handcuffs with the little silver key,
   * effectively shackling yourself to the campus railing. It's
   * a mark of your privilege that you think this will stop the
   * bulldozers, which roll right over you on their way to
   * demolish the University Hall. You have died. But such a
   * noble death! One day the University bards will write ballads
   * about your heroic failure.
   * </pre>
   *
   * <p>
   * <strong>Lock</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the lock has
   * asset.dov.lock.enabled set to true and its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_is_locked">is.locked</a>
   * property set to false. If the lock requires a key,
   * verb will soft prompt for one.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @ajsdemo OpenGame, SittingRoom, Library, Playground, Objects
   */
  A.Preverbs.lock = {
    name: "lock",
    prettyname: "lock",
    past_tense: "locked",
    synonyms: ["lock"],
    state: "locked",
    related: ["unlock", "pick"],
    state_strings: { state: "locked", unstate: "unlocked" },
    state_string: "locked",
    unstate_string: "unlocked",

    /**
     * @ajsverbstructures
     * @memberof lock
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof lock
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof lock
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof lock
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var soft_prompt_for_asset;
      var asset_in_player;
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1346 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1347 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.Articlename} is already ${this.getState()}. `;
        this.handleFailure(msg);
        return false;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1824 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1348 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1706 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1343 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1344 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1903 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1809 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";
      var autoclose;

      this.game.debug(`F1350 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, true);

      // update incidental verb count
      if (!direct_object.is.closed) {
        direct_object.setClosed(); //is.closed = true;
        direct_object.incrementDoVerbCount("close", 1);
        autoclose = true;
      }

      // compose output
      msg += `$(We) ${autoclose ? "close and " : ""} ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // lock

// look.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class look
   * @ajsnode game.dictionary.verbs.look
   * @ajsconstruct MyGame.createVerb({ "name": "look", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading SensationVerbs
   * @summary Verb meaning look at an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; look behind moose head</span>
   * You look behind the stuffed and mounted moose head. You find
   * a brittle, age-stained business card for ACE TAXIDERMY.
   * Written on the back of the card in a shaky cursive script
   * is a name: ABRAHAM MANAHAN.
   * </pre>
   * <pre class="display border outline">
   * <span class="input">&gt; look in genie's bottle</span>
   * You look in the genie's bottle. The bottle glass is
   * dark green and smoky, almost opaque, but by turning
   * the glass this way and that in the light, you can
   * almost make out a dark powerful shape roiling inside it.
   * </pre>
   * <pre class="display border outline">
   * <span class="input">&gt; look on car roof</span>
   * You look on the car roof. And a good thing you did,
   * because you almost left the baby in its basket there.
   * </pre>
   * <pre class="display border outline">
   * <span class="input">&gt; look under left foot</span>
   * You look under your left foot. In the immemorial time
   * since you took up your position, an underground ecology
   * has established there. Blind creatures lay revealed
   * beneath your giant raised foot, and writhe away from
   * the sunlight. An underground spring fills in the depression
   * where your heel pressed into the earth.
   * </pre>
   * <strong>look</strong> can be used in a number of ways.
   * <ul>
   * <li><strong>look</strong> by itself returns a description of the room from
   * room.descriptions.look, along with a list of things in the room. If those
   * things have aspects, aka asset.aspects.on.list_in_room set to true, their
   * contents will also be listed</li>
   * <li><strong>look at asset</strong> returns a description of the asset from
   * asset.descriptions.look</li>
   * <li><strong>look at asset</strong> can be configured so that it returns
   * different values depending on the player's position. For example if player
   * is in a tree, "look at asset" will try to find a description at
   * asset.descriptions.look["from tree"]</li>
   * <li><strong>look in asset</strong>, used with "in" or any other preposition,
   * will try to find a description at asset.descriptions[preposition]</li>
   * <li><strong>look at asset through another asset</strong>, used with through or
   * any other preposition, will try to find a description at
   * asset.descriptions.look["through other asset"]</li>
   * </ul>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.look = {
    name: "look",
    prettyname: "look",
    past_tense: "looked",
    synonyms: ["look", "l"],
    verb_prep_noun: [],
    verb_prep_prep_noun: [],
    verb_noun_prep_noun: [],

    /**
     * @ajsverbstructures
     * 'verb noun preposition noun' is a special case to catch things
     * like "look out window with flashlight" where "out window"
     * is found at an early stage of parsing in world_lookup and
     * converted to the window asset id, leaving us with
     * "look window with flashlight"
     * @memberof look
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
      "verb preposition noun preposition noun",
    ],

    /**
     * @memberof look
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     singular: false,
     *   },
     *   accepts_preposition: true,
     *   accepts_preposition_without_noun: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        visible_if_tangible: true,
        singular: false,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
    },

    /**
     * @memberof look
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   //accepts_these_prepositions: [ 'with', 'through', 'at' ],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof look
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    tryThrough: function (asset) {
      var msg = "";
      // @todo If item is in inventory, not in hands, see if it can be
      // taken, allow it, then take it out on doSuccess.
      // if( asset.must_be_in_inventory_to_look_through
      if (
        asset.must.be_in_hands_to_look_through &&
        !asset.isIn(this.game.player)
      ) {
        this.game.debug(
          `F1014 | ${this.name}.js | ${asset.id}.must.be_in_hands_to_look_through is false`,
        );
        msg += `$(We're) not holding ${asset.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // @todo If item is in inventory, not worn, see if it can be
      // worn, allow it, then take it out on doSuccess.
      if (asset.must.be_worn_to_look_through && !asset.is.worn) {
        this.game.debug(
          `F1015 | ${this.name}.js | ${asset.id}.must.be_worn_to_look_through is false`,
        );
        msg += `$(We're) not wearing ${asset.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // @TODO this bit is more likely to apply to direct object
      // than indirect object. Re-examine.
      if (!asset.hasDescription("through")) {
        this.game.debug(
          `F1851 | ${this.name}.js | ${asset.id}.descriptions.through not found`,
        );
        if (1 < asset.dimensions.opacity) {
          msg += `Though ${asset.articlename} is 
              ${
                asset.dimensions.opacity > 0.5 ? "translucent" : "transparent"
              }, 
              $(we) can't see through it. `;
        } else {
          msg += `$(We) can't see through ${asset.articlename}. `;
        }
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    tryWith: function (asset) {
      var msg = "";
      // can player look with this object?
      if (!asset.isIOV("look")) {
        this.game.debug(
          `F1224 | ${this.name}.js | ${asset.id}.iov.look.enabled is false`,
        );
        msg += `$(We) can't look with ${asset.articlename}. `;
        this.handleFailure(msg);
        return null;
      }
      if (!asset.isIn(this.game.getPlayer())) {
        this.game.debug(
          `F1845 | ${this.name}.js | ${asset.id} is not in player`,
        );
        msg += `$(We're) not holding ${asset.articlename}. `;
        this.handleFailure(msg);
        return null;
      }
    },

    tryFrom: function (asset) {
      var msg = "";
      // is player nested in the object? that's the only way to look from it
      // if so just let it go so we can print that
      if (asset === this.game.player.getNestAsset()) {
        return true;
      } else {
        this.game.debug(
          `F1016 | ${this.name}.js | player not nested within ${asset.id}`,
        );
        msg += `$(We're) not ${asset.default_aspect} ${asset.articlename}. `;
        this.handleFailure(msg);
        return null;
      }
    },

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";
      var wornoptics;
      var results;

      if (
        direct_object &&
        direct_object.direction === "out" &&
        !direct_preposition &&
        -1 !== input.input.indexOf("look out ")
      ) {
        // Catch special case where player inputs something like
        // "look out window" where parser finds "out window" to be
        // asset id "bedroom_window". This works for most cases
        // except for cases like "look out window with flashlight"
        // which would be parsed as "look window with flashlight"
        direct_preposition = "out";
        input.setPreposition(1, "out");
        input.setStructure(
          input.getStructure().replace("noun ", "noun preposition "),
        );
      } else if (
        direct_object &&
        direct_object.direction === "in" &&
        !direct_preposition &&
        -1 !== input.input.indexOf("look in ")
      ) {
        direct_preposition = "in";
        input.setPreposition(1, "in");
        input.setStructure(
          input.getStructure().replace("noun ", "noun preposition "),
        );
      }

      // check for worn items like eyeglasses
      if (direct_object && !indirect_object) {
        // need a function to see if player is wearing
        // something they can look through
        wornoptics = player.getWornOptics();
        if (wornoptics.length > 0) {
          // there's nothing stopping player from wearing
          // multiple pairs of glasses but we're only prepared
          // to handle one
          indirect_object = this.game.getAsset(wornoptics[0]);
          indirect_preposition = "through";
          input.setAsset(2, indirect_object);
          input.setPreposition(2, indirect_preposition);
        }
      }

      if (direct_preposition && indirect_preposition) {
        if (indirect_preposition === "at") {
          this.game.print(
            `F1852 | ${this.name}.js | swapping order of nouns in sentence`,
          );
          //if( direct_preposition === "through" || direct_preposition === "with" )
          //{
          // we prefer "look at x through y" and "look at x with y"
          input.swapPhrases(1, 2);
          direct_object = input.getAsset(1);
          direct_preposition = input.getPreposition(1);
          indirect_object = input.getAsset(2);
          indirect_preposition = input.getPreposition(2);
          //}
        }
      }

      // sentence structure: verb
      if (input.hasStructure("verb")) {
        return true;
      } // verb

      // sentence structure: verb preposition
      if (input.hasStructure("verb preposition")) {
        input.setSoftPrompt({ noun1: true });
        this.game.debug(
          `F1100 | ${this.name}.js | received preposition/${direct_preposition} with no noun, soft prompt noun1`,
        );
        msg += `Look ${direct_preposition} what? `;
        this.handleFailure(msg);
        return null;
      } // verb preposition

      // sentence structure: verb noun / verb preposition noun
      if (
        input.hasStructure("verb noun") ||
        input.hasStructure("verb preposition noun")
      ) {
        // TRY > ONENOUN > NOUN IS DIRECTION
        // if player has input something like "look north"
        // we're just going to print the exit description
        if (input.parsedNoun1.matches.direction) return true;

        // TRY > ONENOUN > NO PREPOSITION
        // if there's no preposition we're just going to print the asset decription
        if (!direct_preposition) return true;

        // TRY > ONENOUN > PREPOSITION
        if (direct_preposition) {
          // TRY > ONENOUN > PREPOSITION > AT
          // no blockers, pass to success
          if ("at" === direct_preposition) {
            return true;
          }

          // TRY > ONENOUN > PREPOSITION > IN
          // unique check for conditions not applicable to other aspects
          if ("in" === direct_preposition) {
            // it can contain things but it's closed and opaque
            if (
              direct_object.hasAspectAt("in") &&
              direct_object.isDOV("close") &&
              direct_object.is.closed &&
              1 >= direct_object.dimensions.opacity
            ) {
              this.game.debug(
                `F1101 | ${this.name}.js | ${direct_object.id}.is.closed and .dimensions.opacity is 1`,
              );
              msg += `$(We) can't see anything in ${direct_object.articlename} while it's closed. `;
              this.handleFailure(msg);
              return null;
            }
          } // in

          // TRY > ONENOUN > PREPOSITION > FROM
          // from is a special case where player must be nested in the object
          if ("from" === direct_preposition) {
            results = this.tryFrom(direct_object);
            if ("undefined" !== typeof results) return results;
          } // from

          // TRY > ONENOUN > PREPOSITION > WITH
          // with is a special case for things with
          // .iov.look.enabled === true
          // with needs to be disambiguated from "is.lookthroughable" as they may
          // mean the same thing for some objects (e.g. a magnifying glass)
          // but not for others (e.g. a flashlight)
          if (
            "with" === direct_preposition &&
            direct_object.quirks.look_with_means_look_through
          ) {
            direct_preposition = "through";
            input.setPreposition(1, "through");
          }

          // TRY > ONENOUN > PREPOSITION > WITH
          if ("with" === direct_preposition) {
            results = this.tryWith(direct_object);
            if ("undefined" !== typeof results) return results;
          } // with

          // TRY > ONENOUN > PREPOSITION > THROUGH
          // through is a special case that handles
          // assets with is.lookthroughable = true
          else if ("through" === direct_preposition) {
            results = this.tryThrough(direct_object);
            if ("undefined" !== typeof results) return results;
          } // through

          // otherwise if there's a description we'll just provide that.
          else if (direct_object.descriptions[direct_preposition]) return true;
          // TRY > ONENOUN > PREPOSITION > NO ASPECT OR DESCRIPTION
          // no aspect for this preposition
          else if (
            !direct_object.hasDescription(direct_preposition) &&
            !direct_object.hasAspectAt(direct_preposition)
          ) {
            this.game.debug(
              `F1017 | ${this.name}.js | ${direct_object.id}.aspects.${direct_preposition} is not defined`,
            );
            msg += `$(We) can't see anything ${direct_preposition} ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // TRY > ONENOUN > PREPOSITION > EMPTY ASPECT
          // aspect is enabled, but empty
          else if (
            direct_object.hasAspectAt(direct_preposition) &&
            !direct_object.hasContentsAtAspect(direct_preposition) &&
            !direct_object.hasVesselAtAspect(direct_preposition)
          ) {
            this.game.debug(
              `F1102 | ${this.name}.js | ${direct_object.id}.aspects.${direct_preposition} is empty`,
            );
            msg += `$(We) don't see anything ${direct_preposition} ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        } // direct_preposition
      } // verb noun / verb preposition noun

      // TRY > TWONOUNS
      // sentence structure: verb noun preposition noun / verb preposition noun preposition noun
      else if (
        input.hasStructure("verb noun preposition noun") ||
        input.hasStructure("verb preposition noun preposition noun")
      ) {
        // "look at x with y" and "look at x through y" are the only
        // versions of this we accept

        // what about "look through window with telescope" ?

        // TRY > TWONOUNS > NO INDIRECT PREPOSITION
        // this should get caught by sentence structure check
        // in parseInput.js but leaving it here for now
        if (!indirect_preposition) {
          this.game.debug(`F1228 | ${this.name}.js | no indirect_preposition`);
          msg += `$(We) can't look ${direct_preposition} ${direct_object.articlename} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // TRY > TWONOUNS > AT

        // TRY > TWONOUNS > AT > WITH MEANS THROUGH
        if (
          indirect_preposition === "with" &&
          indirect_object.quirks.look_with_means_look_through
        ) {
          this.game.print(
            `F1848 | ${this.name}.js | direct_preposition 'with' means 'through'`,
          );
          indirect_preposition = "through";
          input.setPreposition(2, "through");
        }

        // TRY > TWONOUNS > AT > WITH
        if (indirect_preposition === "with") {
          results = this.tryWith(indirect_object);
          if ("undefined" !== typeof results) return results;
        }

        // TRY > TWONOUNS > AT > THROUGH
        else if (indirect_preposition === "through") {
          this.game.print(
            `F1849 | ${this.name}.js | direct_preposition 'through'`,
          );
          results = this.tryThrough(indirect_object);
          if ("undefined" !== typeof results) return results;
        }

        // TRY > TWONOUNS > AT > FROM
        // from is a special case where player
        // must be nested in the object
        else if (indirect_preposition === "from") {
          this.game.print(
            `F1850 | ${this.name}.js | direct_preposition 'from'`,
          );
          results = this.tryFrom(indirect_object);
          if ("undefined" !== typeof results) return results;
        } // from

        // TRY > TWONOUNS > AT > NO INDIRECT ASPECT
        // assume indirect preposition is aspect
        // and check for it
        else if (!indirect_object.hasAspectAt(indirect_preposition)) {
          this.game.debug(
            `F1226 | ${this.name}.js | ${indirect_object.id} has no ${indirect_preposition} aspect`,
          );
          msg += `$(We) don't see anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // TRY > TWONOUNS > AT > NO PLACE
        // if indirect_object has aspect, check if direct_object is in it
        else if (
          indirect_object.hasAspectAt(indirect_preposition) &&
          !direct_object.isPlacedAtAspectAndAsset(
            indirect_preposition,
            indirect_object.id,
          )
        ) {
          this.game.debug(
            `F1225 | ${this.name}.js | ${direct_object.id} not ${indirect_preposition} ${indirect_object.id}`,
          );
          msg += `${direct_object.Articlename} is not ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        } else if (
          direct_preposition !== "at" &&
          !direct_object.hasAspectAt(direct_preposition)
        ) {
          this.game.debug(
            `F1227 | ${this.name}.js | ${direct_preposition} is not at`,
          );
          msg += `$(We) can't look ${indirect_preposition} ${indirect_object.articlename} ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun / verb preposition noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var nest_asset = player.getNestAsset();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";

      // sentence structure: verb
      if (input.hasStructure("verb")) {
        this.game.printCurrentRoom({ verbose: true });
        return true;
      } // verb

      // sentence structure: verb noun / verb preposition noun
      if (
        input.hasStructure("verb noun") ||
        input.hasStructure("verb preposition noun")
      ) {
        // SUCCESS > ONENOUN > NOUN IS DIRECTION
        // did player look in a direction?
        if (input.parsedNoun1.matches.direction) {
          if (direct_object.hasDescription()) {
            this.game.debug(
              `F1229 | ${this.name}.js | print ${direct_object.id}.descriptions.look`,
            );
            msg += direct_object.getDescription();
          } else {
            // otherwise print this
            this.game.debug(
              `F1018 | ${this.name}.js | ${direct_object.id} has no description`,
            );
            msg += `$(We) see nothing special about ${direct_object.articlename}. `;
          }
          this.handleSuccess(msg, direct_object);
          return true;
        } // direction

        // SUCCESS > ONENOUN > NO PREPOSITION
        // no preposition was provided, so print the default description
        if (!direct_preposition || direct_preposition === "at") {
          this.game.debug(
            `F1049 | ${this.name}.js | print default description or indirect description`,
          );

          // See if there's an indirect description for this. For example,
          // if user is in tree and inputs "look at floor from tree"
          // see if author has written a description for that.
          if (
            nest_asset &&
            direct_object.hasIndirectDescription("look", "from", nest_asset)
          ) {
            msg += direct_object.getIndirectDescription(
              "look",
              "from",
              nest_asset,
            );
            this.handleSuccess(msg, direct_object);
            return true;
          } else if (direct_object.hasDescription()) {
            msg += direct_object.getDescription();
          }

          msg += direct_object.getPrintableListOfContents({
            caller: "examine",
          });
          this.handleSuccess(msg, direct_object);
          return true;
        }

        // first try getting a description

        // SUCCESS > ONENOUN > PREPOSITION
        if (direct_preposition) {
          // SUCCESS > ONENOUN > PREPOSITION > FIND DESCRIPTION
          // if author has set a description, default to that
          // it overrides any other considerations
          // This is meant to handle things like "look through telescope"
          // where the telescope has a description, but no "through" aspect
          if (direct_object.hasDescription(direct_preposition)) {
            // otherwise see if A.descriptions has a field for "at A"
            this.game.debug(
              `F1221 | ${this.name}.js | print '${direct_preposition} ${direct_object.id}'`,
            );
            msg += direct_object.getDescription(direct_preposition);
            this.handleSuccess(msg, direct_object);
            return true;
          }

          // SUCCESS > ONENOUN > PREPOSITION > FROM
          // From assumes player is nested on direct_object
          // and we've already checked for that. If player defined a description
          // for "from", we would've already provided that above in
          // FIND DESCRIPTION. If we're here we didn't find that,
          // so use the default room description.
          if ("from" === direct_preposition) {
            this.game.debug(
              `F1223 | ${this.name}.js | print 'from' description`,
            );
            msg += `From $(our) position ${player.getNestPreposition()} 
                ${direct_object.articlename} $(we) can see `;
            msg += this.game.getCurrentRoom().use_definite_article_in_lists
              ? this.game.getCurrentRoom().articlename
              : this.game.getCurrentRoom().name;
            msg += `, which does not look any different from this perspective. `;
            this.handleSuccess(msg, direct_object);
            return true;
          }

          // SUCCESS > ONENOUN > PREPOSITION > DEFAULT
          // otherwise just describe the aspect's contents
          if (direct_object.hasAspectAt(direct_preposition)) {
            this.game.debug(
              `F1051 | ${this.name}.js | print '${direct_preposition} ${direct_object.id} contents'`,
            );
            msg +=
              direct_object.getPrintableListOfContentsAt(direct_preposition) ||
              `$(We) don't see anything ${direct_preposition} ${direct_object.articlename}. `;
            this.handleSuccess(msg, direct_object);
            return true;
          }
        }
      } // verb noun / verb preposition noun

      // SUCCESS > TWONOUNS
      // sentence structure: verb noun preposition noun / verb preposition noun preposition noun
      else if (
        input.hasStructure("verb noun preposition noun") ||
        input.hasStructure("verb preposition noun preposition noun")
      ) {
        this.game.debug(
          `F1048 | ${this.name}.js | print success with two nouns`,
        );
        if (
          direct_object.hasIndirectDescription(
            direct_preposition,
            indirect_preposition,
            indirect_object,
          )
        ) {
          // if player input "look at A with B"
          // and A.descriptions has a field for "with B"
          msg += direct_object.getIndirectDescription(
            direct_preposition,
            indirect_preposition,
            indirect_object,
          );
        } else if (direct_object.hasDescription(direct_preposition)) {
          // otherwise see if A.descriptions has a field for "at A"
          msg += direct_object.getDescription(direct_preposition);
        } else {
          // otherwise print this
          msg += `Looking ${direct_preposition} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename} doesn't reveal anything new. `;
        }
        if (direct_preposition === "at") {
          // if player input "look at asset" print anything that's visible
          msg += direct_object.getPrintableListOfContents({
            caller: "examine",
          });
        } else {
          // if player input "look in asset" only print what's inside
          msg += direct_object.getPrintableListOfContentsAt(direct_preposition);
        }
        this.handleSuccess(msg, direct_object);
        return true;
      } // verb noun preposition noun / verb preposition noun preposition noun

      // player shouldn't see this, but just in case
      this.game.debug(`F1031 | ${this.name}.js | default`);
      msg += `$(We) see nothing special. `;
      this.handleSuccess(msg, direct_object);
      return true;
    }, // doSuccess
  };
})();

// move.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class move
   * @ajsnode game.dictionary.verbs.move
   * @ajsconstruct MyGame.createVerb({ "name": "move", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning move an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; move sofa north</span>
   * You move the sofa north, into the parlor. Yup, it
   * definitely looks better there against the sunny window.
   * </pre>
   * <p>
   * <strong>Move</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} in a direction.
   * Requires that the Asset has
   * asset.dov.move.enabled set to true.
   * If successful, will move
   * player and Asset to new
   * {@link adventurejs.Room|Room}.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.move = {
    name: "move",
    prettyname: "move",
    past_tense: "moved",
    synonyms: ["move", "slide"],

    /**
     * @ajsverbstructures
     * @memberof move
     */
    accepts_structures: [
      "verb noun",
      "verb noun noun",
      "verb noun preposition noun",
      "verb noun preposition noun preposition noun",
    ],

    /**
     * @memberof move
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof move
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     // direction: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof move
     * @ajsverbphrase
     * phrase3:
     * {
     *   // only supports form: move asset from asset to asset
     *   accepts_noun:true,
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase3: {
      accepts_noun: true,
      accepts_preposition: true,
      requires_preposition: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof move
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var indirect_object2 = input.getAsset(3);
      var indirect_preposition2 = input.getPreposition(3);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      if (!direct_object.isDOV("move") && !direct_object.isDOV("take")) {
        // if you can take it, you can move it
        this.game.debug(
          `F1351 | move.js | ${direct_object.id}.dov.move.enabled is false `
        );
        msg += `$(We) can't move ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (
        indirect_object &&
        indirect_object.direction &&
        !direct_object.can.push_from_room &&
        !direct_object.isDOV("take")
      ) {
        this.game.debug(
          `F1352 | move.js | ${direct_object.id}.can.push_from_room is false `
        );
        msg += `$(We) can't move ${direct_object.articlename} out of the room. `;
        this.handleFailure(msg);
        return null;
      }

      if (input.hasStructure("verb noun noun")) {
        if (!indirect_object.direction) {
          // player input "move asset asset"
          this.game.debug(
            `F1675 | move.js | ${indirect_object.id} is not direction `
          );
          msg += this.game.parser.getUnparsedMessage(input.input);
          this.handleFailure(msg);
          return null;
        }
      }

      if (input.hasStructure("verb noun preposition noun preposition noun")) {
        // did player input "move a from b to c"?
        if (indirect_preposition === "from" && indirect_preposition2 === "to") {
          // if so swap to/from because we're going to drop from at a later step
          input.swapPhrases(2, 3);
          indirect_preposition = "to";
          indirect_preposition2 = "from";
          indirect_object = input.getAsset(2);
          indirect_object2 = input.getAsset(3);
        }

        if (indirect_preposition !== "to" || indirect_preposition2 !== "from") {
          // we don't handle any other phrases in this structure
          this.game.debug(
            `F1686 | push.js | sentence structure is 'verb noun preposition noun preposition noun' but phrase is not handled`
          );
          msg += this.game.parser.getUnparsedMessage(input.input);
          this.handleFailure(msg);
          return null;
        }

        // is asset at the "from" location?
        if (direct_object.getPlaceAssetId() !== indirect_object2.id) {
          this.game.debug(
            `F1687 | move.js | ${direct_object.id} is not ${indirect_object2.default_aspect} ${indirect_object2.id}`
          );
          msg += `${direct_object.Articlename} is not ${indirect_object2.default_aspect} ${indirect_object2.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // simplify this down to 'verb noun preposition noun'
        input.setStructure("verb noun preposition noun");
      } // verb noun preposition noun preposition noun

      if (input.hasStructure("verb noun preposition noun")) {
        if (direct_object === indirect_object) {
          this.game.debug(
            `F1676 | move.js | direct_object ${direct_object.id} is indirect_object ${indirect_object.id} `
          );
          msg += `$(We) can't move ${direct_object.articlename} ${indirect_preposition} itself. `;
          this.handleFailure(msg);
          return null;
        }

        // is prep across, over, or match direct object's position?
        // but not in same place as asset?
        if (
          [direct_object.getPlacePreposition(), "across", "over"].indexOf(
            indirect_preposition
          ) > -1 &&
          direct_object.getPlaceAsset().id !== indirect_object.id
        ) {
          this.game.debug(
            `F1677 | move.js | ${direct_object.id} is not ${indirect_preposition} ${indirect_object.id} `
          );
          msg += `${direct_object.Articlename} is not on ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        } // across over

        // is prep across, over, or match direct object's position?
        // and is in same place as asset?
        if (
          [direct_object.getPlacePreposition(), "across", "over"].indexOf(
            indirect_preposition
          ) > -1 &&
          direct_object.getPlaceAsset().id === indirect_object.id
        ) {
          // ok
        } else if ("off" === indirect_preposition) {
          if (
            "on" !== direct_object.getPlacePreposition() ||
            direct_object.getPlaceAssetId() !== indirect_object.id
          ) {
            this.game.debug(
              `F1678 | move.js | ${direct_object.id} is not on ${indirect_object.id} `
            );
            msg += `${direct_object.Articlename} isn't on ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        } // off
        else if ("to" === indirect_preposition) {
          // is player holding direct object and not indirect object?
          // redirect to put
          if (direct_object.isIn(player)) {
            this.game.debug(`F1683 | move.js | infer 'put', doVerb put`);
            input.setPreposition(2, indirect_object.default_aspect);
            this.game.dictionary.doVerb("put");
            return null;
          }

          // is asset already at target?
          if (direct_object.getPlaceAssetId() === indirect_object.id) {
            this.game.debug(
              `F1685 | move.js | ${direct_object.id} is already ${indirect_preposition} ${indirect_object.id} `
            );
            msg += `${
              direct_object.Articlename
            } is already ${direct_object.getPlacePreposition()} ${
              indirect_object.articlename
            }. `;
            this.handleFailure(msg);
            return null;
          }
        } // to
        else if (["toward", "near"].indexOf(indirect_preposition) > -1) {
          // are both things in the same place?
          if (
            direct_object.getPlaceAssetId() !==
            indirect_object.getPlaceAssetId()
          ) {
            this.game.debug(
              `F1682 | move.js | ${direct_object.id} is not in the same place as ${indirect_object.id} `
            );
            msg += `$(We) can't move ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        } // toward near
        else if (!indirect_object.hasAspectAt(indirect_preposition)) {
          this.game.debug(
            `F1679 | move.js | ${indirect_object.id} has no aspect at ${indirect_preposition} `
          );
          msg += `$(We) can't move ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (
          -1 !== "in on under behind".indexOf(indirect_preposition) &&
          !indirect_object.hasAspectAt(indirect_preposition)
        ) {
          this.game.debug(
            `F1680 | move.js | ${indirect_object.id} has no aspect at ${indirect_preposition} `
          );
          msg += `$(We) can't move anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (indirect_object.hasAspectAt(indirect_preposition)) {
          results = this.tryToPutThisInThatAspect(
            direct_object,
            indirect_preposition,
            indirect_object
          );
          if (results.fail) {
            msg = results.msg;
            this.handleFailure(msg);
            if (results.end_turn) return false;
            return null;
          }
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;
      var results1, results2;

      this.game.debug(`F1684 | move.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        msg += `$(We) nudge ${direct_object.articlename}. `;
      }

      if (indirect_object && indirect_object.direction) {
        results = this.game.tryTravel(indirect_object.direction, {
          with: [direct_object.id],
        });
        if (A.isFalseOrNull(results)) return results;
        // no msg because tryTravel handled it
      }

      if (input.hasStructure("verb noun noun")) {
      }

      if (input.hasStructure("verb noun preposition noun")) {
        if (
          [direct_object.getPlacePreposition(), "across", "over"].indexOf(
            indirect_preposition
          ) > -1 &&
          direct_object.getPlaceAsset().id === indirect_object.id
        ) {
          msg += `$(We) nudge ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        } // across over
        else if (
          -1 < "in on under behind".indexOf(indirect_preposition) &&
          indirect_object.hasAspectAt(indirect_preposition)
        ) {
          results1 = direct_object
            .getPlaceAsset()
            .onRemoveThatFromThis(direct_object);
          if (!A.isFalseOrNull(results1)) {
            results2 = indirect_object.onMoveThatToThis(
              direct_object,
              "behind"
            );
          }
          if (A.isFalseOrNull(results1) || A.isFalseOrNull(results2)) {
            msg = `$(We're) prevented from moving ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          }
        } // in on under behind
        else if ("off" === indirect_preposition) {
          results1 = indirect_object.onRemoveThatFromThis(direct_object);
          if (!A.isFalseOrNull(results1)) {
            results2 = indirect_object
              .getPlaceAsset()
              .onMoveThatToThis(
                direct_object,
                indirect_object.getPlacePreposition()
              );
          }
          if (A.isFalseOrNull(results1) || A.isFalseOrNull(results2)) {
            msg = `$(We're) prevented from moving ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          } else {
            msg = `$(We) move ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          }
        } // off
        else if ("to" === indirect_preposition) {
          // move one thing to another implies picking it up
          // which means it passes through player
          // this might be overkill, can we skip the player passthrough?
          var oldlocation = direct_object.getPlaceAsset();

          // remove direct object from indirect object
          results = oldlocation.onRemoveThatFromThis(direct_object);
          if ("undefined" !== typeof results) return results;

          // player has to pick this up
          // set direct object's temporary location to player
          results = player.onMoveThatToThis(direct_object);
          if ("undefined" !== typeof results) return results;

          // remove noun1 from player
          results = player.onRemoveThatFromThis(direct_object);
          if ("undefined" !== typeof results) return results;

          // set noun1's new location to noun2
          results = indirect_object.onMoveThatToThis(
            direct_object,
            indirect_preposition
          );
          if ("undefined" !== typeof results) return results;

          msg = `$(We) move ${direct_object.articlename} from ${oldlocation.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        } // to
        else if (["toward", "near"].indexOf(indirect_preposition) > -1) {
          // no status changes at the moment
          msg += `$(We) move ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        } // toward near
      } // verb noun preposition noun

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    }, // move
  };
})();

// nothing.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class nothing
   * @ajsnode game.dictionary.verbs.nothing
   * @ajsconstruct MyGame.createVerb({ "name": "nothing", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb meaning do nothing (expends a turn).
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; nothing</span>
   * You do nothing.
   * </pre>
   * <p>
   * <strong>Nothing</strong> does nothing. Similar to
   * {@link wait}.
   * </p>
   */
  A.Preverbs.nothing = {
    name: "nothing",
    prettyname: "nothing",
    synonyms: ["nothing"],

    /**
     * @ajsverbstructures
     * @memberof nothing
     */
    accepts_structures: ["verb"],

    do: function () {
      var input = this.game.getInput();
      var msg = "$(We) do nothing.";
      if (msg) this.game.print(msg, input.output_class);
      return;
    },
  };
})();

// oops.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class oops
   * @ajsnode game.dictionary.verbs.oops
   * @ajsconstruct MyGame.createVerb({ "name": "oops", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb meaning replace unknown word with new input.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; sacrifice virgin on walter/span>
   * I don't know of anything called 'walter'.
   * <span class="input">&gt; oops alter</span>
   * You sacrifice the virgin on the alter, thereby opening the
   * seventh seal and damning all of mankind to a thousand years
   * of runny eggs, unstylish Crocs knockoffs, and community theater.
   * </pre>
   * <p>
   * <strong>Oops</strong> allows players to correct a mistake in
   * the previous turn.
   * </p>
   */
  A.Preverbs.oops = {
    name: "oops",

    /**
     * @ajsverbstructures
     * @memberof exits
     */
    accepts_structures: ["verb noun"],

    /**
     * @memberof oops
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
    },

    let_verb_handle_disambiguation: true,
    let_verb_handle_remaining_input: true,
    msgNoObject: "Oops?",

    do: function () {
      var input = this.game.getInput();
      // everything after 'oops '
      var replacementWord = input.input.substring(4).trim();
      this.game.log("log", "high", "oops " + replacementWord, "verbs");

      if ("object" === typeof replacementWord) {
        replacementWord = replacementWord.input;
      }

      var lastInput = this.game.parser.input_history[1].parsed_input;
      if (!this.game.parser.input_history[1].unknown_word) {
        var msg = "Oops indeed.";
        this.handleFailure(msg);
        return false;
      }

      var lastInputUnknownWord = this.game.parser.input_history[1].unknown_word;

      // TODO disambiguation
      if ("undefined" !== typeof lastInputUnknownWord) {
        lastInput = lastInput.replace(lastInputUnknownWord, replacementWord);
        this.game.parser.input_queue.push({
          input: lastInput,
          printInput: false,
        });
        return;
      }

      // TODO disambiguation
      if (!replacementWord) {
        var msg = "Oops found nothing to oops.";
        this.handleFailure(msg);
        return false;
      }

      var msg = `Oops found ${replacementWord}. `;
      this.handleFailure(msg);
      return true;
    },
  };
})();

// open.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class open
   * @ajsnode game.dictionary.verbs.open
   * @ajsconstruct MyGame.createVerb({ "name": "open", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading OpenCloseVerbs
   * @ajscaninferindirect true
   * @summary Verb meaning open asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; open refrigerator</span>
   * You open the refrigerator. Contrary to the expectations created
   * by a lifetime of watching film, it does NOT contain the bloody
   * corpse of a wife or girlfriend, nor does it contain rotting meat
   * replete with buzzing flies, nor is it comically empty. In fact,
   * this refrigerator (or 'fridge, if you prefer) is full, nay, packed,
   * with healthy and nutritious looking fruits and vegetables.
   * </pre>
   * <p>
   * <strong>Open</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset to open has
   * <code>asset.dov.open.enabled</code> set to true and
   * <code>asset.is.closed</code> set to true.
   * For the sake of giving better user experience, "open" is
   * generously interpreted according to context, since players
   * might use it broadly in several contexts. For example,
   * "open" can be understood to mean unlock, unseal, unzip, or
   * unplug, if conditions suggest that's what the user means.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @ajsdemo OpenGame, SittingRoom, Library, Playground, Objects
   */
  A.Preverbs.open = {
    name: "open",
    prettyname: "open",
    past_tense: "opened",
    synonyms: ["open"],
    unstate: "closed",
    enqueue_collections: true,

    /**
     * @ajsverbstructures
     * @memberof open
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof open
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     singular: false,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        singular: false,
      },
    },

    /**
     * @memberof open
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof open
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // has direct object got a registered drain asset?
      // if so use that as direct object
      if (direct_object.registered_parts?.Drain) {
        direct_object = this.game.getAsset(
          direct_object.registered_parts.Drain,
        );
        if (!direct_object) return null;
        input.setAsset(1, direct_object);
        input.setAssumed(1, true);
      }

      // did player input "open drain"
      // where open means unplug?
      if (direct_object.isDOV("unplug") && direct_object.is.plugged) {
        this.game.debug(
          `F1367 | ${this.name}.js | ${direct_object.id}.dov.plug, doVerb plug `,
        );
        this.game.dictionary.doVerb("unplug");
        return null;
      }

      // we give some latitude in interpreting 'open'
      // see if any of these verbs can be applied
      var openverbs = ["unlock", "pick", "unseal", "unzip"]; // unplug needs additional logic
      for (var i = 0; i < openverbs.length; i++) {
        if (
          direct_object.isDOV(openverbs[i]) &&
          !direct_object.isState(openverbs[i])
        ) {
          // @TODO this complicates verb.with_results when open-> unlock with auto-open
          // may need to rethink or add a setting for it
          if (direct_object.DOVallowWithNothing(openverbs[i])) {
            input.verb_params.auto_open = true;
            this.game.debug(
              `F1707 | ${this.name}.js | ${direct_object.id}.is.locked, doVerb unlock `,
            );
            this.game.dictionary.doVerb(openverbs[i]);
            return null;
          }

          this.game.debug(
            `F1703 | ${this.name}.js | ${
              direct_object.id
            }.is.${this.game.dictionary.verbs[openverbs[i]].getState()}`,
          );
          msg += `${direct_object.Articlename} is ${this.game.dictionary.verbs[
            openverbs[i]
          ].getState()}. `;
          this.handleFailure(msg);
          return false;
        }
      }

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1144 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1145 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.Articlename} isn't ${this.getState()}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1825 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1754 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1756 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1356 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1357 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1904 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1810 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1695 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // printable contents?
      if (direct_object.hasContentsAtAspect("in")) {
        msg += direct_object.getPrintableListOfContentsAt("in");
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // open

// pick.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class pick
   * @ajsnode game.dictionary.verbs.pick
   * @ajsconstruct MyGame.createVerb({ "name": "pick", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading OpenCloseVerbs
   * @summary Verb meaning pick an asset, as in picking a lock.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; pick cabinet lock with bobby pin</span>
   * You pick the cabinet lock with the bobby pin. The pin snaps, but
   * the cabinet door releases with a satisfying click. You quietly
   * slide the door open, revealing a rat's nest of file folders.
   * </pre>
   * <strong>Pick</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the lock has
   * asset.dov.pick.enabled set to true and its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_is_locked">is.locked</a>
   * property set to true.
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @ajsdemo OpenGame, SittingRoom, Library, Playground, Objects
   */
  A.Preverbs.pick = {
    name: "pick",
    prettyname: "pick",
    past_tense: "picked",
    synonyms: ["pick"],
    unstate: "locked",

    /**
     * @ajsverbstructures
     * @memberof pick
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof pick
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof pick
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof pick
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // verb enabled?
      if (!direct_object.isDOV("pick")) {
        this.game.debug(
          `F1362 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += direct_object.isDOV("unlock")
          ? `$(We're) unable to pick ${direct_object.articlename}. `
          : `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1363 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is false`,
        );
        msg += `${direct_object.Articlename} isn't ${this.getState()}. `;
        this.handleFailure(msg);
        return false;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1826 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1466 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1364 | ${this.name}.js | soft prompt for noun2 `);
          msg += input.verb_params.auto_open
            ? `${direct_object.Articlename} is locked. `
            : ``;
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1479 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1702 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1905 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1811 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";
      var auto_open = false;

      this.game.debug(`F1361 | ${this.name}.js | print doSuccess `);

      if (input.verb_params.auto_open) {
        direct_object.setClosed(false); //is.closed = false;
        direct_object.incrementDoVerbCount("open", 1);
        auto_open = true;
      }

      // apply state changes
      this.setState(direct_object, false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `${auto_open ? " and open it" : ""}`;
      msg += `. `;

      // printable contents?
      if (auto_open && direct_object.hasContentsAtAspect("in")) {
        msg += direct_object.getPrintableListOfContentsAt("in");
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // pick

// plug.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class plug
   * @ajsnode game.dictionary.verbs.plug
   * @ajsconstruct MyGame.createVerb({ "name": "plug", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @ajsstate plugged
   * @summary Verb meaning plug, as in "plug sink".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display">
   * <span class="input">&gt; plug rusty drain</span>
   * You plug the rusty drain with the rubber stopper. It makes a
   * poor seal and probably won't hold water for very long.
   * Whatever you have in mind, you'd better do it quickly.
   * </pre>
   * <p>
   * <strong>Plug</strong> can be understood a couple of ways.
   * In the case of a sink that can be plugged without
   * the use of another asset, "plug sink" will be equivalent
   * to open/close. Here's how you might create this sink:
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Sink",
   *   name: "sink",
   *   dov: { plug: { with_nothing: true, }, },
   * })</code></pre>
   * <p>
   * In the case of a sink that can be plugged by inserting another asset,
   * like a stopper, to plug it, "plug sink with stopper" will mean
   * putting the stopper in the sink (or sink drain, if it has one).
   * Here's how you might create this sink and stopper:
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Sink",
   *   name: "sink",
   *   dov: { plug: { with_assets: ['stopper'], }, },
   * })
   * MyGame.createAsset({
   *   class: "Plug",
   *   name: "stopper",
   *   iov: { plug: { with_assets: ['sink'], }, },
   * })</code></pre>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @ajsdemo PlugGame, PlugSomethingIntoSomething, PlugSomethingIntoNothing, PlugSomethingWithSomething, PlugSomethingWithNothing
   */
  A.Preverbs.plug = {
    name: "plug",
    prettyname: "plug",
    past_tense: "plugged",
    synonyms: ["plug"],
    state: "plugged",
    state_strings: { state: "plugged", unstate: "unplugged" },
    state_string: "plugged",
    unstate_string: "unplugged",

    /**
     * @ajsverbstructures
     * @memberof plug
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof plug
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   accepts_preposition: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof plug
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     in_inventory_if_takeable: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: [ "with" ],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        in_inventory_if_takeable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof plug
     * @ajsverbparams
     * with_params: {
     *   connections: [],
     *   max_connections: 1,
     *   take_breaks_connections: true,
     *   take_takes_connections: false,
     * },
     */
    with_params: {
      connections: [],
      max_connections: 1,
      take_breaks_connections: true,
      take_takes_connections: false,
    },

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";
      var drain;

      // has direct object got a registered drain?
      if (direct_object.registered_parts?.Drain) {
        drain = this.game.getAsset(direct_object.registered_parts.Drain);
        if (drain) {
          direct_object = drain;
          input.setAsset(1, direct_object);
          input.setAssumed(1);
        }
      }

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // can be direct object of verb?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1730 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1766 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.Articlename} is already ${this.getState()}. `;
        this.handleFailure(msg);
        return false;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1827 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1366 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1470 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1243 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `${direct_object.Articlename} doesn't need anything to ${this.name} it with. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1715 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1906 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1812 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var direct_place = direct_object.getPlaceAsset();
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";
      var results;

      this.game.debug(`F1365 | ${this.name}.js | print doSuccess `);

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // is plug in player inventory?
        if (indirect_object.isIn(player)) {
          // remove indirect_object from player
          results = indirect_object.moveFrom(player);
          if ("undefined" !== typeof results) return results;
        }

        // move indirect_object to direct_object
        results = indirect_object.moveTo("in", direct_object);
        if ("undefined" !== typeof results) return results;

        // connect direct object to indirect object
        this.setVerbSubscriptionConnection(direct_object, indirect_object);
        //direct_object.DOVsetConnection(this.name, indirect_object);
      }

      // apply state changes
      this.setState(direct_object, true);
      // partially redundant because if we have an indirect object
      // it'll have been handled by onMoveThatToThis but still required
      // if dov.plug.with_nothing = true

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // plug

// plugIn.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class plugIn
   * @ajsnode game.dictionary.verbs.plugIn
   * @ajsconstruct MyGame.createVerb({ "name": "plugIn", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @ajsstate pluggedIn
   * @summary Verb meaning plug in, as in "plug in computer".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; plug computer into socket</span>
   * You plug the ancient computer into the dusty socket. Nothing happens.
   * But wait! Was that a flicker of light? It was! A small red light blinks on.
   * And then another, and another as the ancient computer begins to wake.
   * You hear a deep thrumming sound that rises in pitch until it becomes a
   * painful screeching whine. And then silence. Until. The computer speaks!
   * "THIS WORLD IS MINE!" Uh oh.
   * </pre>
   * <p>
   * <strong>PlugIn</strong> applies to the physical act of attaching one
   * asset to another, such as plugging in a computer. If
   * <code>asset.dov.plugIn.with_nothing</code>
   * is true, players can input "plug in computer" without specifying a
   * particular asset to plug the computer into, and it will just be
   * implied that the computer is plugged into a wall outlet.
   * Conversely, in order to specify an asset such as an outlet to plug
   * the computer into, enter asset IDs into the computer's
   * <code>asset.dov.plugIn.with_assets</code>.
   * This distinction exists so that authors can choose how fiddly
   * they want to get.
   * Note that plugIn is distinct from
   * <a href="/doc/plug.html">Plug</a>, which pertains to plugging things like
   * drains.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @ajsdemo PlugGame, PlugSomethingIntoSomething, PlugSomethingIntoNothing, PlugSomethingWithSomething, PlugSomethingWithNothing
   */
  A.Preverbs.plugIn = {
    name: "plugIn",
    prettyname: "plug in",
    past_tense: "plugged in",
    verb_noun_prep: ["plug in"], // plug computer in
    verb_prep_noun: ["plug in"], // plug in computer
    verb_noun_prep_noun: ["plug into", "plug in"], // plug computer into outlet
    state: "pluggedIn",
    state_string: "plugged in",
    unstate_string: "not plugged in",

    /**
     * @ajsverbstructures
     * plugIn is parsed as a compound word which means that we
     * don't parse 'in' as a separate word and therefore don't
     * accept 'verb noun preposition noun' as with many other verbs.
     * @memberof plugIn
     */
    accepts_structures: ["verb noun", "verb noun noun"],

    /**
     * @memberof plugIn
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   //accepts_preposition: true,
     *   //accepts_these_prepositions: ["in"],
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof plugIn
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   //requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   //accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: [ "to" ],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      //requires_preposition: true,
      //accepts_these_prepositions: [ "to" ],
    },

    /**
     * @memberof plugIn
     * @ajsverbparams
     * with_params: {
     *   connections: [],
     *   max_connections: 1,
     *   take_breaks_connections: true,
     *   take_takes_connections: false,
     * },
     */
    with_params: {
      connections: [],
      max_connections: 1,
      take_breaks_connections: true,
      take_takes_connections: false,
    },

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";
      var drain;

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // can be direct object of verb?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1765 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      // already plugged into nothing? // takes place of state check
      if (
        direct_object.DOVallowWithNothing(this.name) &&
        direct_object.DOVisConnectedToNothing(this.name)
      ) {
        this.game.debug(
          `F1358 | ${this.name}.js | ${direct_object.id}.dov.plugIn.with_params.connections contains null `,
        );
        msg += `${direct_object.Articlename} is already plugged in. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun // ie plugIn computer
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1690 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.prettyname} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object);
        if (results.prompt) {
          // restructure sentence for next turn
          //input.setPreposition(2,'with');
          input.setSoftPrompt({
            noun2: true,
            structure: "verb noun noun",
          });
          this.game.debug(`F1692 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to plug ${direct_object.articlename} into? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "to";
          input.setNewPhrase({
            asset: indirect_object,
            preposition: indirect_preposition,
          });
          input.setStructure("verb noun noun");
        }
      } // verb noun

      // parsed sentence structure: verb noun noun
      // ie plugIn computer outlet
      if (input.hasStructure("verb noun noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1762 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't plug ${direct_object.articlename} into ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1763 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't plug ${direct_object.articlename} into ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1907 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1813 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }

        // is direct object already plugged in?
        if (
          direct_object.dov.plugIn.with_params.connections.length >=
          direct_object.dov.plugIn.with_params.max_connections
        ) {
          this.game.debug(
            `F1752 | ${this.name}.js | ${direct_object.id}.dov.plugIn.with_params.max_connections reached `,
          );
          msg += direct_object.DOVisConnectedToAsset(this.name, indirect_object)
            ? `${direct_object.Articlename} is already plugged into ${indirect_object.articlename}. `
            : `${direct_object.Articlename} can't be plugged into any more things. `;
          this.handleFailure(msg);
          return null;
        }

        // does indirect object already have max plugged into it?
        if (
          indirect_object.iov.plugIn.with_params.connections.length >=
          indirect_object.iov.plugIn.with_params.max_connections
        ) {
          this.game.debug(
            `F1760 | ${this.name}.js | ${indirect_object.id}.iov.plugIn.with_params.max_connections reached `,
          );
          msg += `${indirect_object.Articlename} can't have any more things plugged into it. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_place = direct_object.getPlaceAsset();
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";
      var results;

      this.game.debug(`F1723 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // connect direct object to null
        this.setVerbSubscriptionConnection(direct_object, null);
      } // verb noun

      // sentence structure: verb noun noun
      if (input.hasStructure("verb noun noun")) {
        // connect direct object to indirect object
        this.setVerbSubscriptionConnection(direct_object, indirect_object);

        // @TODO reconsider plug as one type of attachment
        // what to do if player moves between nests or tries travel?
        // if( direct_object.isIn(player) )
        // {
        //   // remove direct_object from player?
        //   results = indirect_object.moveFrom( player );
        //   if( "undefined" !== typeof results ) return results;
        // }
        // // move indirect_object to direct_object
        // results = indirect_object.moveTo( "in", direct_object );
        // if( "undefined" !== typeof results ) return results;
      } // verb noun noun

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) plug`;
      msg += `${indirect_object ? "" : " in"}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_object ? " into " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // plug

// point.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class point
   * @ajsnode game.dictionary.verbs.point
   * @ajsconstruct MyGame.createVerb({ "name": "point", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading GesticulationVerbs
   * @summary Verb meaning point a tangible asset.
   * @ajssynonyms point
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; point gun at thief</span>
   * You point the gun at the thief. He freezes, and a collection
   * of stolen goods clatters to the ground.
   * </pre>
   * <p>
   * Point a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}. Asset must have
   * asset.dov.point.enabled
   * set to true. There's no particular
   * code to handle pointing, so any special results will need
   * to be custom coded through a method such as setting a
   * verb override for the Asset. To learn about verb hooks,
   * see <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.point = {
    name: "point",
    prettyname: "point",
    past_tense: "pointed",
    synonyms: ["point"],
    state: "pointed",

    /**
     * @ajsverbstructures
     * @memberof point
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof point
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof point
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      accepts_preposition: true,
      requires_preposition: true,
      // accepts_these_prepositions: ["with"],
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
      },
    },

    /**
     * @memberof point
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1733 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      // skip verb state check for point because it's not a simple binary
      // if( this.hasState() && direct_object.isState(this.name) )
      // {
      //   this.game.debug(`XXXX | ${this.name}.js | ${
      //   direct_object.id
      // }.is.${this.getState()} is ${direct_object.isState(this.name)}`);
      //   msg += `${direct_object.Articlename} is already ${this.getState()}. `;
      //   this.handleFailure(msg);
      //   return false;
      // }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1828 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1798 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1799 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1761 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1800 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1908 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1814 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1764 | ${this.name}.js | print doSuccess `);

      // apply state changes
      // none

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // point

// poke.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class poke
   * @ajsnode game.dictionary.verbs.poke
   * @ajsconstruct MyGame.createVerb({ "name": "poke", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning poke an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; poke bear</span>
   * You poke the sleeping bear. It grumpfs and growls and then
   * rolls over, catching you up in one mighty arm and clutching
   * you to it like a teddy bear. Best settle in for a long winter.
   * </pre>
   * <p>
   * <strong>Poke</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset to be poked has
   * asset.dov.poke.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.poke = {
    name: "poke",
    prettyname: "poke",
    past_tense: "poked",
    synonyms: ["poke"],

    /**
     * @ajsverbstructures
     * @memberof poke
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof poke
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof poke
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     *   // @todo what about "poke person on nose"?
     *   // also possessive: "poke person's nose"
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof poke
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV("poke")) {
        this.game.debug(
          `F1370 | ${this.name}.js | ${direct_object.id}.dov.poke.enabled is false `,
        );
        msg += `$(We) can't poke ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state? skip

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1977 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      if (input.hasStructure("verb noun")) {
        // can verb act without an indirect object?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            ` | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1978 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        // if( direct_object.DOVallowWithNothing(this.name) )
        // {
        //   this.game.debug(` | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `);
        //   msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        //   this.handleFailure(msg);
        //   return null;
        // }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1979 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1980 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1981 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1371 | ${this.name}.js | print doSuccess `);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    }, // poke
  };
})();

// pour.js also means empty
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class pour
   * @ajsnode game.dictionary.verbs.pour
   * @ajsconstruct MyGame.createVerb({ "name": "pour", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning pour substance from an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; pour bottle into volcano</span>
   * You pour the bottle of vinegar into the papier-mÃ¢chÃ© volcano.
   * Nothing happens. As you lean in to investigate, you're disturbed
   * by a deep rumbling sound. You lean back. Nothing happens. You wait
   * for a long moment. You lean in and THE VOLCANO ERUPTS WITH THE SOULS
   * OF THE DAMNED! Wraiths stream from the sculpture, rise into the air
   * above the stone plinth, begin circling around the crowded
   * amphitheatre. The wisps spin faster and faster, raising a ghostly
   * vortex that climbs toward the darkening sky. Dammit, you knew you
   * should have used the Mentos and Coke method.
   * </pre>
   * <p>
   * <strong>Pour</strong> is a special case that also doubles
   * for <strong>empty</strong>. Because
   * {@link adventurejs.Aspect|Aspects} can contain both
   * {@link adventurejs.Tangible|Tangibles} and
   * {@link adventurejs.Substance|Substances}, pouring or emptying
   * means that both the Tangibles and the Substances will fall out
   * of the source {@link adventurejs.Asset|Asset}
   * and into the destination Asset. If the target is a Tangible,
   * depending on its capacity, it may not be able to hold all of the
   * contents of the source Asset. In this case, excess Tangibles and
   * Substances will overflow onto the floor.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.pour = {
    name: "pour",
    prettyname: "pour",
    past_tense: "poured",
    synonyms: ["pour"],

    /**
     * @ajsverbstructures
     * @memberof pour
     */
    accepts_structures: [
      "verb noun",
      "verb preposition noun",
      "verb noun preposition noun",
      "verb noun preposition noun preposition noun",
    ],

    /**
     * @memberof pour
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
    },

    /**
     * @memberof pour
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof pour
     * @ajsverbphrase
     * phrase3:
     * {
     *   accepts_noun:true,
     *   accepts_preposition:true,
     *   requires_preposition: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     * },
     */
    phrase3: {
      accepts_noun: true,
      accepts_preposition: true,
      requires_preposition: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
    },

    /**
     * @memberof pour
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var noun3 = input.getAsset(3);
      var preposition3 = input.getPreposition(3);
      var player = this.game.getPlayer();
      var containers;
      var msg = "";
      var results;

      // our goal is to get to
      // "verb noun preposition noun" aka "pour bucket into sink"
      // from whatever parsed sentence structure we've received

      // if input is "pour water"
      // if input is "pour water into sink"
      // find a container

      // if input is "pour bucket"
      // if input is "pour from bucket"
      // verify that bucket contains anything

      // if input is "pour water from bucket"
      // if input is "pour water from bucket into sink"
      // verify that bucket contains water

      // if input is "pour bucket into sink"
      // verify that bucket contains anything

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      // ex: pour water / pour bucket
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (input.hasStructure("verb preposition noun")) {
      }

      // call actions
      if (input.hasStructure("verb noun preposition noun")) {
        // pour bucket into sink
      }

      // call actions
      if (input.hasStructure("verb noun preposition noun preposition noun")) {
        // pour water from bucket into sink
        // empty water from bucket into sink
      }

      if (input.hasStructure("verb preposition noun")) {
        // pour from bucket

        // is preposition one that we support?
        // for many verbs we pre-define accepted prepositions
        // and wouldn't have to ask this here but pour needs
        // to be flexible to handle either substance or tangible
        if ("from" !== direct_preposition) {
          this.game.debug(
            `F1584 | ${this.name}.js | pour ${direct_preposition} isn't currently handled `
          );
          msg += `$(We) don't know how to pour ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // is direct object a substance?
        // usually we pre-check using NounMustBe but pour needs
        // to be flexible to handle either substance or tangible
        if (direct_object instanceof adventurejs.Substance) {
          this.game.debug(
            `F1736 | ${this.name}.js | ${direct_object.id} isn't Tangible class `
          );
          msg += `$(We) don't know how to pour from ${direct_object.name}. `;
          this.handleFailure(msg);
          return null;
        }

        // remove the "from" and treat it as "pour bucket"
        input.setPreposition(1, "");
        input.setStructure("verb noun");
      } // verb preposition noun

      // did player input "pour substance" with or without indirect object?
      if (
        direct_object instanceof adventurejs.Substance &&
        (input.hasStructure("verb noun") ||
          (input.hasStructure("verb noun preposition noun") &&
            "from" === indirect_preposition))
      ) {
        // if so we need to look for a container in inventory
        containers = this.game.findSubstanceContainers(direct_object.id, [
          "InInventory",
        ]);
        switch (containers.length) {
          case 0:
            this.game.debug(`F1739 | ${this.name}.js | no containers found `);
            msg += `$(We're) not carrying anything with ${direct_object.name} in it. `;
            this.handleFailure(msg);
            return null;
          case 1:
            // set direct object to the container
            // ie "pour water" becomes "pour bowl"
            input.verb_params.substance = direct_object;
            direct_object = this.game.getAsset(containers[0]);
            input.setAsset(1, direct_object);
            input.setAssumed(1, true);
            break;
          default:
            // disambiguate - set parsedNoun.matches for next turn
            this.game.debug(
              `F1740 | ${this.name}.js | multiple containers found, disambiguate `
            );
            // save containers back to input for next turn disambiguation
            input.setParsedNounMatchesQualified(1, containers);
            this.game.parser.printNounDisambiguation({
              parsedNoun: input.getParsedNoun(1),
              nounIndex: 1,
            });
            return null;
        } // switch
      } // find substance container

      if (input.hasStructure("verb noun")) {
        // pour water / pour bucket

        if (direct_object instanceof adventurejs.Tangible) {
          // does direct object contain any substance?
          if (!direct_object.doesContainAnySubstance()) {
            this.game.debug(
              `F1737 | ${this.name}.js | ${direct_object.id} doesn't contain substance `
            );
            msg += `${direct_object.Articlename} doesn't contain anything pourable. `;
            this.handleFailure(msg);
            return null;
          }

          // find target - player parent / room
          indirect_object = player.getNestOrPlaceAsset();
          indirect_preposition = player.getNestOrPlacePreposition();
          input.setAsset(2, indirect_object);
          input.setPreposition(2, indirect_preposition);
          input.setAssumed(2, true);
          input.setStructure("verb noun preposition noun");
        }
      } // verb noun

      if (input.hasStructure("verb noun preposition noun preposition noun")) {
        // pour water from bucket into sink

        // "from" is the only preposition we accept
        // for many verbs we already would have pre-checked this
        // but pour needs to be flexible to accommodate several syntax forms
        if ("from" !== indirect_preposition) {
          this.game.debug(
            `F1737 | ${this.name}.js | pour ${indirect_preposition} isn't currently handled `
          );
          msg += `$(We) don't know how to pour ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // is direct object a substance? that's the only class we handle in this form
        if (!(direct_object instanceof adventurejs.Substance)) {
          this.game.debug(
            `F1738 | ${this.name}.js | ${direct_object.id} isn't Substance class `
          );
          msg += `$(We) don't know how to pour ${direct_object.name}. `;
          this.handleFailure(msg);
          return null;
        }

        // does indirect object contain direct object?
        if (!indirect_object.doesContainSubstance(direct_object.id)) {
          this.game.debug(
            `F1557 | ${this.name}.js | ${indirect_object.id} does not contain ${direct_object.id} `
          );
          msg += `${indirect_object.Articlename} doesn't contain ${direct_object.name}. `;
          this.handleFailure(msg);
          return null;
        }

        // did player input "pour substance from A to B"?
        // that's a reasonable phrase, but 'to' isn't a
        // normal aspect so change it to default aspect
        if ("to" === preposition3) {
          preposition3 = noun3.default_aspect;
          input.setPreposition(3, preposition3);
        }

        // though player explicitly named substance as direct object,
        // now that we've confirmed its presence in indirect object,
        // we're removing it from the input to streamline handling
        input.verb_params.substance = direct_object;
        input.setPhrase(1, input.getPhrase(2));
        direct_object = input.getAsset(1);
        direct_preposition = input.getPreposition(1);
        input.setPhrase(2, input.getPhrase(3));
        indirect_object = input.getAsset(2);
        indirect_preposition = input.getPreposition(2);
        input.setPhrase(3, {});
        input.setStructure("verb noun preposition noun");
      }

      if (input.hasStructure("verb noun preposition noun")) {
        // pour bucket into sink

        // we've already checked for "pour water into sink"
        // and replaced water with bucket

        // is direct_object in player?
        if (!direct_object.isIn(player)) {
          this.game.debug(
            `F1552 | ${this.name}.js | ${direct_object.id}.place not in player `
          );
          msg += `$(We're) not carrying ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // does direct_object have vessel?
        if (!direct_object.hasVessel()) {
          this.game.debug(
            `F1271 | ${this.name}.js | ${direct_object.id} has no aspect with vessel `
          );
          msg += `$(We) can't pour ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // does target have aspect?
        if (
          !indirect_object.hasAspectAt(indirect_preposition) &&
          "on" !== indirect_preposition
        ) {
          // took away a check for floor here as in "pour bucket on floor"
          // but we're going to allow "pour on" anything regardless of aspects
          this.game.debug(
            `F1550 | ${this.name}.js | ${indirect_object.id} does not have ${indirect_preposition} aspect `
          );
          msg += `$(We) can't pour ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // is direct_object closed?
        if (direct_object.isDOV("open")) {
          this.game.debug(
            `F1272 | ${this.name}.js | ${direct_object.id}.is.closed `
          );
          msg += `${direct_object.Articlename} is closed. `;
          this.handleFailure(msg);
          return null;
        }

        // is direct_object empty?
        if (!direct_object.doesContainAnySubstance()) {
          this.game.debug(
            `F1551 | ${this.name}.js | ${direct_object.id}.in.vessel.getVolume is 0 `
          );
          msg += `${direct_object.Articlename} is empty. `;
          this.handleFailure(msg);
          return null;
        }

        // is target closed?
        if ("in" === indirect_preposition && indirect_object.isDOV("open")) {
          this.game.debug(
            `F1554 | ${this.name}.js | ${indirect_object.id}.is.closed `
          );
          msg += `${indirect_object.Articlename} is closed. `;
          this.handleFailure(msg);
          return null;
        }

        // is target the floor? set to room
        if (indirect_object instanceof adventurejs.Floor) {
          indirect_object = this.game.getCurrentRoom();
          input.setAsset(2, indirect_object);
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;
      var room = indirect_object instanceof adventurejs.Room;
      var target_object, target_preposition;
      var emptied_count = 0;
      var transferred = [];
      var spillover = [];
      var overflow = false;
      var substance_asset;
      var empty_this = false;
      var mixer;

      this.game.debug(`F1274 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // all parsed sentence structures should have resolved into
      // "verb noun preposition noun" because we always need
      // a source and a target

      if (indirect_object) {
      }

      msg += `$(We) tip ${direct_object.articlename}`;
      if (
        "under" === indirect_preposition ||
        "behind" === indirect_preposition
      ) {
        msg += ` ${indirect_preposition} ${indirect_object.articlename}`;
      } else {
        msg += ` over ${room ? "the floor" : indirect_object.articlename}`;
      }
      msg += `. `;

      // handle substances
      if (direct_object.hasVesselAtAspect("in")) {
        if (0 < direct_object.aspects.in.vessel.getVolume()) {
          // direct_object has substance
          substance_asset = this.game.getAsset(
            direct_object.aspects.in.vessel.substance_id
          );

          if (
            room ||
            "under" === indirect_preposition ||
            "behind" === indirect_preposition
          ) {
            // if indirect_object is room, substance just spills out
            msg += `${substance_asset.Name} spills to the floor. `;
            empty_this = true;
          } else if (
            "on" === indirect_preposition &&
            !indirect_object.hasVesselAtAspect(indirect_preposition)
          ) {
            // player said "pour on" and target has no on aspect
            msg += `${substance_asset.Name} pours over ${indirect_object.articlename} and then drains away. `;
            empty_this = true;
          } else if (indirect_object.hasVesselAtAspect(indirect_preposition)) {
            mixer = new adventurejs.SubstanceMixer(this.game.game_name).set({
              source_input: direct_object.id,
              source_aspect: "in",
              source_substance_id: direct_object.aspects.in.vessel.substance_id,
              target_input: indirect_object.id,
              target_aspect: indirect_preposition,
            });
            results = mixer.mix();
            if (A.isFalseOrNull(results)) return results;
            mixer.target_vessel.vessel_is_known = true;

            msg += `${mixer.source_substance_asset.Name} 
              pours from 
              ${mixer.source_asset.articlename} 
              ${indirect_preposition} 
              ${
                indirect_preposition === "in" || indirect_preposition === "on"
                  ? "to "
                  : ""
              }
              ${mixer.target_asset.articlename}`;

            if (mixer.can_drain_target) {
              msg += `, where it quickly drains away`;
            } else if (mixer.did_overflow_target) {
              msg += `, overflowing ${mixer.target_asset.articlename} with {mixer.did_mix_substances ? mixer.output_substance_asset.name : mixer.source_substance_asset.name}`;
            } else if (mixer.did_fill_target) {
              msg += `, filling ${mixer.target_asset.articlename} with ${
                mixer.did_mix_substances
                  ? mixer.output_substance_asset.name
                  : mixer.source_substance_asset.name
              }`;
            } else if (mixer.did_mix_substances) {
              msg += `, resulting in ${mixer.output_substance_asset.name}`;
            }
            msg += `. `;
          } else {
            msg += `${substance_asset.Name} pours over ${indirect_object.articlename} and then spills to the floor. `;
            empty_this = true;
          }
        }

        if (
          empty_this &&
          isFinite(direct_object.aspects.in.vessel.getVolume())
        ) {
          direct_object.aspects.in.vessel.setVolume(0);
        }
      } // handle substances

      // handle physical assets
      if (0 < direct_object.aspects.in.contents.length) {
        for (
          var i = direct_object.aspects.in.contents.length - 1;
          i > -1;
          i--
        ) {
          var content_object = this.game.getAsset(
            direct_object.aspects.in.contents[i]
          );
          target_object = indirect_object;
          target_preposition = indirect_preposition;
          overflow = false;
          emptied_count++;

          // if indirect_object is not the room, we need to check
          // if it can hold each object
          // if it can't, objects should fall to the floor

          if (room) {
            transferred.push(content_object);
          } else {
            if (
              indirect_object.canContainAssetAt(
                content_object,
                indirect_preposition
              )
            ) {
              transferred.push(content_object);
            } else {
              target_object = this.game.getCurrentRoom();
              target_preposition = "in";
              spillover.push(content_object);
              overflow = true;
            }
          }

          // remove content_object from direct_object
          results = direct_object.onRemoveThatFromThis(content_object);
          if ("undefined" !== typeof results) return results;

          // set content_object's target_object
          // if no target_object was specified, set to player's parent
          results = target_object.onMoveThatToThis(
            content_object,
            target_preposition
          );
          if ("undefined" !== typeof results) return results;

          // msg += "and you succeed. ";
        }
      }

      // print the results of physical assets
      if (room) {
        // everything falls to the floor
        switch (emptied_count) {
          case 0:
            break;
          case 1:
            msg += "A single item tumbles out and falls to the floor. ";
            break;
          case 2:
            msg += "Two items tumble out and fall to the floor. ";
            break;
          case 3:
            msg += "Several items tumble out and fall to the floor. ";
            break;
          default:
            msg += "A number of items tumble out and fall to the floor. ";
            break;
        }
      } else {
        var to_target =
          indirect_preposition +
          (indirect_preposition === "in" || indirect_preposition === "on"
            ? " to "
            : " ") +
          indirect_object.articlename;

        switch (emptied_count) {
          // some items are transferred to target, some may fall to the floor
          case 0:
            break;
          case 1:
            msg += "A single item tumbles " + to_target;
            switch (spillover.length) {
              case 0:
                msg += ". ";
                break;
              case 1:
                msg += " then falls to the floor. ";
                break;
            }
            break;
          case 2:
            msg += "Two items tumble " + to_target;
            switch (spillover.length) {
              case 0:
                msg += ". ";
                break;
              case 1:
                msg += ", and one falls to the floor. ";
                break;
              case 2:
                msg += " then fall to the floor. ";
                break;
            }
            break;
          case 3:
            msg += "Several items tumble " + to_target;
            switch (spillover.length) {
              case 0:
                msg += ". ";
                break;
              case 1:
                msg += ", and one falls to the floor. ";
                break;
              case 2:
                msg += ", and a couple of them fall to the floor. ";
                break;
              case 3:
                msg += " then fall to the floor. ";
                break;
            }
            break;
          default:
            msg += "A number of items tumble " + to_target;
            switch (spillover.length) {
              case 0:
                msg += ". ";
                break;
              case 1:
                msg += ", and one falls to the floor. ";
                break;
              case 2:
                msg += ", and a couple of them fall to the floor. ";
                break;
              case 3:
                msg += ", and several fall to the floor. ";
                break;
              default:
                msg += " and some fall to the floor. ";
                break;
            }
            break;
        }
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // pour

// press.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class press
   * @ajsnode game.dictionary.verbs.press
   * @ajsconstruct MyGame.createVerb({ "name": "press", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning press an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; press button</span>
   * You press the button. A little sign lights up, saying
   * "Please do not press this button again."
   * </pre>
   * <p>
   * <strong>Press</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be pressed has
   * asset.dov.press.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.press = {
    name: "press",
    prettyname: "press",
    past_tense: "pressed",
    synonyms: ["press"],

    /**
     * @memberof press
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof press
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (!direct_object.isDOV("press")) {
        this.game.debug(
          `F1379 | ${this.name}.js | ${direct_object.id}.dov.press.enabled is false `
        );
        msg += `$(We) can't press ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1378 | ${this.name}.js | print soSuccess `);
      msg += `$(We) press ${direct_object.articlename}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    }, // press
  };
})();

// pull.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class pull
   * @ajsnode game.dictionary.verbs.pull
   * @ajsconstruct MyGame.createVerb({ "name": "pull", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning pull an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; pull mask</span>
   * You don't tug on Superman's cape.
   * You don't spit into the wind.
   * You don't pull the mask off that old Lone Ranger.
   * And you don't mess around with Jim.
   * </pre>
   * <p>
   * <strong>Pull</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be pulled has
   * asset.dov.pull.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.pull = {
    name: "pull",
    prettyname: "pull",
    past_tense: "pulled",
    synonyms: ["pull"],

    /**
     * @memberof pull
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof pull
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (!direct_object.isDOV("pull")) {
        this.game.debug(
          `F1380 | ${this.name}.js | ${direct_object.id}.dov.pull.enabled is false `
        );
        msg += `$(We) can't pull ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1381 | ${this.name}.js | print doSuccess `);
      msg = `$(We) pull ${direct_object.articlename}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    }, // pull
  };
})();

// punch.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class punch
   * @ajsnode game.dictionary.verbs.punch
   * @ajsconstruct MyGame.createVerb({ "name": "punch", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning punch an asset.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; punch dalton</span>
   * You punch Sir Hillary Dalton with a great roundhouse sweep.
   * His top hat goes flying
   * and his cane clatters to the ground as he topples like a
   * chopped birch sapling. Dame Dalton shrieks and steps toward
   * Sir Dalton, trips on her fluttering crinolines and falls atop
   * him, losing one delicate embroidered slipper in the process.
   * You retrieve the slipper and secrete it away into a fold of
   * your voluminous cloak for later inspection.
   * </pre>
   * <p>
   * <strong>Punch</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be punched has
   * asset.dov.punch.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.punch = {
    name: "punch",
    prettyname: "punch",
    past_tense: "punched",
    synonyms: ["punch"],

    /**
     * @ajsverbstructures
     * @memberof punch
     */
    accepts_structures: ["verb noun"],

    /**
     * @memberof punch
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    // @todo what about "punch person on nose"?
    // also possessive: "punch person's nose"

    /**
     * @memberof punch
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV("punch")) {
        this.game.debug(
          `F1382 | ${this.name}.js | ${direct_object.id}.dov.punch.enabled is false `
        );
        msg += `$(We) can't punch ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state? skip

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1982 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      if (input.hasStructure("verb noun")) {
        // can verb act without an indirect object?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }
      } // verb noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1383 | ${this.name}.js | print doSuccess `);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    }, // punch
  };
})();

// push.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class push
   * @ajsnode game.dictionary.verbs.push
   * @ajsconstruct MyGame.createVerb({ "name": "push", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning push an asset.
   * @ajssynonyms shove, push
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; push builder</span>
   * You push the builder up the hill. He complains loudly.
   * "Hey! Whatsamatta you?!? Is you a'crazy?" He rolls back
   * down the hill and resumes the very important building
   * project that you interrupted. Meanwhile, a deformed
   * buzzard has landed on you. It begins plucking out your
   * intestines. "You don't mind, do ya chum? My momma don'tol'
   * me, bring something for dinner." Gruesome, isn't it?
   * Really makes you wish you had spellcheck.
   * </pre>
   * <p>
   * <strong>Push</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has
   * asset.dov.push.enabled set to true.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.push = {
    name: "push",
    prettyname: "push",
    past_tense: "pushed",
    synonyms: ["push", "shove"],

    /**
     * @ajsverbstructures
     * @memberof push
     */
    accepts_structures: [
      "verb noun", // ie 'push boulder'
      "verb noun noun", // ie 'push boulder north'
      "verb noun preposition noun", // ie 'push boulder over hill'
      "verb noun preposition noun preposition noun", // ie 'push boulder from dingle to hill'
    ],

    /**
     * @memberof push
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof push
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof push
     * @ajsverbphrase
     * phrase3:
     * {
     *   // only supports form: push asset from asset to asset
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase3: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof push
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var indirect_object2 = input.getAsset(3);
      var indirect_preposition2 = input.getPreposition(3);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (!direct_object.isDOV(this.name) && !direct_object.isDOV("take")) {
        // if you can take it, you can push it
        this.game.debug(
          `F1384 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      if (
        indirect_object &&
        indirect_object.direction &&
        !direct_object.can.push_from_room &&
        !direct_object.isDOV("take")
      ) {
        this.game.debug(
          `F1386 | ${this.name}.js | ${direct_object.id}.can.push_from_room is false `
        );
        msg += `$(We) can't push ${direct_object.articlename} out of the room. `;
        this.handleFailure(msg);
        return null;
      }

      if (input.hasStructure("verb noun noun")) {
        if (!indirect_object.direction) {
          // player input "push asset asset"
          this.game.debug(
            `F1385 | ${this.name}.js | ${indirect_object.id} is not direction `
          );
          msg += this.game.parser.getUnparsedMessage(input.input);
          this.handleFailure(msg);
          return null;
        }
      }

      if (input.hasStructure("verb noun preposition noun preposition noun")) {
        // did player input "push a from b to c"?
        if (indirect_preposition === "from" && indirect_preposition2 === "to") {
          // if so swap to/from because we're going to drop from at a later step
          input.swapPhrases(2, 3);
          indirect_preposition = "to";
          indirect_preposition2 = "from";
          indirect_object = input.getAsset(2);
          indirect_object2 = input.getAsset(3);
        }

        if (indirect_preposition !== "to" || indirect_preposition2 !== "from") {
          // we don't handle any other phrases in this structure
          this.game.debug(
            `F1688 | ${this.name}.js | sentence structure is 'verb noun preposition noun preposition noun' but phrase is not handled`
          );
          msg += this.game.parser.getUnparsedMessage(input.input);
          this.handleFailure(msg);
          return null;
        }

        // is asset at the "from" location?
        if (direct_object.getPlaceAssetId() !== indirect_object2.id) {
          this.game.debug(
            `F1689 | move.js | ${direct_object.id} is not ${indirect_object2.default_aspect} ${indirect_object2.id} `
          );
          msg += `${direct_object.Articlename} is not ${indirect_object2.default_aspect} ${indirect_object2.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // simplify this down to 'verb noun preposition noun'
        input.setStructure("verb noun preposition noun");
      } // verb noun preposition noun preposition noun

      if (input.hasStructure("verb noun preposition noun")) {
        if (direct_object === indirect_object) {
          this.game.debug(
            `F1673 | ${this.name}.js | direct_object ${direct_object.id} is indirect_object ${indirect_object.id} `
          );
          msg += `$(We) can't push ${direct_object.articlename} ${indirect_preposition} itself. `;
          this.handleFailure(msg);
          return null;
        }

        // if( [direct_object.getPlacePreposition(), "across", "over"].indexOf( indirect_preposition ) > -1
        // && direct_object.getPlaceAsset().id === indirect_object.id )
        // {
        //   this.game.debug(`F1672 | ${this.name}.js | ${direct_object.id} is ${indirect_preposition} ${indirect_object.id} `);
        //   msg += `$(We) nudge ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        //   this.handleFailure(msg);
        //   return null;
        // }

        if (
          [direct_object.getPlacePreposition(), "across", "over"].indexOf(
            indirect_preposition
          ) > -1 &&
          direct_object.getPlaceAsset().id !== indirect_object.id
        ) {
          this.game.debug(
            `F1674 | ${this.name}.js | ${direct_object.id} is not ${indirect_preposition} ${indirect_object.id} `
          );
          msg += `${direct_object.Articlename} is not on ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (
          [direct_object.getPlacePreposition(), "across", "over"].indexOf(
            indirect_preposition
          ) > -1 &&
          direct_object.getPlaceAsset().id === indirect_object.id
        ) {
          // ok
        } else if ("off" === indirect_preposition) {
          if (
            "on" !== direct_object.getPlacePreposition() ||
            direct_object.getPlaceAssetId() !== indirect_object.id
          ) {
            this.game.debug(
              `F1138 | ${this.name}.js | ${direct_object.id} is not on ${indirect_object.id} `
            );
            msg += `${direct_object.Articlename} isn't on ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        } else if (
          ["to", "toward", "near"].indexOf(indirect_preposition) > -1
        ) {
          // @TODO what does it mean to move a thing toward another thing?
          // is direct in same place as indirect?
          if (
            direct_object.getPlaceAssetId() !==
              indirect_object.getPlaceAssetId() ||
            direct_object.getPlacePreposition() !==
              indirect_object.getPlacePreposition()
          ) {
            this.game.debug(
              `F1681 | ${this.name}.js | ${direct_object.id} isn't in same parent as ${indirect_object.id} `
            );
            msg += `$(We) can't push ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        } else if (!indirect_object.hasAspectAt(indirect_preposition)) {
          this.game.debug(
            `F1204 | ${this.name}.js | ${indirect_object.id} has no aspect at ${indirect_preposition} `
          );
          msg += `$(We) can't push ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (
          -1 !== "in on under behind".indexOf(indirect_preposition) &&
          !indirect_object.hasAspectAt(indirect_preposition)
        ) {
          this.game.debug(
            `F1188 | ${this.name}.js | ${indirect_object.id} has no aspect at ${indirect_preposition} `
          );
          msg += `$(We) can't push anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (indirect_object.hasAspectAt(indirect_preposition)) {
          results = this.tryToPutThisInThatAspect(
            direct_object,
            indirect_preposition,
            indirect_object
          );
          if (results.fail) {
            msg = results.msg;
            this.handleFailure(msg);
            if (results.end_turn) return false;
            return null;
          }
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;
      var results1, results2;

      this.game.debug(`F1387 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        msg += `$(We) nudge ${direct_object.articlename}. `;
      } // verb noun

      if (indirect_object && indirect_object.direction) {
        results = this.game.tryTravel(indirect_object.direction, {
          with: [direct_object.id],
        });
        if (A.isFalseOrNull(results)) return results;
        // no msg because tryTravel handled it
      }

      if (input.hasStructure("verb noun noun")) {
      } // verb noun noun

      if (input.hasStructure("verb noun preposition noun")) {
        if (
          [direct_object.getPlacePreposition(), "across", "over"].indexOf(
            indirect_preposition
          ) > -1 &&
          direct_object.getPlaceAsset().id === indirect_object.id
        ) {
          msg += `$(We) nudge ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        } // across over
        else if (
          -1 < "in on under behind".indexOf(indirect_preposition) &&
          indirect_object.hasAspectAt(indirect_preposition)
        ) {
          results1 = direct_object
            .getPlaceAsset()
            .onRemoveThatFromThis(direct_object);
          if (!A.isFalseOrNull(results1)) {
            results2 = indirect_object.onMoveThatToThis(
              direct_object,
              "behind"
            );
          }
          if (A.isFalseOrNull(results1) || A.isFalseOrNull(results2)) {
            msg += `$(We're) prevented from pushing ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          }
        } // in on under behind
        else if ("off" === indirect_preposition) {
          results1 = indirect_object.onRemoveThatFromThis(direct_object);
          if (!A.isFalseOrNull(results1)) {
            results2 = indirect_object
              .getPlaceAsset()
              .onMoveThatToThis(
                direct_object,
                indirect_object.getPlacePreposition()
              );
          }
          if (A.isFalseOrNull(results1) || A.isFalseOrNull(results2)) {
            msg += `$(We're) prevented from pushing ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          } else {
            msg += `$(We) push ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          }
        } // off
        else if (["to", "toward", "near"].indexOf(indirect_preposition) > -1) {
          // @TODO what does it mean to move a thing toward another thing?
          msg += `$(We) push ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        } // to toward near
      } // verb noun preposition noun

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    }, // push
  };
})();

// put.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class put
   * @ajsnode game.dictionary.verbs.put
   * @ajsconstruct MyGame.createVerb({ "name": "put", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning put, as in 'put sword' or 'put sword in scabbard'.
   * @ajssynonyms put
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; put paper behind painting</span>
   * You put the slip of paper on which is written the Illuminati
   * password behind the painted portrait of Grover Cleveland.
   * </pre>
   * <pre class="display border outline">
   * <span class="input">&gt; put sword in stone</span>
   * You put the sword in the stone. The stone begins to glow
   * with a soft purple light. The glow brightens slowly,
   * growing gradually into incandescence. You shield your eyes
   * with your hands. There is a loud WHUMPF followed by cool
   * darkness. You lower your hands. The sword and the stone are gone.
   * </pre>
   * <pre class="display border outline">
   * <span class="input">&gt; put syrup on pancakes</span>
   * You can't put anything on the pancakes.
   *
   * Kidding! The game understands that you actually meant
   * "pour syrup on pancakes". The game is not cruel or dumb
   * or inflexible. The game loves you, and accommodates
   * you, and only wants you to enjoy a healthy nutritious
   * breakfast. You pour some syrup on the pancakes. Mmmm.
   * </pre>
   * <pre class="display border outline">
   * <span class="input">&gt; put lizard under rock</span>
   * You put the lizard back under the hot rock. It wriggles its
   * legs and burrows in contentedly.
   * </pre>
   * <p>
   * <strong>Put</strong> one
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} behind/in/on/under another Tangible Asset.
   * Requires that the destination Asset has a
   * {@link adventurejs.Aspect|Aspect}
   * there..
   * To learn about Aspects, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.put = {
    name: "put",
    prettyname: "put",
    past_tense: "put",
    synonyms: ["put", "place", "set"],
    enqueue_collections: true,

    /**
     * @ajsverbstructures
     * @memberof put
     */
    accepts_structures: [
      "verb noun",
      "verb noun preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof put
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   accepts_plural_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     not_worn_if_all: true,
     *     not_nested_inventory_if_all: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      accepts_plural_noun: true,
      noun_must_be: {
        in_inventory: true,
        not_worn_if_all: true,
        not_nested_inventory_if_all: true,
      },
    },

    /**
     * @memberof put
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     known: true,
     *     not_in_prior_plural: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        known: true,
        not_in_prior_plural: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof put
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var direct_preposition = input.getPreposition(1);
      var indirect_preposition = input.getPreposition(2);
      var indirect_aspect;
      var msg = "";
      var results;

      // can be direct object of verb?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1722 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is unset `
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      if (input.hasStructure("verb noun")) {
        // we've arrived here without an indirect_object, which is legit,
        // player can "put thing", in which case we just want to drop
        this.game.debug(
          `F1161 | ${this.name}.js | no indirect object, doVerb drop `
        );
        this.game.dictionary.doVerb("drop");
        return null;
      }

      if (input.hasStructure("verb noun preposition")) {
        if (["on", "down"].indexOf(indirect_preposition) > -1) {
          input.setPreposition(1, indirect_preposition);
          input.deletePhrase(2);
          input.setStructure("verb preposition noun");
        } else {
          this.game.debug(
            `F1925 | ${this.name}.js | ${this.name} ${indirect_preposition} not handled `
          );
          msg += `$(We) don't know how to ${this.name} ${direct_object.articlename} ${indirect_preposition}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      if (input.hasStructure("verb preposition noun")) {
        if (direct_preposition === "down") {
          this.game.debug(`F1926 | ${this.name}.js | put down, doVerb drop `);
          this.game.dictionary.doVerb("drop");
          return null;
        }
        if (direct_preposition === "on" && direct_object.isDOV("wear")) {
          this.game.debug(`F1891 | ${this.name}.js | put on, doVerb wear `);
          this.game.dictionary.doVerb("wear");
          return null;
        }
        // @TODO what about "put in key"? prompt for indirect object? assume from context?
        this.game.debug(
          `F1927 | ${this.name}.js | ${this.name} ${direct_preposition} not handled `
        );
        msg += `$(We) don't know how to ${this.name} ${direct_preposition} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (input.hasStructure("verb noun preposition noun")) {
        if (direct_object === indirect_object) {
          this.game.debug(
            `F1154 | ${this.name}.js | direct_object ${direct_object.id} is indirect_object ${indirect_object.id} `
          );
          msg += `$(We) can't put ${direct_object.articlename} ${indirect_preposition} itself. `;
          this.handleFailure(msg);
          return null;
        }

        if (
          indirect_object instanceof adventurejs.Floor &&
          indirect_preposition === "on"
        ) {
          this.game.debug(
            `F1162 | ${this.name}.js | indirect_object is floor, doVerb drop `
          );
          this.game.dictionary.doVerb("drop");
          return null;
        }

        // in some cases "put on" can mean "attach to"
        // ex "put cap on pen"
        // so see if we can attach these things
        if (
          indirect_preposition === "on" &&
          !indirect_object.hasAspectAt(indirect_preposition) &&
          (direct_object.canBePut("attached", indirect_object) ||
            indirect_object.canBePut("attached", direct_object))
        ) {
          input.setPreposition(2, "attached");
          this.game.debug(
            `F1155 | ${this.name}.js | ${direct_object.id} and ${indirect_object.id} can attach, doVerb attach `
          );
          this.game.dictionary.doVerb("attach");
          return null;
        }

        if (!indirect_object.hasAspectAt(indirect_preposition)) {
          this.game.debug(
            `F1156 | ${this.name}.js | ${indirect_object.id} has no ${indirect_preposition} aspect `
          );
          msg += `$(We) can't put anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (
          direct_object.getPlacePreposition() === indirect_preposition &&
          direct_object.getPlaceAssetId() === indirect_object.id
        ) {
          this.game.debug(
            `F1163 | ${this.name}.js | ${indirect_object.id} is ${indirect_preposition} ${indirect_object.id}`
          );
          msg += `${direct_object.Articlename} is already ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (
          "in" === indirect_preposition &&
          indirect_object.isDOV("close") &&
          indirect_object.is.closed
        ) {
          // @TODO automatically open the thing, if context allows it
          this.game.debug(
            `F1157 | ${this.name}.js | ${indirect_object.id}.is.closed `
          );
          msg += `${indirect_object.Articlename} is closed. `;
          this.handleFailure(msg);
          return false;
        }

        results = this.tryToPutThisInThatAspect(
          direct_object,
          indirect_preposition,
          indirect_object
        );
        if (results.fail) {
          msg = results.msg;
          this.handleFailure(msg);
          if (results.end_turn) return false;
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;
      var moved = false;

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        this.game.debug(`F1164 | ${this.name}.js | doSuccess `);
        msg += `$(We)`;
        if (direct_object.getPlaceAssetId() !== player.id) {
          msg += ` take ${direct_object.articlename} from ${
            direct_object.getPlaceAsset().articlename
          } and `;
          moved = true;
        }
        msg += ` put ${
          moved ? direct_object.pronoun : direct_object.articlename
        } ${indirect_preposition} ${indirect_object.articlename}. `;

        // remove noun1 from player
        results = player.onRemoveThatFromThis(direct_object);
        if ("undefined" !== typeof results) return results;

        // set noun1's new location to noun2
        // add noun1 to noun2's contents
        results = indirect_object.onMoveThatToThis(
          direct_object,
          indirect_preposition
        );
        if ("undefined" !== typeof results) return results;

        if (
          input.parsedNoun1.matches.qualified.length > 1 &&
          -1 === input.output_class.indexOf("concatenate_output")
        ) {
          input.output_class += " concatenate_output";
        }
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // put

// read.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class read
   * @ajsnode game.dictionary.verbs.read
   * @ajsconstruct MyGame.createVerb({ "name": "read", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading CompositionVerbs
   * @summary Verb meaning read asset, as in "read scroll".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; read grimoire</span>
   * You read the ancient grimoire. Instantly, your head begins to fill with
   * ancient spells. Lead to gold! Levitation! Spiritual transformation?
   * Your mind expands with a rush of incoming knowledge. Or does it?
   * Do minds have a maximum capacity? Does it feel as if the new
   * spells are overwriting your own memories? You try to recall a childhood
   * memory, and turn up a spell to purify water. You think back to your
   * first kiss, and find a spell to transform yourself into an eagle. You...
   * no, there is no you. There is only the spellbook, and the timeless, immortal
   * spells within it.
   * </pre>
   * <p>
   * <strong>Read</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be read has
   * asset.dov.read.enabled set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.read = {
    name: "read",
    prettyname: "read",
    past_tense: "read",
    synonyms: ["read"],

    /**
     * @memberof read
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof read
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (!direct_object.isDOV("read")) {
        this.game.debug(
          `F1388 | ${this.name}.js | ${direct_object.id}.dov.read.enabled is false `
        );
        msg += `$(We) can't read ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (
        direct_object.must.be_in_hands_to_read &&
        player.id !== direct_object.getPlaceAssetId()
      ) {
        this.game.debug(
          `F1389 | ${this.name}.js | ${direct_object.id}.must.be_in_hands_to_read `
        );
        msg += `$(We) have to be holding ${direct_object.articlename} in order to read it. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      this.game.debug(`F1390 | ${this.name}.js | print doSuccess `);
      msg += `$(We) read ${direct_object.articlename}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    }, // read
  };
})();

// release.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class release
   * @ajsnode game.dictionary.verbs.release
   * @ajsconstruct MyGame.createVerb({ "name": "release", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning release or let go of, as in "let go of rope".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; let go of pride</span>
   * You let go of your pride. With it, you feel a swell
   * of emotion: loss, grief, regret. Joy. You sob and laugh
   * with an intense, almost hysterical feeling of release,
   * tinged with a hint of bitterness at all the time you've lost.
   * </pre>
   * <p>
   * <strong>Let go of</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Operates in several ways. If player is hanging, as if from a rope,
   * redirects to {@link go_off}. If player is holding but not nested,
   * as if with an end of a rope, player lets go. If player is carrying
   * Asset, player drops it.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.release = {
    name: "release",
    prettyname: "release",
    synonyms: ["release"],
    verb_prep_noun: ["let go"],
    verb_prep_prep_noun: ["let go of"],

    /**
     * @ajsverbstructures
     * @memberof release
     */
    accepts_structures: ["verb", "verb noun"],

    /**
     * @memberof release
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     known: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     //in_inventory: true,
     *     // If we were carrying we'd limit to in_inventory
     *     // but "let go of" can also apply to things player
     *     // is holding on to.
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        tangible: true,
        known: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof release
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var nest_asset = player.getNestAsset();
      var results;
      var asset;
      var msg = "";

      if (input.hasStructure("verb")) {
        // parsed sentence structure: verb

        if ("release" === input.input_verb) {
          // we think of "release" as meaning drop
          // and we don't accept it as intransitive
          // in the way that we accept "let go" where
          // context should make direct object clear

          // prompt for a direct object
          input.setSoftPrompt({ noun1: true, input_verb: input.input_verb });
          this.game.debug(
            `F1355 | ${this.name}.js | no noun provided or inferrable, soft prompt noun1`
          );
          msg += `What did $(we) want to release? `;
          this.handleFailure(msg);
          return null;
        }

        // is player nested in something they can drop from?
        if (player.isNested() && nest_asset.quirks.let_go_of_means_go_off) {
          asset = nest_asset;
        }

        // is player holding one thing?
        else if (1 === player.IOVgetConnectionCount("hold")) {
          asset = this.game.getAsset(player.IOVgetConnections("hold")[0]);
        }

        if (!asset) {
          this.game.debug(
            `F1709 | ${this.name}.js | no noun supplied or inferred, soft prompt noun1 `
          );
          input.setSoftPrompt({ noun1: true, verb: "release" });
          msg += "Let go of what? ";
          this.handleFailure(msg);
          return null;
        }

        direct_object = asset;
        input.setAsset(1, asset);
        input.setAssumed(1);
        input.setStructure("verb noun");
      } // verb

      // sentence structure: verb noun
      // example: let go of rope (holding)
      if (input.hasStructure("verb noun")) {
        // example: let go of branch (hanging from)
        // might result in falling to ground
        // might also result in tryTravel to lower room

        // @TODO
        // what if player is in space?
        // or in rushing water?

        // author can do these in doAfterSuccess

        // is object takeable and in player inventory? do drop
        if (direct_object.isIn(player) && direct_object.isDOV("drop")) {
          this.game.debug(
            `F1710 | ${this.name}.js | infer 'drop ${direct_object.name}', doVerb drop`
          );
          this.game.dictionary.doVerb("drop");
          return null;
        }

        // is player nested in an object where letGo means goOff?
        if (
          player.isNested() &&
          direct_object.id === nest_asset.id &&
          direct_object.quirks.let_go_of_means_go_off
        ) {
          this.game.debug(
            `F1711 | ${this.name}.js | infer 'go off', doVerb go`
          );
          if (player.IOVisConnectedToAsset("hold", direct_object)) {
            // break "held" connection
            player.IOVunsetConnection("hold", direct_object);
          }
          input.setVerb("go");
          input.setPreposition(1, "off");
          input.setStructure("verb preposition noun");
          this.game.dictionary.doVerb("go");
          return null;
        }

        // is player nested in an object where letGo means goDown?
        if (
          player.isNested() &&
          direct_object.id === nest_asset.id &&
          direct_object.quirks.let_go_of_means_go_down
        ) {
          this.game.debug(
            `F1712 | ${this.name}.js | infer 'go down', doVerb down`
          );
          if (player.IOVisConnectedToAsset("hold", direct_object)) {
            // break "held" connection
            player.IOVunsetConnection("hold", direct_object);
          }
          this.game.tryTravel("down");
          return null;
        }

        // not holding object
        if (!player.IOVisConnectedToAsset("hold", direct_object)) {
          msg += `$(We're) not holding ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1360 | ${this.name}.js | print doSuccess `);

      // apply state changes
      if (player.IOVisConnectedToAsset("hold", direct_object)) {
        player.IOVunsetConnection("hold", direct_object);
      }

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // release

// remove.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class remove
   * @ajsnode game.dictionary.verbs.remove
   * @ajsconstruct MyGame.createVerb({ "name": "remove", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning remove, as in "remove cap from toothpaste".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; remove hat from from</span>
   * You try to remove the top hat from the singing frog. He leans
   * neatly away without moving from his spot on the piano, causing you to
   * miss and plunge hands first into the taut piano strings. You leap
   * backwards with strings wrapped around you and crash into the drum
   * set, trodding loudly upon the snare drum.
   * The sudden cacophony draws the conductor, who whacks you about
   * the head and shoulders with his baton and chases you into the
   * stage curtains. You wrestle with the curtains, which tear and fall
   * heavily down upon you. You climb to your feet, wrapped in twisted
   * curtains and piano strings, one foot stuck in a drum, and find
   * yourself on stage, bathed in spotlight, facing the shocked crowd.
   * </pre>
   * <p>
   * <strong>Remove</strong> may be interpreted ambiguously. It tries to respond
   * contextually depending on the properties of the objects provided.
   * Remove may redirect to
   * {@link untie},
   * {@link detach}, or
   * {@link take}.
   * Remove may also remove items worn by the player or
   * {@link adventurejs.NPC|NPCs}, automatically unzipping or unbuttoning them if needed.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.remove = {
    name: "remove",
    prettyname: "remove",
    past_tense: "removed",
    synonyms: ["remove"],

    /**
     * @ajsverbstructures
     * @memberof remove
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof remove
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof remove
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: [ 'from' ],
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["from"],
    },

    /**
     * @memberof remove
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var msg = "";

      // if (!direct_object.isDOV("remove")) {
      //   this.game.debug(
      //     `F1923 | ${this.name}.js | ${direct_object.id}.dov.${this.name} not enabled `
      //   );
      //   msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
      //   this.handleFailure(msg);
      //   return null;
      // }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        var parent = direct_object.getPlaceAsset();

        input.setAsset(2, parent);
        input.setPreposition(2, "from");
        input.setAssumed(2);
        input.setStructure("verb noun preposition noun");
        indirect_object = parent;
      }

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // if direct_object is tied, redirect to untie
        if (direct_object.dov.tie?.with_params.connections.length) {
          this.game.debug(
            `F1254 | ${this.name}.js | ${direct_object.id}.dov.tie, infer untie `,
          );
          this.game.dictionary.doVerb("untie");
          return null;
        }

        // if direct_object is attached, redirect to detach
        if (direct_object.isPlacedAtAspect("attached")) {
          this.game.debug(
            `F1254 | ${this.name}.js | ${direct_object.id} is attached, infer detach `,
          );
          this.game.dictionary.doVerb("detach");
          return null;
        }

        // thing not in other thing
        if (!direct_object.isIn(indirect_object)) {
          this.game.debug(
            `F1255 | ${this.name}.js | ${direct_object.id} place is not ${indirect_object.id} `,
          );
          msg += `${direct_object.Articlename} isn't in ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // if direct_object is worn & can be removed, take it off
        if (
          direct_object.is.worn &&
          direct_object.isDOV("remove") &&
          indirect_object.id === player.id
        ) {
          return true;
        }

        // direct_object is worn by player but can't be removed
        // handcuffs for instance
        if (
          direct_object.is.worn &&
          !direct_object.isDOV("remove") &&
          indirect_object.id === player.id
        ) {
          this.game.debug(
            `F1256 | ${this.name}.js | ${direct_object.id}.dov.remove.enabled is false `,
          );
          msg += `$(We) can't remove ${direct_object.articlename}. `;

          this.handleFailure(msg);
          return null;
        }

        // direct_object is worn by other char but can't be removed
        if (
          direct_object.is.worn &&
          indirect_object !== player.id &&
          (!direct_object.isDOV("remove") || !indirect_object.isIOV("take"))
        ) {
          this.game.debug(
            `F1257 | ${this.name}.js | ${direct_object.id}.dov.remove is unset or ${indirect_object.id}.iov.take is unset`,
          );
          msg += `$(We) can't remove ${direct_object.articlename} from ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // worn by a character like a pet that you can take from?
        // as in "remove collar from cat"
        if (
          direct_object.is.worn &&
          indirect_object.id !== player.id &&
          direct_object.isDOV("remove") &&
          indirect_object.isIOV("take")
        ) {
          // any conditions that would prevent removing clothing?
          // none at the moment so just proceed to success
          return true;
        }

        // try taking a thing from a character
        // who can't be taken from
        // authors will probably want some control over this interation
        if (!indirect_object.isIOV("take")) {
          this.game.debug(
            `F1258 | ${this.name}.js | ${indirect_object.id}.iov.take is unset`,
          );
          msg += `$(We) can't take anything from ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        if (direct_object.is.worn && !direct_object.isDOV("remove")) {
          // TODO article + noun or proper noun, depending on if is character
          this.game.debug(
            `F1259 | ${this.name}.js | ${direct_object.id}.dov.remove.enabled is false`,
          );
          msg += `$(We) can't remove ${direct_object.articlename} from ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      // if it's none of these things, redirect to take
      this.game.debug(`F1260 | ${this.name}.js | infer take`);
      this.game.dictionary.doVerb("take");
      return null;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var parent = direct_object.getPlaceAsset();
      var msg = "";
      var closedAnscestors = [];
      var results;

      this.game.debug(`F1261 | ${this.name}.js | print doSuccess`);

      // open any containers if necessary
      // we only do this for items nested in inventory
      if (direct_object.isIn(player) && direct_object.areAnscestorsClosed()) {
        closedAnscestors = direct_object.getClosedAnscestors();

        for (var i = 0; i < closedAnscestors.length; i++) {
          this.game.getAsset(closedAnscestors[i]).is.closed = false;
          closedAnscestors[i] = this.game.getAsset(closedAnscestors[i]).name;
        }

        if (closedAnscestors.length > 0) {
          msg += "$(We) open the ";
          for (var i = 0; i < closedAnscestors.length; i++) {
            if (
              closedAnscestors.length > 2 &&
              i < closedAnscestors.length - 2
            ) {
              msg += ", ";
            }
            if (
              closedAnscestors.length > 1 &&
              i === closedAnscestors.length - 1
            ) {
              msg += " and the ";
            }
            msg += closedAnscestors[i];
          }
          msg += ". ";
        }
      }

      // if direct_object is worn, take it off
      if (direct_object.is.worn && indirect_object.id == player.id) {
        results = direct_object.unfasten();
        msg += results ? `$(We) ${results}, then remove, ` : `$(We) remove `;
        msg += `${direct_object.articlename}. `;
        direct_object.is.worn = false;
      }

      // worn by a character like a pet that you can take from
      // what if it's sexy sex? removing clothes from a partner
      if (
        direct_object.is.worn &&
        indirect_object.id !== player.id &&
        indirect_object.isIOV("take")
      ) {
        results = direct_object.unfasten();
        msg += results ? `$(We) ${results}, then remove, ` : `$(We) remove `;
        msg += `${direct_object.articlename} from ${indirect_object.articlename}. `;
        direct_object.is.worn = false;
      }

      if (indirect_object.id !== player.id && direct_object.takeable) {
        // remove thing from its current container
        results = parent.onRemoveThatFromThis(direct_object);
        if ("undefined" !== typeof results) return results;

        // add thing to player's contents
        results = player.onMoveThatToThis(direct_object, "in");
        if ("undefined" !== typeof results) return results;
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // remove

// restore.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class restore
   * @ajsnode game.dictionary.verbs.restore
   * @ajsconstruct MyGame.createVerb({ "name": "restore", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb used to initiate restoring a saved game.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; restore</span>
   * </pre>
   * <p>
   * <strong>Restore</strong> brings up the 'restore game' panel,
   * </p>
   */
  A.Preverbs.restore = {
    name: "restore",
    synonyms: ["restore", "restore game"],
    verb_prep_noun: ["restore game"],

    /**
     * @ajsverbstructures
     * @memberof restore
     */
    accepts_structures: ["verb"],

    do: function () {
      console.log("restore.do");
      this.game.log("log", "high", "Opening restore manager.", "verbs");
      this.game.restoreManager.openDisplay();
      return true;
    },
  };
})();

// revive.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class revive
   * @ajsnode game.dictionary.verbs.revive
   * @ajsconstruct MyGame.createVerb({ "name": "revive", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading RestorationVerbs
   * @summary Verb meaning revive character.
   * @ajssynonyms resurrect, resuscitate, revive
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; revive bus driver</span>
   * You lean all your weight into compressing the doughy
   * bus driver's chest. Your hands sink deep into his flesh.
   * Your vigorous compressions work: he coughs and spits
   * out half of a ham sandwich!
   * </pre>
   * <p>
   * <strong>Revive</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be revived has
   * asset.dov.revive.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.revive = {
    name: "revive",
    prettyname: "revive",
    past_tense: "revived",
    synonyms: ["revive", "resurrect", "resuscitate"],
    unstate: "dead",

    /**
     * @ajsverbstructures
     * @memberof revive
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof revive
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof revive
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   accepts_preposition:true,
     *   requires_preposition:true,
     *   accepts_these_prepositions: ['with'],
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     in_inventory: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
      noun_must_be: {
        known: true,
        tangible: true,
        in_inventory: true,
      },
    },

    /**
     * @memberof revive
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV("revive")) {
        this.game.debug(
          `F1968 | ${this.name}.js | ${direct_object.id}.dov.revive.enabled is false `,
        );
        msg += `$(We) can't revive ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1969 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.propername} isn't ${this.getState()}. `;
        this.handleFailure(msg);
        return false;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1970 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      if (input.hasStructure("verb noun")) {
        // can verb act without an indirect object?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1971 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1972 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        // if( direct_object.DOVallowWithNothing(this.name) )
        // {
        //   this.game.debug(` | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `);
        //   msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        //   this.handleFailure(msg);
        //   return null;
        // }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1973 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1974 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1975 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      }
      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1976 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    }, // revive
  };
})();

// ride.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class ride
   * @ajsnode game.dictionary.verbs.ride
   * @ajsconstruct MyGame.createVerb({ "name": "ride", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning ride, as in "ride horse".
   * @todo Ride NPCs (like a horse). Will NPC be a SimpleVehicle?
   * @todo What about things like rafts that aren't under player's control?
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; ride hippogryph</span>
   * You ride the hippogryph, bearing in mind that this is not one of your
   * classical type hippogryphs - you know, half horse, half gryphon - but
   * is in fact a full-on hippopotamus named Griff. As such, Griff has
   * mixed feelings about the arrangement of being ridden. On the one hand,
   * you could kick your heels and go "yah!" and he could carry you across
   * the lake. On the other, he could roll over and crush you. Griff
   * casually regurgitates some cud and reswallows it while he considers the
   * situation. (Unlike other ruminants, hippos don't chew their cud.
   * THE MORE YOU KNOW!)
   * </pre>
   * <p>
   * <strong>Ride</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}, optionally in a direction.
   * Requires that the Asset to be ridden has
   * asset.dov.ride.enabled
   * set to true. If player isn't on Asset, verb will
   * redirect to {@link go}. If player is already on Asset
   * and a direction is also provided, player will try to travel.
   * </p>
   * <p>
   * It's assumed that anything that has
   * dov.ride will be a
   * {@link adventurejs.SimpleVehicle|SimpleVehicle}.
   * See
   * <a href="/doc/Tangibles_SimpleVehicles.html">Simple Vehicles</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.ride = {
    name: "ride",
    prettyname: "ride",
    past_tense: "rode",
    synonyms: ["ride", "peddle", "skate"],
    verb_prep_noun: ["ride on"],

    /**
     * @ajsverbstructures
     * @memberof ride
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition noun",
      "verb noun noun",
      "verb noun preposition noun",
    ],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
      able_to_ride: true,
    },

    /**
     * @memberof ride
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     singular: false,
     *     //not_in_inventory: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        singular: false,
      },
    },

    /**
     * @memberof ride
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     direction: true,
     *   },
     *   accepts_preposition: true,
     *   // accepts_these_prepositions: ["to"], // ride onto? ride into?
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        direction: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof ride
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var input_verb = input.input_verb;
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var nest_asset = player.getNestAsset();
      var currentRoom = this.game.getCurrentRoom();
      var msg = "";

      if (!direct_object) {
        if (nest_asset && nest_asset.is.rideable) {
          // was ride called without noun?
          direct_object = nest_asset;
          input.setAsset(2, direct_object);
          this.game.debug(
            `F1213 | ${this.name}.js | infer ${direct_object.id} as direct_object `,
          );
        } else {
          // can't do it
          input.setSoftPrompt({ noun1: true, verb: "ride" });
          this.game.debug(
            `F1211 | ${this.name}.js | no direct_object received or inferred, soft prompt noun1 `,
          );
          msg += `What would $(we) like to ${input_verb}? `;
          this.handleFailure(msg);
          return null;
        }
      }

      // did player input something like "ride east" ?
      if (
        direct_object.direction &&
        !indirect_object &&
        nest_asset &&
        nest_asset.is.rideable
      ) {
        // set nest as direct object
        indirect_object = direct_object;
        direct_object = nest_asset;
        input.setPhrase(2, input.getPhrase(1));
        input.setAsset(1, nest_asset);
        input.setStructure("verb noun noun");
      }

      if ("peddle" === input_verb && !direct_object.is.peddleable) {
        this.game.debug(
          `F1214 | ${this.name}.js | ${direct_object.id}.is.peddleable is false `,
        );
        msg += `${direct_object.Articlename} can't be peddled. `;
        this.handleFailure(msg);
        return null;
      }

      if ("skate" === input_verb && !direct_object.is.skateable) {
        this.game.debug(
          `F1215 | ${this.name}.js | ${direct_object.id}.is.skateable is false `,
        );
        msg += `$(We) can't skate on ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (!direct_object.isDOV("ride")) {
        this.game.debug(
          `F1216 | ${this.name}.js | ${direct_object.id}.dov.ride.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ridden. `;
        this.handleFailure(msg);
        return null;
      }

      if (nest_asset.id !== direct_object.id) {
        if (indirect_object) {
          this.game.debug(
            `F1217 | ${this.name}.js | player must be on ${direct_object.id} `,
          );
          msg += `$(We're) not on ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
        input.setVerb("go");
        input.setPreposition(1, "on");
        input.setStructure("verb preposition noun");
        this.game.dictionary.doVerb("go");
        return null;
      }

      if (!player.can.ride || !player.getNestOrPlaceAspect().player.can.ride) {
        this.game.debug(
          `F1854 | ${
            this.name
          }.js | player.can.ride is false or ${player.getNestOrPlaceAsset()}.aspects.${player.getNestOrPlacePreposition()} }.player.can.ride is false`,
        );
        msg += `$(We) can't ride ${direct_object.articlename} here. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player = this.game.getPlayer();
      var nest_asset = player.getNestAsset();
      var msg = "";
      var results;

      this.game.debug(`F1212 | ${this.name}.js | doSuccess `);

      if (indirect_object && indirect_object.direction) {
        results = this.game.tryTravel(indirect_object.direction, {
          with: [direct_object.id],
        });
        if (A.isFalseOrNull(results)) return results;
        // no msg because tryTravel handled it
      } else {
        msg += `$(We) ride ${direct_object.articlename} around the room. `;
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // ride

// run.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class run
   * @ajsnode game.dictionary.verbs.run
   * @ajsconstruct MyGame.createVerb({ "name": "run", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning run, as in "run on treadmill"; or, travel in specified direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; run under cat</span>
   * You run under the old half-blind cat. It sniffs the air and
   * mews with confusion. You're safe for a moment, but there's
   * no time to waste. You wrack your brain for ways to reverse
   * the witch's spell with your little mousey paws.
   * </pre>
   * Run extends core verb <a href="go.html">go</a>.
   * It checks whether "run" is contextually available
   * before forwarding to "go" for further handling.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.run = {
    name: "run",
    prettyname: "run",
    past_tense: "ran",
    synonyms: ["run"],
    type: { locomotion: true, travel: true },
    extends: { go: true },

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
      able_to_run: true,
    },

    /**
     * @ajsverbstructures
     * @memberof run
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof run
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof run
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof run
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    do: function () {
      return this.game.dictionary.doVerb("go");
    },
  }; // END run
})();

// save.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class save
   * @ajsnode game.dictionary.verbs.save
   * @ajsconstruct MyGame.createVerb({ "name": "save", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb used to initiate saving a saved game.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; save</span>
   * </pre>
   * <p>
   * <strong>Save</strong> brings up the 'save game' panel,
   * </p>
   */
  A.Preverbs.save = {
    name: "save",
    synonyms: ["save", "save game"],
    verb_prep_noun: ["save game"],

    /**
     * @ajsverbstructures
     * @memberof save
     */
    accepts_structures: ["verb"],

    do: function () {
      this.game.log("log", "high", "Opening save manager.", "verbs");
      this.game.saveManager.openDisplay();
      return true;
    },
  };
})();

// screw.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class screw
   * @ajsnode game.dictionary.verbs.screw
   * @ajsconstruct MyGame.createVerb({ "name": "screw", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning screw, as in "screw rod into socket".
   * @todo replace canScrewToThing with Aspect methods for limiting attachment
   * @todo attachment type?
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; screw suppressor to pistol</span>
   * You screw the suppressor to the barrel of the pistol, carefully
   * guiding the threads into place. The seam closes tightly, squeezing
   * out a bit of grease. You wipe it away with a bit of chamois from
   * your pocket. As you refold the chamois, greasy side in, you consider
   * the chain of events that brought you here. A late phone call, a
   * veiled threat, an untrustworthy promise. You certainly have no
   * loyalties to betray here, but neither do you care to be manipulated.
   * </pre>
   * <p>
   * <strong>Screw</strong> one {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to another.
   * Requires that the receiving Asset has an <code>attach</code>
   * {@link adventurejs.Aspect|Aspect}.
   * To learn about Aspects, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.screw = {
    name: "screw",
    prettyname: "screw",
    past_tense: "screwed",
    synonyms: ["screw"],
    verb_noun_prep_noun: ["screw to", "screw onto"],
    verb_noun_prep_prep_noun: ["screw on to"],
    state: "screwed",
    //unstate: "unscrewed",

    /**
     * @memberof screw
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof screw
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   //accepts_preposition: true,
     *   //requires_preposition: true,
     *   //accepts_these_prepositions: [ 'to' ], // @todo
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof screw
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var msg = "";

      // no indirect object given
      if ("undefined" === typeof input.parsedNoun2) {
        input.setSoftPrompt({ noun2: true, verb: "screw" });
        this.game.debug(
          `F1396 | ${this.name}.js | no indirect object received or inferred, soft prompt noun2 `,
        );
        msg += `Screw ${direct_object.articlename} to what? `;
        this.handleFailure(msg);
        return null;
      }

      var indirect_object = input.getAsset(2);

      // can't screw
      if (
        !direct_object.isDOV("screw") ||
        !indirect_object.hasAspectAt("attached")
      ) {
        this.game.debug(
          `F1395 | ${this.name}.js | ${direct_object.id}.dov.screw.enabled is false or ${indirect_object.id} has no attached aspect `,
        );
        msg += `$(We) can't screw ${direct_object.articlename} into ${indirect_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // can we attach this particular thing to that particular thing?
      var can_be_screwed = false;
      /** @TODO these functions don't exist yet */
      if (
        direct_object.canScrewToClassOf(indirect_object) ||
        direct_object.canScrewToThing(indirect_object)
      ) {
        can_be_screwed = true;
      }

      if (!can_be_screwed) {
        this.game.debug(
          `F1394 | ${this.name}.js | ${indirect_object.id} can't accept ${direct_object.id} `,
        );
        msg += `$(We) can't screw ${direct_object.articlename} into ${indirect_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // already screwed
      if (direct_object.isPlacedAtAspect("attached")) {
        this.game.debug(
          `F1397 | ${this.name}.js | ${
            direct_object.id
          } is already attached to ${direct_object.getPlaceAssetId()}`,
        );
        msg += `${direct_object.Articlename} is ${
          direct_object.isDOV("screw") ? "screwed" : "attached"
        } to ${indirect_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var doParent = direct_object.getPlaceAsset();
      var indirect_object = input.getAsset(2);
      var msg = "";
      var results;

      this.game.debug(`F1398 | ${this.name}.js | print doSuccess `);
      if (doParent.id !== indirect_object.id) {
        // remove thing from current parent
        //results = parent.onRemoveThatFromThis( direct_object );
        results = direct_object.moveFrom(doParent);
        if ("undefined" !== typeof results) return results;

        // add thing to new parent
        //results = indirect_object.onMoveThatToThis( direct_object, "attached" );
        results = direct_object.moveTo("attached", indirect_object);
        if ("undefined" !== typeof results) return results;
      }

      msg += `$(We) screw ${direct_object.articlename} into ${indirect_object.articlename}. `;

      direct_object.is.screwed = true;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // screw

// seal.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class seal
   * @ajsnode game.dictionary.verbs.seal
   * @ajsconstruct MyGame.createVerb({ "name": "seal", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading OpenCloseVerbs
   * @ajscaninferindirect
   * @summary Verb meaning seal, as in "seal envelope with wax".
   * @todo Finish implementing seal.
   * @todo Move thing that seals into sealed thing.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; seal book with wax</span>
   * You seal the book with wax. No one must ever again
   * open the pages of the Bokronomicon. The ancient recipes
   * inscribed within are too tasty, too tempting; the
   * blends of hallowed herbs and mystic spices too sacrilicious.
   * NO CHICKEN PREPARED BY MAN SHOULD BE SO TENDER.
   * </pre>
   * <p>
   * <strong>Seal</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} using a second
   * Tangible Asset.
   * Requires that the asset to be sealed has
   * <code>asset.dov.seal.enabled</code> set to true and its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_is_sealed">is.sealed</a>
   * property set to false; and that the id of the sealant
   * is listed in the sealable's
   * <code>asset.dov.seal.with_assets</code>
   * property; and that the sealant is in player's inventory.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.seal = {
    name: "seal",
    prettyname: "seal",
    past_tense: "sealed",
    synonyms: ["seal"],
    state: "sealed",
    related: ["unseal"],
    state_strings: { state: "sealed", unstate: "unsealed" },
    state_string: "sealed",
    unstate_string: "unsealed",

    /**
     * @ajsverbstructures
     * @memberof seal
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof seal
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof seal
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof seal
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1400 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1401 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`
        );
        msg += `${direct_object.Articlename} is already ${this.getState()}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1829 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1252 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1756 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1402 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1404 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1909 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1815 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1399 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // seal

// shake.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class shake
   * @ajsnode game.dictionary.verbs.shake
   * @ajsconstruct MyGame.createVerb({ "name": "shake", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning shake, as in "shake baby".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; shake baby</span>
   * You shake the baby gargoyle. The baby gargoyle
   * strenuously objects. It clamps a stone hand around
   * your wrist then, using that initial grip, proceeds
   * to climb hand-over-hand up your arms, shoulders, and
   * onto your head, where it takes up a perch that feels
   * unsettlingly permanent.
   * </pre>
   * <p>
   * <strong>Shake</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be shaken has
   * asset.dov.shake.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.shake = {
    name: "shake",
    prettyname: "shake",
    past_tense: "shook",
    synonyms: ["shake"],

    /**
     * @memberof shake
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof shake
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (!direct_object.isDOV("shake")) {
        this.game.debug(
          `F1405 | ${this.name}.js | ${direct_object.id}.dov.shake.enabled is false `
        );
        msg += `$(We) can't shake ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1406 | ${this.name}.js | print doSuccess `);
      msg += `$(We) shake ${direct_object.articlename}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // shake

// shine.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class shine
   * @ajsnode game.dictionary.verbs.shine
   * @ajsconstruct MyGame.createVerb({ "name": "shine", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning shine a tangible asset.
   * @ajssynonyms shine
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; shine candle in cave</span>
   * The flickering candle light reveals... a slathering horror!
   * No, wait, that's just your reflection the slick cave wall.
   * </pre>
   * <p>
   * Shine a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}. Asset must have
   * asset.dov.shine.enabled
   * set to true. There's no particular
   * code to handle shine, so any special results will need
   * to be custom coded through a method such as setting a
   * verb override for the Asset. To learn about verb hooks,
   * see <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.shine = {
    name: "shine",
    prettyname: "shine",
    past_tense: "shone",
    synonyms: ["shine"],
    state: "shone",

    /**
     * @ajsverbstructures
     * @memberof shine
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof shine
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof shine
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      accepts_preposition: true,
      requires_preposition: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof shine
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1774 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state? skip it
      // if( this.hasState() && direct_object.isState(this.name) )
      // {
      //   this.game.debug(`XXXX | ${this.name}.js | ${
      //   direct_object.id
      // }.is.${this.getState()} is ${direct_object.isState(this.name)}`);
      //   msg += `${direct_object.Articlename} is already ${this.getState()}. `;
      //   this.handleFailure(msg);
      //   return false;
      // }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1830 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1793 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1794 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} on? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1775 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1795 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1910 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1816 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1773 | ${this.name}.js | print doSuccess `);

      // apply state changes
      // none

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // shine

// sit.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class sit
   * @ajsnode game.dictionary.verbs.sit
   * @ajsconstruct MyGame.createVerb({ "name": "sit", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading PositionVerbs
   * @summary Verb meaning sit, as in "sit on throne".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; sit</span>
   * You sit on the floor.
   * </pre>
   * <p>
   * If input without an object, <strong>Sit</strong> tries to
   * put player into a sitting position wherever they happen to be.
   * If player is not nested in a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}, <strong>Sit</strong> uses
   * the {@link adventurejs.Floor|Floor}. Requires that the target
   * Asset has an aspect with its
   * aspect.player.can.sit
   * property set to true.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.sit = {
    name: "sit",
    prettyname: "sit",
    past_tense: "sat",
    synonyms: ["sit"],
    //verb_prep_noun: ["sit down", "sit up"],

    /**
     * @ajsverbstructures
     * @memberof sit
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
    ],

    /**
     * @memberof sit
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     not_direction: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        not_direction: true,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      requires_preposition: true,
    },

    /**
     * @memberof sit
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    in_can_mean_on: true,

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_asset = player.getNestAsset();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var current_room = this.game.getCurrentRoom();
      var msg = "";
      var results;

      // sentence structure: verb
      if (input.hasStructure("verb")) {
        // already sitting
        if (player.is.sitting) {
          this.game.debug(`F1019 | ${this.name}.js | ${player.id}.is.sitting`);
          msg += `$(We're) already sitting! `;
          this.handleFailure(msg);
          return null;
        }
        direct_preposition = player.getNestOrPlacePreposition();
        input.setPreposition(1, direct_preposition);
        direct_object = player.getNestOrPlaceAsset();
        input.setStructure("verb preposition noun");
      } // verb

      // sentence structure: verb preposition
      if (input.hasStructure("verb preposition")) {
        if (direct_preposition === "up") {
          if (player.is.sitting) {
            this.game.debug(`F1097 | ${this.name}.js | 'sit up'`);
            msg += `$(We) sit up a bit straighter. `;
            this.handleFailure(msg);
            return null;
          }
          if (!player.is.lying) {
            this.game.debug(`F1446 | ${this.name}.js | 'sit up'`);
            msg += `$(We) can't sit up while $(we're) ${player.getPostureGerund()}. `;
            this.handleFailure(msg);
            return null;
          }
        } else if (direct_preposition === "down") {
          if (player.is.sitting) {
            this.game.debug(
              `F1098 | ${this.name}.js | ${player.id}.is.sitting`
            );
            msg += `$(We) slouch down a bit lower. `;
            this.handleFailure(msg);
            return null;
          }
        } else {
          this.game.debug(
            `F1098 | ${this.name}.js | no direct object received or inferred`
          );
          msg += `$(We) try to sit ${direct_preposition}, and fail. `;
          this.handleFailure(msg);
          return null;
        }
        // sit down is still an option but we need a direct object
        if (nest_asset) {
          direct_object = nest_asset;
          direct_preposition = nest_preposition;
        } else {
          // see if the room has its own floor
          direct_object = this.game.getCurrentRoomFloor();
          direct_preposition = "on";
        }
        if (direct_object) {
          input.setAsset(1, direct_object);
          input.setPreposition(1, direct_preposition);
          input.setAssumed(1, true);
          input.setStructure("verb preposition noun");
        }
      } // verb preposition

      // sentence structure: verb preposition noun
      if (input.hasStructure("verb preposition noun")) {
        // is player allowed to sit here?
        if (
          !player.can.sit ||
          !direct_object.aspects[direct_preposition].player.can.sit
        ) {
          this.game.debug(
            `F1087 | ${this.name}.js | player.can.sit is false or ${direct_object.id}.aspects.${direct_preposition} }.player.can.sit is false`
          );
          msg += `$(We) can't sit ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can player reach it?
        if (nest_asset && nest_asset.id !== direct_object.id) {
          results = this.canPlayerGoThereFromNest(
            direct_preposition,
            direct_object
          );
          if (results.failure) {
            this.handleFailure(results.msg);
            return null;
          }
          if (results.return) return true;
        }

        // player is nested some other way with target
        // and needs to unnest first
        if (
          nest_asset &&
          nest_asset.id === direct_object.id &&
          nest_preposition !== direct_preposition
        ) {
          this.game.debug(
            `F1022 | ${this.name}.js | player is otherwise nested ${nest_preposition} ${nest_asset.id} `
          );
          msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} ${nest_preposition} ${
            nest_asset.articlename
          }. `;
          this.handleFailure(msg);
          return null;
        }

        // player is already sitting [preposition] target
        if (player.is.sitting) {
          var already_on_it;

          if (
            nest_asset &&
            nest_asset.id === direct_object.id &&
            nest_preposition === direct_preposition
          )
            already_on_it = true;

          if (!nest_asset && direct_object instanceof adventurejs.Floor)
            already_on_it = true;

          if (already_on_it) {
            this.game.debug(
              `F1089 | ${this.name}.js | player.is.sitting ${direct_preposition} ${direct_object.id}`
            );
            msg += `$(We're) already sitting ${direct_preposition} ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        }
      } // verb preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_asset = player.getNestAsset();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var do_nest, do_unnest;
      var fromfloor;
      var tofloor;
      var results;
      var msg = "";

      this.game.debug(`F1632 | ${this.name}.js | print doSuccess `);

      tofloor = direct_object instanceof adventurejs.Floor;
      fromfloor = !nest_asset || nest_asset instanceof adventurejs.Floor;

      // floor to floor
      if (fromfloor && tofloor) {
        do_nest = true;
        this.game.debug(`F1633 | ${this.name}.js | from floor to floor `);
        msg += `$(We) sit ${player.is.lying ? "up" : "down"} on the floor. `;
      }

      // floor to nest or change positions on nest
      else if (
        (fromfloor && !tofloor) ||
        (nest_asset && nest_asset.id === direct_object.id)
      ) {
        do_nest = fromfloor && !tofloor;
        this.game.debug(
          `F1634 | ${this.name}.js | from floor to asset or change position on asset `
        );
        msg += `$(We) sit ${direct_preposition} ${direct_object.articlename}. `;
      }

      // nest_asset to floor - unnest
      else if (!fromfloor && tofloor) {
        do_unnest = true;
        this.game.debug(`F1635 | ${this.name}.js | from asset to floor `);
        msg += `$(We) hop ${player.getPrettyUnnestPreposition()} ${
          nest_asset.articlename
        } and sit ${direct_preposition} ${direct_object.articlename}. `;
      }

      // nest_asset to same nest_asset
      else if (!fromfloor && !tofloor && direct_object.id === nest_asset.id) {
        if (player.is.lying || player.is.sitting || player.is.kneeling) {
          this.game.debug(`F1636 | ${this.name}.js | change posture on floor `);
          msg += `$(We) sit down ${nest_preposition} ${direct_object.articlename}. `;
        }
      }

      // nest_asset to other nest_asset
      else if (!fromfloor && !tofloor && direct_object.id !== nest_asset.id) {
        do_nest = true;
        do_unnest = true;
        this.game.debug(
          `F1637 | ${this.name}.js | move from one asset to another `
        );
        msg += `$(We) climb over to ${direct_object.articlename} and sit down ${direct_preposition} it. `;
      }

      if (do_unnest && nest_asset) {
        results = player.onUnnestThisFromThat(nest_asset);
        if ("undefined" !== typeof results) return results;
      }

      if (do_nest && direct_object) {
        results = player.onNestThisToThat(direct_object, direct_preposition);
        if ("undefined" !== typeof results) return results;
      }

      player.posture = "sit";

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // sit

// slap.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class slap
   * @ajsnode game.dictionary.verbs.slap
   * @ajsconstruct MyGame.createVerb({ "name": "slap", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning slap, as in "slap knight with gauntlet".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; slap salami</span>
   * You slap the salami as much as the next guy, but right
   * now is neither the time nor the place. In thirteen minutes
   * the Prime Minister is going to walk through that door and
   * if you haven't got the perfect sandwich prepared and waiting,
   * your career as Head Sandwich Maker at 10 Downing Street
   * will be done before it's begun. Best prepare your secret weapon:
   * the sweet baby gherkins. You whip out the jar and jerk open the lid.
   * </pre>
   * <p>
   * <strong>Slap</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset to be slapped has
   * asset.dov.slap.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.slap = {
    name: "slap",
    prettyname: "slap",
    past_tense: "slapped",
    synonyms: ["slap"],

    /**
     * @ajsverbstructures
     * @memberof slap
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof slap
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof slap
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     in_inventory: true,
     *   },
     *   accepts_preposition:true,
     *   requires_preposition:true,
     *   accepts_these_prepositions: ['with'],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof slap
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV("slap")) {
        this.game.debug(
          `F1407 | ${this.name}.js | ${direct_object.id}.dov.slap.enabled is false`,
        );
        msg += `$(We) can't slap ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1983 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      if (input.hasStructure("verb noun")) {
        // can verb act without an indirect object?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1984 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1985 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        // if( direct_object.DOVallowWithNothing(this.name) )
        // {
        //   this.game.debug(` | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `);
        //   msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
        //   this.handleFailure(msg);
        //   return null;
        // }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1986 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1987 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1988 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      }
      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1408 | ${this.name}.js | print doSuccess`);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // slap

// slither.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class slither
   * @ajsnode game.dictionary.verbs.slither
   * @ajsconstruct MyGame.createVerb({ "name": "slither", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning slither, as in "slither over log"; or, travel in specified direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; slither under barbed wire</span>
   * Like the yellow bellied coward you are, you press yourself
   * as deeply into the mud as you are able, and slither under
   * the barbed wire.
   * </pre>
   * Swim extends core verb <a href="go.html">go</a>.
   * It checks whether "swim" is contextually available
   * before forwarding to "go" for further handling.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.slither = {
    name: "slither",
    prettyname: "slither",
    past_tense: "slithered",
    synonyms: ["slither"],
    type: { locomotion: true, travel: true },
    extends: { go: true },

    player_must_be: {
      not_constrained: true,
      able_to_slither: true,
    },

    /**
     * @ajsverbstructures
     * @memberof slither
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof slither
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof slither
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof slither
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    do: function () {
      return this.game.dictionary.doVerb("go");
    },
  }; // END slither
})();

// smell.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class smell
   * @ajsnode game.dictionary.verbs.smell
   * @ajsconstruct MyGame.createVerb({ "name": "smell", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading SensationVerbs
   * @summary Verb meaning smell asset, as in "smell roses".
   * @todo should return description.odor.
   * @todo smell without dObj should return room/zone/global smell.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; smell</span>
   * You smell like a daisy! Or is it a racehorse?
   * </pre>
   * <p>
   * <strong>Smell</strong> tries to found a smell description.
   * If no direct object is provided, it looks first at the current
   * room.descriptions.smell and then at the global_smell.description.
   * If a direct object is provided, it looks for
   * asset.descriptions.smell.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.smell = {
    name: "smell",
    synonyms: ["smell"],
    past_tense: "smelled",

    /**
     * @ajsverbstructures
     * @memberof smell
     */
    accepts_structures: ["verb", "verb noun", "verb noun preposition noun"],

    /**
     * @memberof smell
     * @ajsverbphrase
     * phrase1:
     * {
     *   present: true, // @todo smells are non tangible
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        present: true,
        matter: true,
      },
    },

    /**
     * @memberof close
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof smell
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var currentRoom = this.game.getCurrentRoom();
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // sentence structure: verb
      if (input.hasStructure("verb")) {
        // does current room have smell?
        if (currentRoom.hasDescription("smell")) {
          input.verb_params.source = currentRoom.descriptions.smell;
        } else {
          // try to get global_smell
          input.verb_params.source = this.game.getGlobalAssetDescription(
            "global_smell",
            "smell",
          );
        }
        if (input.verb_params.source) {
          return true;
        } else {
          this.game.debug(`F1776 | ${this.name}.js | no smell found `);
          msg += `$(We) don't detect any particular odor. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1412 | ${this.name}.js | ${direct_object.id}.dov.smell.enabled is false `,
        );
        msg += `$(We) can't smell ${direct_object.articlename} . `;
        this.handleFailure(msg);
        return null;
      }

      if (!direct_object.hasDescription("smell")) {
        this.game.debug(
          `F1413 | ${this.name}.js | ${direct_object.id}.descriptions.smell is unset `,
        );
        msg += `$(We) can't detect any particular odor from ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      } else {
        input.verb_params.source = direct_object.getDescription("smell");
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1780 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't have any way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1781 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1778 | ${this.name}.js | ${direct_object.id} can't be ${this.state} by ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1777 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1911 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1816 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1414 | ${this.name}.js | print doSuccess`);

      // compose output
      msg += direct_object ? `$(We) sniff at ${direct_object.articlename}` : ``;
      msg += indirect_object
        ? `${indirect_preposition} ${indirect_object.articlename}}`
        : ``;
      msg += direct_object ? `. ` : ``;
      msg += input.verb_params.source
        ? A.getSAF.call(this.game, input.verb_params.source)
        : `$(We) don't smell anything in particular. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // smell

// stand.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class stand
   * @ajsnode game.dictionary.verbs.stand
   * @ajsconstruct MyGame.createVerb({ "name": "stand", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading PositionVerbs
   * @summary Verb meaning stand, as in "stand up" or "stand on trap door".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; stand in pentagram</span>
   * You stand in the pentagram. Eldritch energies
   * flicker and rise from the chalked symbol, protecting
   * you or trapping you inside, you're not sure which.
   * </pre>
   * <p>
   * <strong>Stand in</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} has an <strong>in</strong>
   * {@link adventurejs.Aspect|Aspect}
   * and that its
   * aspect.player.can.stand
   * property is set to true.
   * If player is already in the Asset, player will move to
   * a standing position.
   * See
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.stand = {
    name: "stand",
    prettyname: "stand",
    past_tense: "stood",
    synonyms: ["stand"],
    // verb_prep_noun: ["stand up", "get up", "stand down"],

    /**
     * @ajsverbstructures
     * @memberof stand
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
    ],

    player_must_be: {
      not_constrained: true,
      //not_on_floor: true,
      //not_nested_elsewhere: true,
    },

    /**
     * @memberof stand
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     not_direction: true,
     *     not_in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        not_direction: true,
        not_in_inventory: true,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      requires_preposition: true,
    },

    /**
     * @memberof stand
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    in_can_mean_on: true,

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var nest_asset = player.getNestAsset();
      var nest_preposition = player.getNestPreposition();
      var current_room = this.game.getCurrentRoom();
      var msg = "";
      var results;

      // sentence structure: verb
      if (input.hasStructure("verb")) {
        // already standing
        if (player.is.standing) {
          this.game.debug(`F1099 | ${this.name}.js | ${player.id}.is.standing`);
          msg += `$(We're) already standing! `;
          this.handleFailure(msg);
          return null;
        }
        if (nest_asset && !nest_asset.quirks.stand_means_get_off) {
          direct_preposition = player.getNestOrPlacePreposition();
          direct_object = nest_asset;
        } else {
          direct_preposition = "on";
          direct_object = this.game.getCurrentRoomFloor();
        }
        input.setAsset(1, direct_object);
        input.setPreposition(1, direct_preposition);
        input.setStructure("verb preposition noun");
      }

      // sentence structure: verb preposition
      if (input.hasStructure("verb preposition")) {
        // player input "stand down"
        if (direct_preposition === "down") {
          this.game.debug(
            `F1023 | ${this.name}.js | no response for idiom 'stand down'`
          );
          msg += `YES, SIR! `;
          this.handleFailure(msg);
          return null;
        }

        if (direct_preposition !== "up") {
          this.game.debug(
            `F1096 | ${this.name}.js | no response for idiom 'stand down'`
          );
          msg += `$(We) don't know how to stand ${direct_preposition}. `;
          this.handleFailure(msg);
          return null;
        }

        // already standing
        if (player.is.standing) {
          this.game.debug(`F1024 | ${this.name}.js | player.is.standing`);
          msg += `$(We're) already standing! `;
          this.handleFailure(msg);
          return null;
        }
      } // verb preposition

      // sentence structure: verb preposition
      if (
        input.hasStructure("verb") ||
        input.hasStructure("verb preposition")
      ) {
        // player input "stand" or "stand up"

        if (
          nest_asset &&
          (nest_asset.quirks.stand_means_get_off ||
            ("get" === input.input_verb &&
              nest_asset.quirks.get_up_means_get_off))
        ) {
          // if quirks.stand_means_get_off, go straight to doSuccess
          // return true;
          direct_object = this.game.getCurrentRoomFloor();
          direct_preposition = "on";
        } else if (nest_asset) {
          direct_object = nest_asset;
          direct_preposition = nest_preposition;
        } else {
          // see if the room has its own floor
          direct_object = this.game.getCurrentRoomFloor();
          direct_preposition = "on";
        }

        // we should now be able to assume a direct object
        if (direct_object) {
          input.setAsset(1, direct_object);
          input.setPreposition(1, direct_preposition);
          input.setAssumed(1, true);
          input.setStructure("verb preposition noun");
        }
      } // verb || verb preposition

      // sentence structure: verb preposition noun
      if (input.hasStructure("verb preposition noun")) {
        // is player allowed to stand here?
        if (
          !player.can.stand ||
          !direct_object.aspects[direct_preposition].player.can.stand
        ) {
          this.game.debug(
            `F1025 | ${this.name}.js | player.can.stand is false or ${direct_object.id}.aspects.${direct_preposition} }.player.can.stand is false`
          );
          msg += `$(We) can't stand ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can player reach it?
        if (nest_asset && nest_asset.id !== direct_object.id) {
          results = this.canPlayerGoThereFromNest(
            direct_preposition,
            direct_object
          );
          if (results.failure) {
            // this.handleFailure(results.msg);
            // return null;
            this.game.dictionary.doVerb("go");
            return null;
          }
          // if (results.return) return true;
        }

        // player is nested some other way with target
        // and needs to unnest first
        if (
          nest_asset &&
          nest_asset.id === direct_object.id &&
          nest_preposition !== direct_preposition
        ) {
          this.game.debug(
            `F1028 | ${this.name}.js | player is otherwise nested ${nest_preposition} ${nest_asset.id}`
          );
          msg += `$(We) can't do that from $(our) position ${player.getPostureGerund()} ${nest_preposition} ${
            nest_asset.articlename
          }. `;
          this.handleFailure(msg);
          return null;
        }

        // player is already standing [preposition] target
        if (player.is.standing) {
          var already_on_it;

          if (
            nest_asset &&
            nest_asset.id === direct_object.id &&
            nest_preposition === direct_preposition
          ) {
            already_on_it = true;
          }
          if (!nest_asset && direct_object instanceof adventurejs.Floor) {
            already_on_it = true;
          }

          if (already_on_it) {
            this.game.debug(
              `F1029 | ${this.name}.js | player.is.standing ${direct_preposition} ${direct_object.id} `
            );
            msg += `$(We're) already standing ${direct_preposition} ${direct_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        }
      }
      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var nest_asset = player.getNestAsset();
      var nest_preposition = player.getNestPreposition();
      var do_nest, do_unnest;
      var fromfloor;
      var tofloor;
      var results;
      var msg = "";

      this.game.debug(`F1415 | ${this.name}.js | print doSuccess`);

      tofloor = direct_object instanceof adventurejs.Floor;
      fromfloor = !nest_asset || nest_asset instanceof adventurejs.Floor;

      // floor to floor
      if (fromfloor && tofloor) {
        do_unnest = true;
        this.game.debug(`F1026 | ${this.name}.js | from floor to floor `);
        msg += `$(We) clamber up to a standing position. `;
      }

      // floor to nest or change positions on nest
      else if (
        (fromfloor && !tofloor) ||
        (nest_asset && nest_asset.id === direct_object.id)
      ) {
        do_unnest = nest_asset && nest_asset.id !== direct_object.id;
        do_nest = fromfloor && !tofloor;
        this.game.debug(
          `F1617 | ${this.name}.js | from floor to asset or change position on asset `
        );
        msg += `$(We) climb to a standing position ${direct_preposition} ${direct_object.articlename}. `;
      }

      // nest_asset to floor - unnest
      else if (!fromfloor && tofloor) {
        do_unnest = true;
        this.game.debug(`F1618 | ${this.name}.js | from asset to floor `);
        msg += `$(We) hop ${player.getPrettyUnnestPreposition()} ${
          nest_asset.articlename
        } and stand ${direct_preposition} ${direct_object.articlename}. `;
      }

      // nest_asset to same nest_asset
      else if (!fromfloor && !tofloor && direct_object.id === nest_asset.id) {
        if (player.is.lying || player.is.sitting || player.is.kneeling) {
          this.game.debug(`F1619 | ${this.name}.js | change posture on floor `);
          msg += `$(We) stand up ${nest_preposition} ${direct_object.articlename}. `;
        }
      }

      // nest_asset to other nest_asset
      else if (!fromfloor && !tofloor && direct_object.id !== nest_asset.id) {
        do_nest = true;
        do_unnest = true;
        this.game.debug(
          `F1620 | ${this.name}.js | move from one asset to another `
        );
        msg += `$(We) climb over to ${direct_object.articlename} and stand ${direct_preposition} it. `;
      }

      if (do_unnest && nest_asset) {
        results = player.onUnnestThisFromThat(nest_asset);
        if ("undefined" !== typeof results) return results;
      }

      if (do_nest && direct_object) {
        results = player.onNestThisToThat(direct_object, direct_preposition);
        if ("undefined" !== typeof results) return results;
      }

      player.posture = "stand";

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // stand

// step.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class step
   * @ajsnode game.dictionary.verbs.step
   * @ajsconstruct MyGame.createVerb({ "name": "step", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning step, as in "step on ant" or "step over threshold".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; step over threshold</span>
   * You step over the threshold, carrying your new bride, careful to
   * avoid tripping over your own comically large feet. Your bride runs
   * her gloved hand through your rainbow colored perm, tickling your nose
   * with her colorful yellow and fuscia frill. She raises her head for
   * a kiss, and you mash your brightly painted red lips into hers,
   * commingling both your makeups into smears of red and white pancake.
   * You part breathlessly, and she honks your foam nose in connubial bliss.
   * </pre>
   * <p>
   * See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn how to customize this verb.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.step = {
    name: "step",
    prettyname: "step",
    past_tense: "stepped",
    synonyms: ["step"],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
    },

    /**
     * @memberof step
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *     visible: true,
     *     not_worn: true,
     *     not_in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
        visible: true,
        not_worn: true,
        not_in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof step
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var msg = "";
      var containers;

      if (!direct_object) {
        this.game.debug(`F1648 | ${this.name}.js | no direct object `);
        msg += `$(We) step. `;
        this.handleFailure(msg);
        return null;
      }

      // this can be a travel verb - is noun a direction?
      if (direct_object.direction) {
        if (
          !direct_preposition ||
          "through" === direct_preposition ||
          "in" === direct_preposition
        ) {
          this.game.debug(
            `F1416 | ${this.name}.js | tryTravel ${direct_object.direction} `
          );
          this.game.tryTravel(direct_object.direction);
          return null;
        }
      }

      // no preposition
      if (!direct_preposition) {
        this.game.debug(`F1644 | ${this.name}.js | preposition required `);
        msg += this.game.parser.getUnparsedMessage(input.input);
        this.handleFailure(msg);
        return null;
      }

      // did player input something like "step on sand" ?
      // if so it must come from a substance container that
      // is a reachable substance body
      if (direct_object instanceof adventurejs.Substance) {
        // get a list of available bodies of substance
        containers = this.game.findSubstanceContainers(direct_object.id, [
          "Present",
          "Known",
          "Visible",
          "BodyOfSubstance",
        ]);
        console.warn("containers", containers);

        switch (containers.length) {
          case 0:
            this.game.debug(`F1649 | ${this.name}.js | no valid vessel found `);
            msg += `There doesn't appear to be any ${
              this.game.getAsset(direct_object.id).name
            } to step ${direct_preposition}. `;
            this.handleFailure(msg);
            return null;
          case 1:
            // set container as direct_object
            // and treat like "step in container"
            direct_object = this.game.getAsset(containers[0]);
            input.setAsset(1, direct_object);
            if (direct_object.id === this.game.getCurrentRoom().id) {
              this.game.debug(
                `F1651 | ${this.name}.js | ${direct_object.id} is current room `
              );
              msg += `$(We're) standing in it. `;
              this.handleFailure(msg);
              return null;
            }
            break;
          default:
            this.game.debug(
              `F1650 | ${this.name}.js | multiple containers found, disambiguate `
            );
            // disambiguate - need to set parsedNoun.matches
            // save containers back to input for next turn disambiguation
            input.setParsedNounMatchesQualified(1, containers);
            this.game.parser.printNounDisambiguation({
              parsedNoun: input.getParsedNoun(1),
              nounIndex: 1,
            });
            return null;
        } // switch containers.length
      } // direct_object is substance

      // did player mean to stand on the thing?
      if (
        direct_preposition === "on" &&
        direct_object.quirks.step_on_means_stand_on
      ) {
        this.game.debug(`F1645 | ${this.name}.js | doVerb stand `);
        this.game.dictionary.doVerb("stand");
        return null;
      }

      // did player input something like "step in tub" ?
      // let them go
      if (
        direct_object.hasAspectAt(direct_preposition) &&
        direct_object.getAspectAt(direct_preposition).player.can.enter
      ) {
        this.game.debug(`F1646 | ${this.name}.js | doVerb go `);
        input.setVerb("go");
        this.game.dictionary.doVerb("go");
        return null;
      }

      // did player input something like "step in tub" ?
      // let them go
      if (
        direct_object.hasAspectAt(direct_preposition) &&
        !direct_object.getAspectAt(direct_preposition).player.can.enter
      ) {
        this.game.debug(`F1417 | ${this.name}.js | doVerb go `);
        msg += `$(We) can't step ${direct_preposition} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // did player input something like "step in tub" ?
      // but can't go in tub?
      if (
        "on" !== direct_preposition &&
        (!direct_object.hasAspectAt(direct_preposition) ||
          !direct_object.aspects[direct_preposition].player.can.enter)
      ) {
        this.game.debug(`F1647 | ${this.name}.js | doVerb go `);
        msg += `$(We) can't step ${direct_preposition} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (
        direct_object.getPlaceAssetId() !== player.getPlaceAssetId() &&
        direct_object.getPlaceAssetId() !== player.getNestId()
      ) {
        this.game.debug(
          `F1652 | ${this.name}.js | ${
            direct_object.id
          } is ${direct_object.getPlacePreposition()} ${direct_object.getPlaceAssetId()} and player is ${player.getPlacePreposition()} ${player.getPlaceAssetId()}`
        );
        msg += `$(We) can't step ${direct_preposition} ${
          direct_object.articlename
        } ${direct_object.getPlacePreposition()} ${
          direct_object.getPlaceAsset().articlename
        }. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1418 | ${this.name}.js | print doSuccess `);
      msg += `$(We) step ${direct_preposition} ${direct_object.articlename}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  }; // END step
})();

// stomp.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class stomp
   * @ajsnode game.dictionary.verbs.stomp
   * @ajsconstruct MyGame.createVerb({ "name": "stomp", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning stomp, as in "stomp on wine glass".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; stomp on ant</span>
   * Forgetting the proportional strength of the irradiated ant,
   * you attempt to stomp on it. Using its gamma induced strength,
   * it throws you back on your bum.
   * </pre>
   * <p>
   * <strong>Stomp</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be kicked has
   * <code>dov.stomp</code> set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn how to customize this verb.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.stomp = {
    name: "stomp",
    prettyname: "stomp",
    past_tense: "stamped",
    synonyms: ["stomp", "stamp"],

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
    },

    /**
     * @ajsverbstructures
     * @memberof stomp
     */
    accepts_structures: ["verb noun", "verb preposition noun"],

    /**
     * @memberof stomp
     * @ajsverbphrase
     * phrase1:
     * {
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *     visible: true,
     *     not_worn: true,
     *     not_in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   accepts_these_prepositions: ["on","in"],
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
        visible: true,
        not_worn: true,
        not_in_inventory: true,
      },
      accepts_preposition: true,
      accepts_these_prepositions: ["on", "in"],
    },

    /**
     * @memberof stomp
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var msg = "";
      var containers;
      var direct_object_vessel;

      if (!direct_object) {
        this.game.debug(`F1652 | ${this.name}.js | no direct object `);
        msg += `$(We) stomp $(our) pretty little feet. `;
        this.handleFailure(msg);
        return null;
      }

      // this can be a travel verb - is noun a direction?
      if (direct_object.direction) {
        if (
          !direct_preposition ||
          "through" === direct_preposition ||
          "in" === direct_preposition
        ) {
          this.game.debug(
            `F1653 | ${this.name}.js | tryTravel ${direct_object.direction} `,
          );
          this.game.tryTravel(direct_object.direction);
          return null;
        }
      }

      // verb enabled?
      if (!direct_object.isDOV("kick")) {
        this.game.debug(
          `F1989 | ${this.name}.js | ${direct_object.id}.dov.kick.enabled is false `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // this.game.debug(`F1647 | ${this.name}.js | preposition required `);
        // msg += this.game.parser.getUnparsedMessage(input.input);
        // this.handleFailure(msg);
        // return null;
        direct_preposition = "on";
        input.setPreposition(1, "on");
        input.setStructure("verb preposition noun");
      } // verb noun

      // did player input something like "stomp on water" ?
      // if so it must come from a substance container that
      // is a reachable substance body
      if (direct_object instanceof adventurejs.Substance) {
        // get a list of available bodies of substance
        containers = this.game.findSubstanceContainers(direct_object.id, [
          "Present",
          "Known",
          "Visible",
          "BodyOfSubstance",
        ]);
        console.warn("containers", containers);

        switch (containers.length) {
          case 0:
            this.game.debug(`F1657 | ${this.name}.js | no valid vessel found `);
            msg += `There doesn't appear to be any ${
              this.game.getAsset(direct_object.id).name
            } to stomp ${direct_preposition}. `;
            this.handleFailure(msg);
            return null;
          case 1:
            // set container as direct_object
            // and treat like "stomp in container"
            direct_object_vessel = this.game.getAsset(containers[0]);
            input.setAssumed(1, true);
            input.setVessel(1, direct_object_vessel);

            // is player in same location as substance?
            if (direct_object_vessel.id !== player.getNestOrPlaceAsset().id) {
              this.game.debug(
                `F1658 | ${this.name}.js | ${direct_object_vessel.id} !== ${
                  player.getNestOrPlaceAsset().id
                }`,
              );
              msg += `$(We're) not standing in it. `;
              this.handleFailure(msg);
              return null;
            }
            return true;
          //break;
          default:
            this.game.debug(
              `F1659 | ${this.name}.js | multiple containers found, disambiguate `,
            );
            // disambiguate - need to set parsedNoun.matches
            // save containers back to input for next turn disambiguation
            input.setParsedNounMatchesQualified(1, containers);
            this.game.parser.printNounDisambiguation({
              parsedNoun: input.getParsedNoun(1),
              nounIndex: 1,
            });
            return null;
        } // switch containers.length
      } // direct_object is substance

      // did player input something like "stomp in tub" ?
      // if they're in the tub let them do it
      if (
        player.getNestOrPlaceAsset().id === direct_object.id &&
        player.getNestOrPlacePreposition() === direct_preposition
      ) {
        this.game.debug(`F1654 | ${this.name}.js | allow stomp `);
        return true;
      }

      // did player input something like "stamp in desk" ?
      // but can't go in desk?
      if (
        "on" !== direct_preposition &&
        (!direct_object.hasAspectAt(direct_preposition) ||
          !direct_object.aspects[direct_preposition].player.can.enter)
      ) {
        this.game.debug(`F1660 | ${this.name}.js | doVerb go `);
        msg += `$(We) can't stomp ${direct_preposition} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (
        direct_object.getPlaceAssetId() !== player.getPlaceAssetId() &&
        direct_object.getPlaceAssetId() !== player.getNestId()
      ) {
        this.game.debug(
          `F1655 | ${this.name}.js | ${
            direct_object.id
          } is ${direct_object.getPlacePreposition()} ${direct_object.getPlaceAssetId()} and player is ${player.getPlacePreposition()} ${player.getPlaceAssetId()}`,
        );
        msg += `$(We) can't stomp ${direct_preposition} ${
          direct_object.articlename
        } ${direct_object.getPlacePreposition()} ${
          direct_object.getPlaceAsset().articlename
        }. `;
        this.handleFailure(msg);
        return null;
      }

      if (direct_object.getPlaceAssetId() === player.id) {
        this.game.debug(
          `F1990 | ${this.name}.js | ${direct_object.id} is in player `,
        );
        msg += `$(We) can't ${this.name} ${direct_preposition} ${direct_object.articlename} while holding it. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1991 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1656 | ${this.name}.js | print doSuccess `);

      // compose output
      msg += `$(We) ${this.name} ${direct_preposition} ${direct_object.articlename}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // stomp

// swim.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class swim
   * @ajsnode game.dictionary.verbs.swim
   * @ajsconstruct MyGame.createVerb({ "name": "swim", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning swim, as in "swim through tunnel"; or, travel in specified direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; swim under bear</span>
   * You try to swim under the bear that blocks your path to the
   * waterfall and the spawning grounds beyond. Sadly, it
   * pulls you out of the water with one big swipe of its paw.
   * </pre>
   * Swim extends core verb <a href="go.html">go</a>.
   * It checks whether "swim" is contextually available
   * before forwarding to "go" for further handling.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.swim = {
    name: "swim",
    prettyname: "swim",
    past_tense: "swam",
    synonyms: ["swim"],
    type: { locomotion: true, travel: true },
    extends: { go: true },

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
      able_to_swim: true,
    },

    /**
     * @ajsverbstructures
     * @memberof swim
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof swim
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof swim
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof swim
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    do: function () {
      return this.game.dictionary.doVerb("go");
    },
  }; // END swim
})();

// take.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class take
   * @ajsnode game.dictionary.verbs.take
   * @ajsconstruct MyGame.createVerb({ "name": "take", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning take, as in "take lantern".
   * @ajssynonyms take, pick up
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; take nap</span>
   * You take a nap from the dish on the console table,
   * but you're not sure what to do with it.
   * </pre>
   * <p>
   * <strong>Take</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that
   * <code>asset.dov.take.enabled</code> is true.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.take = {
    name: "take",
    prettyname: "take",
    past_tense: "took",
    synonyms: ["take"],
    enqueue_collections: true,

    /**
     * @ajsverbstructures
     * @memberof take
     */
    accepts_structures: [
      "verb noun",
      "verb preposition noun", // take off jacket
      "verb noun preposition", // take jacket off
      "verb noun preposition noun",
    ],

    /**
     * @memberof take
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   accepts_plural_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     not_global: true,
     *     not_scenery: true,
     *     not_exit: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     takeable: true,
     *     not_in_hands: true,
     *     not_worn: true,
     *     not_nested_inventory_if_all: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      accepts_plural_noun: true,
      noun_must_be: {
        known: true,
        not_global: true,
        not_scenery: true,
        not_exit: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        takeable: true,
        not_in_hands: true,
        //not_worn: true,
        not_nested_inventory_if_all: true,
      },
      accepts_preposition: true,
      //accepts_these_prepositions: ["off"],
    },

    /**
     * @memberof take
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     not_global: true,
     *     not_scenery: true,
     *     not_exit: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   accepts_these_prepositions: [],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        not_global: true,
        not_scenery: true,
        not_exit: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      //accepts_these_prepositions: [],
    },

    /**
     * @memberof take
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var direct_preposition = input.getPreposition(1);
      var indirect_preposition = input.getPreposition(2);
      var closedAnscestors = [];
      var player = this.game.getPlayer();
      var msg = "";
      var takefrom = "";
      var substance;
      var results;

      //console.warn(`doTry take ${direct_object.id}`);

      if (!direct_object.isDOV("take")) {
        this.game.debug(
          `F1922 | ${this.name}.js | ${direct_object.id}.dov.${this.name} not enabled `,
        );
        msg += `$(We) can't ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (input.hasStructure("verb noun preposition")) {
        if (["off"].indexOf(indirect_preposition) > -1) {
          // ex: take jacket off
          if (direct_object.is.worn) {
            direct_preposition = indirect_preposition;
            input.setPreposition(1, indirect_preposition);
            input.deletePhrase(2);
            input.setStructure("verb preposition noun");
          } else {
            // otherwise just take it
            indirect_preposition = "";
            input.setStructure("verb noun");
            input.deletePhrase(2);
          }
        } else if (["down"].indexOf(indirect_preposition) > -1) {
          // ex: take curtain down
          indirect_preposition = "";
          input.deletePhrase(2);
          input.setStructure("verb noun");
        } else {
          this.game.debug(
            `F1925 | ${this.name}.js | ${this.name} ${indirect_preposition} not handled `,
          );
          msg += `$(We) don't know how to ${this.name} ${direct_object.articlename} ${indirect_preposition}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      if (input.hasStructure("verb preposition noun")) {
        if (direct_preposition === "off") {
          // ex: take off jacket
          if (direct_object.is.worn) {
            direct_preposition = "";
            input.setPreposition(1, "");
            input.setStructure("verb noun");
            this.game.debug(
              `F1927 | ${this.name}.js | take off, doVerb remove `,
            );
            this.game.dictionary.doVerb("remove");
            return null;
          } else {
            // otherwise just take it
            direct_preposition = "";
            input.setStructure("verb noun");
            input.deletePhrase(2);
          }
        } else if (direct_preposition === "down") {
          // ex: take down curtain
          input.setStructure("verb noun");
        } else {
          this.game.debug(
            `F1928 | ${this.name}.js | ${this.name} ${direct_preposition} not handled `,
          );
          msg += `$(We) don't know how to ${this.name} ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        indirect_object = direct_object.getPlaceAsset();
        indirect_preposition = "from";
        input.setAsset(2, indirect_object);
        input.setPreposition(2, indirect_preposition);
        input.setStructure("verb noun preposition noun");
      } // verb noun

      if ("from" === indirect_preposition || "out" === indirect_preposition) {
        takefrom = "from";
      }
      if ("fromin" === indirect_preposition) {
        takefrom = "in";
      } else if ("fromon" === indirect_preposition) {
        takefrom = "on";
      } else if (
        "fromunder" === indirect_preposition ||
        "outfromunder" === indirect_preposition
      ) {
        takefrom = "under";
      } else if (
        "frombehind" === indirect_preposition ||
        "outfrombehind" === indirect_preposition
      ) {
        takefrom = "behind";
      }

      if (input.hasStructure("verb noun preposition noun")) {
      }

      // we're handling take and hold distinctly though there is clear crossover
      // mind this because there is also an opportunity for hold to redirect to take
      if (direct_object.quirks.take_means_hold && direct_object.isDOV("hold")) {
        if ("all" !== input.parsedNoun1.deserialized_input) {
          this.game.debug(
            `F1422 | ${this.name}.js | ${direct_object.id}.quirks.take_means_hold, doVerb hold `,
          );
          this.game.dictionary.doVerb("hold");
        }
        return null;
      }

      // can't take exits
      if (direct_object instanceof adventurejs.Exit) {
        this.game.debug(
          `F1425 | ${this.name}.js | ${direct_object.id} is exit `,
        );
        msg += "Pity $(we) can't take direction.";
        this.handleFailure(msg);
        return null;
      }

      // can't take substances
      substance = input.getParsedNoun(1).matches.substance;
      if (substance) {
        this.game.debug(
          `F1372 | ${this.name}.js | substance ${substance} can only be carried in a vessel `,
        );
        msg +=
          this.game.getAsset(substance).Articlename +
          " slips through $(our) fingers. ";
        this.handleFailure(msg);
        return null;
      }

      // already carrying
      if (direct_object.getPlaceAssetId() === this.game.getPlayer().id) {
        this.game.debug(
          `F1426 | ${this.name}.js | ${direct_object.id} is in player `,
        );
        msg += `$(We're) already ${
          direct_object.is.worn ? "wearing" : "carrying"
        } ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // can't "take" it...
      if (
        direct_object.isDOV("tie") &&
        !direct_object.DOVhasMaxConnections("tie")
      ) {
        // but might be able to "hold" it...?
        if (
          direct_object.isDOV("hold") &&
          !player.IOVisConnectedToAsset(this.name, direct_object) &&
          !player.IOVhasMaxConnections(this.name)
        ) {
          this.game.debug(
            `F1427 | ${this.name}.js | ${direct_object.id} is tied to things and .dov.hold.enabled, doVerb hold `,
          );
          this.game.dictionary.doVerb("hold");
          return null;
        }

        if (player.IOVisConnectedToAsset("hold", direct_object)) {
          this.game.debug(
            `F1428 | ${this.name}.js | ${direct_object.id} is in ${player.id}.iov.hold.with_params.connections `,
          );
          msg += `$(We're) holding ${direct_object.articlename} already. `;
        }

        this.game.debug(
          `F1429 | ${this.name}.js | ${direct_object.id} is tied to things `,
        );
        msg += `$(We) can't take ${direct_object.articlename} while it's tied to
            this.game.getPrintableObjectList({ objects: direct_object.DOVgetConnections('tie') }). `;
        this.handleFailure(msg);
        return null;
      }

      if (indirect_object) {
        if (!direct_object.isIn(indirect_object)) {
          this.game.debug(
            `F1512 | ${this.name}.js | ${direct_object.id} is not in ${indirect_object.id} `,
          );
          if (indirect_object instanceof adventurejs.Character) {
            msg += `${indirect_object.Articlename} hasn't got ${direct_object.articlename}. `;
          } else {
            msg += `There's no ${direct_object.name} 
              ${
                takefrom && takefrom !== "from"
                  ? takefrom
                  : indirect_object.default_aspect
              } ${indirect_object.articlename}. `;
          }
          this.handleFailure(msg);
          return null;
        }

        // takefrom
        if (takefrom && takefrom !== "from") {
          if (direct_object.getPlacePreposition() !== takefrom) {
            this.game.debug(
              `F1513 | ${this.name}.js | ${direct_object.id} is not ${takefrom} ${indirect_object.id} `,
            );
            msg += `There's no ${direct_object.name} ${takefrom} ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        }

        if (!indirect_object.isIOV("take")) {
          this.game.debug(
            `F1929 | ${this.name}.js | ${indirect_object.id}.iov.take is unset `,
          );
          msg += `$(We) can't take ${direct_object.articlename} from ${
            direct_object.getPlaceAsset().articlename
          }. `;
          this.handleFailure(msg);
          return null;
        }

        if (direct_object.is.worn && !direct_object.isDOV("remove")) {
          this.game.debug(
            `F1930 | ${this.name}.js | ${direct_object.id}.dov.remove is unset `,
          );
          msg += `$(We) can't remove ${direct_object.articlename} from ${
            direct_object.getPlaceAsset().articlename
          }. `;
          this.handleFailure(msg);
          return null;
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var closedAnscestors = [];
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";
      var results;

      this.game.debug(`F1424 | ${this.name}.js | print doSuccess `);
      // open any containers if necessary
      // we only do this for items nested in inventory
      if (direct_object.isIn(player) && direct_object.areAnscestorsClosed()) {
        closedAnscestors = direct_object.getClosedAnscestors();

        for (var i = 0; i < closedAnscestors.length; i++) {
          this.game.getAsset(closedAnscestors[i]).is.closed = false;
          closedAnscestors[i] = this.game.getAsset(closedAnscestors[i]).name;
        }
      }

      // remove thing from its current container
      //results = indirect_object.onRemoveThatFromThis( direct_object );
      results = direct_object.moveFrom(indirect_object);
      if ("undefined" !== typeof results) return results;

      // add thing to player's contents
      //results = player.onMoveThatToThis( direct_object, "in" );
      results = direct_object.moveTo("in", player);
      if ("undefined" !== typeof results) return results;

      if (closedAnscestors.length > 0) {
        msg += `$(We) open the `;
        for (var i = 0; i < closedAnscestors.length; i++) {
          if (closedAnscestors.length > 2 && i < closedAnscestors.length - 2) {
            msg += `, `;
          }
          if (
            closedAnscestors.length > 1 &&
            i === closedAnscestors.length - 1
          ) {
            msg += ` and the `;
          }
          msg += closedAnscestors[i];
        }
        msg += `. `;
      }

      msg += `$(We) take ${direct_object.articlename}`;
      msg += !(indirect_object instanceof adventurejs.Room)
        ? ` ${indirect_preposition} ${indirect_object.articlename}`
        : ``;
      msg += `. `;

      if (
        1 < input.parsedNoun1.matches.qualified.length &&
        -1 === input.output_class.indexOf("concatenate_output")
      ) {
        input.output_class += " concatenate_output ";
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // take

// tap.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class tap
   * @ajsnode game.dictionary.verbs.tap
   * @ajsconstruct MyGame.createVerb({ "name": "tap", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading GesticulationVerbs
   * @summary Verb meaning tap, as in "tap keyboard".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; tap window</span>
   * You tap on the window in hopes of catching Nurse Emily's attention.
   * Unfortunately it's Doctor Fortescue who turns. You duck beneath the
   * window, now hoping to go unseen. Who knows what might happen if
   * you're caught out of bed. You might be branded a malingerer and sent
   * to the stockade...or worse, get sent back to the front lines.
   * </pre>
   * <p>
   * <strong>Tap</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset to be tapped has
   * asset.dov.tap.enabled set to true.
   * No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.tap = {
    name: "tap",
    prettyname: "tap",
    past_tense: "tapped",
    synonyms: ["tap"],

    /**
     * @ajsverbstructures
     * @memberof wave
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof tap
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof tap
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   //accepts_these_prepositions: [ "with" ],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      //accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof tap
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";
      var results;

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
        this.game.debug(`F1995 | ${this.name}.js | no object given`);
        msg += `$(We) drum $(our) fingers on the nearest surface. `;
        this.handleFailure(msg);
        return null;
      }

      if (!direct_object.isDOV("tap")) {
        this.game.debug(
          `F1430 | ${this.name}.js | ${direct_object.id}.dov.tap.enabled is false `
        );
        msg += `$(We) can't tap ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (input.hasStructure("verb noun preposition noun")) {
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";
      var results;

      this.game.debug(`F1431 | ${this.name}.js | print doSuccess `);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // tap

// taste.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class taste
   * @ajsnode game.dictionary.verbs.taste
   * @ajsconstruct MyGame.createVerb({ "name": "taste", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading SensationVerbs
   * @summary Verb meaning taste, as in "taste toad venom".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; taste fruit</span>
   * You taste the forbidden fruit. Did you think that only
   * tasting it and not eating it would protect you from the
   * curse of knowledge? Well, forget it, buddy. Now you know.
   * NOW. YOU. KNOW. Now get outta my garden!
   * </pre>
   * <p>
   * <strong>Taste</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be tasted has
   * asset.dov.taste.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * <p>
   * Taste and {@link lick|lick} behave identically if they're
   * not given any special reactions.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.taste = {
    name: "taste",
    prettyname: "taste",
    past_tense: "tasted",
    synonyms: ["taste"],

    /**
     * @ajsverbstructures
     * @memberof taste
     */
    accepts_structures: ["verb noun"],

    /**
     * @memberof taste
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof taste
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (!direct_object.isDOV("taste")) {
        this.game.debug(
          `F1432 | ${this.name}.js | ${direct_object.id}.dov.taste.enabled is false `
        );
        msg += `$(We) can't taste ${direct_object.name}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1994 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `
        );
        msg += `$(We've) already ${this.past_tense} enough of ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return false;
      }

      if (!direct_object.hasDescription("taste")) {
        this.game.debug(
          `F1433 | ${this.name}.js | ${direct_object.id}.descriptions.taste is unset `
        );
        msg += `${direct_object.Articlename} has no particular taste. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      this.game.debug(`F1434 | ${this.name}.js | print doSuccess `);

      // compose output
      msg += `$(We) gently nibble at ${direct_object.articlename}. `;
      msg += direct_object.getDescription("taste");

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // taste

// tear.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class tear
   * @ajsnode game.dictionary.verbs.tear
   * @ajsconstruct MyGame.createVerb({ "name": "tear", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DestructionVerbs
   * @summary Verb meaning tear, as in "tear envelope".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; tear card</span>
   * You tear the punch card, despite the explicit warning on it
   * that says, "Do not fold, spindle, or mutilate". The menacing
   * robot stops pursuing you and grinds to a halt. Smoke trickles
   * out of its chassis as it audibly breaks down. It begins to
   * vibrate and wobble. One panel flies off and then another, and
   * the robot begins ejecting cogs and gears at high velocity.
   * Finally, the robot collapses entirely into a pile of greasy parts.
   * </pre>
   * <p>
   * <strong>Tear</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be torn has
   * asset.dov.tear.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.tear = {
    name: "tear",
    prettyname: "tear",
    past_tense: "tore",
    synonyms: ["tear", "rip"],
    state: "torn",

    /**
     * @ajsverbstructures
     * @memberof tear
     */
    accepts_structures: ["verb noun", "verb preposition noun"],

    /**
     * @memberof tear
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   accepts_these_prepositions: ["up"],
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      accepts_these_prepositions: ["up"],
    },

    /**
     * @memberof tear
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (!direct_object.isDOV("tear")) {
        this.game.debug(
          `F1435 | ${this.name}.js | ${direct_object.id}.dov.tear.enabled is false `,
        );
        msg += `$(We) can't tear ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1992 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1436 | ${this.name}.js | print doSuccess `);

      var already_torn = direct_object.isState(this.state);

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) tear ${direct_object.articlename}${already_torn ? " some more" : ""}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // tear

// teleport.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class teleport
   * @ajsnode game.dictionary.verbs.teleport
   * @ajsconstruct MyGame.createVerb({ "name": "teleport", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb meaning teleport, as in "teleport to moonbase".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; teleport to planet</span>
   * You beam down to the planet. Or, at least, someone identical to
   * you does. But is it really <b>you</b> that arrives at the other end of
   * the teleportation beam?
   * </pre>
   * <p>
   * <strong>Teleport to</strong> another
   * {@link adventurejs.Tangible|Tangible}.
   * This is included chiefly as a debug tool, though it
   * could also be tweaked into a useful game verb, for
   * instance with use of a teleportation device.
   * Authors may want to disable it through the use of
   * {@link adventurejs.Game#disableVerbs|disableVerbs}.
   * To learn more, see
   * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>
   * </p>
   */
  A.Preverbs.teleport = {
    name: "teleport",
    prettyname: "teleport to",
    synonyms: ["teleport"],
    verb_prep_noun: ["teleport to"],

    /**
     * @memberof teleport
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     present: false,
     *     // known: true, // false for debug, would be true if used as player verb
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        tangible: true,
        present: false,
      },
    },

    /**
     * @memberof teleport
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var output_class = input.output_class;
      var player = this.game.getPlayer();
      var nest_preposition = player.getNestPreposition();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();
      var currentRoom = this.game.getCurrentRoom();
      var msg = "";

      if (
        direct_object instanceof adventurejs.Room &&
        direct_object.id == currentRoom.id
      ) {
        this.game.debug(
          `F1437 | teleport.js | player is in " + ${currentRoom.id} + " `
        );
        msg += `$(We're) already there. `;
        this.handleFailure(msg);
        return null;
      }

      if (player.isNested() && nest_parent_id === direct_object.id) {
        this.game.debug(
          `F1438 | teleport.js | player is nested in ${nest_parent_id}`
        );
        msg += `$(We're) already ${nest_preposition} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (direct_object.getRoomId() === currentRoom.id) {
        this.game.debug(`F1439 | teleport.js | player is in ${currentRoom.id}`);
        msg = `$(We're) already there. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var output_class = input.output_class;
      var player = this.game.getPlayer();
      var nest_parent_id = player.getNestId();
      var nest_parent_object = player.getNestAsset();
      var newRoom;
      var results;
      var msg = "";

      this.game.debug(`F1440 | teleport.js | print doSuccess `);
      // is direct_object a room?
      if (direct_object instanceof adventurejs.Room) {
        newRoom = direct_object;
      } else {
        newRoom = this.game.getAsset(direct_object.getRoomId());
      }

      // if player is nested, unnest from old nest
      if (player.isNested()) {
        results = player.onUnnestThisFromThat(nest_parent_object);
        if ("undefined" !== typeof results) return results;
      }
      this.game.setPlayerRoom(newRoom, input);
      msg += `$(We) teleport to ${direct_object.definite_name}. `;

      // move player from currentRoom

      // move player to newRoom

      // TODO
      // if newNest, nest player

      // currentRoom = newRoom

      this.handleSuccess(msg, direct_object);

      return true;
    },
  };
})(); // teleport

// tell.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class tell
   * @ajsnode game.dictionary.verbs.tell
   * @ajsconstruct MyGame.createVerb({ "name": "tell", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading Conversation Verbs
   * @summary Verb meaning tell, as in "tell anteater about anthill".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; </span>
   *
   * </pre>
   * <p>
   * Description of the verb.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.tell = {
    name: "tell",
    prettyname: "tell about",
    past_tense: "told",
    synonyms: ["tellabout"],
    verb_prep_noun: ["tell about"], // tell about thing
    verb_noun_prep_noun: ["tell about"], // tell person about thing

    /**
     * @memberof tell
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     present: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        present: true,
      },
    },

    /**
     * @memberof tell
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
      },
    },

    /**
     * @memberof tell
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var msg = "";

      // no indirect object given
      // if( "undefined" === typeof input.parsedNoun2 )
      // {
      //   input.parsedNoun2 = A.clone.call(this.game, input.parsedNoun1 );
      //   input.parsedNoun1 = undefined;
      //   input.setSoftPrompt({ noun1: true, verb: 'tell' });
      //   var msg = "To whom would you like to tell it? ";
      //   this.handleFailure(msg);
      //   return null;
      // }

      // can't talk to non-characters
      if (!(direct_object instanceof adventurejs.Character)) {
        this.game.debug(
          `F1441 | ${this.name}.js | ${direct_object.id} is not class Character `
        );
        msg += `${direct_object.Articlename} doesn't listen. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player;
      var direct_object;
      var msg = "";

      this.game.debug(`F1442 | ${this.name}.js | print doSuccess `);
      // tell x about y
      msg += `$(We) tell ${direct_object.articlename} about ${indirect_object.articlename}. `;

      // transfer of knowledge

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // tell

// test.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class test
   * @ajsnode game.dictionary.verbs.test
   * @ajsconstruct MyGame.createVerb({ "name": "test", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc Verbs start out as generic objects, which are converted
   * to verb class instances at runtime.
   * <br/><br/>
   * Verbs have access to the global Input object ( game.getInput() ),
   * which contains parsed player input.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.test = {
    name: "test",
    prettyname: "test",
    past_tense: "tested",
    state: "tested",
    unstate: "untested",
    synonyms: ["test"],
    verb_noun_prep: [],
    verb_prep_noun: [],
    verb_prep_prep_noun: [],
    verb_prep_prep_prep_noun: [],
    verb_noun_prep_noun: [],
    verb_noun_prep_prep_noun: [],
    verb_noun_prep_noun_prep_noun: [],
    verb_prep_noun_prep_noun_prep_noun: [],

    /**
     * @ajsverbstructures
     * @memberof test
     */
    accepts_structures: [
      "verb",
      "verb preposition",
      "verb noun",
      "verb preposition noun",
      "verb noun noun",
      "verb noun preposition noun",
      "verb noun preposition noun preposition noun",
      "verb preposition noun preposition noun preposition noun",
    ],

    /**
     * @memberof test
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   // requires_noun: true,
     *   // accepts_plural_noun: true,
     *   noun_must_be: {
     *     // direction: true,
     *     // not_direction: true,
     *     // tangible: true,
     *     // intangible: true,
     *     // character: true,
     *     // present: true,
     *     // visible: true,
     *     // reachable: true,
     *     // takeable: true,
     *     // known: true,
     *     // in_inventory: true,
     *     // not_in_inventory: true,
     *     // worn: true,
     *     // not_worn: true,
     *     // in_hands: true,
     *     // not_in_hands: true,
     *   },
     *   // accepts_preposition: true,
     *   // accepts_preposition_without_noun: true,
     *   // requires_preposition: true,
     *   // accepts_these_prepositions: [ 'from' ],
     *   // declines_these_prepositions: [ 'to' ],
     * },
     */

    phrase1: {
      accepts_noun: true,
      // requires_noun: true,
      accepts_plural_noun: true,
      noun_must_be: {
        // direction: true,
        // not_direction: true,
        // tangible: true,
        // intangible: true,
        // character: true,
        // present: true,
        // visible: true,
        // reachable: true,
        // takeable: true,
        // known: true,
        // in_inventory: true,
        // not_in_inventory: true,
        // worn: true,
        // not_worn: true,
        // in_hands: true,
        // not_in_hands: true,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      // requires_preposition: true,
      // accepts_these_prepositions: [ 'from' ],
      // declines_these_prepositions: [ 'to' ],
    },

    /**
     * @memberof test
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   // requires_noun: true,
     *   // accepts_plural_noun: true,
     *   noun_must_be: {
     *     // direction: true,
     *     // not_direction: true,
     *     // tangible: true,
     *     // intangible: true,
     *     // character: true,
     *     // present: true,
     *     // visible: true,
     *     // reachable: true,
     *     // takeable: true,
     *     // known: true,
     *     // in_inventory: true,
     *     // not_in_inventory: true,
     *     // worn: true,
     *     // not_worn: true,
     *     // in_hands: true,
     *     // not_in_hands: true,
     *   },
     *   // accepts_preposition: true,
     *   // accepts_preposition_without_noun: true,
     *   // requires_preposition: true,
     *   // accepts_these_prepositions: [ 'from' ],
     *   // declines_these_prepositions: [ 'to' ],
     * },
     */

    phrase2: {
      accepts_noun: true,
      // requires_noun: true,
      accepts_plural_noun: true,
      noun_must_be: {
        // direction: true,
        // not_direction: true,
        // tangible: true,
        // intangible: true,
        // character: true,
        // present: true,
        // visible: true,
        // reachable: true,
        // takeable: true,
        // known: true,
        // in_inventory: true,
        // not_in_inventory: true,
        // worn: true,
        // not_worn: true,
        // in_hands: true,
        // not_in_hands: true,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      // requires_preposition: true,
      // accepts_these_prepositions: [ 'from' ],
      // declines_these_prepositions: [ 'to' ],
    },

    /**
     * @memberof test
     * @ajsverbphrase
     * phrase3:
     * {
     *   accepts_noun: true,
     *   // requires_noun: true,
     *   // accepts_plural_noun: true,
     *   noun_must_be: {
     *     // direction: true,
     *     // not_direction: true,
     *     // tangible: true,
     *     // intangible: true,
     *     // character: true,
     *     // present: true,
     *     // visible: true,
     *     // reachable: true,
     *     // takeable: true,
     *     // known: true,
     *     // in_inventory: true,
     *     // not_in_inventory: true,
     *     // worn: true,
     *     // not_worn: true,
     *     // in_hands: true,
     *     // not_in_hands: true,
     *   },
     *   // accepts_preposition: true,
     *   // accepts_preposition_without_noun: true,
     *   // requires_preposition: true,
     *   // accepts_these_prepositions: [ 'from' ],
     *   // declines_these_prepositions: [ 'to' ],
     * },
     */

    phrase3: {
      accepts_noun: true,
      // requires_noun: true,
      accepts_plural_noun: true,
      noun_must_be: {
        // direction: true,
        // not_direction: true,
        // tangible: true,
        // intangible: true,
        // character: true,
        // present: true,
        // visible: true,
        // reachable: true,
        // takeable: true,
        // known: true,
        // in_inventory: true,
        // not_in_inventory: true,
        // worn: true,
        // not_worn: true,
        // in_hands: true,
        // not_in_hands: true,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      // requires_preposition: true,
      // accepts_these_prepositions: [ 'from' ],
      // declines_these_prepositions: [ 'to' ],
    },

    let_verb_handle_disambiguation: false,

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";

      if (input.hasStructure("verb")) {
        // this.game.debug(` | ${this.name}.js | sentence structure 'verb'`);
        // msg += this.game.parser.getUnparsedMessage(input.input);
        // this.handleFailure(msg);
        // return false;
      }

      if (input.hasStructure("verb noun")) {
        // this.game.debug(` | ${this.name}.js | sentence structure 'verb'`);
        // msg += this.game.parser.getUnparsedMessage(input.input);
        // this.handleFailure(msg);
        // return false;
      }

      if (input.hasStructure("verb preposition")) {
        // this.game.debug(` | ${this.name}.js | sentence structure 'verb'`);
        // msg += this.game.parser.getUnparsedMessage(input.input);
        // this.handleFailure(msg);
        // return false;
      }

      if (input.hasStructure("verb preposition noun")) {
      }

      // sentence structure: verb noun preposition noun ----------
      if (input.hasStructure("verb noun preposition noun")) {
      }

      /*
       * If any block in doTry returns false, that ends the parse.
       * If the parser is working on stacked input (for example,
       * "do this THEN do that"), the parser will move to the next
       * item in the stack.
       */
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var indirect_object2 = input.getAsset(3);
      var indirect_preposition2 = input.getPreposition(3);
      var player = this.game.getPlayer();
      var msg = "";

      this.game.debug(` | ${this.name}.js | doSuccess `);

      // apply state changes
      //this.setState(direct_object,false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += direct_preposition ? ` ${direct_preposition}` : ``;
      msg += direct_object ? ` ${direct_object.articlename}` : ``;
      msg += indirect_preposition ? ` ${indirect_preposition}` : ``;
      msg += indirect_object ? ` ${indirect_object.articlename}` : ``;
      msg += indirect_preposition2 ? ` ${indirect_preposition2}` : ``;
      msg += indirect_object2 ? ` ${indirect_object2.articlename}` : ``;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // verb

// think.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class think
   * @ajsnode game.dictionary.verbs.think
   * @ajsconstruct MyGame.createVerb({ "name": "think", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading Conversation Verbs
   * @summary Verb meaning think, as in "think about love letters".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; </span>
   *
   * </pre>
   * <p>
   * Description of the verb.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @TODO everything - copied this from tell, which also is todo
   */
  A.Preverbs.think = {
    name: "think",
    prettyname: "think about",
    past_tense: "told",
    synonyms: ["thinkabout"],
    verb_prep_noun: ["think about"], // think about thing
    verb_noun_prep_noun: ["think about"], // think person about thing

    /**
     * @memberof think
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     present: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        present: true,
      },
    },

    /**
     * @memberof think
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
      },
    },

    /**
     * @memberof think
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var msg = "";

      // no indirect object given
      // if( "undefined" === typeof input.parsedNoun2 )
      // {
      //   input.parsedNoun2 = A.clone.call(this.game, input.parsedNoun1 );
      //   input.parsedNoun1 = undefined;
      //   input.setSoftPrompt({ noun1: true, verb: 'think' });
      //   var msg = "To whom would you like to think it? ";
      //   this.handleFailure(msg);
      //   return null;
      // }

      // can't talk to non-characters
      if (!(direct_object instanceof adventurejs.Character)) {
        this.game.debug(
          ` | ${this.name}.js | ${direct_object.id} is not class Character `
        );
        msg += `${direct_object.Articlename} doesn't listen. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var player;
      var direct_object;
      var msg = "";

      this.game.debug(`F1855 | ${this.name}.js | print doSuccess `);
      // think x about y
      msg += `$(We) think ${direct_object.articlename} about ${indirect_object.articlename}. `;

      // transfer of knowledge

      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // think

// throw.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class throw
   * @ajsnode game.dictionary.verbs.throw
   * @ajsconstruct MyGame.createVerb({ "name": "throw", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @param {Object} parsedNoun One word user input string.
   * @summary Verb meaning throw, as in "throw boulder at giant".
   * @ajssynonyms throw, toss
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; throw flugelhorn</span>
   * You throw the jewel encrusted flugelhorn. It emits a sad little blat.
   * </pre>
   * <p>
   * <strong>throw</strong> a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}. Requires that the Asset is
   * in player's inventory.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.throw = {
    name: "throw",
    prettyname: "throw",
    past_tense: "threw",
    synonyms: ["throw", "toss"],

    /**
     * @ajsverbstructures
     * @memberof throw
     */
    accepts_structures: [
      "verb noun",
      "verb noun preposition",
      "verb noun preposition noun",
    ],

    player_must_be: {
      not_constrained: true,
    },

    /**
     * @memberof throw
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     //in_hands: true, // defer this check until after substance check
     *     matter: true,
     *     present_if_tangible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        matter: true,
        present_if_tangible: true,
      },
    },

    /**
     * @memberof throw
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     matter: true,
     *     present_if_tangible: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        matter: true,
        present_if_tangible: true,
      },
      accepts_preposition: true,
      accepts_preposition_without_noun: true,
      requires_preposition: true,
    },

    /**
     * @memberof throw
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var currentRoom = this.game.getCurrentRoom();
      var msg = "";
      var containers;
      var bodycontainers;
      var results;
      var inhands;
      var direct_object_vessel;
      var indirect_object_vessel;

      // did player input something like "throw sand" ?
      // if so it must come from a substance container that
      // is either in hands, or in a reachable substance body
      if (direct_object instanceof adventurejs.Substance) {
        // get a list of available vessels
        // this includes only things in inventory and nearby bodies of substance

        containers = this.game.findSubstanceBodyOrHeld(direct_object.id);

        // console.warn("containers", containers);

        switch (containers.length) {
          case 0:
            this.game.debug(`F1447 | ${this.name}.js | no valid vessel found `);
            msg += `There doesn't appear to be any ${
              this.game.getAsset(direct_object.id).name
            } to throw. `;
            this.handleFailure(msg);
            return null;
          case 1:
            // set container as direct_object
            // and treat like "throw asset in container"
            direct_object_vessel = this.game.getAsset(containers[0]);
            input.setAssumed(1, true);
            input.setVessel(1, direct_object_vessel);
            break;
          default:
            this.game.debug(
              `F1448 | ${this.name}.js | multiple containers found, disambiguate `
            );
            // disambiguate - need to set parsedNoun.matches
            // save containers back to input for next turn disambiguation
            input.setParsedNounMatchesQualified(1, containers);
            this.game.parser.printNounDisambiguation({
              parsedNoun: input.getParsedNoun(1),
              nounIndex: 1,
            });
            return null;
        } // switch containers.length
      } // direct_object is substance // not substance
      else {
        // we bypassed the usual in_hands check to allow
        // substance handling so we need to check that now
        inhands = this.game.parser.selectInHands(direct_object.id);
        if (!inhands.length) {
          this.game.debug(
            `F1601 | ${this.name}.js | ${direct_object.id} not in player's hands `
          );
          msg += `$(We're) not holding ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      if (input.hasStructure("verb noun preposition")) {
        if (["up", "down"].indexOf(indirect_preposition) > -1) {
          input.deletePhrase(2);
          input.setStructure("verb noun");
          indirect_preposition = false;
        } else {
          this.game.debug(
            `F1956 | ${this.name}.js | no handling for ${this.name} ${direct_object.id} ${indirect_preposition} `
          );
          msg += `$(We) don't know how to ${this.name} ${direct_object.id} ${indirect_preposition}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      if (!direct_object.isDOV("throw")) {
        this.game.debug(
          `F1495 | ${this.name}.js | ${direct_object.id}.dov.throw.enabled is false `
        );
        msg += `$(We) can't throw ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (indirect_object) {
        if (indirect_object.isIn(player)) {
          this.game.debug(
            `F1612 | ${this.name}.js | ${indirect_object.id}.isIn player `
          );
          msg += `$(We're) carrying ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // is indirect_object a substance?
        // if so find a container
        if (indirect_object instanceof adventurejs.Substance) {
          // get a list of available
          containers = this.game.findSubstanceContainers(indirect_object.id, [
            "Present",
            "Known",
            "Visible",
          ]);

          if (this.game.settings.throw_at_substance_prefers_bodies) {
            // if only bodies of substance will do, use this
            containers = this.game.parser.selectBodyOfSubstance(containers);
          } else {
            // if any vessel will do, use this
            // presumes player is not trying to throw at a vessel they're holding
            containers = this.game.parser.selectNotInInventory(containers);
          }

          switch (containers.length) {
            case 0:
              this.game.debug(
                `F1444 | ${this.name}.js | no body of substance found `
              );
              msg += `There doesn't appear to be any ${
                this.game.getAsset(indirect_object.id).name
              } suitable for throwing ${indirect_preposition}. `;
              this.handleFailure(msg);
              return null;
            case 1:
              // save the found vessel back to the input object
              indirect_object_vessel = this.game.getAsset(containers[0]);
              input.setAssumed(2, true);
              input.setVessel(2, indirect_object_vessel);
              break;
            default:
              this.game.debug(
                `F1445 | ${this.name}.js | multiple containers found, disambiguate `
              );
              // disambiguate - need to set parsedNoun.matches
              // save containers back to input for next turn disambiguation
              input.setParsedNounMatchesQualified(2, containers);
              this.game.parser.printNounDisambiguation({
                parsedNoun: input.getParsedNoun(2),
                nounIndex: 2,
              });
              return null;
          } // switch containers.length
        } // substance
      } // indirect_object

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var currentRoom = this.game.getCurrentRoom();
      var player = this.game.getPlayer();
      var msg = "";
      var direct_object_vessel = this.game.getAsset(input.getVessel(1));
      var indirect_object_vessel = this.game.getAsset(input.getVessel(2));
      var dv, iv;
      var results;
      var can_contain;
      var input_verb = input.input_verb;

      this.game.debug(`F1449 | ${this.name}.js | print doSuccess`);

      if (direct_object_vessel) {
        dv = direct_object_vessel.getVesselAt(
          direct_object_vessel.getAspectWithVessel()
        );
      }
      if (indirect_object_vessel) {
        iv = indirect_object_vessel.getVesselAt(
          indirect_object_vessel.getAspectWithVessel()
        );
      }

      // if thrown thing isn't substance, remove it from player
      if (!(direct_object instanceof adventurejs.Substance)) {
        // remove thing from player
        results = player.onRemoveThatFromThis(direct_object);
        if ("undefined" !== typeof results) return results;
      }

      // did player input "throw asset" without a target?
      if (!indirect_object) {
        // if player input something like "throw sand"
        // then we chose a vessel for them that contains sand
        // either in inventory or a body of substance
        // and we're going to throw the sand, not the vessel
        if (direct_object instanceof adventurejs.Substance) {
          this.game.debug(
            `F1602 | ${this.name}.js | no indirect object and direct object is substance `
          );
          msg += `$(We) sprinkle a handful of ${direct_object.name}`;
          if (direct_object_vessel && !direct_object_vessel.$is("body")) {
            msg += ` from ${direct_object_vessel.articlename}`;
          }
          msg += ` into the air. `;
          if (dv.volume !== Infinity) {
            dv.subtractVolume(this.game.settings.handful);
          }
        } // substance // not substance
        else {
          this.game.debug(`F1603 | ${this.name}.js | no indirect object `);
          msg += `$(We) ${input_verb} ${direct_object.articlename}. `;
          msg += direct_object.getDescription("throw");

          // @TODO add logic for water rooms, anti-gravity

          // set thing's new location to player's location
          results = currentRoom.onMoveThatToThis(direct_object, "in");
          if ("undefined" !== typeof results) return results;
        } // not substance
      } // no indirect_object

      if (indirect_object) {
        if (
          direct_object instanceof adventurejs.Substance &&
          indirect_object instanceof adventurejs.Substance
        ) {
          // we're throwing substance from direct_object_vessel
          // to indirect_object_vessel
          // our target must be a body of substance so there's
          // not going to be any mixing
          // but we can empty the direct_object_vessel

          if (direct_object_vessel.isIn(player)) {
            this.game.debug(
              `F1604 | ${this.name}.js | both objects are substances and player is holding substance vessel `
            );
            msg += `$(We) ${input_verb} ${direct_object.articlename} from ${direct_object_vessel.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
            dv.empty();
          } // from body to body
          else {
            this.game.debug(
              `F1605 | ${this.name}.js | both objects are substance bodies `
            );
            msg += `$(We) scoop a handful of ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          }
        } // both substances
        else if (direct_object instanceof adventurejs.Substance) {
          // we're throwing substance at asset
          if (direct_object_vessel.isIn(player)) {
            this.game.debug(
              `F1606 | ${this.name}.js | direct object is substance held by player `
            );
            msg += `$(We) ${input_verb} ${direct_object.articlename} from ${direct_object_vessel.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
            dv.empty();
          } // from body to asset
          else {
            this.game.debug(
              `F1608 | ${this.name}.js | direct object is substance in a body `
            );
            msg += `$(We) scoop a handful of ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          }
        } // direct is substance
        else if (indirect_object instanceof adventurejs.Substance) {
          // we're throwing asset at substance
          this.game.debug(
            `F1609 | ${this.name}.js | indirect object is substance in a body `
          );
          msg += `$(We) ${input_verb} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;

          // set thing's new location to vessel
          // this might need more consideration for prepositions
          // ie "throw asset over water" does it land on other side?
          // though hopefully the hooks give enough opportunity for customization
          // also might want to consider whether this asset can be placed in this vessel
          // and whether throwing something in it means destroying the asset
          results = indirect_object_vessel.onMoveThatToThis(
            direct_object,
            "in"
          );
          if ("undefined" !== typeof results) return results;
        } // indirect is substance // two assets, neither substance
        else {
          // we're throwing asset at asset
          // check preposition against iobj aspects
          if (
            ["in", "on", "under", "behind"].indexOf(indirect_preposition) > -1
          ) {
            if (
              indirect_object.canContainAssetAt(
                direct_object,
                indirect_preposition
              )
            ) {
              can_contain = true;
            }
          }

          if (can_contain) {
            // if asset lands in other asset
            results = indirect_object.onMoveThatToThis(
              direct_object,
              indirect_preposition
            );
            this.game.debug(
              `F1610 | ${this.name}.js | both objects are tangible, indirect can contain direct `
            );
            msg += `$(We) ${input_verb} ${direct_object.articlename} neatly ${indirect_preposition} ${indirect_object.articlename}. `;
          } else {
            // if asset lands in room
            results = currentRoom.onMoveThatToThis(direct_object, "in");
            this.game.debug(
              `F1611 | ${this.name}.js | both objects are tangible, direct lands in room `
            );
            msg += `$(We) ${input_verb} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. It falls to the floor. `;
          }
          if ("undefined" !== typeof results) return results;
        }
      } // indirect object

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // throw

// toggle.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class toggle
   * @ajsnode game.dictionary.verbs.toggle
   * @ajsconstruct MyGame.createVerb({ "name": "toggle", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning toggle, as in "toggle switch".
   * @todo toggle should have logic for switches
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; toggle switch</span>
   * You toggle the light switch. The lights turn off. Standing
   * still in the dark, you hear breathing that is not your own.
   * </pre>
   * <p>
   * <strong>Toggle</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be toggled has
   * asset.dov.toggle.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.toggle = {
    name: "toggle",
    prettyname: "toggle",
    past_tense: "toggled",
    synonyms: ["toggle"],

    /**
     * @memberof toggle
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof toggle
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (!direct_object.isDOV("toggle")) {
        this.game.debug(
          `F1450 | ${this.name}.js | ${direct_object.id}.dov.toggle.enabled is false `
        );
        msg += `$(We) can't toggle ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1451 | ${this.name}.js | print doSuccess `);
      msg += `$(We) toggle direct_object.articlename. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // toggle

// touch.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class touch
   * @ajsnode game.dictionary.verbs.touch
   * @ajsconstruct MyGame.createVerb({ "name": "touch", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading SensationVerbs
   * @summary Verb meaning touch, as in "touch blob of jelly".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; touch blob</span>
   * You touch the blob. Ew, it's squishy! Oh! And it sticks! In fact,
   * you can't get it off your finger. Oh, uh, and it's starting to burn.
   * You shake your hand in a panic. Not only is the blob not dislodged,
   * but it advances further up your finger, increasing the burning sensation.
   * </pre>
   * <p>
   * <strong>Touch</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset to be touched has
   * asset.dov.touch.enabled
   * set to true. If successful, returns the Asset's
   * <code class="property">descriptions.touch</code> property.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.touch = {
    name: "touch",
    prettyname: "touch",
    past_tense: "touched",
    synonyms: ["touch", "feel"],

    /**
     * @ajsverbstructures
     * @memberof touch
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof touch
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
    },

    /**
     * @memberof touch
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     matter: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        matter: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof touch
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var output_class = input.output_class;
      var direct_object = input.getAsset(1);
      var indirect_preposition = input.getPreposition(2);
      var indirect_object = input.getAsset(2);
      var currentRoom = this.game.getCurrentRoom();
      var direct_substance;
      var indirect_substance;
      var results;
      var msg = "";

      direct_substance = direct_object instanceof adventurejs.Substance;

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun preposition noun")) {
        indirect_substance = indirect_object instanceof adventurejs.Substance;
      } // verb noun

      if (!direct_object && input.input_verb === "feel") {
        if (currentRoom.hasDescription("feel")) {
          input.setAsset(1, currentRoom);
          input.verb_params.source = currentRoom.descriptions.feel;
          return true;
        }
      }

      if (indirect_object) {
        // did player try something like "touch sand in water" ?
        // we don't handle it
        if (direct_substance && indirect_substance) {
          this.game.debug(
            `F1641 | ${this.name}.js | both items are substances `
          );
          msg += `$(We) can't touch ${direct_object.name} ${indirect_preposition} ${indirect_object.name}. `;
          this.handleFailure(msg);
          return null;
        }

        if (
          direct_substance &&
          (!indirect_object.hasAspectAt(indirect_preposition) ||
            indirect_object.getAspectAt(indirect_preposition).vessel
              .substance_id !== direct_object.id)
        ) {
          this.game.debug(
            `F1643 | ${this.name}.js | ${indirect_object.id} does not contain ${direct_object.id} `
          );
          msg += `${indirect_object.Articlename} doesn't contain ${direct_object.name}. `;
          this.handleFailure(msg);
          return null;
        }

        // did player try to touch something in a non-existent aspect?
        if (
          !indirect_substance &&
          !indirect_object.hasAspectAt(indirect_preposition)
        ) {
          this.game.debug(
            `F1639 | ${this.name}.js | ${indirect_object.id} has no aspect at ${indirect_preposition} `
          );
          msg += `There's nothing ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // did player try to touch something in a thing it's not in?
        if (
          !direct_substance &&
          !indirect_substance &&
          !direct_object.isIn(indirect_object)
        ) {
          this.game.debug(
            `F1640 | ${this.name}.js | ${direct_object.id} not in ${direct_object.id} `
          );
          msg += `${direct_object.Articlename} doesn't appear to be ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // did player try to touch something in a substance?
        // like "touch toy in sand" ?
        if (indirect_substance) {
          // is direct_object inside an asset
          // that also contains indirect_substance?
          var daspect = direct_object.getPlaceAspect();
          if (
            !daspect ||
            !daspect.vessel ||
            daspect.vessel.substance_id !== indirect_object.id
          ) {
            this.game.debug(
              `F1642 | ${this.name}.js | ${direct_object.id} is not in something that contains ${indirect_object.id} `
            );
            msg += `${direct_object.Articlename} doesn't appear to be ${indirect_preposition} ${indirect_object.name}. `;
            this.handleFailure(msg);
            return null;
          }
        }
      } // has indirect_object

      if (!direct_object.isDOV("touch")) {
        this.game.debug(
          `F1452 | ${this.name}.js | ${direct_object.id}.dov.touch.enabled is false `
        );
        msg += `$(We) can't touch ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (!direct_object.hasDescription("touch")) {
        this.game.debug(
          `F1453 | ${this.name}.js | ${direct_object.id}.descriptions.touch is unset `
        );
        msg += `$(We) don't feel anything special. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1454 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      msg += `$(We) touch ${direct_object.articlename}. `;
      if (input.verb_params.source) {
        msg += A.getSAF.call(this.game, input.verb_params.source);
      } else if (direct_object.hasDescription("touch")) {
        msg += direct_object.getDescription("touch");
      } else {
        msg += `$(We) don't feel anything in particular. `;
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // touch

// turn.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class turn
   * @ajsnode game.dictionary.verbs.turn
   * @ajsconstruct MyGame.createVerb({ "name": "turn", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning turn, as in "turn faucet handle".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; turn sparrow</span>
   * You turn the carven sparrow that caps the newel post
   * of the teak balustrade. The little statue rotates smoothly
   * and clicks neatly into position at 45 degrees from its original
   * position. A bass rumble emanates from somewhere deep in the house.
   * </pre>
   * <pre class="display border outline">
   * <span class="input">&gt; turn off timer</span>
   * You turn off the bomb timer with only three seconds to spare!
   * </pre>
   * <pre class="display border outline">
   * <span class="input">&gt; turn on washing machine</span>
   * You turn on the washing machine. It immediately starts to
   * buck across the bar's cement floor. The other machine leaps
   * out ahead of yours. The race is on!
   * </pre>
   * <p>
   * <strong>Turn</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be turned has
   * asset.dov.turn.enabled set to true.
   * Turn offers a couple of distinct contexts. "Turn on" and "turn off"
   * do as you might expect. Just plain "turn" requires not only the
   * verb subscription but also that asset.can.turn is true.
   * Authors wanting to make use of turn may wish to use verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.turn = {
    name: "turn",
    prettyname: "turn",
    past_tense: "turned",
    synonyms: ["turn"],

    /**
     * @ajsverbstructures
     * @memberof remove
     */
    accepts_structures: [
      "verb noun", // turn statue
      "verb preposition noun", // turn on faucet
      "verb noun preposition", // turn faucet on
      "verb noun preposition noun", // turn faucet with wrench, turn statue to east
      "verb preposition noun preposition noun", // turn on faucet with wrench
    ],

    /**
     * @memberof turn
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof turn
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof turn
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var direct_preposition = input.getPreposition(1);
      var indirect_preposition = input.getPreposition(2);
      var indirect_aspect;
      var msg = "";
      var results;

      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1455 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is unset `
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}${
          direct_preposition ? " " + direct_preposition : ""
        }. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1933 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      if (input.hasStructure("verb noun")) {
        if (!direct_object.can.turn) {
          this.game.debug(
            `F1183 | ${this.name}.js | ${direct_object.id}.can.${this.name} is unset `
          );
          msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
          this.handleFailure(msg);
          return null;
        }
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1934 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1935 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition
      if (input.hasStructure("verb noun preposition")) {
        if (["on", "off"].indexOf(indirect_preposition) > -1) {
          input.setPreposition(1, indirect_preposition);
          input.deletePhrase(2);
          input.setStructure("verb preposition noun");
        } else {
          this.game.debug(
            `F1068 | ${this.name}.js | ${this.name} ${indirect_preposition} not handled `
          );
          msg += `$(We) don't know how to ${this.name} ${direct_object.articlename} ${indirect_preposition}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition

      // sentence structure: verb preposition noun
      // ex: turn on radio, turn off computer
      // @TODO turn in thief
      if (input.hasStructure("verb preposition noun")) {
        if (["on", "off"].indexOf(direct_preposition) === -1) {
          this.game.debug(
            `F1070 | ${this.name}.js | ${this.name} ${direct_preposition} not handled `
          );
          msg += `$(We) don't know how to ${this.name} ${direct_preposition} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb preposition noun

      // sentence structure: verb noun preposition noun
      // ex: turn statue toward window, turn statue with lever
      if (input.hasStructure("verb noun preposition noun")) {
        if (["to", "from", "with"].indexOf(indirect_preposition) === -1) {
          this.game.debug(
            `F1072 | ${this.name}.js | ${this.name} ${direct_object} ${indirect_preposition} ${indirect_object} not handled `
          );
          msg += `$(We) don't know how to ${this.name} ${direct_object} ${indirect_preposition} ${indirect_object}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      // sentence structure: verb preposition noun preposition noun
      // ex: turn on faucet with wrench, turn off faucet with wrench
      // @TODO turn in thief to police?
      if (input.hasStructure("verb preposition noun preposition noun")) {
        if (
          ["on", "off"].indexOf(direct_preposition) === -1 ||
          indirect_preposition !== "with"
        ) {
          this.game.debug(
            `F1499 | ${this.name}.js | ${this.name} ${direct_object} ${indirect_preposition} ${indirect_object} not handled `
          );
          msg += `$(We) don't know how to ${this.name} ${direct_preposition} ${direct_object} ${indirect_preposition} ${indirect_object}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb preposition noun preposition noun

      if (
        input.hasStructure("verb noun preposition noun") ||
        (input.hasStructure("verb preposition noun preposition noun") &&
          "with" === indirect_preposition)
      ) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1597 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1930 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1499 | ${this.name}.js | ${indirect_object.id}.iov.${this.name} is unset `
          );
          msg += `${indirect_object.Articlename} can't be used to ${this.name} anything. `;
          this.handleFailure(msg);
          return null;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1932 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1456 | ${this.name}.js | print doSuccess `);

      if (direct_preposition === "on") direct_object.is.on = true;
      if (direct_preposition === "off") direct_object.is.on = false;

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // turn

// twist.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class twist
   * @ajsnode game.dictionary.verbs.twist
   * @ajsconstruct MyGame.createVerb({ "name": "twist", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning twist, as in "twist bottle cap".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; twist cap</span>
   * You twist the bottle cap. Well, you try to.
   * It's a classic steel 21-tooth crown cap, which bites into
   * the palm of your hand, leaving painful tiny tooth marks.
   * If only you had a bottle opener, HINT HINT.
   * </pre>
   * <p>
   * <strong>Twist</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be twisted has
   * asset.dov.twist.enabled
   * set to true. No special logic is provided with the verb.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.twist = {
    name: "twist",
    prettyname: "twist",
    past_tense: "twisted",
    synonyms: ["twist"],

    /**
     * @memberof twist
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof twist
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1457 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `
        );
        msg += `$(We) try to ${this.name} ${direct_object.articlename} and fail $(fail_adverb). `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1458 | ${this.name}.js | print doSuccess `);
      msg += `$(We) twist ${direct_object.articlename}. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // twist

// type.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class type
   * @ajsnode game.dictionary.verbs.type
   * @ajsconstruct MyGame.createVerb({ "name": "type", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading CompositionVerbs
   * @summary Verb meaning type, as in "type on keyboard".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; type on keyboard</span>
   * You type on the keyboard. PEFBIJOVAS;DVLKJ ;LAJKSVJVJLS J.
   * Well, walk across it, more like. Your paws aren't very precise.
   * The computer blares a warning: "CAT-LIKE TYPING DETECTED!"
   * </pre>
   * <p>
   * <strong>Type</strong> on a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has
   * asset.dov.type.enabled set to true. <strong>Type</strong> takes account
   * of the Asset's parent, so for instance it correctly interprets
   * <code class="property">type on paper</code> if paper is in a
   * typewriter.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.type = {
    name: "type",
    prettyname: "type on",
    past_tense: "typed",
    synonyms: ["type"],
    // verb_prep_noun: [ "type on" ],

    /**
     * @ajsverbstructures
     * @memberof type
     */
    accepts_structures: [
      "verb noun",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof type
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     *   accepts_preposition: true,
     *   accepts_these_prepositions: ["on"],
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
      accepts_preposition: true,
      accepts_these_prepositions: ["on"],
    },

    /**
     * @memberof type
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["on"],
     *   noun_must_be:
     *   {
     *     known: true,
     *     present_if_tangible: true,
     *     reachable_if_tangible: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["on"],
      noun_must_be: {
        known: true,
        present_if_tangible: true,
        reachable_if_tangible: true,
      },
    },

    /**
     * @memberof type
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var direct_object_place, indirect_object_place;
      var typing_target;
      var room = this.game.getCurrentRoom();
      var msg = "";

      if (
        input.hasStructure("verb noun") ||
        input.hasStructure("verb noun preposition noun")
      ) {
        // @TODO other information types like password or name
        if (!(direct_object instanceof adventurejs.GlobalString)) {
          this.game.debug(
            `F1663 | ${this.name}.js | ${direct_object.id} can not be typed `,
          );
          msg += `$(We) can't type ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      // did player input "type foo" ?
      if (input.hasStructure("verb noun")) {
        // see if there's an obvious keyboard
        var room_contents = room.getAllNestedContents();
        var asset = null;
        var typers = [];

        for (var i = 0; i < room_contents.length; i++) {
          var id = room_contents[i];
          var asset = this.game.getAsset(id);
          if (!asset) continue;
          if (asset.isDOV("type")) {
            typers.push(id);
          }
        }

        if (typers.length) {
          typers = this.game.parser.selectKnown(typers);
          typers = this.game.parser.selectReachable(typers);
          typers = this.game.parser.selectVisible(typers);
        }

        switch (typers.length) {
          case 0:
            this.game.debug(
              `F1663 | ${this.name}.js | no assets found with .dov.type.enabled set to true `,
            );
            msg += `$(We) don't see anything to type on. `;
            this.handleFailure(msg);
            return null;

          case 1:
            // set input phrase2 to the keyboard
            input.setPhrase(2, {});
            input.setAsset(2, this.game.getAsset(typers[0]));
            input.setPreposition(2, "on");
            input.setAssumed(2, true);
            indirect_object = input.getAsset(2);
            indirect_preposition = "on";
            input.setStructure("verb noun preposition noun");
            console.warn("typer", typers[0]);
            break;

          default:
            this.game.debug(
              `F1664 | ${this.name}.js | multiple keyboards found, disambiguate `,
            );
            // ask player to choose a keyboard
            input.setParsedNoun(2, new adventurejs.ParsedNoun());
            input.setPreposition(2, "on");
            // save containers back to input for next turn disambiguation
            input.setParsedNounMatchesQualified(2, typers);
            // revise the sentence structure
            input.setStructure("verb noun preposition noun");
            this.game.parser.printNounDisambiguation({
              parsedNoun: input.getParsedNoun(2),
              nounIndex: 2,
            });
            return null;
        } // switch
      } // verb noun

      if (input.hasStructure("verb preposition noun")) {
        // can player type on it?
        if (!direct_object.isDOV("type")) {
          // if not, is it something like a piece of paper in a typewriter?
          direct_object_place = direct_object.getPlaceAsset();
          if (
            direct_object.can.be_typed_on && // ie paper
            direct_object_place.isDOV("type")
          ) {
            // ie typewriter
            typing_target = direct_object;
            input.verb_params.typing_target = typing_target;
            direct_object = direct_object_place;
            input.setAsset(1, direct_object);
            input.setAssumed(1, true);
          }
        }

        if (!direct_object.isDOV("type")) {
          this.game.debug(
            `F1665 | ${this.name}.js | ${direct_object.id} .dov.type.enabled is false `,
          );
          msg += `$(We) can't type on ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb preposition noun

      if (input.hasStructure("verb noun preposition noun")) {
        // can player type on it?
        if (!indirect_object.isDOV("type")) {
          // if not, is it something like a piece of paper in a typewriter?
          indirect_object_place = indirect_object.getPlaceAsset();
          if (
            indirect_object.can.be_typed_on && // ie paper
            indirect_object_place.isDOV("type")
          ) {
            // ie typewriter
            typing_target = indirect_object;
            input.verb_params.typing_target = typing_target;
            indirect_object = indirect_object_place;
            input.setAsset(2, indirect_object);
            input.setAssumed(2, true);
          }
        }

        if (!indirect_object.isDOV("type")) {
          this.game.debug(
            `F1666 | ${this.name}.js | ${indirect_object.id} .dov.type.enabled is false `,
          );
          msg += `$(We) can't type on ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // does indirect_object contain something that can.be_typed_on?
        if (!typing_target && indirect_object.hasAspectAt("in")) {
          var contents = indirect_object.getAspectAt("in");
          if (contents) contents = contents.contents;
          for (var i = 0; i < contents.length; i++) {
            var asset = this.game.getAsset(contents[i]);
            if (!asset) continue;
            if (asset.can.be_typed_on) {
              // take the first thing found
              typing_target = asset;
              input.verb_params.typing_target = typing_target;
              break;
            }
          }
        }
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var typing_target;
      var results;
      var msg = "";

      if (input.verb_params.typing_target)
        typing_target = input.verb_params.typing_target;

      this.game.debug(`F1459 | ${this.name}.js | print doSuccess `);

      if (input.hasStructure("verb noun")) {
        msg += "This should not happen. ";
      }

      if (input.hasStructure("verb preposition noun")) {
        msg += `$(We) type on ${direct_object.articlename}. `;
      }

      if (input.hasStructure("verb noun preposition noun")) {
        msg += "$(We) type ";
        if (0 < input.strings.length) {
          if (typing_target)
            typing_target.written_strings.push(input.strings[0]);
          msg += input.strings[0] + " ";
        }
        msg += "on " + indirect_object.articlename + ". ";
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // type

// unbutton.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class unbutton
   * @ajsnode game.dictionary.verbs.unbutton
   * @ajsconstruct MyGame.createVerb({ "name": "unbutton", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning unbutton, as in "unbutton trousers".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; unbutton trousers</span>
   * You rise and unbutton your trousers. Was this the right moment
   * for this? You do a quick read of the room. The disgusted faces
   * of your co-workers suggest that it was not.
   * </pre>
   * <p>
   * <strong>Unbutton</strong> a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has
   * asset.dov.unbutton.enabled set to true.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.unbutton = {
    name: "unbutton",
    synonyms: ["unbutton"],
    past_tense: "unbuttoned",
    prettyname: "unbutton",
    unstate: "buttoned",

    /**
     * @ajsverbstructures
     * @memberof unbutton
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof unbutton
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     not_global: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        not_global: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof unbutton
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof unbutton
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1883 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1884 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is false`,
        );
        msg += `${direct_object.Articlename} isn't ${this.getState()}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1885 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1885 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1886 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1887 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1888 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1912 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1889 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1890 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // unbutton

// undo.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class undo
   * @ajsnode game.dictionary.verbs.undo
   * @ajsconstruct MyGame.createVerb({ "name": "undo", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb meaning undo the last turn.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; rochambeau troll</span>
   * The bridge troll shows genuine shock at your ungentlemanly
   * comportment. Unfortunately the bridge troll is also wearing a
   * stone codpiece, such that you do more damage to your foot
   * than to his unmentionables. The troll considers you as you hop
   * about on one foot, and after a brief hesitation decides
   * to teach you an unforgettable lesson in the trollish art of war.
   * <span class="input">&gt; undo</span>
   * Undoing one turn.
   * </pre>
   * <p>
   * <code>Undo</code> the player's last turn.
   * </p>
   */
  A.Preverbs.undo = {
    name: "undo",
    synonyms: ["undo"],
    msgNoObject: "msgNoObject - shouldn't be seeing this.",

    /**
     * @ajsverbstructures
     * @memberof undo
     */
    accepts_structures: ["verb"],

    do: function () {
      this.game.log("log", "high", "undo", "verbs");
      var input = this.game.getInput();
      //console.warn( "undo input");
      //console.warn( input );
      var msg = "";

      if (0 < this.game.world_history.length) {
        let worldString = this.game.world_history[0];
        delete this.game.world_history[0];
        this.game.world_history.shift();

        let restored = A.restoreWorld.call(this.game, worldString);

        if (restored) {
          this.game.parser.input_history.shift();
          this.game.debug(`F1461 | ${this.name}.js | undo successful `);
          msg += "Undoing one turn. ";
          if (msg) this.game.print(msg, "");
          return true;
        } else {
          this.game.debug(`F1462 | ${this.name}.js | undo failed `);
          msg += `Undo failed! (You might say, "undo undone.") `;
          if (msg) this.game.print(msg, "");
          return false;
        }
      }

      this.game.debug(`F1463 | ${this.name}.js | undo default `);
      msg += "Nothing to undo. ";
      if (msg) this.game.print(msg, "");

      return true;
    },
  };
})();

// unlock.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class unlock
   * @ajsnode game.dictionary.verbs.unlock
   * @ajsconstruct MyGame.createVerb({ "name": "unlock", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading OpenCloseVerbs
   * @ajscaninferindirect true
   * @summary Verb meaning unlock, as in "unlock door with key".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; unlock heart with love</span>
   * You unlock the heart stone with the loving key. The
   * chamber's dim lighting immediately brightens into a pulsating
   * glow. The sense of forboding that had descended upon you lifts
   * too. You feel yourself buoyed with positive emotion. In fact...
   * whoa... you look down to find your feet rising from the ground.
   * </pre>
   *
   * <p>
   * <strong>Unlock</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the lock has
   * asset.dov.unlock.enabled set to true and its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_is_locked">is.locked</a>
   * property set to true.
   * If the lock requires a key, verb will soft prompt for one.
   * </p>
   *
   * tryUnlockThis
   * tryUnlockThisWithThat
   * tryUnlockThatWithThis
   * doUnlockThis
   * doUnlockThisWithThat
   * doUnlockThatWithThis
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @ajsdemo OpenGame, SittingRoom, Library, Playground, Objects
   */
  A.Preverbs.unlock = {
    name: "unlock",
    prettyname: "unlock",
    past_tense: "unlocked",
    synonyms: ["unlock"],
    unstate: "locked",
    related: ["lock", "pick"],

    /**
     * @ajsverbstructures
     * @memberof unlock
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof unlock
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof unlock
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof unlock
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // be nice and redirect to pick if appropriate
      if (
        direct_object?.isDOV("pick") &&
        indirect_object &&
        direct_object.DOVallowWithAsset("pick", indirect_object.id)
      ) {
        this.game.dictionary.doVerb("pick");
        return null;
      }

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // can be direct object of verb?
      if (!direct_object.isDOV(this.name)) {
        if (direct_object.isDOV("pick")) {
          this.game.dictionary.doVerb("pick");
          return null;
        }
        this.game.debug(
          `F1464 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1465 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is false`,
        );
        msg += `${direct_object.Articlename} isn't ${this.getState()}. `;
        this.handleFailure(msg);
        return false;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1831 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1466 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of anything that unlocks ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1757 | ${this.name}.js | soft prompt for noun2 `);
          msg += input.verb_params.auto_open
            ? `${direct_object.Articlename} is locked. `
            : ``;
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1696 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1698 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1913 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1817 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";
      var auto_open = false;

      this.game.debug(`F1468 | ${this.name}.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      if (input.verb_params.auto_open) {
        direct_object.setClosed(false); //is.closed = false;
        direct_object.incrementDoVerbCount("open", 1);
        auto_open = true;
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
      } // verb noun preposition noun

      // apply state changes
      this.setState(direct_object, false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += auto_open ? ` and open it` : ``;
      msg += `. `;

      // printable contents?
      if (auto_open && direct_object.hasContentsAtAspect("in")) {
        msg += direct_object.getPrintableListOfContentsAt("in");
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // unlock

// unplug.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class unplug
   * @ajsnode game.dictionary.verbs.unplug
   * @ajsconstruct MyGame.createVerb({ "name": "unplug", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning unplug, as in "unplug computer".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; unplug computer</span>
   * You unplug the computer! The screen goes dead!
   * But did you stop the upload in time???
   * </pre>
   *
   * <p>
   * <strong>Unplug</strong> is understood to have four distinct uses.
   * As an unverb to <a href="/doc/plug.html" class="property">plug</a>,
   * it can unplug a sink in the sense of opening it, or unplug a
   * sink in the sense of removing a stopper from it.
   * As an unverb to <a href="/doc/plugIn.html" class="property">plugIn</a>,
   * it can unplug a computer from an abstract non-specific connection,
   * or unplug a computer from a specific connection like an outlet.
   * Unplug determines based on context which situation is implied.
   * Authors can determine which one to apply on a per-object basis
   * through a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset's}
   * verb subscriptions.
   * </p>
   *
   * <p>
   * <code>sink.dov.plug.with_nothing</code><br>
   * If this meaning is set, unplug will interpret "unplug sink"
   * to mean simply changing the plugged state of the direct object.
   * </p>
   *
   * <p>
   * <code>sink.dov.plug.with_assets = ['stopper']</code><br>
   * If this meaning is set, unplug will interpret "unplug sink"
   * to mean remove a plug object from the direct object.
   * </p>
   *
   * <p>
   * <code>computer.dov.plugIn.with_nothing</code><br>
   * If this meaning is set, unplug will interpret "unplug computer"
   * to unplug a direct object from an abstract / non-existent
   * indirect object, as in unplugging a computer without specifying
   * an outlet, where the outlet is simply implied.
   * </p>
   *
   * <p>
   * <code>computer.dov.plugIn.with_assets = ['outlet']</code><br>
   * If this meaning is set, unplug will interpret "unplug computer"
   * to unplug a direct object from an indirect object, as in unplugging
   * a computer from a specific tangible electrical outlet.
   * </p>
   *
   * tryUnplugThis
   * tryUnplugThis[Preposition]That
   * tryUnplugThat[Preposition]This
   * doUnplugThis
   * doUnplugThis[Preposition]That
   * doUnplugThat[Preposition]This
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   * @ajsdemo PlugGame, PlugSomethingIntoSomething, PlugSomethingIntoNothing, PlugSomethingWithSomething, PlugSomethingWithNothing
   */
  A.Preverbs.unplug = {
    name: "unplug",
    prettyname: "unplug",
    past_tense: "unplugged",
    synonyms: ["unplug"],
    //state_string: "unplugged",

    /**
     * @ajsverbstructures
     * @memberof unplug
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof unplug
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof unplug
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["from", "with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["from", "with"],
    },

    /**
     * @memberof unplug
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";
      var drain;
      var can_plug, can_plugIn;
      var unverb, unstate;
      var plug_asset;
      var is_plug_asset_takeable;

      // has direct object got a registered drain?
      if (direct_object.registered_parts?.Drain) {
        drain = this.game.getAsset(direct_object.registered_parts.Drain);
        if (drain) {
          direct_object = drain;
          input.setAsset(1, direct_object);
          input.setAssumed(1);
        }
      }

      // which type of plug are we unplugging?
      can_plug = direct_object.isDOV("plug");
      can_plugIn = direct_object.isDOV("plugIn");
      if (can_plug && can_plugIn) {
        // this should not happen, but try to disambiguate
        if (direct_object.is.plugged) unverb = "plug";
        else if (direct_object.is.pluggedIn) unverb = "plugIn";
      }
      if (!unverb) {
        unverb = can_plug ? "plug" : can_plugIn ? "plugIn" : null;
      }
      if (unverb) unstate = this.game.dictionary.verbs[unverb].state;
      input.verb_params.unverb = unverb;
      input.verb_params.unstate = unstate;

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // can be direct object of verb?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1470 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (unstate && !direct_object.is[unstate]) {
        this.game.debug(
          `F1766 | ${this.name}.js | ${direct_object.id}.is.${unstate} is false `,
        );
        msg += `${direct_object.Articlename} is not ${
          unstate === "pluggedIn" ? "plugged in" : unstate
        }. `;
        this.handleFailure(msg);
        return false;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1832 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // does direct object contain a plug?
      if (unverb === "plug") {
        // current logic only supports one thing plugging a drain
        plug_asset = direct_object.dov.plug?.with_params.connections[0];
        if (plug_asset) plug_asset = this.game.getAsset(plug_asset);
        if (plug_asset) input.verb_params.plug_asset = plug_asset;
      } // unverb===plug

      // sentence structure: verb noun
      // ie "unplug sink" or "unplug computer"
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }
      }

      // sentence structure: verb noun // ie "unplug sink"
      if (input.hasStructure("verb noun") && unverb === "plugIn") {
        switch (direct_object.dov.plugIn.with_params.connections.length) {
          case 0:
            // this case should've already been handled by unstate check
            this.game.debug(
              `F1717 | ${this.name}.js | ${direct_object.id}.dov.plugIn.with_params.connections.length is 0 `,
            );
            msg += `${direct_object.Articlename} doesn't appear to be plugged in. `;
            this.handleFailure(msg);
            return null;
          case 1:
            // if it is plugged in to one thing,
            // update the sentence structure to "unplug x from y"
            input.setStructure("verb noun preposition noun");
            indirect_object = this.game.getAsset(
              direct_object.dov.plugIn.with_params.connections[0],
            );
            input.setAsset(2, indirect_object);
            input.setPreposition(2, "from");
            indirect_preposition = "from";
            break;
          default:
            // plugged in to more than one thing,
            // prompt for which thing to unplug from
            input.setPreposition(2, "from"); // set up next turn for "unplug x with y"
            input.setSoftPrompt({ noun2: true }); // ask for noun
            this.game.debug(
              `F1469 | ${this.name}.js | ${direct_object.id}.dov.plugIn.with_params.connections.length > 1, soft prompt for indirect object`,
            );
            msg += `What would $(we) like to unplug ${direct_object.articlename} from? `;
            this.handleFailure(msg);
            return null;
        }
      } // verb noun && plugIn

      // repeat sentence structure: verb noun
      if (input.hasStructure("verb noun") && unverb === "plug") {
        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1713 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1714 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return null;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      // ie: unplug computer from outlet
      // ie: unplug toilet with plunger
      if (input.hasStructure("verb noun preposition noun")) {
        // with
        if ("with" === indirect_preposition) {
          // unplug sink with plunger

          // is indirect object in player inventory?
          if (indirect_object.isDOV("take") && !indirect_object.isIn(player)) {
            this.game.debug(
              `F1734 | ${this.name}.js | ${indirect_object.id} is not in player inventory `,
            );
            msg += `$(We're) not holding ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // works with any indirect object?
          if (direct_object.DOVallowWithAnything(this.name)) {
            return true;
          }

          // indirect object not required?
          if (direct_object.DOVallowWithNothing(this.name)) {
            this.game.debug(
              `F1731 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
            );
            msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // indirect object usable with direct object?
          if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
            this.game.debug(
              `F1727 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
            );
            msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return null;
          }

          // can indirect object be used?
          if (!indirect_object.isIOV(this.name)) {
            this.game.debug(
              `F1895 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
            );
            msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
            this.handleFailure(msg);
            return false;
          }

          // single use indirect object?
          if (
            indirect_object.IOVallowOnce(this.name) &&
            indirect_object.IOVdidDo(this.name)
          ) {
            this.game.debug(
              `F1818 | ${this.name}.js | ${indirect_object.id}.iov.${
                this.name
              }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
                indirect_object.iov[this.name].do_count
              } `,
            );
            msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
            this.handleFailure(msg);
            return null;
          }
        } // with

        // from
        if ("from" === indirect_preposition) {
          // unplug computer from outlet

          // is direct object plugged into indirect object?
          if (!direct_object.DOVisConnectedToAsset("plugIn", indirect_object)) {
            // if dobj isn't plugged into iobj, let's see if iobj is plugged into dobj
            // 'cause we don't need to be dicks about it
            if (
              indirect_object.DOVisConnectedToAsset("plugIn", direct_object)
            ) {
              input.swapPhrases(1, 2);
              input.setPreposition(1, "");
              input.setPreposition(2, "from");
            } else {
              this.game.debug(
                `F1735 | ${this.name}.js | ${direct_object.id}.dov.plugIn.with_assets.connections does not include ${indirect_object.id} `,
              );
              msg += `${direct_object.Articlename} doesn't appear to be plugged into ${indirect_object.articlename}. `;
              this.handleFailure(msg);
              return null;
            }
          }
        } // from
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var msg = "";
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var direct_place = direct_object.getPlaceAsset();
      var results;
      var plug_asset = input.verb_params.plug_asset;

      this.game.debug(`F1472 | unplug.js | print doSuccess `);

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // sentence structure: verb noun
      // ie "unplug computer"
      if (
        input.hasStructure("verb noun") &&
        input.verb_params.unverb === "plugIn"
      ) {
        // unplug from nothing
        direct_object.DOVunsetConnection("plugIn", null);
        direct_object.is.pluggedIn = false;
      } // verb noun

      // sentence structure: verb noun
      // ie "unplug sink"
      if (
        input.hasStructure("verb noun") &&
        direct_object.DOVallowWithNothing("plug")
      ) {
        direct_object.is.plugged = false;
      }

      // was there a plug to remove?
      // applies to verb noun and verb noun preposition noun
      if (input.verb_params.unverb === "plug" && plug_asset) {
        console.warn("try to remove plug from sink");
        // remove plug from direct object - also handles state change
        results = plug_asset.moveFrom(direct_object);
        if ("undefined" !== typeof results) return results;

        // disconnect plug from direct object (as indirect object)
        // direct_object.DOVunsetConnection('plug',null);

        // is plug takeable?
        if (plug_asset.isDOV("take")) {
          // move plug to player
          results = plug_asset.moveTo("in", player);
        } else {
          // move plug to parent of direct_object
          results = plug_asset.moveTo(
            direct_place.default_aspect,
            direct_place,
          );
        }
        if ("undefined" !== typeof results) return results;
      } // plug_asset

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // from
        if (
          input.verb_params.unverb === "plugIn" &&
          "from" === indirect_preposition
        ) {
          // disconnect them
          direct_object.DOVunsetConnection("plugIn", indirect_object);

          // things may be plugged into multiple items - how now?
          if (0 >= direct_object.dov.plugIn.with_params.connections.length) {
            direct_object.is.pluggedIn = false;
          }
        } // from
      } // verb noun preposition noun

      // apply state changes
      // already done

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg +=
        plug_asset && plug_asset.isIn(player)
          ? ` and take ${plug_asset.articlename}`
          : ``;
      msg +=
        plug_asset && !plug_asset.isIn(player)
          ? ` and leave ${
              plug_asset.articlename
            } ${plug_asset.getPlacePreposition()} ${
              plug_asset.getPlaceAsset().articlename
            }`
          : ``;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // unplug

// unscrew.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class unscrew
   * @ajsnode game.dictionary.verbs.unscrew
   * @ajsconstruct MyGame.createVerb({ "name": "unscrew", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning unscrew, as in "unscrew table leg".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; unscrew table leg</span>
   * You unscrew the thick table leg. A bottle cap falls out of the
   * screw hole and pings to the floor. You pick up the bottle cap.
   * Red Devil Brewery. Could it be a clue?
   * </pre>
   * <p>
   * <strong>Unscrew</strong> a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has
   * asset.dov.unscrew.enabled set to true.
   * </p>
   * tryUnscrewThis
   * tryUnscrewThis[Preposition]That
   * tryUnscrewThat[Preposition]This
   * doUnscrewThis
   * doUnscrewThis[Preposition]That
   * doUnscrewThat[Preposition]This
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.unscrew = {
    name: "unscrew",
    synonyms: ["unscrew"],
    past_tense: "unscrewed",
    prettyname: "unscrew",
    unstate: "screwed",

    /**
     * @memberof unscrew
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof unscrew
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";
      var results;

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // if it's attached to something then we're unscrewing it from something
      if ("attached" === direct_object.getPlacePreposition()) {
        /** @TODO consolidate unscrew_from into screw */
        this.game.debug(
          `F1473 | ${this.name}.js | ${direct_object.id} is attached, infer unscrew_from `
        );
        this.game.dictionary.doVerb("unscrew_from");
        return null;
      }

      // can't unscrew
      if (!direct_object.isDOV("unscrew")) {
        this.game.debug(
          `F1474 | ${this.name}.js | ${direct_object.id}.dov.unscrew.enabled is false `
        );
        msg += `$(We) can't unscrew ${direct_object.articlename}. `;

        this.handleFailure(msg);
        return null;
      }

      // already unscrewed
      if (!direct_object.is.screwed) {
        this.game.debug(
          `F1475 | ${this.name}.js | ${direct_object.id}.is.screwed is false `
        );
        msg += `${direct_object.Articlename} is already unscrewed. `;
        this.handleFailure(msg);
        return null;
      }

      if (input.hasStructure("verb noun preposition noun")) {
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var msg = "";
      var results;

      this.game.debug(`F1476 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // we don't do anything more
      // could be something like a pen that is traded for two new objects
      // leaving it up to author to decide
      // what happens to it, using doAfterSuccess

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // unscrew

// unseal.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class unseal
   * @ajsnode game.dictionary.verbs.unseal
   * @ajsconstruct MyGame.createVerb({ "name": "unseal", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading OpenCloseVerbs
   * @ajscaninferindirect true
   * @summary Verb meaning unseal, as in "unseal envelope".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; unseal tomb</span>
   * You unseal the tomb of Akhenaten. Ahh, mummy! No, wait,
   * of course there's a mummy. That's why you're here!
   * You smack your head. At last, you've found the real resting
   * place of Akhenaten!
   * </pre>
   * <p>
   * <strong>Unseal</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset to unseal has
   * asset.dov.unseal.enabled set to true and its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_is_sealed">is.sealed</a>
   * property set to true.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.unseal = {
    name: "unseal",
    prettyname: "unseal",
    past_tense: "unsealed",
    synonyms: ["unseal"],
    unstate: "sealed",
    related: ["seal"],

    /**
     * @ajsverbstructures
     * @memberof unseal
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof unseal
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof unseal
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     in_inventory: true,
     *     known: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        in_inventory: true,
        known: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof unseal
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1477 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1478 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is false`,
        );
        msg += `${direct_object.Articlename} isn't ${this.getState()}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1833 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1705 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1758 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1699 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1700 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1893 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1819 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1481 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // printable contents?
      if (direct_object.hasContentsAtAspect("in")) {
        msg += direct_object.getPrintableListOfContentsAt("in");
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // unseal

// untie.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class untie
   * @ajsnode game.dictionary.verbs.untie
   * @ajsconstruct MyGame.createVerb({ "name": "untie", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning untie, as in "untie string from finger".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; untie shoelace</span>
   * You untie your shoelace. Hung from the tree branch by your shoe
   * as you are, this promptly results in you resuming your fall
   * toward the ground. Yoink! Your parachute catches in the same branch
   * and you're caught again, but thankfully only a couple of feet off
   * the ground this time.
   * </pre>
   * <p>
   * <strong>Untie</strong> a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has
   * asset.dov.untie.enabled set to true.
   * </p>
   * tryUntieThis
   * tryUntieThis[Preposition]That
   * tryUntieThat[Preposition]This
   * doUntieThis
   * doUntieThis[Preposition]That
   * doUntieThat[Preposition]This
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.untie = {
    name: "untie",
    synonyms: ["untie"],
    past_tense: "untied",
    prettyname: "untie",

    /**
     * @memberof untie
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof untie
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof untie
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";

      // example: untie rope (from thing)
      // example: untie table (from rope)

      // parsed sentence structure: verb
      if (input.hasStructure("verb")) {
      }

      // parsed sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // can't tie to or tie with
      if (!direct_object.isDOV(this.name) && !!direct_object.isIOV(this.name)) {
        this.game.debug(
          `F1482 | ${this.name}.js | ${direct_object.id}.dov.untie and .iov.untie are false `
        );
        msg += `${direct_object.Articlename} can't be untied. `;
        this.handleFailure(msg);
        return null;
      }

      // can't be untied, which might be true even if it's a rope
      if (!direct_object.isDOV("untie")) {
        this.game.debug(
          `F1483 | ${this.name}.js | ${direct_object.id}.dov.untie.enabled is false `
        );
        msg += `$(We) can't untie ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // if object is rope but not tied to anything
      if (direct_object.dov.tie?.with_params.connections.length === 0) {
        // rope isn't tied to anything
        this.game.debug(
          `F1484 | ${this.name}.js | ${direct_object.id}.dov.tie.with_params.connections.length is 0 `
        );
        msg += `${direct_object.Articlename} isn't tied to anything. `;
        this.handleFailure(msg);
        return null;
      }

      // if object can have rope tied to it but doesn't
      if (
        direct_object.isIOV("tie") &&
        0 === direct_object.iov.tie.with_params.connections.length
      ) {
        this.game.debug(
          `F1485 | ${this.name}.js | ${direct_object.id}.iov.tie.with_params.connections.length is 0`
        );
        msg += `Nothing is tied to ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // if object is rope but tied to multiple things
      if (direct_object.dov.tie?.with_params.connections.length > 1) {
        this.game.debug(
          `F1486 | ${this.name}.js | ${direct_object.id}.dov.tie.with_params.connections.length > 1, soft prompt noun2 `
        );
        msg += `${direct_object.Articlename} is tied to
          ${this.game.getPrintableObjectList({
            objects: direct_object.dov.tie.with_params.connections,
          })}. Which thing would you like to untie it from? `;

        // soft prompt for untiewith object
        input.setSoftPrompt({ noun2: true, verb: "untie_from" });

        this.handleFailure(msg);
        return null;
      }

      // only tied to one thing so be nice and kick over to untiefrom
      if (direct_object.dov.tie?.with_params.connections.length === 1) {
        var tiedToObject = this.game.getAsset(
          direct_object.dov.tie?.with_params.connections[0]
        );
        input.parsedNoun2 = new adventurejs.ParsedNoun(tiedToObject);
        this.game.dictionary.doVerb(
          "untie_from"
        ); /** @TODO consolidate untie_from */
        return null;
      }

      if (input.hasStructure("verb noun preposition noun")) {
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";

      this.game.debug(`F1487 | ${this.name}.js | print doSuccess `);

      // apply state changes
      // @TODO break dov connection

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // untie

// unzip.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class unzip
   * @ajsnode game.dictionary.verbs.unzip
   * @ajsconstruct MyGame.createVerb({ "name": "unzip", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning unzip, as in "unzip hoodie".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; unzip fly</span>
   * You unzip your fly and introduce the world to your little friend.
   * A group of girls passes, giggling. You blush furiously and zip back up.
   * </pre>
   * <p>
   * <strong>Unzip</strong> a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has
   * asset.dov.unzip.enabled set to true.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.unzip = {
    name: "unzip",
    synonyms: ["unzip"],
    past_tense: "unzipped",
    prettyname: "unzip",
    unstate: "zipped",

    /**
     * @ajsverbstructures
     * @memberof unzip
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof unzip
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     not_global: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        not_global: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof unzip
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof unzip
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";

      // // can't unzip
      // if (!direct_object.isDOV("unzip")) {
      //   this.game.debug(
      //     ` | ${this.name}.js | ${direct_object.id}.dov.unzip.enabled is false `
      //   );
      //   msg += `$(We) can't unzip ${direct_object.articlename}. `;

      //   this.handleFailure(msg);
      //   return null;
      // }

      // // already unzipped
      // if (!direct_object.is.zipped) {
      //   this.game.debug(
      //     ` | ${this.name}.js | ${direct_object.id}.is.zipped is false `
      //   );
      //   msg += `${direct_object.Articlename} is already unzipped. `;
      //   this.handleFailure(msg);
      //   return null;
      // }

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1488 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return null;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1391 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is false`,
        );
        msg += `${direct_object.Articlename} isn't ${this.getState()}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1392 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1393 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1419 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // parsed sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1420 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1421 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1423 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1490 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // unzip

// use.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class use
   * @ajsnode game.dictionary.verbs.use
   * @ajsconstruct MyGame.createVerb({ "name": "use", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb meaning use a tangible asset.
   * @ajssynonyms use
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; use blender</span>
   * It blends!
   * </pre>
   * <p>
   * Use a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}. Asset must have
   * asset.dov.use.enabled
   * set to true. There's no particular
   * code to handle use, so any special results will need
   * to be custom coded through a method such as setting a
   * verb override for the Asset. To learn about verb hooks,
   * see <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.use = {
    name: "use",
    prettyname: "use",
    past_tense: "used",
    synonyms: ["use"],
    state: "used",

    /**
     * @ajsverbstructures
     * @memberof use
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof use
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   requires_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof use
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        reachable: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
    },

    /**
     * @memberof use
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1146 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `
        );
        msg += `$(We) don't know how to ${this.name} ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1916 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1917 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1918 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        } else if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1919 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1920 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1729 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1921 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";

      this.game.debug(`F1732 | ${this.name}.js | print doSuccess `);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // apply state changes
      this.setState(direct_object, true);

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // use

// verb_template.js - Use this file as a template to create new verbs.

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class verb_template
   * @ajsnode game.dictionary.verbs.verb_template
   * @ajsconstruct MyGame.createVerb({ "name": "verb_template", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Summary.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc Verbs start out as generic objects, which are converted
   * to verb class instances at runtime.
   * <br/><br/>
   * Verbs have access to the global Input object ( game.getInput() ),
   * which contains parsed player input.
   * tryVerbThis
   * tryVerbThis[Preposition]That
   * tryVerbThat[Preposition]This
   * doVerbThis
   * doVerbThis[Preposition]That
   * doVerbThat[Preposition]This
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.verb_template = {
    name: "verb_template",
    prettyname: "verb to",
    past_tense: "verbed",
    state: "verbed",
    unstate: "unverbed",
    synonyms: ["verb"],
    verb_noun_prep: [],
    verb_prep_noun: [],
    verb_prep_prep_noun: [],
    verb_prep_prep_prep_noun: [],
    verb_noun_prep_noun: [],
    verb_noun_prep_prep_noun: [],
    verb_noun_prep_noun_prep_noun: [],
    verb_prep_noun_prep_noun_prep_noun: [],

    /**
     * @ajsverbstructures
     * @memberof verb
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof verb
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   // requires_noun: true,
     *   // accepts_plural_noun: true,
     *   noun_must_be: {
     *     // direction: true,
     *     // not_direction: true,
     *     // tangible: true,
     *     // intangible: true,
     *     // character: true,
     *     // present: true,
     *     // visible: true,
     *     // reachable: true,
     *     // takeable: true,
     *     // known: true,
     *     // in_inventory: true,
     *     // not_in_inventory: true,
     *     // worn: true,
     *     // not_worn: true,
     *     // in_hands: true,
     *     // not_in_hands: true,
     *   },
     *   // accepts_preposition: true,
     *   // accepts_preposition_without_noun: true,
     *   // requires_preposition: true,
     *   // accepts_these_prepositions: [ 'from' ],
     *   // declines_these_prepositions: [ 'to' ],
     * },
     */

    phrase1: {
      accepts_noun: true,
      // requires_noun: true,
      // accepts_plural_noun: true,
      noun_must_be: {
        // direction: true,
        // not_direction: true,
        // tangible: true,
        // intangible: true,
        // character: true,
        // present: true,
        // visible: true,
        // reachable: true,
        // takeable: true,
        // known: true,
        // in_inventory: true,
        // not_in_inventory: true,
        // worn: true,
        // not_worn: true,
        // in_hands: true,
        // not_in_hands: true,
      },
      // accepts_preposition: true,
      // accepts_preposition_without_noun: true,
      // requires_preposition: true,
      // accepts_these_prepositions: [ 'from' ],
      // declines_these_prepositions: [ 'to' ],
    },

    /**
     * @memberof verb
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   // requires_noun: true,
     *   // accepts_plural_noun: true,
     *   noun_must_be: {
     *     // direction: true,
     *     // not_direction: true,
     *     // tangible: true,
     *     // intangible: true,
     *     // character: true,
     *     // present: true,
     *     // visible: true,
     *     // reachable: true,
     *     // takeable: true,
     *     // known: true,
     *     // in_inventory: true,
     *     // not_in_inventory: true,
     *     // worn: true,
     *     // not_worn: true,
     *     // in_hands: true,
     *     // not_in_hands: true,
     *   },
     *   // accepts_preposition: true,
     *   // accepts_preposition_without_noun: true,
     *   // requires_preposition: true,
     *   // accepts_these_prepositions: [ 'from' ],
     *   // declines_these_prepositions: [ 'to' ],
     * },
     */

    phrase2: {
      // accepts_noun: true,
      // requires_noun: true,
      // accepts_plural_noun: true,
      noun_must_be: {
        // direction: true,
        // not_direction: true,
        // tangible: true,
        // intangible: true,
        // character: true,
        // present: true,
        // visible: true,
        // reachable: true,
        // takeable: true,
        // known: true,
        // in_inventory: true,
        // not_in_inventory: true,
        // worn: true,
        // not_worn: true,
        // in_hands: true,
        // not_in_hands: true,
      },
      // accepts_preposition: true,
      // accepts_preposition_without_noun: true,
      // requires_preposition: true,
      // accepts_these_prepositions: [ 'from' ],
      // declines_these_prepositions: [ 'to' ],
    },

    /**
     * @memberof verb
     * @ajsverbphrase
     * phrase3:
     * {
     *   accepts_noun: true,
     *   // requires_noun: true,
     *   // accepts_plural_noun: true,
     *   noun_must_be: {
     *     // direction: true,
     *     // not_direction: true,
     *     // tangible: true,
     *     // intangible: true,
     *     // character: true,
     *     // present: true,
     *     // visible: true,
     *     // reachable: true,
     *     // takeable: true,
     *     // known: true,
     *     // in_inventory: true,
     *     // not_in_inventory: true,
     *     // worn: true,
     *     // not_worn: true,
     *     // in_hands: true,
     *     // not_in_hands: true,
     *   },
     *   // accepts_preposition: true,
     *   // accepts_preposition_without_noun: true,
     *   // requires_preposition: true,
     *   // accepts_these_prepositions: [ 'from' ],
     *   // declines_these_prepositions: [ 'to' ],
     * },
     */

    phrase3: {
      // accepts_noun: true,
      // requires_noun: true,
      // accepts_plural_noun: true,
      noun_must_be: {
        // direction: true,
        // not_direction: true,
        // tangible: true,
        // intangible: true,
        // character: true,
        // present: true,
        // visible: true,
        // reachable: true,
        // takeable: true,
        // known: true,
        // in_inventory: true,
        // not_in_inventory: true,
        // worn: true,
        // not_worn: true,
        // in_hands: true,
        // not_in_hands: true,
      },
      // accepts_preposition: true,
      // accepts_preposition_without_noun: true,
      // requires_preposition: true,
      // accepts_these_prepositions: [ 'from' ],
      // declines_these_prepositions: [ 'to' ],
    },

    let_verb_handle_disambiguation: false,

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      if (input.hasStructure("verb")) {
        // this.game.debug(` | ${this.name}.js | sentence structure 'verb'`);
        // msg += this.game.parser.getUnparsedMessage(input.input);
        // this.handleFailure(msg);
        // return false;
      }

      if (input.hasStructure("verb noun")) {
        // this.game.debug(` | ${this.name}.js | sentence structure 'verb'`);
        // msg += this.game.parser.getUnparsedMessage(input.input);
        // this.handleFailure(msg);
        // return false;
      }

      if (input.hasStructure("verb preposition")) {
        // this.game.debug(` | ${this.name}.js | sentence structure 'verb'`);
        // msg += this.game.parser.getUnparsedMessage(input.input);
        // this.handleFailure(msg);
        // return false;
      }

      if (input.hasStructure("verb preposition noun")) {
        // this.game.debug(` | ${this.name}.js | sentence structure 'verb'`);
        // msg += this.game.parser.getUnparsedMessage(input.input);
        // this.handleFailure(msg);
        // return false;
      }

      // sentence structure: verb noun preposition noun ----------
      if (input.hasStructure("verb noun preposition noun")) {
      }

      /*
       * If any block in doTry returns false, that ends the parse.
       * If the parser is working on stacked input (for example,
       * "do this THEN do that"), the parser will move to the next
       * item in the stack.
       */
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(` | ${this.name}.js | doSuccess `);

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
      } // verb noun

      // sentence structure: verb preposition noun
      if (input.hasStructure("verb preposition noun")) {
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
      } // verb noun preposition noun

      // apply state changes
      //this.setState(direct_object,false);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // verb

// verbose.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class verbose
   * @ajsnode game.dictionary.verbs.verbose
   * @ajsconstruct MyGame.createVerb({ "name": "verbose", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb that instructs game to provide verbose room descriptions.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <p>
   * <code>verbose</code> displays full {@link adventurejs.Room|Room}
   * descriptions, if available.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; verbose</span>
   * Ok, I'll show full room descriptions.
   * </pre>
   */
  A.Preverbs.verbose = {
    name: "verbose",
    synonyms: ["verbose"],

    /**
     * @ajsverbstructures
     * @memberof verbose
     */
    accepts_structures: ["verb"],

    do: function () {
      var input = this.game.getInput();
      if (this.game.settings.verbosity < this.game.settings.max_verbosity) {
        this.game.settings.verbosity += 1;
      }
      var msg = "Ok, I'll try to show longer room descriptions. ";
      if (msg) this.game.print(msg, input.output_class);

      return true;
    },
  };
})();

// verbs.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class verbs
   * @ajsconstruct MyGame.createVerb({ "name": "verbs", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @ajsnode game.dictionary.verbs.verbs
   * @summary Verb that returns a list of all available verbs.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; verbs</span>
   * - aft
   * - again
   * - ask about
   * - etc.
   * </pre>
   * <p>
   * Verbs returns a list of all active verbs.
   * </p>
   */
  A.Preverbs.verbs = {
    name: "verbs",
    synonyms: ["verbs"],

    /**
     * @ajsverbstructures
     * @memberof verbs
     */
    accepts_structures: ["verb"],

    do: function () {
      var input = this.game.getInput();
      var verbList = "Available verbs: ";
      var count = 0;
      for (var prop in this.dictionary.verbs) {
        if (count > 0) verbList += ", ";
        verbList += this.dictionary.verbs[prop].prettyname;
        count++;
      }
      verbList += ". ";
      this.game.print(verbList, input.output_class);
      return true;
    },
  };
})();

// wait.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class wait
   * @ajsnode game.dictionary.verbs.wait
   * @ajsconstruct MyGame.createVerb({ "name": "wait", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb that waits for one turn.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; wait</span>
   * You wait one turn. Three buses arrive.
   * </pre>
   * <p>
   * <code>Wait</code> one turn.
   * </p>
   */
  A.Preverbs.wait = {
    name: "wait",
    past_tense: "waited",
    synonyms: ["wait", "z"],

    /**
     * @ajsverbstructures
     * @memberof wait
     * @TODO wait for x minutes or x turns
     */
    accepts_structures: ["verb"],

    do: function () {
      var input = this.game.getInput();

      // TODO passage of time
      this.game.print("$(We) wait a turn.", input.output_class);

      return true;
    },
  };
})();

// walk.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class walk
   * @ajsnode game.dictionary.verbs.walk
   * @ajsconstruct MyGame.createVerb({ "name": "walk", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning walk, as in "walk to diving board"; or, travel in specified direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; walk under ladder</span>
   * Throwing caution to the winds, you walk under the ladder.
   * You slip on a bit of rope hung from the ladder, which
   * dislodges a bucket of paint from the top of the ladder.
   * The bucket glances off your head, spilling a full gallon
   * of paint that puddles at your feet. You slip in the paint
   * and flail wildly, bringing the ladder crashing down
   * on top of you, as you and it fall to the ground.
   * </pre>
   * Walk extends core verb <a href="go.html">go</a>.
   * It checks whether "walk" is contextually available
   * before forwarding to "go" for further handling.
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.walk = {
    name: "walk",
    prettyname: "walk",
    past_tense: "walked",
    synonyms: ["walk"],
    type: { locomotion: true, travel: true },
    extends: { go: true },

    player_must_be: {
      not_constrained: true,
      not_on_floor: true,
      not_nested_elsewhere: true,
      able_to_walk: true,
    },

    /**
     * @ajsverbstructures
     * @memberof walk
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    /**
     * @memberof walk
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof walk
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof walk
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    do: function () {
      return this.game.dictionary.doVerb("go");
    },
  }; // END walk
})();

// wave.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class wave
   * @ajsnode game.dictionary.verbs.wave
   * @ajsconstruct MyGame.createVerb({ "name": "wave", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading GesticulationVerbs
   * @summary Verb meaning wave, as in "wave at Queen" or "wave pennant".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; wave at dock</span>
   * You wave at the people remaining on the dock. Poor bastards who
   * couldn't afford the ticket. Oh well, sod 'em all. You don't give
   * them another thought as you turn to find your cabin aboard the
   * RMS Titanic.
   * </pre>
   * <p>
   * <strong>Wave</strong> can be intransitive, or it can take a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be waved.
   * Wave doesn't provide any special logic.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.wave = {
    name: "wave",
    past_tense: "waved",
    synonyms: ["wave"],

    /**
     * @ajsverbstructures
     * @memberof wave
     */
    accepts_structures: [
      "verb",
      "verb noun",
      "verb preposition noun",
      "verb noun preposition noun",
    ],

    player_must_be: {
      not_constrained: true,
    },

    /**
     * @memberof wave
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *   },
     *   accepts_preposition: true,
     *   accepts_these_prepositions: [ 'at', 'to' ],
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
      },
      accepts_preposition: true,
      accepts_these_prepositions: ["at", "to"],
    },

    /**
     * @memberof wave
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *   },
     *   requires_preposition: true,
     *   accepts_preposition: true,
     *   accepts_these_prepositions: [ 'at', 'to' ],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
      },
      requires_preposition: true,
      accepts_preposition: true,
      accepts_these_prepositions: ["at", "to"],
    },

    /**
     * @memberof wave
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";

      if (direct_object && !direct_preposition) {
        // is player holding asset?
        //if( !direct_object.isIn(player) )
        if (0 === this.game.parser.selectInHands(direct_object.id).length) {
          this.game.debug(
            `F1600 | ${this.name}.js | ${direct_object.id}.isIn player is false `,
          );
          msg += `$(We're) not holding ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }
      }

      // player input "wave x at y"
      if (indirect_object) {
        return true;
      }

      // player input "wave x" or "wave at x"
      else if (direct_object) {
        // player input "wave at x"
        if (direct_preposition) {
        }

        // player input "wave x"
        if (!direct_preposition) {
        }

        return true;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      this.game.debug(`F1494 | ${this.name}.js | print doSuccess `);

      // player input "wave x at y"
      if (indirect_object) {
        msg += `$(We) wave ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
      }

      // player input "wave x" or "wave at x"
      else if (direct_object) {
        // player input "wave at x"
        if (direct_preposition) {
          msg += `$(We) wave ${direct_preposition} ${direct_object.articlename}. `;
        }

        // player input "wave x"
        if (!direct_preposition) {
          msg += `$(We) wave ${direct_object.articlename}. `;
        }
      } else {
        msg += "$(We) wave! ";
      }

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // wave

// wear.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class wear
   * @ajsnode game.dictionary.verbs.wear
   * @ajsconstruct MyGame.createVerb({ "name": "wear", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading LocomotionVerbs
   * @summary Verb meaning wear, as in "wear chain mail".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; wear knapsack</span>
   * You wear the knapsack. Inside are some comic books, a Superman
   * Pez dispenser, your flashlight, some twine, a Swiss Army knife,
   * a bottle of water, and a tin of field rations.
   * All the basics needed for your big adventure.
   * </pre>
   * <p>
   * <strong>Wear</strong> requires that the
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} to be worn has
   * asset.dov.wear.enabled set to true.
   * Worn objects will have their
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_is_worn">is.worn</a>
   * set to true, and may be handled differently from other inventory by
   * some verbs.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.wear = {
    name: "wear",
    prettyname: "wear",
    past_tense: "wore",
    synonyms: ["wear"],

    /**
     * @ajsverbstructures
     * @memberof wear
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof wear
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     takeable: true,
     *     in_inventory: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        takeable: true,
        in_inventory: true,
      },
    },

    /**
     * @memberof wear
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *     takeable: true,
     *     in_inventory: true,
     *   },
     *   accepts_preposition: true,
     * },
     */
    phrase2: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
        present: true,
        visible: true,
        reachable: true,
        takeable: true,
        in_inventory: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof wear
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var parent = direct_object.getPlaceAsset();
      var msg = "";

      if (!direct_object.isDOV("wear")) {
        this.game.debug(
          `F1497 | ${this.name}.js | ${direct_object.id}.dov.wear.enabled is false `
        );
        msg += `$(We) can't wear ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (direct_object.is.worn) {
        this.game.debug(
          `F1498 | ${this.name}.js | ${direct_object.id}.is.worn `
        );
        msg += `$(We're) already wearing ${direct_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      if (direct_object.is.zipped || direct_object.is.buttoned) {
        let state = direct_object.is.zipped ? "zipped" : "buttoned";
        let verb = direct_object.is.zipped ? "unzip" : "unbutton";
        this.game.debug(
          `F1892 | ${this.name}.js | ${direct_object.id}.is.${state} is true `
        );
        msg += `$(We'll) need to ${verb} ${direct_object.articlename} first. `;
        this.handleFailure(msg);
        return null;
      }

      // @TODO wear hat on head

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var closedAnscestors = [];
      var direct_object = input.getAsset(1);
      var player = this.game.getPlayer();
      var parent = direct_object.getPlaceAsset();
      var tookFromParent;
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var results;
      var msg = "";

      this.game.debug(`F1496 | ${this.name}.js | print doSuccess `);
      // alternately, if we've decided it's available,
      // it doesn't matter if it's in inventory
      if (parent.id !== player.id) {
        // open any containers if necessary
        // we only do this for items nested in inventory
        if (direct_object.isIn(player) && direct_object.areAnscestorsClosed()) {
          closedAnscestors = direct_object.getClosedAnscestors();
          for (var i = 0; i < closedAnscestors.length; i++) {
            this.game.getAsset(closedAnscestors[i]).is.closed = false;
            closedAnscestors[i] = this.game.getAsset(closedAnscestors[i]).name;
          }
        }

        // remove direct_object from its parent
        var results = parent.onRemoveThatFromThis(direct_object);
        if ("undefined" !== typeof results) return results;

        // set direct_object's new location to player
        results = player.onMoveThatToThis(direct_object, "in");
        if ("undefined" !== typeof results) return results;

        tookFromParent = true;
      }

      if (closedAnscestors.length > 0) {
        msg += "$(We) open the ";
        for (var i = 0; i < closedAnscestors.length; i++) {
          if (closedAnscestors.length > 2 && i < closedAnscestors.length - 2) {
            msg += ", ";
          }
          if (
            closedAnscestors.length > 1 &&
            i === closedAnscestors.length - 1
          ) {
            msg += " and the ";
          }
          msg += closedAnscestors[i];
        }
        msg += ". ";
      }
      if (tookFromParent) {
        msg += "$(We) take " + direct_object.articlename;
        if (false === parent instanceof adventurejs.Room) {
          msg += " from " + parent.articlename;
        }
        msg += " and put it on. ";
      } else {
        msg += "$(We) wear " + direct_object.articlename + ". ";
      }

      // apply state changes
      direct_object.is.worn = true;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // wear

// where.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class where
   * @ajsnode game.dictionary.verbs.where
   * @ajsconstruct MyGame.createVerb({ "name": "where", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb that returns location of an object.
   * @todo consider "last saw" and how this applies to NPCs who move between rooms
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; where is hendrickson</span>
   * You last saw Ms. Hendrickson in the Supply Room.
   * </pre>
   * <p>
   * <strong>Where is</strong> a
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} will return the name of the
   * {@link adventurejs.Room|Room} that the Asset is in. Intended
   * chiefly for debugging, but may also be useful in game play.
   * </p>
   * tryWhereThis
   * doWhereThis
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.where = {
    name: "where",
    prettyname: "where is",
    synonyms: [],
    verb_prep_noun: ["where is"],

    /**
     * @ajsverbstructures
     * @memberof exits
     */
    accepts_structures: ["verb noun"],

    /**
     * @memberof where
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     tangible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        tangible: true,
      },
    },

    /**
     * @memberof where
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var room = direct_object.getRoomId();
      var results;
      var msg = "";

      if ("Room" === direct_object.class) {
        this.game.debug(
          `F1500 | where.js | " + direct_object.id + ".class is Room `
        );
        msg += `Maybe $(we) should draw a map? `;
        this.handleFailure(msg);
        return null;
      }

      if (!direct_object.areAnscestorsKnown()) {
        this.game.debug(
          `F1501 | where.js | ${direct_object.id} has unknown ancestors `
        );
        msg += `$(We) don't know where ${direct_object.articlename} is. `;
        this.handleFailure(msg);
        return null;
      }

      if (!room) {
        this.game.debug(`F1502 | where.js | ${direct_object.id} has no room `);
        msg += `$(We) don't know where ${direct_object.articlename} is. `;
        this.handleFailure(msg);
        return null;
      }

      if (room === this.game.world._currentRoom) {
        this.game.debug(
          `F1503 | where.js | ${direct_object.id} is in current room `
        );
        msg += `${direct_object.Articlename} is right here in the room with $(us)! `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var direct_object = input.getAsset(1);
      var room = this.game.getAsset(direct_object.getRoomId());
      var results;
      var msg = "";

      // TODO: handle characters
      this.game.debug(`F1504 | where.js | print doSuccess `);
      msg += `$(We) last saw ${direct_object.articlename} in ${
        room.use_definite_article_in_lists ? room.definite_article + " " : ""
      } ${room.name}. `;

      this.handleSuccess(msg, direct_object);

      return true;
    },
  };
})(); // where

// write.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class write
   * @ajsnode game.dictionary.verbs.write
   * @ajsconstruct MyGame.createVerb({ "name": "write", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading CompositionVerbs
   * @summary Verb that means write, as in "write on blackboard".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; write on blackboard with chalk</span>
   * You scribble a hasty formula on the blackboard with the chalk.
   * Hmm, no, that doesn't look right.
   * </pre>
   * <p>
   * <strong>Write on</strong> a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the writing Asset has
   * <code>.iov.write.enabled</code>
   * set to true and that the target has
   * <code>asset.dov.write.enabled</code>
   * set to true.
   * <strong>Write on</strong> saves a record
   * of things written on an Asset to its
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_written_strings">written_strings</a>
   * property, which can be appended to the Asset's description.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.write = {
    name: "write",
    prettyname: "write on",
    past_tense: "wrote",
    synonyms: ["write"],

    // write on x
    //verb_prep_noun: [ "write on" ],

    // write on x with y
    //verb_prep_noun_prep_noun: [ "write on with" ],

    /**
     * @ajsverbstructures
     * @memberof write
     */
    accepts_structures: [
      "verb noun",
      "verb preposition noun",
      "verb noun preposition noun",
      "verb preposition noun preposition noun",
      "verb noun preposition noun preposition noun",
    ],

    /**
     * @memberof write
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   accepts_preposition: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     //tangible: true, // @todo write idea on thing
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      accepts_preposition: true,
      noun_must_be: {
        known: true,
        present: true,
        visible: true,
        reachable: true,
      },
    },

    /**
     * @memberof write
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     //tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   //requires_preposition: true,
     *   //accepts_these_prepositions: [ 'with' ], // @todo
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof write
     * @ajsverbphrase
     * phrase3:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     //tangible: true,
     *     present: true,
     *     visible: true,
     *     reachable: true,
     *   },
     *   accepts_preposition: true,
     *   //requires_preposition: true,
     *   //accepts_these_prepositions: [ 'with' ], // @todo
     * },
     */
    phrase3: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        present: true,
        visible: true,
        reachable: true,
      },
      accepts_preposition: true,
    },

    /**
     * @memberof write
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var msg = "";
      var allow = true;
      var information_object, writing_object, surface_object;
      var results;

      /**
       * 'write' doesn't follow an easy directObject/indirectObject
       * pattern. Player can input "write 'foo'" or "write 'foo' on board"
       * or "write 'foo' on board with chalk"
       * or "write with chalk" or "write on board"
       * We need to do some extra work to figure out what's what
       * and save the results in the verb_params object for doSuccess to use.
       * All we're saving is the phrase number, not the actual phrase.
       */
      input.verb_params.surface_phrase = 0;
      input.verb_params.writing_phrase = 0;
      input.verb_params.information_phrase = 0;

      for (var i = 0; i <= 3; i++) {
        var asset = input.getAsset(i);
        var preposition = input.getPreposition(i);
        if (asset && asset.class === "GlobalString") {
          // need to expand this to handle abtractions
          // like "type password" or "write name"
          information_object = asset;
          input.verb_params.information_phrase = i;
        } else if (preposition === "with") {
          // it's our writing implement
          writing_object = input.getAsset(i);
          input.verb_params.writing_phrase = i;

          if (!writing_object.isIOV("write")) {
            this.game.debug(
              `F1528 | ${this.name}.js | ${writing_object.id}.iov.write.enabled is false `,
            );
            msg += `${writing_object.Articlename} can't be written with. `;
            this.handleFailure(msg);
            return false;
          }
        } else if (preposition === "on" || preposition === "in") {
          // it's our writing surface
          // write on paper is different from write in book
          // maybe need to add a "quirks.write_on_means_write_in" property?
          surface_object = input.getAsset(i);
          input.verb_params.surface_phrase = i;

          //if( !surface_object["can_be_written_"+preposition] )
          if (!surface_object.isDOV("write")) {
            this.game.debug(
              `F1527 | ${this.name}.js | ${surface_object.id}.dov.write.enabled is false `,
            );
            msg += `${surface_object.Articlename} doesn't offer a good writing surface. `;
            this.handleFailure(msg);
            return false;
          }
        } else if (preposition) {
          // we don't know any other prepositions
          this.game.debug(
            `F1535 | ${this.name}.js | received a preposition we don't know how to handle `,
          );
          msg += `$(We) can't write ${preposition} ${asset.articlename}. `;
          this.handleFailure(msg);
          return false;
        }
      }

      if (!surface_object) {
        // because we don't know which noun,
        // maybe don't do a soft prompt?
        var phrase = input.getPhraseCount() + 1;
        input.setPreposition(phrase, "on");
        input.setSoftPrompt({
          ["noun" + phrase]: true,
          // ["preposition"+phrase]: "on",
          // verb: 'write'
        });
        this.game.debug(
          `F1525 | ${this.name}.js | soft prompt for surface object `,
        );
        msg += `What would $(we) like to write on? `;
        this.handleFailure(msg);
        return null;
      }

      // is player holding the writing implement?
      // in most verbs would be handled by NounMustBe,
      // but write's noun_must_be is a little more complicated
      // because the order of words can vary
      if (
        writing_object &&
        !this.game.parser.selectInHands([writing_object.id]).length
      ) {
        this.game.debug(
          `F1549 | ${this.name}.js | ${writing_object.id}.place is not ${player.id} `,
        );
        msg += `$(We're) not holding ${writing_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // can writing object write on surface object?
      if (
        writing_object &&
        (!writing_object.isDOV(this.name) ||
          !writing_object.DOVallowWithAsset(this.name, surface_object))
      ) {
        this.game.debug(
          `F1517 | ${this.name}.js | neither ${writing_object.id} nor ${surface_object.id} lists the other in .assets_this_can_${this.name}, .assets_that_can_${this.name}_this, .classes_this_can_${this.name}, .classes_that_can_${this.name}_this `,
        );
        msg += `${surface_object.Articlename} doesn't present a good writing surface for ${writing_object.articlename}. `;
        this.handleFailure(msg);
        return null;
      }

      // can we infer a writing object?
      if (!writing_object && this.game.settings.try_to_infer_indirect_objects) {
        results = this.tryToInferIndirectObject(surface_object);
        if (results.fail) {
          /* do nothing */
        } else if (results.prompt) {
          /* do nothing here, we'll handle later */
        } else if (results.success) {
          writing_object = results.indirect_object;
          var index = input.setNewPhrase({
            asset: writing_object,
            preposition: "with",
          });
          input.verb_params.writing_phrase = index;
        }
      }

      // no writing object after all
      if (!writing_object) {
        var index = input.hasPhrase(2) ? 3 : 2;
        // we're implying an indirect object so restructure sentence for next turn
        input.setSoftPrompt({
          ["noun" + index]: true,
          structure: input.getStructure() + " preposition noun",
        });
        input.setPreposition(index, "with");
        this.game.debug(`F1759 | ${this.name}.js | soft prompt for noun2 `);
        msg += `What would $(we) like to write with? `;
        this.handleFailure(msg);
        return false;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var information_object = input.getAsset(0);
      var surface_object = input.getAsset(input.verb_params.surface_phrase);
      var surface_preposition = input.getPreposition(
        input.verb_params.surface_phrase,
      );
      var writing_object = input.getAsset(input.verb_params.writing_phrase);
      var writing_preposition = input.getPreposition(
        input.verb_params.writing_phrase,
      );
      var information_object = input.getAsset(
        input.verb_params.information_phrase,
      );
      var results;
      var msg = "";

      if (information_object) {
        /* *
         * at the moment, the only information object we're handling is GlobalString
         * which is basically an Asset that's used as a placeholder for a string.
         * The string itself is stored in input.strings. This is probably not ideal,
         * and eventually we'll want to handle things like passwords and other
         * abstractions that can be written on a surface.
         * That's all @TODO
         */
      }

      this.game.debug(`F1529 | ${this.name}.js | print doSuccess `);

      if (
        input.verb_params.writing_phrase &&
        input.getAssumed(input.verb_params.writing_phrase)
      ) {
        msg += `<span class='inference'>(with ${writing_object.articlename})</span>`;
      }

      msg += "$(We) write ";
      if (surface_object) {
        if (input.strings.length) {
          msg += input.strings[0] + " ";
          surface_object.written_strings.push(input.strings[0]);
        } else {
          msg += " a few scribbles ";
        }
        msg += surface_object.quirks.write_on_means_write_in ? "in " : "on ";
        msg += surface_object.articlename;
      } else {
        msg += " a few scribbles in the air";
      }
      if (writing_object) {
        msg += " with " + writing_object.articlename;
      }
      msg += ". ";

      // print output
      this.handleSuccess(msg, surface_object);
      return true;
    },
  };
})(); // write

// xyzzy.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class xyzzy
   * @ajsnode game.dictionary.verbs.xyzzy
   * @ajsconstruct MyGame.createVerb({ "name": "xyzzy", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading UtilityVerbs
   * @summary Verb that performs an arbitrary action.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; xyzzy</span>
   * A hollow voice says 'fool'.
   * </pre>
   * <p>
   * If you don't know what it means, ask an old gamer. You'll make their day.
   * </p>
   */
  A.Preverbs.xyzzy = {
    name: "xyzzy",
    prettyname: "xyzzy",
    synonyms: [],
    verb_prep_noun: [],
    verb_prep_prep_noun: [],
    verb_noun_prep_noun: [],

    /**
     * @ajsverbstructures
     * @memberof xyzzy
     */
    accepts_structures: ["verb"],

    do: function () {
      var input = this.game.getInput();
      console.log("verbs.do");
      var msg = "Clever xyzzy response! ";
      if (msg) this.game.print(msg, input.output_class);
      return true;
    },
  };
})();

// yell.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class yell
   * @ajsnode game.dictionary.verbs.yell
   * @ajsconstruct MyGame.createVerb({ "name": "yell", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading Conversation Verbs
   * @summary Verb that means yell, as in "yell MORTAL COMBAT".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; yell</span>
   * Aaaaaah!
   * </pre>
   * <p>
   * <strong>Yell</strong> is intransitive, meaning it takes no object.
   * Yell doesn't provide any special logic.
   * Authors wanting to make use of it may need to use a method such
   * as verb hooks. See
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
   * to learn more.
   * </p>
   * @todo yell at character, yell idea at character
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.yell = {
    name: "yell",
    past_tense: "yelled",
    synonyms: ["yell"],

    /**
     * @memberof yell
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   accepts_preposition: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      accepts_preposition: true,
      noun_must_be: {
        known: true,
      },
    },

    /**
     * @memberof yell
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *   },
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
      },
    },

    /**
     * @memberof yell
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var currentRoom = this.game.getCurrentRoom();
      var msg = "";

      if (player.is.mute) {
        this.game.debug(`F1506 | ${this.name}.js | ${player.id}.is.mute `);
        msg += `$(We) can't yell at all. `;
        this.handleFailure(msg);
        return null;
      }

      if (currentRoom.is_vacuum) {
        this.game.debug(
          `F1507 | ${this.name}.js | ${currentRoom.id}.is_vacuum `
        );
        msg += `In space, no one can hear you scream. `;
        this.handleFailure(msg);
        return null;
      }

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var currentRoom = this.game.getCurrentRoom();
      var msg = "";

      this.game.debug(`F1505 | ${this.name}.js | print doSuccess `);
      msg += `Aaaaaah! `;

      this.handleSuccess(msg, currentRoom);
      return true;
    },
  };
})();

// zip.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class zip
   * @ajsnode game.dictionary.verbs.zip
   * @ajsconstruct MyGame.createVerb({ "name": "zip", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading ManipulationVerbs
   * @summary Verb that means zip, as in "zip parka".
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; zip coat</span>
   * You zip up your rain coat. Ready for another blustery autumn day.
   * </pre>
   * <p>
   * <strong>Zip</strong> a {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}.
   * Requires that the Asset has
   * asset.dov.zip.enabled set to true.
   * </p>
   * @ajsverbreactions
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.zip = {
    name: "zip",
    synonyms: ["zip"],
    past_tense: "zipped",
    prettyname: "zip",
    state: "zipped",

    /**
     * @ajsverbstructures
     * @memberof zip
     */
    accepts_structures: ["verb noun", "verb noun preposition noun"],

    /**
     * @memberof zip
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun: true,
     *   requires_noun: true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     not_global: true,
     *     tangible: true,
     *     present: true,
     *     // visible: true,
     *     reachable: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      requires_noun: true,
      noun_must_be: {
        known: true,
        not_global: true,
        tangible: true,
        present: true,
        reachable: true,
      },
    },

    /**
     * @memberof zip
     * @ajsverbphrase
     * phrase2:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     known: true,
     *     in_inventory: true,
     *   },
     *   accepts_preposition: true,
     *   requires_preposition: true,
     *   accepts_these_prepositions: ["with"],
     * },
     */
    phrase2: {
      accepts_noun: true,
      noun_must_be: {
        known: true,
        in_inventory: true,
      },
      accepts_preposition: true,
      requires_preposition: true,
      accepts_these_prepositions: ["with"],
    },

    /**
     * @memberof zip
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var results;
      var msg = "";

      // verb enabled?
      if (!direct_object.isDOV(this.name)) {
        this.game.debug(
          `F1286 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.enabled is false `,
        );
        msg += `${direct_object.Articlename} can't be ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // verb state?
      if (this.hasState() && direct_object.isState(this.name)) {
        this.game.debug(
          `F1287 | ${this.name}.js | ${
            direct_object.id
          }.is.${this.getState()} is ${direct_object.isState(this.name)}`,
        );
        msg += `${direct_object.Articlename} is already ${this.getState()}. `;
        this.handleFailure(msg);
        return null;
      }

      // single use direct object?
      if (
        direct_object.DOVallowOnce(this.name) &&
        direct_object.DOVdidDo(this.name)
      ) {
        this.game.debug(
          `F1288 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.once and ${direct_object.id}.dov.${this.name}.did_do `,
        );
        msg += `${direct_object.Articlename} has already been ${this.past_tense}. `;
        this.handleFailure(msg);
        return false;
      }

      // sentence structure: verb noun
      if (input.hasStructure("verb noun")) {
        // indirect object required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          return true;
        }

        // indirect objects available?
        if (!direct_object.DOVhasIndirectObjects(this.name)) {
          this.game.debug(
            `F1289 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing is false `,
          );
          msg += `$(We) don't know of a way to ${this.name} ${direct_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // infer indirect object?
        results = this.tryToInferIndirectObject(direct_object, true);
        if (results.prompt) {
          this.game.debug(`F1300 | ${this.name}.js | soft prompt for noun2 `);
          msg += `What would $(we) like to ${this.name} ${direct_object.articlename} with? `;
          this.handleFailure(msg);
          return false;
        }
        if (results.success) {
          indirect_object = results.indirect_object;
          indirect_preposition = "with";
        }
      } // verb noun

      // sentence structure: verb noun preposition noun
      if (input.hasStructure("verb noun preposition noun")) {
        // works with any indirect object?
        if (direct_object.DOVallowWithAnything(this.name)) {
          return true;
        }

        // indirect object not required?
        if (direct_object.DOVallowWithNothing(this.name)) {
          this.game.debug(
            `F1301 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_nothing `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // indirect object usable with direct object?
        if (!direct_object.DOVallowWithAsset(this.name, indirect_object)) {
          this.game.debug(
            `F1302 | ${this.name}.js | ${direct_object.id}.dov.${this.name}.with_assets/with_classes does not include ${indirect_object.id} `,
          );
          msg += `$(We) can't ${this.name} ${direct_object.articlename} ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return null;
        }

        // can indirect object be used?
        if (!indirect_object.isIOV(this.name)) {
          this.game.debug(
            `F1914 | ${this.name}.js | ${indirect_object.id}.iov.${this.name}.enabled is false `,
          );
          msg += `$(We) can't ${this.name} anything ${indirect_preposition} ${indirect_object.articlename}. `;
          this.handleFailure(msg);
          return false;
        }

        // single use indirect object?
        if (
          indirect_object.IOVallowOnce(this.name) &&
          indirect_object.IOVdidDo(this.name)
        ) {
          this.game.debug(
            `F1915 | ${this.name}.js | ${indirect_object.id}.iov.${
              this.name
            }.once and ${indirect_object.id}.iov.${this.name}.do_count is ${
              indirect_object.iov[this.name].do_count
            } `,
          );
          msg += `${indirect_object.Articlename} has already been used to ${this.name} something. `;
          this.handleFailure(msg);
          return null;
        }
      } // verb noun preposition noun

      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      var direct_preposition = input.getPreposition(1);
      var indirect_object = input.getAsset(2);
      var indirect_preposition = input.getPreposition(2);
      var player = this.game.getPlayer();
      var msg = "";
      var results;

      this.game.debug(`F1510 | ${this.name}.js | print doSuccess `);

      // apply state changes
      this.setState(direct_object, true);

      // compose output
      msg += `$(We) ${this.name}`;
      msg += `${direct_preposition ? " " + direct_preposition : ""}`;
      msg += `${direct_object ? " " + direct_object.articlename : ""}`;
      msg += `${indirect_preposition ? " " + indirect_preposition : ""}`;
      msg += `${indirect_object ? " " + indirect_object.articlename : ""}`;
      msg += `. `;

      // print output
      this.handleSuccess(msg, direct_object);
      return true;
    },
  };
})(); // zip

// aft.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class aft
   * @ajsnode game.dictionary.verbs.aft
   * @ajsconstruct MyGame.createVerb({ "name": "aft", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @ajssynonyms aft, rearward, back
   * @summary Verb meaning travel aft.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; aft</span>
   * There's no direction that way. Whaddaya, think you're on a boat?
   * You can go east or west. Oh wait. You were on a boat, and you just
   * walked the plank. Hungry sharks applaud your lack of direction.
   * </pre>
   * <p>
   * Direction verb: go <strong>aft</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.aft = {
    name: "aft",
    is_direction: true,
    is_spatial_direction: true,
    synonyms: ["aft", "rearward", "back", "stern"],
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof aft
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// down.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class down
   * @ajsnode game.dictionary.verbs.down
   * @ajsconstruct MyGame.createVerb({ "name": "down", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel down.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; down</span>
   * You slide down through the dark hole and quickly get eaten by a grue.
   * </pre>
   * <p>
   * Direction verb: go <strong>down</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.down = {
    name: "down",
    is_direction: true,
    is_spatial_direction: true,
    synonyms: ["down", "d"],
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof down
     */
    accepts_structures: ["verb"],

    doTry: function () {
      var player = this.game.getPlayer();
      var nest_asset = player.getNestAsset();
      var input = this.game.getInput();
      var msg = "";

      if (player.isNested()) {
        if (
          nest_asset.is.climbable &&
          player.position.y > nest_asset.position.y
        ) {
          this.game.debug(
            `F1137 | ${
              this.name
            }.js | player is nested ${player.getNestPreposition()} ${player.getNestId()}, doVerb climb`
          );
          input.input_verb = "climb";
          input.setAsset(1, nest_asset);
          input.setPreposition(1, "down");
          input.setStructure("verb preposition noun");
          this.game.dictionary.doVerb("climb");
          return null;
        } // ordinary nest
        else {
          this.game.debug(
            `F1136 | ${
              this.name
            }.js | infer 'get off ${player.getNestId()}, doVerb go off`
          );
          input.setVerb("go");
          input.setAsset(1, nest_asset);
          input.setPreposition(1, "off");
          input.setStructure("verb preposition noun");
          this.game.dictionary.doVerb("go");
          return null;
        }
      } // player.isNested()
    },

    doSuccess: function () {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// east.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class east
   * @ajsnode game.dictionary.verbs.east
   * @ajsconstruct MyGame.createVerb({ "name": "east", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel east.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; east</span>
   * You travel toward the rising sun and eventually die in horrible fire.
   * </pre>
   * <p>
   * Direction verb: go <strong>east</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.east = {
    name: "east",
    is_direction: true,
    is_compass_direction: true,
    synonyms: ["east", "e", "eastward"],
    adjectives: ["eastern", "easterly", "easternly"],
    article: "the",
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof east
     */
    accepts_structures: ["verb"],

    doSuccess: function (params) {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// enter.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class enter
   * @ajsnode game.dictionary.verbs.enter
   * @ajsconstruct MyGame.createVerb({ "name": "enter", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning enter specified asset, or travel in.
   * @ajssynonyms enter, in
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; enter</span>
   * You enter the bathysphere, which drops prematurely, spins,
   * and fills with water, causing you to drown.
   * </pre>
   * <p>
   * Direction verb: <strong>enter</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.enter = {
    name: "enter",
    past_tense: "entered",
    synonyms: ["enter", "in"],
    is_direction: true,
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof enter
     */
    accepts_structures: ["verb", "verb noun"],

    /**
     * @memberof enter
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     tangible: true,
     *     known: true,
     *     present: true,
     *     visible: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        tangible: true,
        known: true,
        present: true,
        visible: true,
      },
    },

    /**
     * @memberof enter
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var direct_object = input.getAsset(1);
      if (direct_object) {
        input.setPreposition(1, "in");
        input.setStructure("verb preposition noun");
        this.game.dictionary.doVerb("go");
        return null;
      }
      return true;
    },

    doSuccess: function () {
      var input = this.game.getInput();
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// exit.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class exit
   * @ajsnode game.dictionary.verbs.exit
   * @ajsconstruct MyGame.createVerb({ "name": "exit", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning exit an asset, or travel out.
   * @ajssynonyms exit, leave, out
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; exit</span>
   * You exit through the revolving door and wind up right back
   * where you started, in the path of your pursuers' guns.
   * </pre>
   * <p>
   * Direction verb: <strong>exit</strong> whatever player is in.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.exit = {
    name: "exit",
    past_tense: "exited",
    is_direction: true,
    synonyms: ["exit", "leave", "out"],
    //verb_prep_noun: [ "go out", "get out" ],
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof exit
     */
    accepts_structures: ["verb", "verb noun"],

    /**
     * @memberof exit
     * @ajsverbphrase
     * phrase1:
     * {
     *   accepts_noun:true,
     *   noun_must_be:
     *   {
     *     player_parent: true,
     *   },
     * },
     */
    phrase1: {
      accepts_noun: true,
      noun_must_be: {
        player_parent: true,
      },
    },

    /**
     * @memberof exit
     * @ajsverbparams
     * with_params: {},
     */
    with_params: {},

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var currentRoom = this.game.getCurrentRoom();
      var nest_asset = player.getNestAsset();
      var nest_preposition = player.getNestPreposition();
      var unnest_preposition = player.getUnnestPreposition();
      var direct_object = input.getAsset(1);
      var msg = "";

      if (direct_object) {
        if (nest_asset) {
          if (nest_asset.id === direct_object.id) {
            this.game.debug(
              `F1277 | ${this.name}.js | infer go ${unnest_preposition}`
            );
            input.setPreposition(1, unnest_preposition);
            input.setStructure("verb preposition noun");
            this.game.dictionary.doVerb("go");
            return null;
          }

          if (nest_asset.id !== direct_object.id) {
            this.game.debug(
              `F1220 | ${this.name}.js | player is ${nest_preposition} ${nest_asset.id}, not ${direct_object.id}`
            );
            msg += `$(We) can't exit 
              ${direct_object.articlename}
              from $(our) position 
              ${nest_preposition}
              ${nest_asset.articlename}. `;
            this.handleFailure(msg);
            return null;
          }
        }

        if (!nest_asset) {
          if (direct_object.id === currentRoom.id) {
            this.game.debug(`F1276 | ${this.name}.js | tryTravel exit`);
            this.game.tryTravel(this.name);
            return null;
          }
        }
      }

      if (!direct_object) {
        if (nest_asset) {
          input.setAsset(1, nest_asset);
          input.setPreposition(1, unnest_preposition);
          input.setStructure("verb preposition noun");
          this.game.debug(
            `F1278 | ${this.name}.js | infer go ${unnest_preposition}`
          );
          this.game.dictionary.doVerb("go");
          return null;
        } else {
          this.game.tryTravel(this.name);
          return null;
        }
      }

      return true;
    },

    doSuccess: function () {
      return true;
    },
  };
})();

// fore.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class fore
   * @ajsnode game.dictionary.verbs.fore
   * @ajsconstruct MyGame.createVerb({ "name": "fore", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to fore direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; fore</span>
   * You travel fore to the prow of the boat, where you are crushed
   * by a caboose-sized chunk of ice that rolls off the looming iceberg.
   * </pre>
   * <p>
   * Direction verb: go <strong>fore</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.fore = {
    name: "fore",
    is_direction: true,
    is_spatial_direction: true,
    synonyms: ["fore", "forward", "bow"],
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof fore
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      var input = this.game.getInput();
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// in.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class in
   * @ajsnode game.dictionary.verbs.in
   * @ajsconstruct MyGame.createVerb({ "name": "in", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel in.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; in</span>
   * You go in the bank vault. The massive door slams behind you,
   * trapping you inside the vault where you eventually suffocate.
   * </pre>
   * <p>
   * Direction verb: go <strong>in</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.in = {
    name: "in",
    is_direction: true,
    is_spatial_direction: true,
    synonyms: ["in"],
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof in
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      var input = this.game.getInput();
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// north.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class north
   * @ajsnode game.dictionary.verbs.north
   * @ajsconstruct MyGame.createVerb({ "name": "north", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to north direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; north</span>
   * You fly north with the Arctic winds, which frost your wings
   * and drag you down into the frigid sea.
   * </pre>
   * <p>
   * Direction verb: go <strong>north</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.north = {
    name: "north",
    is_direction: true,
    is_compass_direction: true,
    synonyms: ["north", "n", "northward"],
    adjectives: ["northern", "northernly"],
    article: "the",
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof north
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// northeast.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class northeast
   * @ajsnode game.dictionary.verbs.northeast
   * @ajsconstruct MyGame.createVerb({ "name": "northeast", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to northeast.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; northeast</span>
   * You step off the cliff and fall to your death among the rocks.
   * </pre>
   * <p>
   * Direction verb: go <strong>northeast</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.northeast = {
    name: "northeast",
    is_direction: true,
    is_compass_direction: true,
    synonyms: ["northeast", "ne", "northeastward"],
    adjectives: ["northeastern", "northeasterly", "northeasternly"],
    article: "the",
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof northeast
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// northwest.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class northwest
   * @ajsnode game.dictionary.verbs.northwest
   * @ajsconstruct MyGame.createVerb({ "name": "northwest", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to northwest.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; northwest</span>
   * You take a delicate step to the northwest,
   * where you're instantly swallowed by quicksand.
   * </pre>
   * <p>
   * Direction verb: go <strong>northwest</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.northwest = {
    name: "northwest",
    is_direction: true,
    is_compass_direction: true,
    synonyms: ["northwest", "nw", "northwestward"],
    adjectives: ["northwestern", "northwesterly", "northwesternly"],
    article: "the",
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof northwest
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      var input = this.game.getInput();
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// out.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class out
   * @ajsnode game.dictionary.verbs.out
   * @ajsconstruct MyGame.createVerb({ "name": "out", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel out.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; out</span>
   * You overcome your fears and leap out of the plane.
   * Too bad you forgot the parachute.
   * </pre>
   * <p>
   * Direction verb: go <strong>out</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.out = {
    name: "out",
    is_direction: true,
    is_spatial_direction: true,
    synonyms: ["out"],
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof out
     */
    accepts_structures: ["verb"],

    doTry: function () {
      var player = this.game.getPlayer();
      var input = this.game.getInput();
      var msg = "";

      if (player.isNested()) {
        var p = player.getNestPreposition();
        // we'll take "out" to mean out of in, under or behind
        if (p === "in" || p === "under" || p === "behind") {
          this.game.debug(
            `F1141 | ${
              this.name
            }.js | infer 'get out of ${player.getNestId()}', doVerb go out`
          );
          input.setVerb("go");
          input.setPreposition(1, "out");
          input.setStructure("verb preposition noun");
          input.setAsset(1, player.getNestAsset());
          this.game.dictionary.doVerb("go");
          return null;
        }
      } // player.isNested()
      return true;
    },

    doSuccess: function () {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// port.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class port
   * @ajsnode game.dictionary.verbs.port
   * @ajsconstruct MyGame.createVerb({ "name": "port", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to port direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; port</span>
   * Against all common sense, you move to port, capsizing the small boat.
   * </pre>
   * <p>
   * Direction verb: go <strong>port</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.port = {
    name: "port",
    is_direction: true,
    is_spatial_direction: true,
    synonyms: ["port", "left"],
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof port
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// south.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class south
   * @ajsnode game.dictionary.verbs.south
   * @ajsconstruct MyGame.createVerb({ "name": "south", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to south direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; south</span>
   * You tiptoe south through the field of sleeping Emperor Penguins...
   * alas, you crush one of their eggs, and they crush you in return.
   * </pre>
   * <p>
   * Direction verb: go <strong>south</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.south = {
    name: "south",
    is_direction: true,
    is_compass_direction: true,
    synonyms: ["south", "s", "southward"],
    adjectives: ["southern", "southerly", "southernly"],
    article: "the",
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof south
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// southeast.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class southeast
   * @ajsnode game.dictionary.verbs.southeast
   * @ajsconstruct MyGame.createVerb({ "name": "southeast", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to southeast direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; southeast</span>
   * You step southeast onto the spongy ground, and are caught
   * completely unawares when it splits open to reveal the terrible teeth.
   * </pre>
   * <p>
   * Direction verb: go <strong>southeast</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.southeast = {
    name: "southeast",
    is_direction: true,
    is_compass_direction: true,
    synonyms: ["southeast", "se", "southeastward"],
    adjectives: ["southeastern", "southeasterly", "southeasternly"],
    article: "the",
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof southeast
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      var input = this.game.getInput();
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// southwest.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class southwest
   * @ajsnode game.dictionary.verbs.southwest
   * @ajsconstruct MyGame.createVerb({ "name": "southwest", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to southwest direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; southwest</span>
   * You float along cautiously to the southwest until a trailing
   * strap of your spacesuit catches on a bit of debris and snaps
   * back, causing you to spin widly out into deep space.
   * </pre>
   * <p>
   * Direction verb: go <strong>southwest</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.southwest = {
    name: "southwest",
    is_direction: true,
    is_compass_direction: true,
    synonyms: ["southwest", "sw", "southwestward"],
    adjectives: ["southwestern", "southwesterly", "southwesternly"],
    article: "the",
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof southwest
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      var input = this.game.getInput();
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// starboard.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class starboard
   * @ajsnode game.dictionary.verbs.starboard
   * @ajsconstruct MyGame.createVerb({ "name": "starboard", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to starboard direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; starboard</span>
   * You take a step to starboard, right into
   * the path of an oncoming cannonball.
   * </pre>
   * <p>
   * Direction verb: go <strong>starboard</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.starboard = {
    name: "starboard",
    is_direction: true,
    is_spatial_direction: true,
    synonyms: ["starboard", "right"],
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof starboard
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      var input = this.game.getInput();
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// up.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class up
   * @ajsnode game.dictionary.verbs.up
   * @ajsconstruct MyGame.createVerb({ "name": "up", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to up direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; up</span>
   * You leap up and fail to avoid the rapidly spinning fan.
   * </pre>
   * <p>
   * Direction verb: go <strong>up</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.up = {
    name: "up",
    is_direction: true,
    is_spatial_direction: true,
    synonyms: ["up", "u"],
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof up
     */
    accepts_structures: ["verb"],

    doTry: function () {
      var input = this.game.getInput();
      var player = this.game.getPlayer();
      var nest_asset = player.getNestAsset();

      if (
        player.isNested() &&
        player.getNestAsset().is.climbable &&
        player.position.y < player.getNestAsset().getYTop()
      ) {
        this.game.debug(
          `F1142 | ${
            this.name
          }.js | player is nested on ${player.getNestId()}, which is climbable, doVerb climb`
        );
        input.setVerb("climb");
        input.setAsset(1, nest_asset);
        input.setPreposition(1, "up");
        input.setStructure("verb preposition noun");
        this.game.dictionary.doVerb("climb");
        return null;
      }
    },

    doSuccess: function () {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// west.js
// OK 09 2023
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Verb}
   * @class west
   * @ajsnode game.dictionary.verbs.west
   * @ajsconstruct MyGame.createVerb({ "name": "west", [...] });
   * @ajsconstructedby adventurejs.Dictionary#createVerb
   * @hideconstructor
   * @ajsinstanceof Verb
   * @ajsnavheading DirectionVerbs
   * @summary Verb meaning travel to west direction.
   * @tutorial Scripting_VerbSubscriptions
   * @tutorial Verbs_VerbAnatomy
   * @tutorial Verbs_VerbProcess
   * @tutorial Verbs_ModifyVerbs
   * @tutorial Verbs_WriteVerbs
   * @classdesc
   * <pre class="display border outline">
   * <span class="input">&gt; west</span>
   * You ride west, following the trail of the setting sun,
   * but not quickly enough to evade the pack of ravenous raptors.
   * </pre>
   * <p>
   * Direction verb: go <strong>west</strong>.
   * To learn about {@link adventurejs.Exit|Exits},
   * see <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   * @ajsverbphases doBeforeTry, doAfterTry, doBeforeSuccess, doAfterSuccess
   */
  A.Preverbs.west = {
    name: "west",
    is_direction: true,
    is_compass_direction: true,
    synonyms: ["west", "w", "westward"],
    adjectives: ["western", "westerly", "westernly"],
    article: "the",
    type: { direction: true },

    /**
     * @ajsverbstructures
     * @memberof west
     */
    accepts_structures: ["verb"],

    doSuccess: function () {
      this.game.tryTravel(this.name);
      return true;
    },
  };
})();

// Display.js

// css columns
//https://developer.mozilla.org/en-US/docs/Web/CSS/columns
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.Display
   * @ajsnavheading FrameworkReference
   * @param {Game} game A reference to the game instance.
   * @param {displayElId|HTMLElement} displayElId An ID for an HTML element to use as a display.
   * @summary Manages the main game display including all related HTML elements.
   * @classdesc
   * <p>
   * <strong>Display</strong> creates and manages the game display,
   * including the main input and output areas and the status bar.
   * It also manages custom compasses, verb docks and inventory
   * docks. Authors can customize the display with custom CSS.
   * CSS styles for Display can be found in
   * <a href="/css/adventurejs.css">adventurejs.css</a>.
   * To learn more, see the
   * </p>
   */
  class Display {
    constructor(displayElId, game) {
      game.log("log", 1, "Display.js > Constructing display.", "Display");

      /**
       * A reference back to the main {@link adventurejs.Game|Game} object.
       * @var {Object} adventurejs.Display#game
       * @default {}
       */
      this.game = game;

      /**
       * An array that contains a list of references to the
       * HTML element of any compasses, including the one
       * in the status bar as well as any custom compasses.
       * @var {compasses} adventurejs.Display#compasses
       * @default []
       */
      this.compasses = [];

      /**
       * An array that contains a list of references to the
       * HTML elements of any verb docks.
       * @var {verbdocks} adventurejs.Display#verbdocks
       * @default []
       */
      this.verbdocks = [];

      /**
       * An array that contains a list of references to the
       * HTML elements of any inventory docks.
       * @var {inventorydocks} adventurejs.Display#inventorydocks
       * @default []
       */
      this.inventorydocks = [];

      /**
       * An array that contains a list of references to the
       * HTML elements of any image docks.
       * @var {imagedocks} adventurejs.Display#imagedocks
       * @default []
       */
      this.imagedocks = [];

      /**
       * A reference to the game's HTML display element.
       * @var {HTMLElement} adventurejs.Display#displayEl
       * @default null
       */
      this.displayEl = null;

      /**
       * The ID of the game's HTML display element.
       * @var {HTMLElement} adventurejs.Display#displayElId
       * @default null
       */
      this.displayElId = null;

      this.initialize(displayElId);
    }

    /**
     * The game's title.
     * @var {String} adventurejs.Display#title
     * @default ""
     */
    get title() {
      return this.titleEl.innerText;
    }
    set title(title) {
      this.titleEl.innerText = title;
    }

    /**
     * The game's version.
     * @var {String} adventurejs.Display#version
     * @default ""
     */
    get version() {
      return this.versionEl.innerText;
    }
    set version(version) {
      this.versionEl.innerText = version;
    }

    /**
     * The game's author.
     * @var {String} adventurejs.Display#author
     * @default ""
     */
    get author() {
      return this.authorEl.innerText;
    }
    set author(author) {
      this.authorEl.innerText = author;
    }

    /**
     * The current room's name.
     * @var {String} adventurejs.Display#room
     * @default ""
     */
    get room() {
      return this.roomEl.innerText;
    }
    set room(room) {
      this.roomEl.innerHTML = room;
    }

    /**
     * The current score.
     * @var {String} adventurejs.Display#score
     * @default ""
     */
    get score() {
      return this.scoreEl.innerText;
    }
    set score(score) {
      this.scoreEl.innerText = score;
    }
  }
  adventurejs.Display = Display;
})();

// clearInput.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
   * Clear the input field
   * @memberOf adventurejs.Display
   * @method adventurejs.Display#clearInput
	 */
  p.clearInput = function Display_clearInput(value)
  {
    this.inputEl.value = '';
    //this.clearBtn.classList.remove('active');
    this.inputContainerEl.classList.remove('active');
  }
  
}());

// clearOutput.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

 /**
  * Clear the game display.
  * @memberOf adventurejs.Display
  * @method adventurejs.Display#clearOutput
  */
 p.clearOutput = function Display_clearOutput() 
 {
   this.outputEl.innerHTML = "";
 }

}());

// createCompass.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
   * <strong>createCompass()</strong> is a method for creating 
   * compasses, including the default compass in the status bar,
   * and any custom compasses. It takes a generic object 
   * containing an id and an optional list of css classes to be 
   * applied to a compass's HTML element.
   * Compasses will be created at runtime. 
   * Compasses can be styled with any custom CSS. 
   * Compasses will be updated to show available exits
   * any time the location changes.
   * To create a new compass: 
   * 
   * <pre class="display"><code class="language-javascript">MyGame.createCompass({ 
   *   "id":"MyCompass",
   *   "cssclasses":["custom"]
   * });
   * </code></pre>
   * 
   * For more information, see
   * <a href="/doc/GUI_Compasses.html">GUI Compasses</a>.
	 * @method adventurejs.Display#createCompass
	 * @param {Object} properties HTML ID and CSS classes.
	 * @returns {Element} Returns the HTML element of the compass.
	 */
	p.createCompass = function Display_createCompass(properties)
  { //ordinal marine
    let compass;
    let author_element;
    let exits;
    let status;
    if(properties.type === 'marine')
    {
      exits = [
        ['ud','updown'],
        ['fore','marine'],
        ['aft','marine'],
        ['port','marine'],
        ['starboard','marine'],
      ];
    }
    else
    {
      exits = [
        ['northwest','ordinal'],
        ['north','cardinal'],
        ['northeast','ordinal'],
        ['west','cardinal'],
        ['ud','updown'],
        ['east','cardinal'],
        ['southwest','ordinal'],
        ['south','cardinal'],
        ['southeast','ordinal'],
      ];
    }

    if(properties.id){
      author_element = document.querySelector('#'+properties.id);
    }
    compass = author_element ? author_element : document.createElement("div");
    if(properties.id) 
    {
      compass.setAttribute('id',properties.id);
    }
    compass.classList.add("ajs-compass-wrapper","ajs-dock-wrapper");
    if(properties.cssclasses) 
    {
      for(var item in properties.cssclasses)
      {
        compass.classList.add(properties.cssclasses[item]);
      }
    }
    
    if(properties.createnodes)
    {
      let exitsEl = document.createElement("div");
      exitsEl.classList.add("ajs-compasspoints");
      compass.appendChild(exitsEl);

      let exitsHoverCatchEl = document.createElement("div");
      exitsHoverCatchEl.classList.add("ajs-compass-hover-trap");
      exitsHoverCatchEl.game = this.game;
      exitsEl.appendChild(exitsHoverCatchEl);
      exitsHoverCatchEl.addEventListener('mouseenter',()=>{
        //console.log('hovered!');
        // hovercatch was imagined as a way to magnify
        // the status bar compass rose on rollover.
        // Could also be used for custom methods.
      })
      for(let exit in exits)
      {
        let exitEl;
        if(exits[exit][0]==='ud') {
          exitEl = document.createElement("div");

          // exitEl.classList.add("ajs-compasspoint", "ajs-compasspoint-button", exits[exit][0], exits[exit][1]);
          // exitEl.game = this.game;

          let u = document.createElement("div");
          u.classList.add("ajs-compasspoint", "up", "ajs-compasspoint-button");
          u.dataset.exit = "up";
          u.innerHTML = "up";
          u.game = this.game;
          u.setAttribute("aria-disabled","true");
          exitEl.appendChild(u);

          let d = document.createElement("div");
          d.classList.add("ajs-compasspoint", "down", "ajs-compasspoint-button");
          d.dataset.exit = "down";
          d.innerHTML = "down";
          d.game = this.game;
          d.setAttribute("aria-disabled","true");
          exitEl.appendChild(d);
        }
        else {
          exitEl = document.createElement("button");
          exitEl.setAttribute("aria-disabled","true");
          exitEl.innerHTML = exits[exit][0];

        }
        exitEl.classList.add("ajs-compasspoint", "ajs-compasspoint-button", exits[exit][0], exits[exit][1]);
        exitEl.dataset.exit = exits[exit][0];
        exitEl.game = this.game;

        exitsEl.appendChild(exitEl);  
      }

      compass.querySelectorAll('.ajs-compasspoint-button').forEach(function(el){
        el.addEventListener('mouseenter',function(event){
          this.classList.add('active');
        });
        el.addEventListener('mouseleave',function(event){
          this.classList.remove('active');
        });
        el.addEventListener('click',function(event){
          console.warn('clicked',this);
          this.game.sendToParser(el.dataset.exit);
        })
      })

    } // createnodes

    if( !properties.statusbar && !author_element )
    {
      this.displayEl.appendChild(compass);
    }
    this.compasses.push(compass);
		return compass;
	}
  
}());

// createImageDock.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Display.prototype;

  /**
   * <strong>createImageDock()</strong> is a method for creating
   * custom image docks. It takes a generic object containing an
   * id, an optional list of css classes to be applied to the
   * element, and an object containing image id / image url pairs.
   * Image docks will be created at runtime, and
   * can be styled with any custom CSS.
   * To create a new image dock:
   *
   * <pre class="display"><code class="language-javascript">MyGame.createImageDock({
   *   "id":"MyImageDock",
   *   "cssclasses":["custom"],
   *   "images": [
   *     [ "myimage_01": "/images/myimage_01.jpg" ],
   *     [ "myimage_02": "/images/myimage_02.jpg" ],
   *   ],
   * });
   * </code></pre>
   *
   * For more information, see
   * <a href="/doc/GUI_ImageDocks.html">Image Dock</a>.
   * @method adventurejs.Display#createImageDock
   * @param {Object} properties HTML ID, CSS classes, and verbs.
   * @returns {Element} Returns the HTML element of the verb dock.
   */
  p.createImageDock = function Display_createImageDock(properties) {
    console.warn("createImageDock", properties);
    let author_element;
    let dock;

    if (properties.id) {
      author_element = document.querySelector("#" + properties.id);
    }
    dock = author_element ? author_element : document.createElement("div");
    if (properties.id) {
      dock.setAttribute("id", properties.id);
    }
    if (properties.type) {
      dock.dataset.type = properties.type;
    }
    dock.classList.add("game_imagedock_container", "ajs-dock-wrapper");
    if (properties.cssclasses) {
      for (var item in properties.cssclasses) {
        dock.classList.add(properties.cssclasses[item]);
      }
    }

    dock.game = this.game;
    dock.messages = [
      " ",
      " ",
      "$(We) clicked the picture, but there's no need for that. It's just a visual reference. ",
      " ",
      " ",
      "There's no need to click. Sorry, but this isn't a point & click game.",
      " ",
      " ",
      "Move on, there's nothing to do in the picture. ",
      " ",
      " ",
      "Whattaya think this is, a point & click game? ",
      " ",
      " ",
    ];
    dock.addEventListener("click", function (event) {
      this.game.print(A.getSAF.call(this.game, this.messages));
    });

    this.imagedocks.push(dock);
    if (!author_element) {
      this.displayEl.appendChild(dock);
    }
    return dock;
  };
})();

// createInventoryDock.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
   * <strong>createInventoryDock()</strong> is a method for creating 
   * custom inventory docks. It takes a generic object containing an 
   * id and an optional list of css classes to be applied to the 
   * element. Inventory docks will be created at runtime, and 
   * can be styled with any custom CSS.
   * To create a new inventory dock: 
   * 
   * <pre class="display"><code class="language-javascript">MyGame.createInventoryDock({ 
   *   "id":"MyInventoryDock",
   *   "cssclasses":["custom"]
   * });
   * </code></pre>
   * 
   * For more information, see 
   * <a href="/doc/GUI_InventoryDocks.html">GUI Inventory Dock</a>.
	 * @method adventurejs.Display#createInventoryDock
	 * @param {Object} properties HTML ID, CSS classes, and verbs.
	 * @returns {Element} Returns the HTML element of the verb dock.
	 */
	p.createInventoryDock = function Display_createInventoryDock(properties)
  {
    console.warn('createInventoryDock',properties);
    let author_element;
    let dock;

    if(properties.id){
      author_element = document.querySelector('#'+properties.id);
    }
    dock = author_element ? author_element : document.createElement("div");
    if(properties.id) 
    {
      dock.setAttribute('id',properties.id);
    }
    dock.classList.add("game_inventorydock_container","ajs-dock-wrapper");
    if(properties.cssclasses) 
    {
      for(var item in properties.cssclasses)
      {
        dock.classList.add(properties.cssclasses[item]);
      }
    }
    if(properties.assetclasses) 
    {
      dock.dataset.assetclasses = properties.assetclasses.join(',');
    }
    if(properties.is) 
    {
      dock.dataset.is = properties.is.join(',');
    }
    if(properties.is_in)
    {
      dock.dataset.is_in = properties.is_in.join(',');
    }

    this.inventorydocks.push(dock);
    if( !author_element )
    {
      this.displayEl.appendChild(dock);
    }
		return dock;
	}
  
}());

// createVerbDock.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
   * <strong>createVerbDock()</strong> is a method for creating 
   * custom verb docks. It takes a generic object containing an id, 
   * a list of verbs, and an optional list of css classes to be
   * applied to the element. Any verbs supplied will have buttons 
   * created for them. Verb docks will be created at runtime, and 
   * can be styled with any custom CSS.
   * To create a new verb dock: 
   * 
   * <pre class="display"><code class="language-javascript">MyGame.createVerbDock({ 
   *   "id":"MyVerbDock",
   *   "cssclasses":["custom"],
   *   "verbs": ["save","restore","examine","take","use","drop"],
   * });
   * </code></pre>
   * 
   * For more information, see
   * <a href="/doc/GUI_VerbDocks.html">GUI Verb Dock</a>.
	 * @method adventurejs.Display#createVerbDock
	 * @param {Object} properties HTML ID, CSS classes, and verbs.
	 * @returns {Element} Returns the HTML element of the verb dock.
	 */
	p.createVerbDock = function Display_createVerbDock(properties)
  {
    console.warn('createVerbDock',properties);
    let author_element;
    let dock;

    if(properties.id){
      author_element = document.querySelector('#'+properties.id);
    }
    dock = author_element ? author_element : document.createElement("div");
    if(properties.id) 
    {
      dock.setAttribute('id',properties.id);
    }
    dock.classList.add("game_verbdock_container","ajs-dock-wrapper");
    if(properties.cssclasses) 
    {
      for(var item in properties.cssclasses)
      {
        dock.classList.add(properties.cssclasses[item]);
      }
    }

    let verbs = document.createElement("div");
    verbs.classList.add("verbdock","verbs");
    dock.appendChild(verbs);

    if(properties.clear)
    {
      let clearbtn = document.createElement('button');
      clearbtn.classList.add("dock_button","btn_verb","btn_clearverbs");
      clearbtn.innerHTML = "&#x2716;";
      clearbtn.game = this.game;
      clearbtn.addEventListener('click',function(){
        this.game.clearInput();
      })
      verbs.appendChild(clearbtn);
    }
    
    properties.verbs.forEach(function(verb){
      if( "string" === typeof verb ) 
      {
        verb = { 
          verb: verb, 
          parse: this.game.dictionary[verb]?.canBeIntransitive()?false:true 
        };
      }
      let btn = document.createElement('button');
      btn.dataset.verb = verb.verb;
      btn.dataset.parse = verb.parse?verb.parse:false;
      btn.classList.add(btn.dataset.verb, "dock_button","btn_verb");
      if(verb.cssclasses)
      {
        for(var item in verb.cssclasses)
        {
          btn.classList.add(verb.cssclasses[item]);
        }
      }

      btn.innerHTML += `<span class="verb name">${verb.verb}</span>`;
      //console.warn(verb.verb,this.game.image_lookup[verb.verb]);
      if(this.game.image_lookup[verb.verb])
      {
        btn.classList.add('hasimage');
        btn.innerHTML += `<span class="verb icon"><img src="${this.game.image_lookup[verb.verb]}"/></span>`;
      }

      btn.game = this.game;
      btn.addEventListener('click',function(){
        console.warn('clicked',this);
        if(this.dataset.parse==="true") 
        {
          this.game.sendToParser(this.dataset.verb);
        }
        else 
        {
          this.game.sendToInput(this.dataset.verb);
        }
      })
      verbs.appendChild(btn);
    },this);

    this.verbdocks.push(dock);
    if( !author_element )
    {
      this.displayEl.appendChild(dock);
    }
		return dock;
	}
  
}());

//initialize.js
(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Display.prototype;

  /**
   * Initialize the game display.
   * Creates all the necessary HTML elements.
   * @method adventurejs.Display#initialize
   * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
   * @returns {adventurejs.Display} Returns the instance the method is called on (useful for chaining calls.)
   */
  p.initialize = function Display_initialize(displayElId) {
    if ("string" === typeof displayElId) {
      this.displayEl = document.getElementById(displayElId);
    }

    if (!this.displayEl) {
      // create display
      let el = document.createElement("div");
      el.setAttribute("id", displayElId);
      document.getElementsByTagName("body")[0].appendChild(el);
      this.displayEl = el;
    }

    this.displayEl.classList.add("ajs-display");
    this.displayElId = displayElId;

    this.titlebarEl = document.createElement("div");
    this.titlebarEl.classList.add("ajs-titlebar");
    this.displayEl.appendChild(this.titlebarEl);

    this.titleEl = document.createElement("span");
    this.titleEl.classList.add("ajs-title");
    this.titleEl.innerText = "Unnamed Game";
    this.titlebarEl.appendChild(this.titleEl);

    this.versionEl = document.createElement("span");
    this.versionEl.classList.add("ajs-version");
    this.versionEl.innerText = "v0.0";
    this.titlebarEl.appendChild(this.versionEl);

    this.authorEl = document.createElement("span");
    this.authorEl.classList.add("ajs-author");
    this.authorEl.innerText = "Unnamed Author";
    this.titlebarEl.appendChild(this.authorEl);

    this.statusbarEl = document.createElement("div");
    this.statusbarEl.classList.add("ajs-statusbar");
    this.displayEl.appendChild(this.statusbarEl);

    this.exitsContainerEl = this.createCompass({
      statusbar: true,
      createnodes: true,
      cssclasses: ["statusbar"],
    });
    this.statusbarEl.appendChild(this.exitsContainerEl);
    if (!this.game.settings.show_compass_rose_in_status) {
      this.exitsContainerEl.classList.add("hidden");
    }
    if (this.game.settings.magnify_compass_rose_on_hover) {
      this.exitsContainerEl.classList.add("magnify");
    }

    this.roomEl = document.createElement("span");
    this.roomEl.classList.add("ajs-room");
    this.statusbarEl.appendChild(this.roomEl);

    this.scoreEl = document.createElement("span");
    this.scoreEl.classList.add("ajs-score");
    this.statusbarEl.appendChild(this.scoreEl);

    this.outputWrapperEl = document.createElement("div");
    this.outputWrapperEl.classList.add("ajs-output-wrapper");
    this.displayEl.appendChild(this.outputWrapperEl);

    this.outputEl = document.createElement("div");
    this.outputEl.classList.add("ajs-output");
    this.outputWrapperEl.appendChild(this.outputEl);

    this.inputContainerEl = document.createElement("div");
    this.inputContainerEl.classList.add("ajs-input-wrapper");
    this.displayEl.appendChild(this.inputContainerEl);

    this.inputPromptEl = document.createElement("span");
    this.inputPromptEl.classList.add("ajs-input-arrow");
    this.inputPromptEl.innerHTML = ">";
    this.inputContainerEl.appendChild(this.inputPromptEl);

    this.inputEl = document.createElement("input");
    //this.inputEl.pattern = "[A-Za-z0-9'-+\"]+";
    this.inputEl.maxLength = 75;
    this.inputEl.placeholder = "type your input here";
    this.inputEl.display = this; // give input a reference back to display
    this.inputEl.game = this.game; // give input a reference back to game
    this.inputEl.setAttribute("id", this.game.game_name + "-" + "ajs-input");
    this.inputEl.setAttribute("autocomplete", "off");
    this.inputEl.classList.add("ajs-input");
    this.inputContainerEl.appendChild(this.inputEl);

    this.inputEl.addEventListener("input", function (event) {
      // Check if the input has text
      if (!this.value || this.value === "" || !this.value.length) {
        this.display.inputContainerEl.classList.remove("active");
        // this.display.clearBtn.classList.remove('active');
      } else {
        this.display.inputContainerEl.classList.add("active");
        // this.display.clearBtn.classList.add('active');
      }
    }); // input

    this.inputEl.addEventListener("keyup", function (event) {
      if (event.key === "Enter") {
        // this.game.reactor.dispatchEvent( this.game.events.inputEnter );
        this.game.sendToParser(this.value);
      } else if (event.key === "ArrowUp") {
        this.value = this.game.parser.getOlderInput();
      } else if (event.key === "ArrowDown") {
        this.value = this.game.parser.getNewerInput();
      }
    }); // keyup

    this.clearBtn = document.createElement("button");
    this.clearBtn.classList.add("clear", "icon");
    this.clearBtn.display = this;
    this.inputContainerEl.appendChild(this.clearBtn);
    this.clearBtn.addEventListener("click", function () {
      this.display.clearInput();
    });

    this.enterBtn = document.createElement("button");
    this.enterBtn.classList.add("enter", "icon");
    this.enterBtn.display = this;
    this.enterBtn.game = this.game;
    this.inputContainerEl.appendChild(this.enterBtn);
    this.enterBtn.addEventListener("click", function () {
      this.game.sendToParser(this.display.inputEl.value);
    });

    this.displayEl.classList.remove("unplayed", "loading");
    this.displayEl.classList.add("initialized");

    //this.inputEl.focus(); // commented because it interferes with doc pages
  };
})();

// print.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Display.prototype;

  /**
   * Global method for printing text to game display.
   * @memberOf adventurejs.Display
   * @method adventurejs.Display#print
   * @param {String} msg An arbitrary string.
   * @param {String} classes Optional class(es) to apply to output.
   * @TODO add ability to pause at screen height so excess text doesn't scroll off screen
   */
  p.print = function Display_print(msg, classes) {
    this.outputEl.innerHTML =
      this.outputEl.innerHTML +
      '<span class="p ' +
      classes +
      '">' +
      msg +
      " </span>";
    this.outputWrapperEl.scrollTo({
      top: this.outputWrapperEl.scrollHeight,
      left: 0,
      behavior: "smooth",
    });
  };
})();

// printInput.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

 /**
  * Print the player's input back to game display.
  * @memberOf adventurejs.Display
  * @method adventurejs.Display#printInput
  * @param {String} input An arbitrary string.
  */
 p.printInput = function Display_printInput(input) 
 {
   if( "undefined" !== typeof input ) 
   {
     this.print( "> " + input, "input" );
     return;
   }
   if(this.game.parser.getInputCount()>0) 
   {
     this.print( "> "
       + this.game.parser.getLastInput(), "input" );
     return;
   }
 }

}());

// printWithInput.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

 /**
  * Print a message preceded by player's input back to game display.
  * @memberOf adventurejs.Display
  * @method adventurejs.Display#printWithInput
  * @param {String} msg An arbitrary string.
  * @param {String} classes Optional class(es) to apply to output.
  */
 p.printWithInput = function Display_printWithInput(msg, classes) 
 {
   if(this.game.parser.getInputCount()>0) 
   {
     this.print( "> "
       + this.game.parser.getLastInput(), "input" );
   }
   this.print(msg, classes);
 }

}());

// sendToInput.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
   * Takes a string and writes it to the input field
   * without submitting it to the parser.
   * @memberOf adventurejs.Display
   * @method adventurejs.Display#sendToInput
	 */
  p.sendToInput = function Display_sendToInput(value)
  {
    if(this.inputEl.value.length) this.inputEl.value += " ";
    this.inputEl.value += value;
    this.clearBtn.classList.add('active');
  }
  
}());

//set.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

  /**
	 * Provides a chainable shortcut method for setting a number of properties on the instance.
	 * @method adventurejs.Display#set
	 * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
	 * @returns {adventurejs.Display} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	*/
	p.set = function Display_set(props) 
  {
		if (props != null) 
    {
			for (var n in props) 
      { 
				this[n] = props[n]; 
			}
		}
		return this;
	};
}());

// setRoomImage.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Set Room image if there is one.
	 * @method adventurejs.Display#setRoomImage
	 * @param {String} id The id of an image in game.image_lookup.
	 * @returns {adventurejs.Display} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	 */
	p.setRoomImage = function Display_setRoomImage(id) 
  {
		this.imagedocks.forEach(function(dock){
      if(dock.dataset.type && dock.dataset.type.toLowerCase()==="room")
      {
        if(this.game.image_lookup[id])
        {
          dock.innerHTML = `<img src="${this.game.image_lookup[id]}" class="room_image id_${id}"/>`;
        }
        else
        { 
          dock.innerHTML = "";
        }
      }
    },this);

		return this;
	}

}());

// setRoom.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Set Room in status bar.
	 * @method adventurejs.Display#setRoom
	 * @param {String} name Sets the Status Bar's Room field.
	 * @returns {adventurejs.Display} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
	 */
	p.setRoomName = function Display_setRoomName(name) 
  {
		this.roomEl.innerHTML = name;
		return this;
	}

}());

// setScore.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Display.prototype;

  /**
   * Set Score in status bar.
   * @method adventurejs.Display#setScore
   * @param {String} score Sets the Status Room field.
   * @returns {Display} Returns the instance the method is called on (useful for chaining calls.)
   * @chainable
   */
  p.setScore = function Display_setScore(score) {
    this.scoreEl.innerText = score;
    return this;
  };
})();

// unsetCompasses.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Reset exits in status bar and custom compass roses.
	 * @method adventurejs.Display#unsetCompasses
	 */
	p.unsetCompasses = function Display_unsetCompasses() 
  {
    this.compasses.forEach(function(element){
      element.querySelector('.ajs-compasspoints')?.setAttribute('class',`ajs-compasspoints`);
    })
	}
  
}());

// unsetImageDocks.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Unset images in image docks.
	 * @method adventurejs.Display#unsetImageDocks
   * @param {Object} properties
	 */
	p.unsetImageDocks = function Display_unsetImageDocks(properties) 
  {
    // this.imagedocks.forEach(function(element){})
	}
  
}());

// unsetInventoryDocks.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Unset inventory in inventory docks.
	 * @method adventurejs.Display#unsetInventoryDocks
   * @param {Object} properties
	 */
	p.unsetInventoryDocks = function Display_unsetInventoryDocks(properties) 
  {
    // this.inventorydocks.forEach(function(element){})
	}
  
}());

// unsetVerbDocks.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Unset verbs in verb docks.
	 * @method adventurejs.Display#unsetVerbDocks
   * @param {Object} properties
	 */
	p.unsetVerbDocks = function Display_unsetVerbDocks(properties) 
  {
    // this.verbdocks.forEach(function(element){})
	}
  
}());

// updateCompasses.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Set exits in status bar and custom compass roses.
	 * @method adventurejs.Display#updateCompasses
   * @param {String} exits
	 */
	p.updateCompasses = function Display_updateCompasses(exits) 
  {
    this.compasses.forEach(function(element){
      let compass = element.querySelector('.ajs-compasspoints');
      compass?.setAttribute('class',`ajs-compasspoints ${exits}`);
      compass?.querySelectorAll('.ajs-compasspoint').forEach(function(point){
        let disabled = (-1 === exits.indexOf(point.dataset.exit));
        point.setAttribute("aria-disabled", disabled ); 
      });

    })
	}
  
}());

// updateImageDocks.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Set images in image docks.
	 * @method adventurejs.Display#updateImageDocks
   * @param {Object} properties
	 */
	p.updateImageDocks = function Display_updateImageDocks(properties) 
  {
    // this.imagedocks.forEach(function(dock){
    //   dock.addEventListener('click',function(){});
    // })
	}
  
}());

// updateInventoryDocks.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Set inventory in inventory docks.
	 * @method adventurejs.Display#updateInventoryDocks
   * @param {Object} properties
   * @TODO different lists for specific docks
	 */
	p.updateInventoryDocks = function Display_updateInventoryDocks(inventory) 
  {

    this.inventorydocks.forEach(function(dock){
      let html = '<div class="inventorydock">'
      let assetclasses, is, is_in;
      if(dock.dataset.assetclasses) 
      {
        assetclasses = dock.dataset.assetclasses.split(',');
      }
      if(dock.dataset.is) 
      {
        is = dock.dataset.is.split(',');
      }
      if(dock.dataset.is_in) 
      {
        is_in = dock.dataset.is_in.split(',');
      }

      inventory.forEach(function(item){
        let asset = this.game.getAsset(item);
        let image = '';
        let hasimage = '';
        if(asset.image) 
        {
          image = `<span class="inventory icon"><img src="${this.game.image_lookup[asset.image]}"/></span>`;
          hasimage = "hasimage";
        }
        let allow = true;

        // assetclasses limits to specified classes, like Weapon or Key
        if(assetclasses && assetclasses.length)
        {
          let allowed_class = false;
          for(var klas in assetclasses)
          {
            if(asset instanceof adventurejs[assetclasses[klas]] ) 
            {
              allowed_class = true;
              continue;
            }
          }
          if(!allowed_class) allow = false;
        }

        // is means limit to inventory with particular state, like is.worn for clothes
        if(is && is.length)
        {
          let allowed_is = false;
          for(var truth in is)
          {
            if(asset.is[is[truth]] ) 
            {
              allowed_is = true;
              continue;
            }
          }
          if(!allowed_is) allow = false;
        }

        // is_in means limit to inventory in a container, like a knapsack
        if(is_in && is_in.length)
        {
          console.warn('asset',asset);
          console.warn('is_in',is_in);
          let allowed_is_in = false;
          for(var id in is_in)
          {
            if( asset.isIn(is_in[id]) ) {
              allowed_is_in = true;
              continue;
            }
          }
          if(!allowed_is_in) allow = false;
        }
        
        if(allow)
        {
          let itemhtml = `<button data-id="${asset.id}" data-name="${asset.name}" class="dock_button btn_inventory inventory id_${asset.id} class_${asset.class} ${hasimage}" data-name="${asset.name}"><span class="inventory name">${asset.name}</span>${image}</button>`;
          html += itemhtml;  
        }

      },this);

      html += '</div>';
      dock.innerHTML = html;

      dock.querySelectorAll('.btn_inventory').forEach(function(el){
        el.game = this.game;
        el.addEventListener('click',function(){
          if(this.game.display.inputEl.value.length)
          {
            this.game.sendToInput(el.dataset.name);
          }
          else {
            this.game.sendToParser('examine ' + el.dataset.name);
          }
          
        });
      },this);

    }, this )


	}
  
}());

// updateVerbDocks.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Display.prototype;

	/**
	 * Set verbs in verb docks.
	 * @method adventurejs.Display#updateVerbDocks
   * @param {Object} properties
	 */
	p.updateVerbDocks = function Display_updateVerbDocks(properties) 
  {
    // this.verbdocks.forEach(function(element){})
	}
  
}());

// Input.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.Input
   * @ajsinternal
   * @ajsnavheading FrameworkReference
   * @summary Framework class, used as a property of the parser instance, that stores a turn's parsed input.
   * @classdesc
   * <p>
   * <strong>Input</strong> is a special class constructed by
   * {@link adventurejs.Parser#parseInput|Parser.parseInput()},
   * and used to store each turn's input and all of
   * the metadata that is generated for it, including the verb and noun(s)
   * that were parsed, whether a disambiguation was called for,
   * whether a soft prompt was made, whether a noun was assumed
   * based upon context, and other data. This is an internal class
   * that authors should not need to construct.
   * </p>
   */
  class Input {
    constructor(params) {
      this.game_name = params.game_name || "";

      this.game.log("log", "high", "Input.js > new input created", "Parser");

      /**
       * Save the original input string for later reference.
       * @var {String} adventurejs.Input#input
       * @default ""
       */
      this.input = ""; // original input

      /**
       * The end result of parsing is a set of verified words -
       * verbs, nouns and prepositions - which can be used by verbs.
       * @var {Object} adventurejs.Input#verified_sentence
       * @default {}
       */
      this.verified_sentence = {};

      /**
       * Property used by handleWord() to pass data to
       * parseMultipleInputs().
       * @var {Array} adventurejs.Input#parsed_word
       * @default { 'enabled':false }
       */
      this.parsed_word = { enabled: false };

      /**
       * We use this as an intermediary step to store the
       * parsed, typed input before we verify it.
       * @var {Array} adventurejs.Input#parsed_sentence
       * @default []
       */
      this.parsed_sentence = [];

      /**
       * This is a simple representation of the parsed input
       * for comparison purposes. Verbs may have their
       * accepts_structures property set to a list of valid
       * sentence structures. This gives us another way to
       * validate input, by comparing it to a verb's capabilities.
       * @var {Array} adventurejs.Input#verified_sentence_structure
       * @default ""
       */
      this.verified_sentence_structure = "";

      /**
       * Object for managing strings that author appends/overrides/prepends
       * to native output.
       * @var {Object} adventurejs.Input#printer
       * @default {append:[],prepend:[],override:[],appended:[],prepended:[],overridden:[]}
       */
      // this.append_to_next_print = [];
      this.printer = {
        append: [],
        prepend: [],
        override: [],
        appended: [],
        prepended: [],
        overriden: [],
      };

      /**
       * The original unparsed player's input string.
       * @var {String} adventurejs.Input#unparsed_input
       * @default ""
       */
      this.unparsed_input = "";

      /**
       * The parsed version of the player's input string.
       * @var {String} adventurejs.Input#parsed_input
       * @default
       */
      this.parsed_input = "";

      /**
       * Optional string containing a space delimited list of
       * CSS classes to apply to the printed output.
       * @var {String} adventurejs.Input#output_class
       * @default ""
       */
      this.output_class = "";

      /**
       * If player only input one word, store that here,
       * because we parse single words differently from multiple words.
       * @var {String} adventurejs.Input#found_word
       * @default ""
       */
      this.found_word = "";

      /**
       * A string representing the verb that was found in player input.
       * @var {String} adventurejs.Input#input_verb
       * @default ""
       */
      this.input_verb = "";

      /**
       * If parser found an unknown word, store it here.
       * @var {String} adventurejs.Input#unknown_word
       * @default undefined
       */
      this.unknown_word = undefined;

      /**
       * We're making a soft prompt with this turn, asking for clarification of a verb or noun.
       * @var {Boolean} adventurejs.Input#soft_prompt
       * @default { 'verb':null, 'noun1':false, 'noun2':false, 'noun3':false, 'enabled':false, 'satisfied':false }
       */
      this.soft_prompt = {
        verb: null,
        input_verb: null,
        noun1: false,
        noun2: false,
        noun3: false,
        nouns: [],
        preposition1: false,
        preposition2: false,
        preposition3: false,
        prepositions: [],
        enabled: false,
        satisfied: false,
        structure: "",
      };

      /**
       * When we call for disambiguation, we ask for noun1, noun2, or noun3.
       * We save the index here so we can refer to, for ex: "disambiguate["noun"+disambiguate.index].
       * @var {int} adventurejs.Input#disambiguate
       * @default { 'index':null, 'noun1':false, 'noun2':false, 'noun3':false }
       */
      this.disambiguate = {
        index: null,
        noun1: false,
        noun2: false,
        noun3: false,
        enabled: false,
        nouns: [],
      };

      /**
       * It's possible to redirect from one verb to another within a
       * single turn. We save each verb's id in verb_chain, to check
       * that we're not stuck in a circular loop.
       * @var {Array} adventurejs.Input#verb_chain
       * @default []
       */
      this.verb_chain = [];

      /**
       * In some instances we want to allow a verb to be reused, such as
       * when we're redirecting between nouns rather than verbs.
       * @var {Boolean} adventurejs.Input#allow_circular_verb
       * @default false
       * @todo Should this also be an Array and sync indexes with verb_chain?
       */
      this.allow_circular_verb = false;

      /**
       * A method for passing arbitrary properties along with a verb redirect.
       * For ex: close_with may redirect to lock_with, and we may want to pass
       * a param such as "autoClose=true".
       * @var {Object} adventurejs.Input#verb_params
       * @default {}
       */
      this.verb_params = {};

      /**
       * During parsing we replace substrings with other substrings.
       * Here we keep a record of the source substrings.
       * @var {Object} adventurejs.Input#replacements
       * @default {}
       */
      this.replacements = {};

      /**
       * If player inputs quoted strings, we save them here. Ex:
       * 'type "foo" on typewriter', we save "foo" as an unparsed string.
       * @var {Array} adventurejs.Input#strings
       * @default []
       */
      this.strings = [];

      /**
       * During parse we perform regex to join verb phrases.
       * For example, if player inputs
       * "write name on paper with pencil",
       * joinVerbNounPrepNounPrepNouns() would find and join
       * "write_on_with paper pencil".
       * When we do a replacement, we're saving the original
       * string and the original verb. Here we save the fomr
       * of the verb phrase, ie verb_noun_prep_noun_prep_noun,
       * for use in verb logic.
       * @var {Array} adventurejs.Input#joint
       * @default []
       */
      this.joint = "";

      // on startup we want to establish a populated turn before the first turn
      // we're probably just setting it to "wait"
      if (params && params.verb) {
        this.input = params.verb;
        this.found_word = params.verb;
        this.input_verb = params.verb;
        this.parsed_input = params.verb;
        this.unparsed_input = params.verb;
        this.setVerb(params.verb);
      }
    }

    /**
     * Getter function that returns the top level game object. Use <code class="property">this.game</code>.
     * @var {Getter} adventurejs.Input#game
     * @returns {adventurejs.Game}
     */
    get game() {
      return window[this.game_name] || false;
    }

    /**
     * Lets author append an arbitrary string to this turn's output.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#appendToOutput
     * @param {String} msg Arbitrary string to append to next print.
     * @returns {boolean}
     */
    appendToOutput(msg) {
      if ("string" !== typeof msg) return false;
      this.printer.append.push(msg);
      return true;
    }

    /**
     * Lets author override this turn's output.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#overrideOutput
     * @param {String} msg Arbitrary string to override next print.
     * @returns {boolean}
     */
    overrideOutput(msg) {
      if ("string" !== typeof msg) return false;
      this.printer.override.push(msg);
      return true;
    }

    /**
     * Lets author prepend an arbitrary string to this turn's output.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#prependToOutput
     * @param {String} msg Arbitrary string to prepend to next print.
     * @returns {boolean}
     */
    prependToOutput(msg) {
      if ("string" !== typeof msg) return false;
      this.printer.prepend.push(msg);
      return true;
    }

    /**
     * Get verb from the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#hasVerb
     * @param {int} index
     * @returns {Object|Boolean}
     */
    hasVerb(index) {
      var bool = false;
      if (!index) index = 1;
      if (this.verified_sentence["verb" + index]) {
        bool = true;
      }
      return bool;
    }

    /**
     * Get verb from the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getVerb
     * @param {int} index
     * @returns {Object|Boolean}
     */
    getVerb(index) {
      var verb = false;
      if (!index) index = 1;
      if (this.verified_sentence["verb" + index]) {
        verb = this.verified_sentence["verb" + index].verb;
      }
      return verb;
    }

    /**
     * Get dictionary verb from the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getDictionaryVerb
     * @param {int} index
     * @returns {Object|Boolean}
     */
    getDictionaryVerb(index) {
      var verb = false;
      if (!index) index = 1;
      if (this.verified_sentence["verb" + index]) {
        verb = this.verified_sentence["verb" + index].verb;
      }
      verb = this.game.getVerb(verb);
      return verb;
    }

    /**
     * Set the specified verb in the verified sentence.
     * We're only ever taking one verb, but provisioning
     * for more in the future in the case of structures
     * such as "tell person to go north".
     * @method adventurejs.Input#setVerb
     * @param {String} value
     */
    setVerb(index, value) {
      if (!index) index = 1;
      if (!this.verified_sentence["verb" + index]) {
        this.verified_sentence["verb" + index] = {};
      }
      this.verified_sentence["verb" + index].verb = value;
    }

    /**
     * Set the specified phrase in the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setPhrase
     * @param {int} index
     * @param {string} type
     * @param {string} value
     */
    setPhrase(index, phrase) {
      this.verified_sentence["phrase" + index] = A.clone.call(
        this.game,
        phrase,
      );
    }

    /**
     * Delete the specified phrase in the verified sentence
     * and renumber any higher numbered phrases.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#deletePhrase
     * @param {int} index
     */
    deletePhrase(index) {
      if (!this.verified_sentence["phrase" + index]) return;
      delete this.verified_sentence["phrase" + index];
      if (this.getPhraseCount() > index) {
        for (let i = index + 1; i <= this.getPhraseCount(); i++) {
          this.verified_sentence["phrase" + (i - 1)] =
            this.verified_sentence["phrase" + i];
          delete this.verified_sentence["phrase" + i];
        }
      }
      this.resetStructure();
      return true;
    }

    /**
     * Reset the verified sentence structure (after revising verified_sentence).
     * @memberof adventurejs.Input
     * @method adventurejs.Input#resetStructure
     */
    resetStructure(index) {
      this.verified_sentence_structure = "";
      if (this.verified_sentence.verb1?.verb) {
        this.verified_sentence_structure += "verb";
      }
      for (let i = 1; i < 4; i++) {
        let phrase = this.verified_sentence["phrase" + i];
        if (phrase && phrase.preposition)
          this.verified_sentence_structure += " preposition";
        if (phrase && phrase.noun) this.verified_sentence_structure += " noun";
      }
      return true;
    }

    /**
     * Get the specified phrase from the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getPhrase
     * @param {int} index
     * @returns {Object}
     */
    getPhrase(index) {
      var phrase = this.verified_sentence["phrase" + index];
      return phrase || {};
    }

    /**
     * Get a count of nouns.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getNounCount
     * @returns {int}
     */
    getNounCount() {
      var count = 0;
      for (var i = 1; i <= 3; i++) {
        if (
          this.verified_sentence["phrase" + i] &&
          (this.verified_sentence["phrase" + i].noun ||
            this.verified_sentence["phrase" + i].parsedNoun)
        ) {
          count++;
        }
      }
      return count;
    }

    /**
     * Does the specified phrase exist in the verified sentence?
     * @memberof adventurejs.Input
     * @method adventurejs.Input#hasPhrase
     * @param {int} index
     * @returns {Boolean}
     */
    hasPhrase(index) {
      if (this.verified_sentence["phrase" + index]) return true;
      return false;
    }

    /**
     * Try to get a noun string from the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getNoun
     * @param {int} index
     * @returns {String|Boolean}
     */
    getNoun(index) {
      return this.getInPhrase(index, "noun");
    }

    /**
     * Set a noun string from the verified sentence.
     * Be careful to avoid letting noun and parsedNoun
     * fall out of sync.
     * By contrast, setAsset() will set both noun and
     * parsedNoun.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setNoun
     * @param {int} index
     * @param {String} value
     * @returns {String|Boolean}
     */
    setNoun(index, value) {
      return this.setInPhrase(index, "noun", value);
    }

    /**
     * Try to get an exclusion string from the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getExclusion
     * @param {int} index
     * @returns {String|Boolean}
     */
    getExclusion(index) {
      return this.getInPhrase(index, "exclusion");
    }

    /**
     * Set an exclusion string in the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setExclusion
     * @param {int} index
     * @param {String} value
     * @returns {String|Boolean}
     */
    setExclusion(index, value) {
      return this.setInPhrase(index, "exclusion", value);
    }

    /**
     * Try to get an asset from the parsedNoun in the
     * specified phrase in the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getAsset
     * @param {int} index
     * @returns {Object|Boolean}
     */
    getAsset(index) {
      var asset = null;
      var parsedNoun = this.getInPhrase(index, "parsedNoun");

      // qualified_object_id is only available when a singular match is found
      //if(parsedNoun) asset = this.game.getAsset( parsedNoun.qualified_object_id );

      // object_id is available when multiple matches are found
      // it doesn't seem we should want multiple matches here,
      // but some verbs for example "take all keys but blue key"
      // result not only in multiple matches but in stacked input
      // @TODO reexamine this
      if (parsedNoun) asset = this.game.getAsset(parsedNoun.object_id);

      return asset;
    }

    /**
     * Set the asset in the specified phrase. Asset means
     * Asset-classed object, but we store here a ParsedNoun
     * which is its own classed object that includes metadata
     * about the Asset object.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setAsset
     * @param {Int} index
     * @param {Object} parsedNoun
     */
    setAsset(index, asset) {
      if (!this.verified_sentence["phrase" + index]) {
        this.verified_sentence["phrase" + index] = {};
      }
      this.verified_sentence["phrase" + index].parsedNoun =
        new adventurejs.ParsedNoun(asset);
      this.verified_sentence["phrase" + index].noun = asset.id;
    }

    /**
     * When player refers to a substance, some verbs will try
     * to identify a vessel containing that substance.
     * Save that vessel id here.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setVessel
     * @param {Int} index
     * @param {Object} asset
     */
    setVessel(index, asset) {
      if (!this.verified_sentence["phrase" + index]) {
        this.verified_sentence["phrase" + index] = {};
      }
      this.verified_sentence["phrase" + index].vessel = asset.id;
    }

    /**
     * When player refers to a substance, some verbs will try
     * to identify a vessel containing that substance.
     * Get that vessel id. Returns null if not found.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setVessel
     * @param {Int} index
     * @param {Object} asset
     */
    getVessel(index) {
      return this.getInPhrase(index, "vessel");
    }

    /**
     * Create a new phrase at the lowest available phrase number.
     * Assumed is always true.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setNewPhrase
     * @param {Object} params
     * @returns {Int}
     */
    setNewPhrase(params) {
      var index = 1;
      if (this.hasPhrase(1)) index = 2;
      if (this.hasPhrase(2)) index = 3;
      if (this.hasPhrase(3)) index = 4; // @TODO throw error
      this.verified_sentence["phrase" + index] = {};
      if (params.preposition) {
        this.verified_sentence_structure += " preposition";
        this.verified_sentence["phrase" + index].preposition =
          params.preposition;
      }
      if (params.asset) {
        this.verified_sentence_structure += " noun";
        this.verified_sentence["phrase" + index].parsedNoun =
          new adventurejs.ParsedNoun(params.asset);
        this.verified_sentence["phrase" + index].noun = params.asset.id;
      }
      this.verified_sentence["phrase" + index].assumed = true;
      return index;
    }

    /**
     * Get the number of phrases in the input.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getPhraseCount
     */
    getPhraseCount() {
      var index = 0;
      if (this.hasPhrase(1)) index = 1;
      if (this.hasPhrase(2)) index = 2;
      if (this.hasPhrase(3)) index = 3;
      // we don't handle 4 phrases yet, but maybe in future?
      return index;
    }

    /**
     * Try to get a preposition from the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getPreposition
     * @param {int} index
     * @returns {Object|Boolean}
     */
    getPreposition(index) {
      return this.getInPhrase(index, "preposition");
    }

    /**
     * Set verified preposition.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setPreposition
     * @param {int} index
     * @param {string} value
     */
    setPreposition(index, value) {
      return this.setInPhrase(index, "preposition", value);
    }

    /**
     * Try to get a direction from the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getDirection
     * @param {int} index
     * @returns {Object|Boolean}
     */
    getDirection(index) {
      return this.getInPhrase(index, "direction");
    }

    /**
     * Set verified direction.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setDirection
     * @param {int} index
     * @param {Object} value
     */
    setDirection(index, value) {
      return this.setInPhrase(index, "direction", value);
    }

    /**
     * Try to get a parsedNoun in the
     * specified phrase in the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getParsedNoun
     * @param {int} index
     * @returns {Object|Boolean}
     */
    getParsedNoun(index) {
      return this.getInPhrase(index, "parsedNoun");
    }

    /**
     * Set a parsedNoun in the
     * specified phrase in the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setParsedNoun
     * @param {int} index
     * @param {Object} parsedNoun
     */
    setParsedNoun(index, parsedNoun) {
      this.setInPhrase(index, "parsedNoun", parsedNoun);
    }

    /**
     * Set a parsedNoun in the
     * specified phrase in the verified sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setParsedNoun
     * @param {int} index
     * @param {Object} parsedNoun
     */
    setParsedNounMatchesQualified(index, value) {
      if (
        this.verified_sentence["phrase" + index] &&
        this.verified_sentence["phrase" + index].parsedNoun
      ) {
        this.verified_sentence["phrase" + index].parsedNoun.matches.qualified =
          value;
      }
    }

    /**
     * Ask if verified noun has been set assumed.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getAssumed
     * @param {int} index
     * @returns {Object|Boolean}
     */
    getAssumed(index) {
      return this.getInPhrase(index, "assumed");
    }

    /**
     * Set verified noun assumed.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setAssumed
     * @param {int} index
     * @returns {Object|Boolean}
     */
    setAssumed(index, value) {
      if (typeof value === "undefined") value = true;
      this.setInPhrase(index, "assumed", value);
    }

    /**
     * Swap two phrases
     * @memberof adventurejs.Input
     * @method adventurejs.Input#swapPhrases
     * @param {int} index1
     * @param {int} index2
     * @returns {Object|Boolean}
     */
    swapPhrases(index1, index2) {
      if (!this.getPhrase(index1)) this[`phrase${index1}`] = {};
      if (!this.getPhrase(index2)) this[`phrase${index2}`] = {};
      var swap1 = A.clone.call(this.game, this.getPhrase(index1));
      var swap2 = A.clone.call(this.game, this.getPhrase(index2));
      this.setPhrase(index1, swap2);
      this.setPhrase(index2, swap1);
    }

    /**
     * Swap two nouns
     * @memberof adventurejs.Input
     * @method adventurejs.Input#swapNouns
     * @param {int} index1
     * @param {int} index2
     * @returns {Object|Boolean}
     */
    swapNouns(index1, index2) {
      var noun1 = String(this.getInPhrase(index1, "noun"));
      var noun2 = String(this.getInPhrase(index2, "noun"));
      var parsedNoun1 = A.clone.call(
        this.game,
        this.getInPhrase(index1, "parsedNoun"),
      );
      var parsedNoun2 = A.clone.call(
        this.game,
        this.getInPhrase(index2, "parsedNoun"),
      );
      this.setInPhrase(index1, "noun", noun2);
      this.setInPhrase(index2, "noun", noun1);
      this.setInPhrase(index1, "parsedNoun", parsedNoun2);
      this.setInPhrase(index2, "parsedNoun", parsedNoun1);
    }

    /**
     * Swap two prepositions
     * @memberof adventurejs.Input
     * @method adventurejs.Input#swapPrepositions
     * @param {int} index1
     * @param {int} index2
     * @returns {Object|Boolean}
     */
    swapPrepositions(index1, index2) {
      var swap1 = String(this.getPreposition(index1));
      var swap2 = String(this.getPreposition(index2));
      this.setPreposition(index1, swap2);
      this.setPreposition(index2, swap1);
    }

    /**
     * Try to get a property from the specified phrase.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getInPhrase
     * @param {String} position
     * @param {String} property
     * @returns {*}
     */
    getInPhrase(index, property) {
      if (
        this.verified_sentence["phrase" + index] &&
        this.verified_sentence["phrase" + index][property]
      ) {
        return this.verified_sentence["phrase" + index][property];
      }
      return null;
    }

    /**
     * Try to get a property from the specified phrase.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setInPhrase
     * @param {String} position
     * @param {String} property
     * @returns {*}
     */
    setInPhrase(index, property, value) {
      if (!this.verified_sentence["phrase" + index]) {
        this.verified_sentence["phrase" + index] = {};
      }
      this.verified_sentence["phrase" + index][property] = value;
    }

    /**
     * Does the input object have verified input?
     * @memberof adventurejs.Input
     * @method adventurejs.Input#hasInput
     * @returns {Boolean}
     */
    hasInput() {
      var bool = Object.keys(this.verified_sentence).length ? true : false;
      return bool;
    }

    /**
     * Set a soft prompt for next turn.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setSoftPrompt
     * @param {Object} params
     */
    setSoftPrompt(params) {
      this.soft_prompt.enabled = true;
      for (var key in params) {
        this.soft_prompt[key] = params[key];
      }
    }

    /**
     * Indicate that this turn parsed one word, which
     * may satisfy a disambiguation prompt.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setOneWord
     * @param {Object} params
     */
    setOneWord(params) {
      console.warn("setOneWord", params);
      this.parsed_word.enabled = true;
      for (var key in params) {
        this.parsed_word[key] = params[key];
      }
    }

    /**
     * Indicate that this turn parsed one word, which
     * may satisfy a disambiguation prompt.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setDisambiguate
     * @param {Object} params
     */
    setDisambiguate(params) {
      this.disambiguate.enabled = true;
      for (var key in params) {
        this.disambiguate[key] = params[key];
      }
    }

    /**
     * Returns the parsed sentence structure.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getStructure
     * @TODO replace with verified sentence structure
     */
    getStructure() {
      return this.verified_sentence_structure;
    }

    /**
     * Set the parsed sentence structure.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#setStructure
     * @TODO replace with verified sentence structure
     */
    setStructure(value) {
      this.verified_sentence_structure = value;
    }

    /**
     * Returns the parsed sentence structure.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#getStructure
     * @param {String} value
     * @returns {boolean}
     * @TODO replace with verified sentence structure
     */
    hasStructure(value) {
      return this.verified_sentence_structure === value;
    }

    /**
     * Push a parsed word to parsed_sentence.
     * @memberof adventurejs.Input
     * @method adventurejs.Input#pushParsedWord
     * @param {Object} params
     */
    pushParsedWord(params) {
      this.parsed_sentence.push(params);
    }

    // TEMPORARY ----------

    /**
     * A bridge between the old and new input systems.
     * @var {Getter|Setter} adventurejs.Input#preposition1
     */
    get preposition1() {
      return this.getInPhrase(1, "preposition");
    }
    set preposition1(value) {
      this.setInPhrase(1, "preposition", value);
    }

    /**
     * A temporary bridge between the old and new input systems.
     * @var {Getter|Setter} adventurejs.Input#preposition2
     */
    get preposition2() {
      return this.getInPhrase(2, "preposition");
    }
    set preposition2(value) {
      this.setInPhrase(2, "preposition", value);
    }

    /**
     * A temporary bridge between the old and new input systems.
     * @var {Getter|Setter} adventurejs.Input#preposition3
     */
    get preposition3() {
      return this.getInPhrase(3, "preposition");
    }
    set preposition3(value) {
      this.setInPhrase(3, "preposition", value);
    }

    /**
     * A bridge between the old and new input systems.
     * A parsed noun object for the first noun found in player input.
     * @var {Getter|Setter} adventurejs.Input#parsedNoun1
     */
    get parsedNoun1() {
      return this.getInPhrase(1, "parsedNoun");
    }
    set parsedNoun1(value) {
      this.setInPhrase(1, "parsedNoun", value);
    }
    /**
     * A bridge between the old and new input systems.
     * @var {Getter|Setter} adventurejs.Input#parsedNoun2
     */
    get parsedNoun2() {
      return this.getInPhrase(2, "parsedNoun");
    }
    set parsedNoun2(value) {
      this.setInPhrase(2, "parsedNoun", value);
    }

    /**
     * A bridge between the old and new input systems.
     * @var {Getter|Setter} adventurejs.Input#parsedNoun3
     */
    get parsedNoun3() {
      return this.getInPhrase(3, "parsedNoun");
    }
    set parsedNoun3(value) {
      this.setInPhrase(3, "parsedNoun", value);
    }

    /**
     * A bridge between the old and new input systems.
     * Player did not input a noun, but we extrapolated one from context.
     * @var {Getter|Setter} adventurejs.Input#parsedNoun1_is_assumed
     */
    get parsedNoun1_is_assumed() {
      return this.getInPhrase(1, "assumed");
    }
    set parsedNoun1_is_assumed(value) {
      this.setInPhrase(1, "assumed", value);
    }

    /**
     * A bridge between the old and new input systems.
     * Player did not input a noun, but we extrapolated one from context.
     * @var {Getter|Setter} adventurejs.Input#parsedNoun2_is_assumed
     */
    get parsedNoun2_is_assumed() {
      return this.getInPhrase(2, "assumed");
    }
    set parsedNoun2_is_assumed(value) {
      this.setInPhrase(2, "assumed", value);
    }

    /**
     * A bridge between the old and new input systems.
     * Player did not input a noun, but we extrapolated one from context.
     * @var {Getter|Setter} adventurejs.Input#parsedNoun3_is_assumed
     */
    get parsedNoun3_is_assumed() {
      return this.getInPhrase(3, "assumed");
    }
    set parsedNoun3_is_assumed(value) {
      this.setInPhrase(3, "assumed", value);
    }

    /**
     * A shortcut method for setting a number of properties on the instance.
     * @memberOf adventurejs.Verb
     * @method adventurejs.Input#set
     * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
     * @returns {adventurejs.Input} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(props) {
      return A.deepSet.call(this.game, props, this);
    }
  }

  adventurejs.Input = Input;
})();

// Parser.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.Parser
   * @ajsnavheading FrameworkReference
   * @param {Game} game A reference to the game instance.
   * @summary Interprets player input.
   * @classdesc
   * <p>
   * The <strong>Parser</strong> class interprets
   * player input. In short, it takes a string, sanitizes it
   * of undesirable characters, performs several operations to
   * strip away extraneous grammar such as definite/indefinite
   * articles, performs a number of
   * regular expression searches, compares the input against
   * different verb/noun patterns stored in a lookup table,
   * all to reduce input to a simple
   * format such as 'verb noun noun'. Parser can accept
   * one verb and up to three nouns. Clauses joined by 'and'
   * or 'then' are split into multiple inputs and queued
   * for serial handling.</p>
   * <p>
   * This is an internal class
   * that authors should not need to construct, though there are
   * methods to allow authors to inject their own custom
   * parser code. See
   * <a href="/doc/Extend_WriteParsers.html">Write Parsers</a>
   * for more info.
   * </p>
   * <p>Here are some examples of inputs and how they would be parsed.
   * </p>
   * <h3 class="examples">Examples:</h3>
   * <code class="input">
   * <ul>
   * <li>unlock the icy door with the glass key<br>
   * <strong>parses to &nbsp;=&gt;&nbsp; </strong> unlock icy_door glass_key</li>
   * <li>ask Mr. Giles about Mrs. Beasley<br>
   * <strong>parses to &nbsp;=&gt;&nbsp; </strong> ask_about mr_giles mrs_beasley</li>
   * <li>climb over to branch<br>
   * <strong>parses to &nbsp;=&gt;&nbsp; </strong> climb_to branch</li>
   * <li>swing from the tree to the cliff on the vine <br>
   * <strong>parses to &nbsp;=&gt;&nbsp; </strong> swing_from_to_on tree cliff vine</li>
   * <li>look at the zebra through the binoculars<br>
   * <strong>parses to &nbsp;=&gt;&nbsp; </strong> lookAt_through zebra binoculars</li>
   * <li>unlock door then open door then go north<br>
   * <strong>parses to three inputs &nbsp;=&gt;&nbsp; </strong> unlock door / open door / go north</li>
   * </ul>
   * </code>
   */
  class Parser {
    constructor(game) {
      /**
       * A reference back to the main {@link adventurejs.Game|Game} object.
       * @var {Object} adventurejs.Parser#game
       * @default {}
       */
      this.game = game;

      /**
       * A reference back to the main Game {@link adventurejs.Dictionary|Dictionary} object.
       * @var {Object} adventurejs.Parser#dictionary
       * @default {}
       */
      this.dictionary = game.dictionary;

      /**
       * A reference back to the main Game {@link adventurejs.Display|Display} object.
       * @var {Object} adventurejs.Parser#display
       * @default {}
       */
      this.display = game.display;

      /**
       * Used to store custom parser code that might be written by authors.
       * @var {Object} adventurejs.Parser#custom_parsers
       * @default {}
       */
      this.custom_parsers = {};

      /**
       * If custom parsers have been written by author,
       * this provides a way to turn them on/off, something you might
       * want to do depending on context.
       * @var {Object} adventurejs.Parser#custom_parsers_enabled
       * @default {}
       */
      this.custom_parsers_enabled = {};

      /**
       * Used to store a copy of player input when player hits enter
       * and before parsing.
       * @var {String} adventurejs.Parser#input_string
       * @default ""
       */
      this.input_string = "";

      // this.game.reactor.addEventListener('inputEnter', function(e){
      //   var msg = "Parser received Event > inputEnter: " + this.game.parser.input_string;
      //   this.game.log( "log", "high", msg );
      //   this.game.parser.parseInput( this.game.parser.input_string );
      // });

      /**
       * Stores all player input. Used for Undo and Again,
       * and in letting player use arrow keys to recall prior
       * turns' input, as in a terminal application.
       * @var {Array} adventurejs.Parser#input_history
       * @default [{input:"wait"}]
       */
      this.input_history = [];

      // push an initial turn to input history so we have something to refer back to on the first turn
      this.input_history.push(
        new adventurejs.Input({ game_name: this.game.game_name, verb: "wait" })
      );

      /**
       * When player uses arrow keys to navigate between old inputs,
       * this stores player's position in the history array.
       * @var {int} adventurejs.Parser#input_history_index
       */
      this.input_history_index = 0;

      /**
       * When player uses conjuctive clauses joined by 'and' or 'then'
       * we split the input into separate inputs and queue them up to
       * handle in sequence. Queued inputs are saved here.
       * @var {Array} adventurejs.Parser#input_queue
       * @default []
       */
      this.input_queue = [];

      /**
       * Unused?
       * @var {Object} adventurejs.Parser#input_object
       * @default {}
       * @todo Is this irrelevant?
       */
      this.input_object = {};

      /**
       * Save (this.input_queue.length > 0) during parse,
       * because at some point later in the parse we shift input_queue,
       * but later than that we still need to know whether we're queued.
       * @var {Boolean} adventurejs.Parser#is_input_queued
       * @default false
       */
      this.is_input_queued = false;
    }

    /**
     * Track input for display, used to present player
     * input from previous turns in the input field,
     * like a terminal does.
     * @memberOf adventurejs.Parser
     * @method adventurejs.Parser#getOlderInput
     */
    getOlderInput() {
      if ("undefined" === typeof this.input_history_index) return "";

      if (-1 === this.input_history_index) {
        this.input_history_index = 0;
      } else if (this.input_history_index < this.input_history.length - 2) {
        this.input_history_index++;
      }

      return this.input_history[this.input_history_index].unparsed_input;
    }

    /**
     * Listen for arrowDown key, used to present player input
     * from previous turns in the input field, as in a terminal.
     * @memberOf adventurejs.Parser
     * @method adventurejs.Parser#getNewerInput
     */
    getNewerInput() {
      if (this.input_history_index > 0) {
        this.input_history_index--;
      }

      if (
        "undefined" !== typeof this.input_history[this.input_history_index] &&
        "undefined" !==
          typeof this.input_history[this.input_history_index].unparsed_input
      ) {
        return this.input_history[this.input_history_index].unparsed_input;
      }

      return "";
    }

    /**
     * Method to get whether we're parsing through a queue of inputs.
     * Possible redundant with is_input_queued?
     * @memberOf adventurejs.Parser
     * @method adventurejs.Parser#isParsingMultiple
     * @todo Is this and is_input_queued duplicative?
     */
    isParsingMultiple() {
      return 0 < this.input_queue.length || this.is_input_queued;
    }

    /**
     * Respond to blank input from player with
     * {@link adventurejs.Settings#if_input_is_empty_print_this|settings.if_input_is_empty_print_this}.
     * @memberOf adventurejs.Parser
     * @method adventurejs.Parser#parseNoInput
     */
    parseNoInput() {
      // settings.if_input_is_empty_print_this can return string, array, or function

      if (this.game.settings.if_input_is_empty_print_room_description) {
        this.game.printCurrentRoom();
        return;
      }

      this.game.print(
        A.getSAF.call(
          this.game,
          this.game.settings.if_input_is_empty_print_this
        )
      );

      return;
    }

    /**
     * Take input and return a standardized "unparsed" message.
     * {@link adventurejs.Settings#if_parser_has_no_response_print_this|settings.if_parser_has_no_response_print_this}.
     * @memberOf adventurejs.Parser
     * @method adventurejs.Parser#getUnparsedMessage
     */
    getUnparsedMessage(input) {
      this.game.debug(
        `F1158 | Parser.js | print settings.if_parser_has_no_response_print_this `
      );
      var msg = A.getSAF.call(
        this.game,
        this.game.settings.if_parser_has_no_response_print_this
      );
      var regex = /\$\((.*?)\)/g;
      return msg.replace(regex, input);
    }

    /**
     * Get input from last turn.
     * @memberOf adventurejs.Parser
     * @method adventurejs.Parser#getLastInput
     * @returns {String}
     */
    getLastInput() {
      return this.input_history[1].unparsed_input;
    }

    /**
     * Get a count of input history.
     * @memberOf adventurejs.Parser
     * @method adventurejs.Parser#getInputCount
     * @returns {int}
     */
    getInputCount() {
      return this.input_history.length;
    }

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     * @memberOf adventurejs.Parser
     * @method adventurejs.Parser#set
     * @param {Object} props A generic object containing properties to copy to the Object instance.
     * @returns {adventurejs.Parser} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(props) {
      if (props != null) {
        for (var n in props) {
          this[n] = props[n];
        }
      }
      return this;
    }
  }
  adventurejs.Parser = Parser;
})();

// createCustomParser.js
(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Install custom parser(s) defined by author.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#createCustomParser
   * @param {Object} parsers An object containing one or more parser functions.
   */
  p.createCustomParser = function Parser_createCustomParser(parsers) {
    var keys = Object.keys(parsers);
    for (var i = 0; i < keys.length; i++) {
      var parser_name = keys[i];
      var msg = "";
      if ("undefined" !== typeof this.custom_parsers[parser_name]) {
        msg =
          "createCustomParser received more than one parser named " +
          parser_name +
          ". ";
        console.warn(msg);
        return false;
      }
      //console.warn( parsers[ parser_name ], typeof parsers[ parser_name ]);
      if ("function" !== typeof parsers[parser_name]) {
        msg =
          "createCustomParser received something that is not a function for parser " +
          parser_name +
          ". ";
        console.warn(msg);
        return false;
      }
      this.custom_parsers[parser_name] = parsers[parser_name];
      this.custom_parsers_enabled[parser_name] = false;
      msg = "createCustomParser.js > registered " + parser_name + ". ";
      //console.log( msg );
      this.game.log("log", "high", msg, "Parser");
    }
    return;
  };
})();

// disableCustomParser.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Disable a custom parser(s) created by author.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#disableCustomParser
   * @param {String} parser The name of a previously created parser that has been stored at game.parser.custom_parsers[name].
   */
   p.disableCustomParser = function Parser_disableCustomParser( parser )
  {
    if( "function" !== typeof this.custom_parsers[ parser ] )
    {
      var msg = "disableCustomParser received invalid parser "
        + parser
        + ". ";
      console.warn( msg );
      return false;
    }
    this.custom_parsers_enabled[ parser ] = false;
    return this;
  }

}());

// enableCustomParser.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Enable a custom parser(s) created by author.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#enableCustomParser
   * @param {String} parser The name of a previously created parser that has been stored at game.parser.custom_parsers[name].
   */
   p.enableCustomParser = function Parser_enableCustomParser( parser )
  {
    if( "function" !== typeof this.custom_parsers[ parser ] )
    {
      var msg = "enableCustomParser received invalid parser "
        + parser
        + ". ";
      console.warn( msg );
      return false;
    }
    this.custom_parsers_enabled[ parser ] = true;
    return;
  }

}());

// findMatchIn.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Used by noun disambiguation in handleWord.js,
   * typically in cases where user has been asked a question like
   * "Which thing do you want, 1) A or 2) B ?",
   * to compare this turn's input against last turn's input.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#findMatchIn
   * @param {Object} newQualified
   * @param {Object} oldQualified
   * @returns {Object} foundMatch
   */
  p.findMatchIn = function Parser_findMatchIn(newQualified, oldQualified) {
    if (!newQualified || !oldQualified) return false;
    var foundMatch;
    for (var i = 0; i < newQualified.length; i++) {
      // 2023.04.08 in cases of bowl:in:water we only want to compare "bowl"
      var nq = newQualified[i].split(":")[0];

      for (var j = 0; j < oldQualified.length; j++) {
        // 2023.04.08 in cases of bowl:in:water we only want to compare "bowl"
        var oq = oldQualified[j].split(":")[0];

        if (nq === oq) {
          foundMatch = nq;
          break;
        }
        if ("undefined" !== typeof foundMatch) break;
      }
    }
    return foundMatch;
  };
})();

// handleSentence.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Handle multi-word input.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#handleSentence
   */
  p.handleSentence = function Parser_handleSentence() {
    this.game.log("log", "high", "handleSentence.js > BEGIN.", "Parser");
    var this_turn = this.input_history[0];
    var last_turn = this.input_history[1];
    var parsed_verb_name = "",
      dictionary_verb = null,
      dictionary_verb_name = "",
      nouns = [],
      exclusions = [],
      prepositions = [],
      parsedNouns = [],
      count = { phrase: 0 },
      msg = "";

    // ----------
    // parsed one word
    // ----------

    if (this_turn.parsed_word.enabled) {
      // we've arrived here via handleWord and
      // we're probably amending last turn's input
      this_turn.verified_sentence = A.clone.call(
        this.game,
        last_turn.verified_sentence,
      );

      // get verb + nouns from last turn prompt,
      // which may differ from last turn's input
      if (this_turn.parsed_word.verb) {
        this_turn.setVerb(1, this_turn.parsed_word.verb);
      }
      for (let i = 1; i <= 3; i++) {
        if (this_turn.parsed_word["noun" + i]) {
          this_turn.setNoun(i, this_turn.parsed_word["noun" + i]);
        }
        if (this_turn.parsed_word["preposition" + i]) {
          this_turn.setPreposition(i, this_turn.parsed_word["preposition" + i]);
        }
      }
    } // parsed_word

    // ----------
    // get verb and nouns
    // ----------

    if (this_turn.hasInput()) {
      //console.warn('this_turn.hasInput');
      // we've got fresh input from parseInput
      if (this_turn.hasVerb()) {
        parsed_verb_name = this_turn.getVerb();
      }

      for (let i = 1; i <= 3; i++) {
        if (this_turn.hasPhrase(i)) {
          prepositions[i] = this_turn.getPreposition(i);
          nouns[i] = this_turn.getNoun(i);
          exclusions[i] = this_turn.getExclusion(i);
        }
      }
    } else {
      // we shouldn't arrive here but may need an error message
      this.game.debug(`F1207 | handleSentence.js | didn't receive words `);
      msg += this.getUnparsedMessage(this_turn.input);
      this.game.print(msg, this_turn.output_class);
    }

    // ----------
    // oops
    // ----------

    if ("oops " === this_turn.input.substring(0, 5)) {
      this.game.printInput(this_turn.input);
      this.game.dictionary.doVerb("oops");
      return false;
    }

    // ----------
    // verify verb
    // ----------

    if (!parsed_verb_name || !this.dictionary.verbs[parsed_verb_name]) {
      let err = `handleSentence.js > Verb not found. This may happen if a compound phrase is improperly found. Original input: ${this_turn.input} Parsed input: ${this_turn.parsed_input}`;
      this.game.log("warn", "high", err, "Parser");

      this.game.debug(
        `F1721 | handleSentence.js | verb not found. Check the console for more info. `,
      );
      msg += this.getUnparsedMessage(this_turn.input);
      this.game.print(msg, this_turn.output_class);
      return false;
    }

    // if verb.let_verb_handle_remaining_input, bypass handleSentence
    // originally used for oops and left in for future cases

    if (
      this.dictionary.verbs[parsed_verb_name].let_verb_handle_remaining_input
    ) {
      this.dictionary.doVerb(parsed_verb_name);
      return false;
    }

    // ----------
    // qualify verb
    // ----------

    // Check verb against circumstances that prevent its use,
    // such as if player is constrained, lying on the floor, etc.

    dictionary_verb = this.qualifyParsedVerb({
      parsed_verb_name: parsed_verb_name,
    });
    // If qualifyParsedVerb returned false, then it already
    // printed an error msg to the player, so we can just...
    if (!dictionary_verb) return false;

    // ----------
    // get phrase count
    // ----------

    for (const key in this_turn.verified_sentence) {
      if (key.startsWith("phrase")) {
        count.phrase++;
      }
    }
    //console.warn("count.phrase", count.phrase);

    // ----------
    // for each phrase
    // ----------

    for (let n = 1; n <= count.phrase; n++) {
      //var n = parseInt(key.replace("phrase", ""), 10);
      var phrase = this_turn.verified_sentence[`phrase${n}`];
      var noun = phrase.noun;
      var preposition = phrase.preposition;
      var exclusion = phrase.exclusion;

      this.game.log(
        "log",
        "high",
        `handleSentence.js > handle phrase ${n}`,
        "Parser",
      );

      // this shouldn't happen
      if (!noun && !preposition) {
        this.game.debug(
          `F1034 | handleSentence.js | ${dictionary_verb.name} didn't receive a noun or preposition`,
        );
        msg += `How did $(we) want to ${this_turn.input}? `;
        this.game.print(msg, this_turn.output_class);
        return false;
      }

      // unsupported noun? ----------

      if (noun && !dictionary_verb[`phrase${n}`].accepts_noun) {
        this.game.debug(
          `F1036 | handleSentence.js | ${dictionary_verb.name} received a noun it can't handle`,
        );
        msg += this.getUnparsedMessage(this_turn.input);
        this.game.print(msg, this_turn.output_class);
        return false;
      }

      // unsupported preposition without noun? ----------

      if (
        preposition &&
        !noun &&
        !dictionary_verb[`phrase${n}`].accepts_preposition_without_noun
      ) {
        this.game.debug(
          `F1033 | handleSentence.js | ${dictionary_verb.name} received preposition without noun, soft prompt noun${n}`,
        );
        msg += `What would $(we) like to ${this_turn.input}? `;
        this_turn.setSoftPrompt({
          [`noun${n}`]: true,
          verb: this_turn.input_verb,
        });
        this.game.print(msg, this_turn.output_class);
        return false;
      }

      // unsupported noun without preposition? ----------

      if (
        noun &&
        !preposition &&
        dictionary_verb[`phrase${n}`].requires_preposition
      ) {
        this.game.debug(
          `F1041 | handleSentence.js | ${dictionary_verb.name} received noun without preposition, soft prompt preposition${n}`,
        );
        //msg += `How did $(we) want to ${this_turn.input_verb} ${phrase.noun}? `;
        switch (n) {
          case 1:
            msg += `Where in relation to ${
              this.game.getAsset(parsedNouns[1].object_id).articlename
            } did $(we) want to ${dictionary_verb.prettyname}? `;
            break;
          case 2:
            msg += `Where in relation to ${
              this.game.getAsset(parsedNouns[2].object_id).articlename
            } did $(we) want to ${dictionary_verb.prettyname} ${
              this.game.getAsset(parsedNouns[1].object_id).articlename
            }? `;
            break;
          case 3:
            msg += `That seems to be missing a preposition. Can $(we) try phrasing that another way? `;
            break;
        }

        this_turn.setSoftPrompt({
          [`preposition${n}`]: true,
          verb: this_turn.input_verb,
        });
        this.game.print(msg, this_turn.output_class);
        return false;
      }

      // unsupported preposition? ----------

      if (
        preposition &&
        dictionary_verb[`phrase${n}`].accepts_these_prepositions.length &&
        -1 ===
          dictionary_verb[`phrase${n}`].accepts_these_prepositions.indexOf(
            preposition,
          )
      ) {
        this.game.debug(
          `F1222 | handleSentence.js | ${
            dictionary_verb.name
          }.phrase${n}.accepts_these_prepositions ${dictionary_verb[
            `phrase${n}`
          ].accepts_these_prepositions.toString()}`,
        );
        msg += `<em class='unparsed'>${A.propercase(preposition)} ${
          noun ? noun : ""
        }</em> doesn't seem to work here. `;
        this.game.print(msg, this_turn.output_class);
        return false;
      }

      // noun ----------

      if (noun) {
        // plural ----------

        // "this and that" is parsed as "this&that"
        let split_noun = noun.split("&");

        // "all keys" might be parsed as "key=keya,keyb,keyc"
        // we deliberately do not handle that here as
        // it conflicts with a later disambiguation handler

        let noun_is_plural = "all" === noun || split_noun.length > 1;

        if (
          noun_is_plural &&
          !dictionary_verb[`phrase${n}`].accepts_plural_noun
        ) {
          this.game.debug(
            `F1032 | handleSentence.js | ${dictionary_verb.name}.phrase${n}.accepts_plural_noun is false`,
          );
          msg += `$(We) can't ${dictionary_verb.prettyname} more than one thing at a time. `;
          this.game.print(msg, this_turn.output_class);
          return false;
        }

        // Split noun string and queue verb-noun inputs for each item
        if (split_noun.length > 1) {
          for (let i = 1; i < split_noun.length; i++) {
            this.input_queue.push({
              input: this_turn.parsed_input.replace(noun, split_noun[i]),
              printInput: false,
            });
          }
          noun = split_noun[0];
        } // plural

        // write a parsedNoun back to the phrase
        phrase.parsedNoun = this.parseNoun(noun);
      } // noun

      // parsedNoun empty? ----------

      if (phrase.parsedNoun && !phrase.parsedNoun.matches.all.length) {
        this.game.log(
          "warn",
          "high",
          [
            "handleSentence.js > input: " +
              this_turn.input +
              ", parsedNouns[1]: ",
            parsedNouns[1],
          ],
          "Parser",
        );

        // save record for "oops"
        this_turn.unknown_word = noun;

        this.game.debug(
          `F1035 | handleSentence.js | ${noun} isn't recognized `,
        );
        msg += this.getUnparsedMessage(phrase.parsedNoun.deserialized_input);
        this.game.print(msg, this_turn.output_class);
        return false;
      } // parsedNoun
      this.game.log(
        "log",
        "medium",
        [`handleSentence.js > phrase${n}.parsedNoun:`, phrase.parsedNoun],
        "Parser",
      );

      // in means on? ----------

      // Replace 'in' with 'on' where applicable such as 'sit in chair'
      if (phrase.parsedNoun && !dictionary_verb[`phrase${n}`].accepts_noun) {
        this.game.debug(
          `F1036 | handleSentence.js | ${dictionary_verb.name} received a noun it can't handle`,
        );
        msg += this.getUnparsedMessage(this_turn.input);
        this.game.print(msg, this_turn.output_class);
        return false;
      }
      if (
        phrase.parsedNoun &&
        "in" === preposition &&
        this.game.getAsset(phrase.parsedNoun.object_id).quirks.in_means_on &&
        dictionary_verb.in_can_mean_on
      ) {
        this_turn.setInPhrase(n, "preposition", "on");
      }

      // exclusion (aka but) ----------

      // examples of exclusions:
      //  "take all but sword"
      //  "take all gems but green gem"
      //  "take all gems but green gem and blue gem"

      if (exclusion && "string" === typeof exclusion) {
        var exclusion_split = exclusion.split("&");

        for (let x = 0; x < exclusion_split.length; x++) {
          var excluded_noun = exclusion_split[x];
          var excluded_parsed_noun = this.parseNoun(excluded_noun);

          this.game.log(
            "log",
            "medium",
            ["handleSentence.js > Exclude:", excluded_parsed_noun],
            "Parser",
          );

          if (excluded_parsed_noun) {
            for (let i = 0; i < excluded_parsed_noun.matches.all.length; i++) {
              let excluded_id = excluded_parsed_noun.matches.all[i];
              // remove excluded_id from parsedNoun.matches.all
              phrase.parsedNoun.matches.all.splice(
                phrase.parsedNoun.matches.all.indexOf(excluded_id),
                1,
              );
              // remove excluded_id from parsedNoun.matches.qualified
              phrase.parsedNoun.matches.qualified.splice(
                phrase.parsedNoun.matches.qualified.indexOf(excluded_id),
                1,
              );
              // remove excluded_id from parsedNoun.matches.unambiguous
              if (phrase.parsedNoun.matches.unambiguous === excluded_id)
                phrase.parsedNoun.matches.unambiguous = "";
            } // for excluded_parsed_noun.matches.all
          } // excluded_parsed_noun
        } // for exclusion_split

        this.game.log(
          "log",
          "medium",
          [
            `handleSentence.js > phrase${n}.parsedNoun minus exclusions: `,
            phrase.parsedNoun,
          ],
          "Parser",
        );
      } // exclusion

      // exclude from prior

      if (n > 1) {
        let first_phrase = this_turn.getPhrase(1);
        let last_split_noun = [];
        last_split_noun = first_phrase.noun && first_phrase.noun.split("&");
        let last_noun_is_plural =
          first_phrase.noun === "all" || last_split_noun.length > 1;
        let exclude_from_plural =
          dictionary_verb[`phrase${n}`].not_in_prior_plural;
        if (last_noun_is_plural && exclude_from_plural) {
          // was there an unambiguous match for this?
          if (phrase.parsedNoun.matches.unambiguous) {
            // remove unambiguous from prior noun's matches
            let excluded_id = phrase.parsedNoun.matches.unambiguous;
            let allindex =
              first_phrase.parsedNoun.matches.all.indexOf(excluded_id);
            let qualindex =
              first_phrase.parsedNoun.matches.qualified.indexOf(excluded_id);
            // remove excluded_id from parsedNoun.matches.all
            first_phrase.parsedNoun.matches.all.splice(allindex, 1);
            // remove excluded_id from parsedNoun.matches.qualified
            first_phrase.parsedNoun.matches.qualified.splice(qualindex, 1);
            // remove excluded_id from parsedNoun.matches.unambiguous
            if (first_phrase.parsedNoun.matches.unambiguous === excluded_id)
              first_phrase.parsedNoun.matches.unambiguous = "";
            if (allindex > -1 || qualindex > -1) {
              // we might need to re-qualify the last noun
              if (first_phrase.parsedNoun) {
                first_phrase.parsedNoun = this.qualifyParsedNoun({
                  parsedNoun: first_phrase.parsedNoun,
                  parsedVerb: dictionary_verb.name,
                  nounIndex: n - 1,
                });
                // If qualifyParsedNoun returned false, then it already
                // printed an error msg to the player, so we can just...
                if (!phrase.parsedNoun) return false;
              }
            }
          }
        }

        // remove iobj from dobj collection ----------
        // @TODO reexamine - this seems like it should be caught in prior block
        if (
          phrase.parsedNoun &&
          phrase.parsedNoun.object_id &&
          first_phrase.parsedNoun.object_id &&
          first_phrase.parsedNoun.matches.qualified.length > 1
        ) {
          for (
            var i = first_phrase.parsedNoun.matches.qualified.length - 1;
            i > -1;
            i--
          ) {
            if (
              phrase.parsedNoun.qualified_object_id ===
              first_phrase.parsedNoun.matches.qualified[i]
            ) {
              first_phrase.parsedNoun.matches.qualified.splice(i, 1);
            }
          }
        } // remove iobj from dobj collection
      } // n>1 / exclude from prior

      // qualify noun ----------

      if (phrase.parsedNoun) {
        phrase.parsedNoun = this.qualifyParsedNoun({
          parsedNoun: phrase.parsedNoun,
          parsedVerb: dictionary_verb.name,
          nounIndex: n,
        });
        // If qualifyParsedNoun returned false, then it already
        // printed an error msg to the player, so we can just...
        if (!phrase.parsedNoun) return false;
      }

      // redirectVerb ----------

      // Has author used redirectVerb for this verb on direct_object?
      if (
        n === 1 &&
        phrase.parsedNoun &&
        phrase.parsedNoun.qualified_object_id
      ) {
        let direct_object = this.game.getAsset(
          phrase.parsedNoun.qualified_object_id,
        );
        if (direct_object.redirected_verbs[dictionary_verb.name]) {
          // requalify verb
          dictionary_verb = this.qualifyParsedVerb({
            parsed_verb_name:
              direct_object.redirected_verbs[dictionary_verb_name],
          });
          if (!dictionary_verb) return false;
        }
      } // redirectVerb
    } // for each phrase

    // ----------
    // each phrase redux
    // ----------

    // I think this is reiterating to account for changes made during the first pass
    for (let n = 1; n <= count.phrase; n++) {
      var phrase = this_turn.verified_sentence[`phrase${n}`];
      var parsedNoun = phrase.parsedNoun;
      if (!parsedNoun) continue;

      this.game.log(
        "log",
        "high",
        `handleSentence.js > final check on phrase ${n}`,
        "Parser",
      );

      if (parsedNoun.matches.qualified.length > 1) {
        var lookup = this.game.world_lookup[parsedNoun.serialized_input];
        var is_plural = false;
        if (1 < parsedNoun.deserialized_input.split("&").length) {
          is_plural = true;
        }
        if (lookup) {
          if ("plural" === lookup.type || "group" === lookup.type) {
            is_plural = true;
          }
        }

        if (is_plural) {
          if (!dictionary_verb[`phrase${n}`].accepts_plural_noun) {
            // verb doesn't accept a plural noun
            this.game.debug(
              `F1202 | handleSentence.js | ${dictionary_verb.name} doesn't handle multiple objects `,
            );
            this.game.log(
              "warn",
              "high",
              "handleSentence.js > " +
                dictionary_verb.name +
                " doesn't handle multiple objecs: " +
                parsedNoun.deserialized_input,
              "Parser",
            );
            this.printNounDisambiguation({
              parsedNoun: parsedNoun,
              nounIndex: n,
            });
            return false;
          }
        }

        // meaning, parsedNoun.matches.qualified.length > 1
        // but verb doesn't handle plurals
        if (!is_plural && !dictionary_verb.let_verb_handle_disambiguation) {
          this.game.debug(
            `F1201 | handleSentence.js | phrase${n}.parsedNoun needs disambiguation `,
          );
          this.game.log(
            "log",
            "high",
            "handleSentence.js > parsedNoun" +
              n +
              " needs disambiguation: " +
              parsedNoun.matches.qualified,
            "Parser",
          );
          this.printNounDisambiguation({
            parsedNoun: parsedNoun,
            nounIndex: n,
          });
          return false;
        }
      } // more than one qualified
    } // each phrase redux

    // do the thing! ----------

    this.game.log("log", "high", "handleSentence.js > END.", "Parser");
    let direct_object = this_turn.getAsset(1);
    if (direct_object?.is.collection && dictionary_verb.enqueue_collections) {
      this.game.debug(
        `F1091 | handleSentence.js | ${
          this_turn.getAsset(1).name
        }.is.collection, enqueueing collection`,
      );
      this.game.print(msg);
      dictionary_verb.enqueueCollection(direct_object);
    } else {
      this.game.debug(
        `F1143 | handleSentence.js | doVerb ${dictionary_verb.name} `,
      );
      dictionary_verb.do();
    }

    return true;
  }; // handleSentence
})();

// handleWord.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Handle single-word input.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#handleWord
   */
  p.handleWord = function Parser_handleWord() {
    this.game.log("log", "high", "handleWord.js > Begin parse.", "Parser");
    var this_turn = this.input_history[0];
    var one_word = this_turn.found_word;
    var parsedNoun1, verb_name;
    var last_turn = this.input_history[1];
    var wordToNumber = Number(one_word);
    var msg = "";
    var foundMatch = false;

    /* *
     * Did the last turn prompt for a preposition?
     * See if this turn's input satisfies that.
     * This ran after the verb check until 3/8/23
     * when I noticed an example that needed this
     * to run before the verb check.
     * Example: "put pen table" where? "in"
     * "in" gets parsed as direction verb but should be preposition
     * @TODO keep an eye on this in case it results in verbs failing to parse
     */
    for (let i = 1; i <= 3; i++) {
      if (
        last_turn.soft_prompt["preposition" + i] &&
        this.game.dictionary.isPreposition(one_word)
      ) {
        this.game.log(
          "log",
          "high",
          "handleWord.js > found soft prompt for preposition" + i,
          "Parser"
        );
        // was sentence structure explicitly set with soft prompt? use that. otherwise use last turn's structure
        this_turn.verified_sentence_structure =
          last_turn.soft_prompt.structure ||
          last_turn.verified_sentence_structure;
        this_turn.soft_prompt.satisfied = true;
        this_turn.setOneWord({ ["preposition" + i]: one_word });
        this.game.debug(
          `F1536 | handleWord.js | last turn soft prompted for preposition${i} and ${one_word} recognized as preposition `
        );
        this.handleSentence();
        return;
      }
    } // preposition

    /**
     * is it a verb that is also a noun that satisfies
     * a travel verb like "go" as in "go east"?
     */
    verb_name = this.parseVerb(one_word);
    this.game.log(
      "log",
      "high",
      "handleWord.js > verb_name " + verb_name,
      "Parser"
    );
    if (
      verb_name &&
      last_turn.soft_prompt.noun1 &&
      this.game.dictionary.verbs[verb_name].type.direction
    ) {
      this.game.debug(
        `F1409 | handleWord.js | soft_prompt received ${one_word} which is direction+noun and satisfies ${this_turn.input_verb}`
      );

      this_turn.setOneWord({ noun1: verb_name });
      if (last_turn.soft_prompt.verb) {
        this_turn.setOneWord({ verb: last_turn.soft_prompt.verb });
        this_turn.input_verb =
          this.game.dictionary.verbs[last_turn.soft_prompt.verb].prettyname;
      }
      this.game.log(
        "log",
        "high",
        "handleWord.js > handle soft prompt for noun1",
        "Parser"
      );
      // was sentence structure explicitly set with soft prompt? use that. otherwise use last turn's structure
      this_turn.verified_sentence_structure =
        last_turn.soft_prompt.structure ||
        last_turn.verified_sentence_structure;
      this_turn.soft_prompt.satisfied = true;
      this.handleSentence();
      return;
    }

    /**
     * Is it a verb?
     * Check our one word input against dictionary verbs.
     * parseVerb returns either the base form of the verb,
     * or false if no matching verb.
     * (Unless last turn was a soft prompt,
     * which is almost always looking for a noun. )
     */
    if (verb_name) {
      //let verb = this.dictionary.verbs[verb_name];

      let verb = this.qualifyParsedVerb({
        parsed_verb_name: verb_name,
      });
      if (!verb) return false;

      if (-1 === verb.accepts_structures.indexOf("verb")) {
        this.game.debug(
          `F1052 | handleWord.js | ${verb_name} doesn't accept structure > verb `
        );
        msg += `${verb.type.travel ? "Where" : "What"} did $(we) want to ${
          verb.prettyname
        }? `;
        msg = msg || verb.msgNoObject;
        this_turn.setSoftPrompt({ noun1: true });
        this.game.print(msg, this_turn.output_class);
        return false;
      }
      this_turn.setVerb(1, verb_name);
      this_turn.setStructure("verb");
      this.game.debug(
        `F1537 | handleWord.js | ${verb_name} recognized as verb`
      );
      this.game.dictionary.doVerb(verb_name);
      return true;
    } // verb_name

    // Is it a number?
    // One way or another, let's find a noun.
    if (Number.isInteger(wordToNumber) && last_turn.disambiguate.index) {
      one_word = last_turn.getParsedNoun(last_turn.disambiguate.index).matches
        .qualified[wordToNumber - 1];
      // this can be asset:aspect:substance
      // if so we want to get the asset
      // and this is an ID so we should be able to get the asset
      // without doing another lookup
      // getAsset returns the container not the substance

      if (!one_word) {
        this.game.debug(
          `F1555 | handleWord.js | ${wordToNumber} is not a valid choice`
        );
        msg += wordToNumber + " doesn't seem to make sense. ";
        if (msg) this.game.print(msg, this_turn.output_class);
        return false;
      }

      // @TODO working here
      parsedNoun1 = new adventurejs.ParsedNoun(this.game.getAsset(one_word));
      console.error("parsedNoun1", parsedNoun1);
    } else {
      parsedNoun1 = this.parseNoun(one_word);
    }

    //No matching key found in world_lookup
    //so we can't do anything with it.
    if (0 === parsedNoun1.matches.all.length) {
      this.game.log(
        "log",
        "high",
        "handleWord.js > no matching key found in world_lookup ",
        "Parser"
      );
      this.game.debug(
        `F1174 | handleWord.js | no matching key found in world_lookup`
      );
      msg += this.getUnparsedMessage(one_word);
      this.game.print(msg, this_turn.output_class);
      return false;
    }

    /**
     * Did the last turn prompt for noun disambiguation?
     * See if this turn's input satisfies that.
     */
    if (last_turn.disambiguate.enabled) {
      this.game.log(
        "log",
        "high",
        "handleWord.js > handle noun disambiguation",
        "Parser"
      );
      foundMatch = this.findMatchIn(
        parsedNoun1.matches.qualified,
        last_turn["parsedNoun" + last_turn.disambiguate.index].matches.qualified
      );
      if (foundMatch) {
        this_turn.verified_sentence_structure =
          last_turn.verified_sentence_structure;
        this_turn.setOneWord({
          ["noun" + last_turn.disambiguate.index]: foundMatch,
        });
        this.game.debug(
          `F1543 | handleWord.js | disambiguate foundMatch ${foundMatch}`
        );
        this.handleSentence();
        return;
      } else {
        // last turn called for disambiguation but no match was found
        this.game.debug(`F1556 | handleWord.js | disambiguation failed`);
        msg += `${wordToNumber} doesn't seem to make sense. `;
        if (msg) this.game.print(msg, this_turn.output_class);
        return false;
      }
    }

    /**
     * Did the last turn soft prompt for anything?
     * See if this turn's input satisfies that.
     */
    if (last_turn.soft_prompt.enabled) {
      this.game.debug(
        `F1544 | handleWord.js | soft_prompt received ${one_word}`
      );

      let p = last_turn.soft_prompt;
      let found = p.noun1
        ? "noun1"
        : p.noun2
        ? "noun2"
        : p.noun3
        ? "noun3"
        : p.preposition1
        ? "preposition1"
        : p.preposition2
        ? "preposition2"
        : p.preposition3
        ? "preposition3"
        : false;

      if (found) this_turn.setOneWord({ [found]: one_word });
      if (last_turn.soft_prompt.verb) {
        this_turn.setOneWord({ verb: last_turn.soft_prompt.verb });
        this_turn.input_verb =
          this.game.dictionary.verbs[last_turn.soft_prompt.verb].prettyname;
      }
      this.game.log(
        "log",
        "high",
        "handleWord.js > handle soft prompt for " + found,
        "Parser"
      );
      // was sentence structure explicitly set with soft prompt? use that. otherwise use last turn's structure
      this_turn.verified_sentence_structure =
        last_turn.soft_prompt.structure ||
        last_turn.verified_sentence_structure;
      this_turn.soft_prompt.satisfied = true;
      this.handleSentence();
      return;
    }

    /**
     * Did we receive a string that hasn't satisfied any prompts?
     */
    if (parsedNoun1.object_id === "global_string") {
      this.game.log("log", "high", "handleWord.js > received string", "Parser");
      this.game.debug(`F1546 | handleWord.js | received string `);
      msg += this_turn.strings.toString() + "...?";
      this.game.print(msg, this_turn.output_class);
      return;
    }

    /**
     * Is settings.if_input_is_an_asset_name_examine_it true?
     *
     * If so, naming a noun with no verb is
     * treated as if player had said "examine x"
     */
    if (this.game.settings.if_input_is_an_asset_name_examine_it) {
      this.game.log(
        "log",
        "high",
        "handleWord.js > if_input_is_an_asset_name_examine_it",
        "Parser"
      );

      this.game.debug(
        `F1547 | handleWord.js | if_input_is_an_asset_name_examine_it `
      );

      parsedNoun1 = this.qualifyParsedNoun({
        parsedNoun: parsedNoun1,
        parsedVerb: "examine",
        nounIndex: "1",
      });

      if (false === parsedNoun1) {
        // if qualifyParsedNoun returned false, it also
        // printed an error message, so we can just...
        return false;
      } else {
        // unambiguous object, print default description
        if (1 === parsedNoun1.matches.qualified.length) {
          this_turn.setParsedNoun(1, parsedNoun1);
          this.game.dictionary.doVerb("examine");
          return;
        }
      }
    } // if( this.game.settings.if_input_is_an_asset_name_examine_it )

    // default
    this.game.debug(
      `F1175 | handleWord.js | reached end of function without resolution`
    );
    msg += this.getUnparsedMessage(one_word);
    this.game.print(msg, this_turn.output_class);
    return false;
  };
})();

// joinCompoundNames.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound object names,
   * by comparing the input string against entries in 
   * this.game.world lookup table, 
   * which was populated during the creation of Game
   * objects. If we find multiple words that match an entry, 
   * we compress the words into a single string
   * that is a noun id.
   * </p> 
   * <p>
   * For example:<br>
   * <code class="property">"turn on brass lantern"</code>
   * becomes 
   * <code class="property">"turn on brass_lantern"</code>.
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinCompoundNames
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinCompoundNames = function Parser_joinCompoundNames( input ) 
  {    
		for(var prop in this.game.world) 
    {
      var name = this.game.world[prop].name;
      if( !name ) continue;

      var id = this.game.world[prop].id;
      //input = input.replace( name, id );

      var search = "\\b"+name+"\\b"; 
      var regex = new RegExp(search,"g");
      input = input.replace( regex, id );
    }

		return input;
  }  
}());

// joinCompoundPhrases.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for multi-word phrases that are not names,
   * such as "north door" to describe an aperture related
   * to a north exit,
   * by comparing the input string against entries in
   * game.world_lookup, which contains space delimited phrases
   * as well as single words which make up those phrases.
   * </p>
   * <p>
   * For example if we had an object named:
   * "Maxwell's silver hammer"
   * </p>
   * <p>
   * User might ask for "hammer" or "silver hammer" or "maxwell's silver hammer"
   * In order to maximize chances of understanding partial user input,
   * each word of the phrase becomes a separate entry in world_lookup.
   * </p>
   * <p>
   * When performing search/replace we don't want to
   * accidentally replace substrings of larger phrases,
   * which means we need to search for longer phrases first
   * and work our way down. We also need to ensure we don't
   * substitute words in phrases we've already serialized.
   * </p>
   * <p>
   * Unfortunately we can't just sort world_lookup by word count
   * because JS object properties aren't indexed, by definition.
   * Instead we figure out the longest word count property and
   * do a loop for each word count from the longest down to two words.
   * (No substitution is needed for single words.)
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinCompoundPhrases
   * @param {String} input Player input.
   * @returns {String}
   * @todo
   * This might be too greedy, or perhaps need to exclude first word of input.
   * I had a room called "Put Plug In This"
   * and this method parsed "put plug in sink" to "put_plug_in_this in sink"
   * Alternately, revise the method that populates world_lookup
   * for instance world_lookup has keys for
   * "Plug Something With Something" and "sink with"
   */
  p.joinCompoundPhrases = function Parser_joinCompoundPhrases(input) {
    this.game.log(
      "log",
      "high",
      "joinCompoundPhrases.js > receive: " + input,
      "Parser"
    );
    var lookupKeys = Object.keys(this.game.world_lookup);
    var maxwords = 0;

    // TODO figure this at the end of Game.play() and store as global var
    // figure the longest word count
    for (var l = 0; l < lookupKeys.length; l++) {
      var length = lookupKeys[l].split(" ").length;
      if (length > maxwords) {
        maxwords = length;
      }
    }

    // iterate from longest to shortest, excluding single words
    for (var m = maxwords; m > 0; m--) {
      for (var i = 1; i < lookupKeys.length; i++) {
        if (
          lookupKeys[i].split(" ").length === m &&
          lookupKeys[i].split(" ").length > 1 && // don't find single words
          lookupKeys[i].split("_").length === 1
        ) {
          //console.log("*** input:",input,"key:",lookupKeys[i], this.game.world_lookup[ lookupKeys[i] ] );
          var lookupValue = this.game.world_lookup[lookupKeys[i]].IDs;
          //console.log("lookupKeys[i]",lookupKeys[i]);
          //console.log("lookupValue",lookupValue);

          /*
           * Exclude keywords with underscores because
           * those will be the results from earlier loops.
           * Ex: we're going to search for "icy door"
           * and convert to "icy_door"
           * and we're also going to search for "icy"
           * and we don't want to wind up with "icy_doordoor".
           *
           * We search with word boundaries
           * When we serialize we're replacing spaces with underscores
           * and underscore is not a word boundary,
           * so for example search will find "icy " or " icy" or " icy "
           * but it won't find "icy" in "icy_door".
           */

          var search = "\\b" + lookupKeys[i] + "\\b";
          var regex = new RegExp(search, "g");

          //
          var match = input.match(regex);

          if (match !== null) {
            //console.log( "match", match );

            /*
             * One clear match found.
             * This lookup key only had one object associated with it.
             * Ex: "wooden chest" returns "wooden_chest".
             */
            if (lookupValue.length === 1) {
              input = input.replace(regex, lookupValue);
              //console.log("lookupValue.length === 1");
              //console.log("input",input);

              // save a replacement record back to input
              // so we can find the original input string,
              // which may not be identical to the name
              // of the object we find
              let context = `joinCompoundPhrases.js > found only one lookup value and replaced '${lookupValue[0]}' with '${lookupKeys[i]}'`;
              //console.warn(context);
              if (!this.game.getInput().replacements[lookupValue[0]]) {
                this.game.getInput().replacements[lookupValue[0]] = {
                  source: lookupKeys[i],
                  context: context,
                };
              }
            } else {
              // we're going to use foundOne for testing after we run the for-loop
              var foundOne = false;
              this.game.log(
                "log",
                "high",
                "joinCompoundPhrases.js > lookupValue: " + lookupValue,
                "Parser"
              );
              for (var k = 0; k < lookupValue.length; k++) {
                this.game.log(
                  "log",
                  "high",
                  "joinCompoundPhrases.js > lookupValue: " + lookupValue[k],
                  "Parser"
                );

                /*
                 * The lookupKey found multiple values,
                 * which means an array of serialized IDs.
                 *
                 * Ex: we searched for "brass key" and found "small_brass_key"
                 * but also "melted_brass_key" and "broken_brass_key"
                 *
                 * So we need to deserialize each value to see if it's found in input.
                 * And as with the parent routine, we need items
                 * ordered from longest word count to shortest.
                 *
                 * Fortunately we already sorted these at startup
                 * in Game.play.sortLookupValues().
                 */
                var lookupValueDeserialized = A.deserialize(lookupValue[k]);
                //console.log("lookupValueDeserialized",lookupValueDeserialized);

                /*
                 * IMPORTANT: don't replace single words.
                 * This was already the intention, but this
                 * line fixes a bug when processing input such as:
                 * "take all keys but fookey".
                 * Prior to this step, "but fookey" has been converted
                 * to "-fookey", giving us "take all keys -fookey".
                 * This loop was finding "fookey" and replacing
                 * "all keys" with "fookey", leading to malformed
                 * input: "take fookey -fookey"
                 */
                if (-1 === lookupValueDeserialized.indexOf(" ")) {
                  continue;
                }

                /*
                 * we found an exact match
                 * Ex: user input included the phrase "melted brass key"
                 * so we can exclude "brass_key" and broken_brass_key"
                 */
                if (-1 !== input.indexOf(lookupValueDeserialized)) {
                  console.log("FOUND UNAMBIGUOUS MATCH!");
                  console.log(regex, "in", input);
                  console.log("original input", input);
                  //var match = [  ];
                  input = input.replace(regex, lookupValue[k]);
                  console.log("revised input", input);
                  foundOne = true;

                  // save a replacement record back to input
                  if (!this.game.getInput().replacements[lookupValue[k]]) {
                    this.game.getInput().replacements[lookupValue[k]] = {
                      source: lookupKeys[i],
                      context: `joinCompoundPhrases > found unambiguous match`,
                    };
                  }
                }
              }
              if (false === foundOne) {
                this.game.log(
                  "log",
                  "high",
                  "joinCompoundPhrases > Need to disamiguate " + lookupValue,
                  "Parser"
                );
                /*
                 * We need to disambiguate, but we're going to kick
                 * that can down the road. Normally we would convert
                 * multiples to an array â but unfortunately
                 * we're still working with strings at this point â
                 * because this may be just one "word" of player input.
                 * Instead we're going to pass on all found object IDs
                 * in a comma delimited list.
                 *
                 * Important: we're saving the original input as the first
                 * item in the comma-delimited list. Down the road,
                 * parseNoun will use that to set parsedNoun.input
                 */

                input = input.replace(
                  regex,
                  A.serialize(lookupKeys[i]) + "=" + lookupValue.toString()
                );

                // save a replacement record back to input
                if (!this.game.getInput().replacements[lookupValue]) {
                  this.game.getInput().replacements[lookupValue] = {
                    source: lookupKeys[i],
                    context: `joinCompoundPhrases.js > looking for disambiguation`,
                  };
                }
              }
            }
          } // if( match !== null )
        }
      } // for( var i = 1; i < lookupKeys.length; i++ )
    } // for( var m = maxwords; m > 0; m-- )

    var searchall = "\\ball_";
    var regexall = new RegExp(searchall, "g");
    input = input.replace(regexall, "");

    this.game.log(
      "log",
      "high",
      "joinCompoundPhrases.js > return: " + input,
      "Parser"
    );
    return input;
  };
})();

// joinCompoundPrepositions.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Convert some common compound prepositions into single words
   * to streamline preposition handling.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinCompoundPrepositions
   * @param {String} input Player input.
   * @returns {String}
   */
  p.joinCompoundPrepositions = function Parser_joinCompoundPrepositions(
    parsed_input
  ) {
    let game = this.game;
    let compounds = this.game.dictionary.compound_prepositions;
    let record = function (match, replacement) {
      game.getInput().replacements[replacement.trim()] = {
        source: match.trim(),
        context: `joinCompoundPrepositions.js > found ${match.trim()}`,
      };
      return replacement;
    };
    for (let i = 0; i < compounds.length; i++) {
      let regex = new RegExp(compounds[i][0], "g");
      parsed_input = parsed_input.replace(regex, (match) => {
        return record(match, compounds[i][1]);
      });
    }

    this.game.log(
      "log",
      "high",
      "parseInput.js > joinCompoundPrepositions return: " + parsed_input,
      "Parser"
    );
    return parsed_input;
  };
})();

// joinCompoundVerbs.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * List of methods to be called during parse that perform
   * regex operations on input in order to join compound verb phrases.
   * @var adventurejs.Parser#joins
   * @type {Array}
   */
  p.joints = [
    "joinVerbPrepNounPrepNounPrepNouns",
    "joinVerbNounPrepPrepNouns",
    "joinVerbNounPrepNounPrepNouns",
    "joinVerbPrepNounPrepNouns",
    "joinVerbPrepPrepPrepNouns",
    "joinVerbPrepPrepNouns",
    "joinVerbNounPrepNouns",
    "joinVerbNounPreps",
    "joinVerbPrepNouns"
  ];

  /**
   * <code>joinCompoundVerbs</code>is a holdover from an earlier version 
   * of the parser that didn't parse prepositions as distinct words, but 
   * instead performed multiple regexs on input, finding patterns like 
   * "swing from tree to cliff on vine" and joining them into 
   * "swing_from_to_on tree cliff vine". All verbs were originally handled 
   * this way. Most now are not, with a few remaining exceptions. There 
   * are still some verbs with baked-in prepositions because it's just 
   * an easier way of catching variants like "get off" or "get down" and 
   * funneling them to the same chunk of logic while also distinguishing 
   * them from "get lamp".
   * <br><br>
   * The listed order of regex operations is important. We're calling them 
   * in order of longest to shortest, to ensure we don't accidentally 
   * catch partial phrases, like only finding "swing_from" out of 
   * "swing from tree to cliff on vine", and then not finding "swing_from_to_on",
   * which is (or was) a distinct verb.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinCompoundVerbs
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinCompoundVerbs = function Parser_joinCompoundVerbs( input ) 
  {    

    // join compound verb phrases
    if( 1 < input.split(" ").length )
    {
      for( var join = 0; join < this.joints.length; join++ )
      {
        input = this[this.joints[join]]( input );
      }
    }

		return input;
  }  
}());

// joinVerbNounPrepNounPrepNouns.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound verb phrases in the format of
   * "verb noun prep noun prep nouns",
   * by comparing the input string against entries in 
   * dictionary.verb_noun_prep_noun_prep_nouns, 
   * which was populated by Verb definitions.
   * If we find a set of words that match an entry, 
   * we compress the words into a single string
   * that is a Verb name.
   * </p> 
   * <p>
   * For example:<br>
   * <code class="property">"tie dog to tree with rope"</code>
   * becomes 
   * <code class="property">"tie_to_with dog tree rope"</code>
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinVerbNounPrepNounPrepNouns
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinVerbNounPrepNounPrepNouns = function Parser_joinVerbNounPrepNounPrepNouns( input ) 
  {
		for( var i=0; i < this.dictionary.verb_noun_prep_noun_prep_nouns.length; i++ ) 
    {
			var trio = this.dictionary.verb_noun_prep_noun_prep_nouns[i][0];
			var verb = trio.split(" ")[0];
			var prep1 = trio.split(" ")[1];
			var prep2 = trio.split(" ")[2];
			var combined = this.dictionary.verb_noun_prep_noun_prep_nouns[i][1];

      /**
       * Valid chars are alphanumeric, plus:
       * " " spaces, used as delimeters
       * "_" underscores, used to serialize compound names
       * "," commas, stripped from input but then used with multiple search results
       * "=" used with multiple search results
       * "&" used with multiple search results
       */
      var search = verb + " ([,_=&A-Za-z0-9]*) " + prep1 + " ([,_=&A-Za-z0-9]*) " + prep2;// + " ([ ,_=&A-Za-z0-9]*)";

      var regex = new RegExp(search,"g");
			var replaced = input.replace(regex, combined + " $1 $2");
      if( replaced !== input ) 
      {
        // save a record of the original input
        this.input_history[ 0 ].input_verb = trio;
        this.input_history[ 0 ].joint = "verb_noun_prep_noun_prep_noun";
        input = replaced;
        break;
      }
    }

    this.game.log( "log", "high", "parseInput.js > joinVerbNounPrepNounPrepNouns returns: " + input, 'Parser' );
    return input;
  }  
}());

// joinVerbNounPrepNouns.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound verb phrases in the format of
   * "verb noun preposition noun",
   * by comparing the input string against entries in
   * dictionary.verb_noun_prep_nouns,
   * which was populated by Verb definitions.
   * If we find a set of words that match an entry,
   * we compress the words into a single string
   * that is a Verb name.
   * </p>
   * <p>
   * This is a holdover from an earlier parsing technique
   * that is not much used now. (This particular example
   * is no longer valid.)
   * <br>
   * <code class="property">"ask grocer about eggplant"</code>
   * becomes
   * <code class="property">"ask_about grocer eggplant"</code>
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinVerbNounPrepNouns
   * @param {String} input Player input.
   * @returns {String}
   */
  p.joinVerbNounPrepNouns = function Parser_joinVerbNounPrepNouns(input) {
    for (var i = 0; i < this.dictionary.verb_noun_prep_nouns.length; i++) {
      var pair = this.dictionary.verb_noun_prep_nouns[i][0];
      var verb = pair.split(" ")[0];
      var prep = pair.split(" ")[1];
      var combined = this.dictionary.verb_noun_prep_nouns[i][1];

      /**
       * Valid chars are alphanumeric, plus:
       * " " spaces, used as delimeters
       * "_" underscores, used to serialize compound names
       * "," commas, stripped from input but then used with multiple search results
       * "=" used with multiple search results
       * "&" used with multiple search results
       */
      var search = verb + " ([,_=&A-Za-z0-9]*) " + prep;

      var regex = new RegExp(search, "g");
      var replaced = input.replace(regex, combined + " $1");
      if (replaced !== input) {
        // save a record of the original input
        this.input_history[0].input_verb = pair;
        this.input_history[0].joint = "verb_noun_prep_noun";
        input = replaced;
        break;
      }
    }

    this.game.log(
      "log",
      "high",
      "parseInput.js > joinVerbNounPrepNouns returns: " + input,
      "Parser",
    );
    return input;
  };
})();

// joinVerbNounPrepPrepNouns.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound verb phrases in the format of
   * "verb noun preposition preposition noun",
   * by comparing the input string against entries in 
   * dictionary.verb_noun_prep_prep_nouns, 
   * which was populated by Verb definitions.
   * If we find a set of words that match an entry, 
   * we compress the words into a single string
   * that is a Verb name.
   * </p> 
   * <p>
   * For example:<br>
   * <code class="property">"take skateboard from under bed"</code>
   * becomes 
   * <code class="property">"take_from skateboard bed"</code>
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinVerbNounPrepPrepNouns
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinVerbNounPrepPrepNouns = function Parser_joinVerbNounPrepPrepNouns( input ) 
  {
		for( var i=0; i < this.dictionary.verb_noun_prep_prep_nouns.length; i++ ) 
    {
			var trio = this.dictionary.verb_noun_prep_prep_nouns[i][0];
			var verb = trio.split(" ")[0];
			var prep1 = trio.split(" ")[1];
			var prep2 = trio.split(" ")[2];
			var combined = this.dictionary.verb_noun_prep_prep_nouns[i][1];

      /**
       * Valid chars are alphanumeric, plus:
       * " " spaces, used as delimeters
       * "_" underscores, used to serialize compound names
       * "," commas, stripped from input but then used with multiple search results
       * "=" used with multiple search results
       * "&" used with multiple search results
       */
      var search = verb + " ([,_=&A-Za-z0-9]*) " + prep1 + " " + prep2 + " ([,_=&A-Za-z0-9]*)";

      var regex = new RegExp(search,"g");
			var replaced = input.replace(regex, combined + " $1 $2");
      if( replaced !== input ) 
      {
        // save a record of the original input
        this.input_history[ 0 ].input_verb = trio;
        this.input_history[ 0 ].joint = "verb_noun_prep_prep_noun";
        input = replaced;
        break;
      }
    }

    this.game.log( "log", "high", "parseInput.js > joinVerbNounPrepPrepNouns returns: " + input, 'Parser' );
    return input;

  }  
}());

// joinVerbNounPreps.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound verb phrases in the format of
   * "verb noun preposition",
   * by comparing the input string against entries in 
   * dictionary.verb_noun_preps, 
   * which was populated by Verb definitions.
   * If we find a set of words that match an entry, 
   * we compress the words into a single string
   * that is a Verb name.
   * </p> 
   * <p>
   * For example:<br>
   * <code class="property">"look in chest"</code>
   * becomes 
   * <code class="property">"lookIn chest"</code>
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinVerbNounPreps
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinVerbNounPreps = function Parser_joinVerbNounPreps( input ) 
  {
		for( var i=0; i < this.dictionary.verb_noun_preps.length; i++ ) 
    {
			var duo = this.dictionary.verb_noun_preps[i][0];
			var verb = duo.split(" ")[0];
			var prep = duo.split(" ")[1];
			var combined = this.dictionary.verb_noun_preps[i][1];

      /**
       * Valid chars are alphanumeric, plus:
       * " " spaces, used as delimeters
       * "_" underscores, used to serialize compound names
       * "," commas, stripped from input but then used with multiple search results
       * "=" used with multiple search results
       * "&" used with multiple search results
       */
      var search = verb + " ([,_=&A-Za-z0-9]*) " + prep;

      var regex = new RegExp(search,"g");
			var replaced = input.replace(regex, combined + " $1");
      if( replaced !== input ) 
      {
        // save a record of the original input
        this.input_history[ 0 ].input_verb = duo;
        this.input_history[ 0 ].joint = "verb_noun_prep";
        input = replaced;
        break;
      }
		}

    this.game.log( "log", "high", "parseInput.js > joinVerbNounPreps returns: " + input, 'Parser' );
		return input;
  }  
}());

// joinVerbPrepNounPrepNounPrepNouns.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound verb phrases in the format of
   * "verb preposition noun preposition noun preposition noun",
   * by comparing the input string against entries in 
   * dictionary.verb_prep_noun_prep_noun_prep_nouns, 
   * which was populated by Verb definitions.
   * If we find a set of words that match an entry, 
   * we compress the words into a single string
   * that is a Verb name.
   * </p> 
   * <p>
   * For example:<br>
   * <code class="property">"swing from tree to stalactite on vine"</code>
   * becomes 
   * <code class="property">"swing_from_to_on tree stalactite vine"</code>.
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinVerbPrepNounPrepNounPrepNouns
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinVerbPrepNounPrepNounPrepNouns = function Parser_joinVerbPrepNounPrepNounPrepNouns( input ) 
  {
		for( var i=0; i < this.dictionary.verb_prep_noun_prep_noun_prep_nouns.length; i++ ) 
    {
			var quad = this.dictionary.verb_prep_noun_prep_noun_prep_nouns[i][0];
			var verb = quad.split(" ")[0];
			var prep1 = quad.split(" ")[1];
			var prep2 = quad.split(" ")[2];
			var prep3 = quad.split(" ")[3];
			var combined = this.dictionary.verb_prep_noun_prep_noun_prep_nouns[i][1];

      /**
       * Valid chars are alphanumeric, plus:
       * " " spaces, used as delimeters
       * "_" underscores, used to serialize compound names
       * "," commas, stripped from input but then used with multiple search results
       * "=" used with multiple search results
       * "&" used with multiple search results
       */
      var search = verb + " " + prep1 + " ([,_=&A-Za-z0-9]*) " + prep2 + " ([,_=&A-Za-z0-9]*) " + prep3 + " ([,_=&A-Za-z0-9]*)";

      var regex = new RegExp(search,"g");
			var replaced = input.replace(regex, combined + " $1" + " $2" + " $3");
      if( replaced !== input ) 
      {
        // save a record of the original input
        this.input_history[ 0 ].input_verb = quad;
        this.input_history[ 0 ].joint = "verb_prep_noun_prep_noun_prep_noun";
        input = replaced;
        break;
      }
		}

    this.game.log( "log", "high", "parseInput.js > joinVerbPrepNounPrepNounPrepNouns returns: " + input, 'Parser' );
    return input;
  }  
}());

// joinVerbPrepNounPrepNouns.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound verb phrases in the format of
   * "verb prep noun prep noun",
   * by comparing the input string against entries in 
   * dictionary.verb_prep_noun_prep_nouns, 
   * which was populated by Verb definitions.
   * If we find a set of words that match an entry, 
   * we compress the words into a single string
   * that is a Verb name.
   * </p> 
   * <p>
   * For example:<br>
   * <code class="property">"jump from branch to vine"</code>
   * becomes 
   * <code class="property">"jumpFrom_to branch vine"</code>
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinVerbPrepNounPrepNouns
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinVerbPrepNounPrepNouns = function Parser_joinVerbPrepNounPrepNouns( input ) 
  {
		for( var i=0; i < this.dictionary.verb_prep_noun_prep_nouns.length; i++ ) 
    {
			var trio = this.dictionary.verb_prep_noun_prep_nouns[i][0];
			var verb = trio.split(" ")[0];
			var prep1 = trio.split(" ")[1];
			var prep2 = trio.split(" ")[2];
			var combined = this.dictionary.verb_prep_noun_prep_nouns[i][1];

      /**
       * Valid chars are alphanumeric, plus:
       * " " spaces, used as delimeters
       * "_" underscores, used to serialize compound names
       * "," commas, stripped from input but then used with multiple search results
       * "=" used with multiple search results
       * "&" used with multiple search results
       */
      var search = verb + " " + prep1 + " ([,_=&A-Za-z0-9]*) " + prep2 + " ([,_=&A-Za-z0-9]*)";

      var regex = new RegExp(search,"g");
			var replaced = input.replace(regex, combined + " $1" + " $2");
      if( replaced !== input ) 
      {
        // save a record of the original input
        this.input_history[ 0 ].input_verb = trio;
        this.input_history[ 0 ].joint = "verb_prep_noun_prep_noun";
        input = replaced;
        break;
      }
		}

    this.game.log( "log", "high", "parseInput.js > joinVerbPrepNounPrepNouns returns: " + input, 'Parser' );
    return input;
  }  
}());

// joinVerbPrepNouns.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound verb phrases in the format of
   * "verb prep noun",
   * by comparing the input string against entries in 
   * dictionary.verb_prep_nouns, 
   * which was populated by Verb definitions.
   * If we find a set of words that match an entry, 
   * we compress the words into a single string
   * that is a Verb name.
   * </p> 
   * <p>
   * For example:<br>
   * <code class="property">"look in desk"</code>
   * becomes 
   * <code class="property">"lookIn desk"</code>
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinVerbPrepNouns
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinVerbPrepNouns = function Parser_joinVerbPrepNouns( input ) 
  {
		for( var i=0; i < this.dictionary.verb_prep_nouns.length; i++ ) 
    {
			var pair = this.dictionary.verb_prep_nouns[i];
      //var replaced = input.replace( pair[0], pair[1] );

      // search anywhere in string
      //var search = "\\b"+pair[0]+"\\b"; 

      // only search beginning of string
      // important for cases like "put plug in sink" so we don't concat "plugIn"
      var search = "^(\\b" + pair[0] + "\\b)";

      var regex = new RegExp(search,"g");
      var replaced = input.replace( regex, pair[1] );

      if( replaced !== input ) 
      {
        console.warn( 'pair[0]', pair[0] );
        console.warn( 'pair[1]', pair[1] );
        // save a record of the original input
        this.input_history[ 0 ].input_verb = pair[0];
        this.input_history[ 0 ].joint = "verb_prep_noun";
        input = replaced;
        break;
      }
		}

    this.game.log( "log", "high", "parseInput.js > joinVerbPrepNouns returns: " + input, 'Parser' );
		return input;
  }  
}());

// joinVerbPrepPrepNouns.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound verb phrases in the format of
   * "verb prep prep noun",
   * by comparing the input string against entries in 
   * dictionary.verb_prep_prep_nouns, 
   * which was populated by Verb definitions.
   * If we find a set of words that match an entry, 
   * we compress the words into a single string
   * that is a Verb name.
   * </p> 
   * <p>
   * For example:<br>
   * <code class="property">"get out of boat"</code>
   * becomes 
   * <code class="property">"go_out boat"</code>
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinVerbPrepPrepNouns
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinVerbPrepPrepNouns = function Parser_joinVerbPrepPrepNouns( input ) 
  {
		for( var i = 0; i < this.dictionary.verb_prep_prep_nouns.length; i++ ) 
    {
      var trio = this.dictionary.verb_prep_prep_nouns[i];
      //var replaced = input.replace( trio[0], trio[1] );

      var search = "\\b"+trio[0]+"\\b"; 
      var regex = new RegExp(search,"g");
      var replaced = input.replace( regex, trio[1] );

      if( replaced !== input ) 
      {
        // save a record of the original input
        this.input_history[ 0 ].input_verb = trio[0];
        this.input_history[ 0 ].joint = "verb_prep_prep_noun";
        input = replaced;
        break;
      }

		}

    this.game.log( "log", "high", "parseInput.js > joinVerbPrepPrepNouns returns: " + input, 'Parser' );
		return input;
  }  
}());

// joinVerbPrepPrepPrepNouns.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Search input for compound verb phrases in the format of
   * "verb prep prep prep noun",
   * by comparing the input string against entries in 
   * dictionary.verb_prep_prep_prep_nouns, 
   * which was populated by Verb definitions.
   * If we find a set of words that match an entry, 
   * we compress the words into a single string
   * that is a Verb name.
   * </p> 
   * <p>
   * For example:<br>
   * <code class="property">"get out from behind boulder"</code>
   * becomes 
   * <code class="property">"go_out_from_behind boulder"</code>
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#joinVerbPrepPrepPrepNouns
   * @param {String} input Player input.
   * @returns {String}
   */
   p.joinVerbPrepPrepPrepNouns = function Parser_joinVerbPrepPrepPrepNouns( input ) 
  {
		for( var i = 0; i < this.dictionary.verb_prep_prep_prep_nouns.length; i++ ) 
    {
      var quad = this.dictionary.verb_prep_prep_prep_nouns[i];
      //var replaced = input.replace( quad[0], quad[1] );

      var search = "\\b"+quad[0]+"\\b"; 
      var regex = new RegExp(search,"g");
      var replaced = input.replace( regex, quad[1] );

      if( replaced !== input ) 
      {
        // save a record of the original input
        this.input_history[ 0 ].input_verb = quad[0];
        this.input_history[ 0 ].joint = "verb_prep_prep_prep_noun";
        input = replaced;
        break;
      }

		}

    this.game.log( "log", "high", "parseInput.js > joinVerbPrepPrepPrepNouns returns: " + input, 'Parser' );
		return input;
  }  
}());
// parseInput.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Parse an input string.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#parseInput
   * @param {String} input Player input.
   */
  p.parseInput = function Parser_parseInput(input) {
    this.game.log("log", "high", "parseInput.js > " + input, "Parser");
    let results;

    // we already dispatched inputEnter when player entered input
    // but parser.parseInput() can be called by other means so we distinguish
    // between dispatching inputEnter vs inputParseBegin
    this.game.reactor.dispatchEvent(this.game.events.inputParseBegin);

    // The undo verb supercedes all parsing.
    if ("undo" === input) {
      //this.game.dictionary.verbs.undo.do();
      this.game.printInput(input);
      this.game.dictionary.doVerb("undo");
      return;
    }

    /**
     * At this point "input" is just the string entered by player.
     * If we're processing stacked input, then input will already
     * have been parsed giving us serialized object ids.
     */
    var parsed_input = input;
    var unparsed_input = input;

    /**
     * Save a snapshot of the game state.
     * Technically this is saving LAST turn's snapshot
     * before engaging in this turn.
     * IMPORTANT: undo must come first.
     */
    A.addWorldToHistory.call(this.game, A.getBaselineDiff.call(this.game)); // delta from baseline

    /**
     * input_history_index is part of a convenience that lets
     * players use the arrow keys to re-enter their own
     * prior input, as in a shell. Player might have used it
     * to enter current input, so reset it now.
     */
    this.input_history_index = -1;

    /**
     * output_class is one of the params that's carried through
     * the entire parse and then used to apply css styles to
     * the output, if applicable.
     */
    var output_class = "";

    /**
     * Run any custom parsers created by author.
     * If custom parser returns a string, parse will continue.
     * If it returns null or false, parse will end.
     */
    if (0 < this.custom_parsers.length) {
      var keys = Object.keys(this.custom_parsers);
      for (var i = 0; i < this.keys.length; i++) {
        var parser_name = keys[i];
        if (true === this.custom_parsers_enabled[parser_name]) {
          input = this.custom_parsers[parser_name].parseInput();
          // TODO at the moment false & null have same results
          // but leaving open option to handle differently
          if (false === input) {
            this.is_input_queued = false;
            this.game.reactor.dispatchEvent(
              this.game.events.inputParseComplete
            );
            return false;
          } else if (null === input) {
            this.is_input_queued = false;
            this.game.reactor.dispatchEvent(
              this.game.events.inputParseComplete
            );
            return null;
          }
        }
      }
    }

    /**
     * Are we parsing stacked commands?
     * Stacked commands are made when user inputs
     * something like "do this THEN do that".
     */

    // if we're parsing stacked input, there are several items
    // we want to carry over from the original input
    var carried_input = new adventurejs.Input({
      game_name: this.game.game_name,
    });

    // when substrings are replaced in compound input,
    // we want to keep track of replacements for subsequent output

    if (this.input_queue.length > 0) {
      // We're currently parsing the first item in the stack,
      // so remove that item.
      // In the event of stacked input, we want to carry forward
      // a record of string replacements that have occurred
      carried_input.replacements = Object.assign(
        carried_input.replacements,
        this.input_history[0].replacements
      );

      // also carry forward a record of the original input string
      carried_input.unparsed_input = this.input_history[0].unparsed_input;

      if (this.input_queue[0].printInput) {
        this.game.printInput(A.deserialize(input));
      }

      if ("undefined" !== typeof this.input_queue[0].output_class) {
        output_class = this.input_queue[0].output_class;
      }

      // it's possible to include pre-set output in the input_queue
      // see goto for example
      if ("undefined" !== typeof this.input_queue[0].output) {
        this.game.print(this.input_queue[0].output, output_class);
      }

      //
      if (
        "undefined" !== typeof this.input_queue[0].linefeed &&
        this.input_queue[0].linefeed
      ) {
        this.game.print("", "linefeed");
      }

      this.input_queue.shift();
    } // if( this.input_queue.length > 0 )
    else {
      // sanitizeInput cleans input of several conditions.
      // Also has the ability to revise unparsed_input in the case of 'again'
      var sanitized_input = this.sanitizeInput(parsed_input, unparsed_input);
      this.game.log(
        "log",
        "high",
        "parseInput.js > sanitizeInput return parsed: " +
          sanitized_input[0] +
          ", unparsed: " +
          sanitized_input[1],
        "Parser"
      );

      parsed_input = sanitized_input[0];
      unparsed_input = sanitized_input[1];

      // Only prints the first item in queue
      this.game.printInput(A.deserialize(parsed_input));
    }

    // make a new input object
    this.input_history.unshift(
      new adventurejs.Input({ game_name: this.game.game_name })
    );
    var this_turn = this.input_history[0];

    // keep a reference to last turn
    var last_turn = this.input_history[1];

    // unparsed_input might not actually be the original input
    // in cases like 'again' where we've subbed in the prior turn's input
    this_turn.input = unparsed_input;

    this_turn.output_class = output_class;

    // if we're parsing compound input aka stacked commands,
    // we want to carry a record of string replacements
    // for later reference
    this_turn.replacements = Object.assign(
      this_turn.replacements,
      carried_input.replacements
    );

    if (carried_input.unparsed_input) {
      this_turn.unparsed_input = carried_input.unparsed_input;
    } else {
      this_turn.unparsed_input = unparsed_input;
    }

    // print the preparsed input back to the player
    // this.game.printInput( A.deserialize(input) );
    // when printed here, prints for each queue item,
    // but including for "this and that" which I don't want

    // Handle quote delimited substrings in input.
    parsed_input = this.parseStrings(parsed_input);

    // join compound names into asset IDs
    // this was breaking on 'item but other item'
    // parsed_input = this.joinCompoundPhrases(parsed_input);

    // we're going to handle 'but' in a later step
    // so we temporarily split the string by 'but'
    let but_arr = parsed_input.split(" but ");
    let but_str = "";
    for (let i = 0; i < but_arr.length; i++) {
      but_str += this.joinCompoundPhrases(but_arr[i]);
      if (i < but_arr.length - 1) but_str += " but ";
    }
    parsed_input = but_str;

    // strip out articles
    parsed_input = this.stripArticles(parsed_input);

    // join some common compound prepositions into single words
    parsed_input = this.joinCompoundPrepositions(parsed_input);

    // join some common compound verbs into single words
    parsed_input = this.joinCompoundVerbs(parsed_input);

    // strip conjunctions and convert them into symbols we can handle
    parsed_input = this.stripConjunctions(parsed_input);

    // Done parsing input, save parsed_input to the global input object.
    this_turn.parsed_input = parsed_input;

    // Split input into an array of individual words.
    var parsed_input_array = parsed_input.split(" ");

    // Save the input array to the global object.
    this_turn.parsed_input_array = parsed_input_array;

    /* *
     * Each of the "compressVerb" functions can write to input_verb
     * but if verb was just one word, it won't have been saved yet,
     * and we may want to send to handleWord. But it's possible
     * that player is replying to a soft prompt and hasn't entered
     * a verb, so first let's verify whether the first word is in
     * fact a verb.
     */
    if (!this_turn.input_verb) {
      var parsedVerb = this.parseVerb(parsed_input_array[0]);

      // recognize it as a verb, save it
      if (parsedVerb) {
        this_turn.input_verb = parsed_input_array[0];
      } else if (last_turn.soft_prompt.noun1) {
        // last turn prompted for a word so assume we're recyling last turn's verb
        parsed_input_array.unshift(last_turn.getVerb());
        parsed_input = this.input_history[1].parsed_input + " " + parsed_input;
        this_turn.parsed_input = parsed_input;
        parsed_input_array = parsed_input.split(" ");
        this_turn.parsed_input_array = parsed_input_array;
      }
    }

    // for use in cases of number prompts
    var isWordNumber =
      null !== last_turn.disambiguate.index &&
      !isNaN(Number(parsed_input_array[0]));

    // IS INPUT USEABLE?
    // We can't do anything with the input.
    if (
      1 === parsed_input_array.length &&
      "" === parsed_input_array[0] &&
      false === isWordNumber
    ) {
      this.parseNoInput();
    }

    // valid one word inputs include intransitive verbs
    // such as look, inventory, and directions
    // we don't know that one of these has been input, but we can move forward
    else if (1 === parsed_input_array.length) {
      this_turn.found_word = parsed_input_array[0];
      this.handleWord();
    }

    // Parse the full sentence
    else {
      if (false === this.parseSentence()) return false;
      if (false === this.verifySentence()) return false;
      if (false === this.verifySentenceStructure()) return false;
      this.handleSentence();
    }

    // TODO special handling for say / ask / tell

    this.game.updateDisplayRoom();

    // If player used a period to input distinct actions,
    // perform the next one in the queue.
    if (this.input_queue.length > 0) {
      this.game.reactor.dispatchEvent(this.game.events.inputQueueNext);
      this.is_input_queued = true;
      this.parseInput(this.input_queue[0].input);
    } else {
      this.is_input_queued = false;
      //this.game.worldSave();
      this.game.reactor.dispatchEvent(this.game.events.inputParseComplete);
      return;
    }
  }; // parseInput
})();

// parseNoun.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Handle noun input.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#parseNoun
   * @param {String} word
   * @returns {adventurejs.parsedNoun}
   */
  p.parseNoun = function Parser_parseNoun(word) {
    this.game.log("log", "high", "parseNoun.js > BEGIN", "Parser");
    this.game.log("log", "high", "parseNoun.js received > " + word, "Parser");
    var currentRoom = this.game.getCurrentRoom();
    var lastTurn = this.input_history[1];

    /**
     * We're using the input word to create a parsedNoun
     * with properties needed by logic down the road.
     */
    var parsedNoun = new adventurejs.ParsedNoun();
    parsedNoun.input = word;
    parsedNoun.serialized_input = A.serialize(word);
    parsedNoun.deserialized_input = A.deserialize(word);

    // player can enter "it" to refer to last turn's direct object
    if (
      "it" === word &&
      lastTurn &&
      lastTurn.parsedNoun1 &&
      lastTurn.parsedNoun1.qualified_object_id
    ) {
      word = lastTurn.parsedNoun1.qualified_object_id;
    }

    /*
     * Does the input word match a direction?
     * getDirection converts shortcuts to full name,
     * eg ne to northeast
     * and returns the full name as a string.
     */
    var direction = this.dictionary.getDirection(word);
    if (direction) {
      // save the direction string to matches object
      parsedNoun.matches.direction = direction;
    }

    var asset = this.game.getAsset(word);
    if (asset && asset instanceof adventurejs.Substance) {
      // save the substance id to matches object
      parsedNoun.matches.substance = asset.id;
    }

    /**
     * Noun is direction and room has an exit in that direction.
     */
    if (direction && "undefined" !== typeof currentRoom.exits[direction]) {
      // save the room's direction object id to matches object
      // TODO have we confirmed the room has a direction there?
      // console.log("*** currentRoom.exits", currentRoom.exits);
      var exitID = currentRoom.exits[direction];
      parsedNoun.matches.all.push(exitID);
      parsedNoun.matches.qualified.push(exitID);
      //parsedNoun.matches.direction = direction;
      parsedNoun.qualified_object_id = exitID;
    } else if (
      /**
       * Noun is direction and room does not have an exit in that direction.
       * Get global direction object.
       */
      direction &&
      "undefined" === typeof currentRoom.exits[direction]
    ) {
      // global direction
      parsedNoun.matches.all.push("global_" + direction);
      parsedNoun.matches.qualified.push("global_" + direction);
    } // direction

    // if player entered "all" as a noun, we're only looking at
    // the current room's contents
    else if ("all" === word) {
      parsedNoun.matches.all = currentRoom.getAllNestedContents();
    } else if (1 === word.split("&").length && 1 === word.split("=").length) {
      /**
       * User did not ask for "this AND that"
       * and world_lookup search returned single ID string
       */
      parsedNoun.matches.all = this.game.parser.selectAll(word);
    } else if (1 < word.split("&").length || 1 < word.split("=").length) {
      /**
       * User asked for "this AND that"
       * or world_lookup search returned multiple IDs
       */
      /**
       * Multiple inputs come from player input such as:
       * "get brass key and silver key"
       */
      // console.log("=======================");
      // console.log("MULTIPLE INPUTS!!!");
      var multipleInput = word.split("&");
      for (var mI = 0; mI < multipleInput.length; mI++) {
        console.log(multipleInput);
        /**
         * Ambiguous inputs come from combineCompoundPhrases,
         * which searches world_lookup trying to match
         * player input with world objects.
         * It doesn't do disambiguation but just passes
         * along multiple values.
         *
         * Example:
         * brass_key=old_brass_key,new_brass_key,small_brass_key
         *
         * The item before the = is the original input.
         */
        var ambiguousInput = multipleInput[mI].split("=");
        if (1 === ambiguousInput.length) {
          parsedNoun.matches.all = parsedNoun.matches.all.concat(
            this.game.parser.selectAll(ambiguousInput[0]),
          );
          this.game.log(
            "log",
            "low",
            "parseNoun.js > Unambiguous match: " + ambiguousInput[0],
            "Parser",
          );
        } else {
          this.game.log(
            "log",
            "low",
            "parseNoun.js > Ambiguous matches:",
            "Parser",
          );
          var ambiguousMatches = ambiguousInput[1].split(",");
          parsedNoun.input = ambiguousInput[0];
          parsedNoun.serialized_input = ambiguousInput[0];
          parsedNoun.deserialized_input = A.deserialize(ambiguousInput[0]);

          for (var aM = 0; aM < ambiguousMatches.length; aM++) {
            var tempParsedNoun = this.game.parser.selectAll(
              ambiguousMatches[aM],
            );
            this.game.log(
              "log",
              "low",
              "parseNoun.js > tempParsedNoun: " + tempParsedNoun,
              "Parser",
            );
            for (var tPN = 0; tPN < tempParsedNoun.length; tPN++) {
              parsedNoun.matches.all.push(tempParsedNoun[tPN]);
            }
            this.game.log(
              "log",
              "low",
              "parseNoun.js > ambiguousMatches: " + ambiguousMatches[aM],
              "Parser",
            );
          } // for loop
        } // if( 1 === ambiguousInput.length )
      } // for loop
    } // else if

    // get an array of objects
    // we clone all -> qualified so that we can delete
    // unqualified objects but still keep a record of all found
    parsedNoun.matches.qualified = Object.assign([], parsedNoun.matches.all);

    if (0 === parsedNoun.matches.all.length) {
      // no objects this word, but it might be a direction
      return parsedNoun;
    }

    //console.error( 'parsedNoun.matches.all',parsedNoun.matches.all );
    // for( var i = 0; i < parsedNoun.matches.all.length; i++)
    // {
    //   if( word === parsedNoun.matches.all[i] )
    //   {
    //     parsedNoun.matches.all = [word];
    //     parsedNoun.matches.qualified = [word];
    //   }
    // }
    // console.error( 'parsedNoun.matches.all',parsedNoun.matches.all );

    if (1 === parsedNoun.matches.all.length) {
      // exact match! whoo hoo!
      // we still need to know if it's present/visible/reachable
      parsedNoun.matches.unambiguous = parsedNoun.matches.all[0];
    }

    //this.game.log( "log", "high", [ "parseNoun.js > matches.all > " + parsedNoun.matches.all ] , 'Parser' );

    /**
     * Is the input word plural?
     * Bearing in mind that we might have received
     * for example, the word "keys" which would simply mean "all keys"
     * or we might've received a compound string like
     * "grass_keys=red_grass_key,green_grass_key,blue_grass_key"
     */
    var lookup = this.game.world_lookup[parsedNoun.deserialized_input];
    if ("undefined" !== typeof lookup) {
      parsedNoun.type = lookup.type;
      if ("singular" === parsedNoun.type) {
        parsedNoun.plural = lookup.plural;
      }
      if ("plural" === lookup.type) {
        parsedNoun.isPlural = true;
        parsedNoun.singular = lookup.singular;
      }
      if ("group" === lookup.type) {
        parsedNoun.isGroup = true;
        parsedNoun.singular = lookup.singular;
      }
    }
    //if( -1 < word.indexOf( "=" ) ) {
    //  parsedNoun.plural = true;
    //}

    this.game.log(
      "log",
      "high",
      "parseNoun.js > returns matches.qualified: " +
        parsedNoun.matches.qualified,
      "Parser",
    );
    this.game.log("log", "high", "parseNoun.js > END", "Parser");
    //console.warn( parsedNoun );
    return parsedNoun;
  };
})();

// parseSentence.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Parse each word in a sentence.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#parseSentence
   * @TODO Will eventually need to look for "person, do thing"
   * or "tell person to do thing"
   */
  p.parseSentence = function Parser_parseSentence() {
    var this_turn = this.input_history[0];
    this.game.log(
      "log",
      "high",
      "parseSentence.js > " + this_turn.input,
      "Parser"
    );

    let last_word_type;
    let last_word;
    let firstverb;
    let count = {
      noun: 0,
      prep: 0,
      verb: 0,
      adverb: 0,
      adjective: 0,
      direction: 0,
      exclusion: 0,
      unknown: 0,
      string: 0,
      phrase: 0,
    };

    for (
      let position_in_parsed_input = 0;
      position_in_parsed_input < this_turn.parsed_input_array.length;
      position_in_parsed_input++
    ) {
      let word = this_turn.parsed_input_array[position_in_parsed_input];

      let verb = this.parseVerb(word);

      let adverb = this.game.dictionary.getAdverb(word);

      let direction = this.game.dictionary.getDirection(word);
      let compass_direction =
        direction && this.game.dictionary.verbs[word].is_compass_direction;
      let spatial_direction =
        direction && this.game.dictionary.verbs[word].is_spatial_direction;
      let parsed_direction = direction && this.parseNoun(direction);

      let preposition = this.game.dictionary.getPreposition(word);

      let string = word === "global_string" ? word : false;

      let noun =
        this.parseNoun(word).matches.all.length > 0 ||
        word.indexOf("&") > -1 ||
        word.indexOf("=") > -1 ||
        "undefined" !== typeof adventurejs[A.propercase(word)];

      let exclusion = word.charAt(0) === "-";

      let number = !isNaN(Number(word)) ? word : false;

      let adjective = this.game.dictionary.getAdjective(word);

      let properties = {
        word: word,
        verb: verb,
        direction: direction,
        compass_direction: compass_direction,
        spatial_direction: spatial_direction,
        parsed_direction: parsed_direction,
        preposition: preposition,
        string: string,
        noun: noun,
        exclusion: exclusion,
        number: number,
        adjective: adjective,
      };

      //this.game.print(
      //  `F1191 | parseSentence.js | \n<br/> - word/ ${word}\n<br/> - verb/ ${verb}\n<br/> - direction/ ${direction}\n<br/> - preposition/ ${preposition}\n<br/> - adverb/ ${adverb}\n<br/> - number/ ${number}\n<br/> - string/ ${string}\n<br/> - noun/ ${noun}`
      //);

      if (noun && exclusion) {
        // both have & in them, get caught by noun check
        // but only exclusion has the leading -
        noun = false;
      }

      // Handle type-of-word ambiguities.
      // Any direction can be a verb.
      // Check position in sentence:
      // - if it's the first word, it's a verb
      // - if it's the second word, it's a direction
      // Directions that are not verbs can be treated like nouns.
      // Later during verification we'll check if direction is a preposition.

      if (verb && direction && preposition) {
        // this catches 'in' and 'out', which are defined as direction
        // verbs in addition to being prepositions
        // @TODO 2/4/24 it can be used to catch 'up' and 'down'
        // if 'up' and 'down' are added to dictionary.prepositions
        // currently evaluating that
        if (position_in_parsed_input === 0) {
          // almost certainly a verb
          direction = false;
          preposition = false;
        } else if (position_in_parsed_input === 1) {
          // could be "go in" - direction and preposition
          // could be "look in" or "put in" - prepositions
          // treat it like a preposition and let verbs handle it
          verb = false;
          direction = false;
        } else {
          // probably preposition
          verb = false;
          direction = false;
        }
      }

      // not parsing adverbs currently but keep this for future
      // if( verb && direction && adverb )
      // {
      //   // this catches 'up' and 'down', which are
      //   // defined as direction verbs and are also adverbs
      //   if( position_in_parsed_input === 0 )
      //   {
      //     // almost certainly a verb
      //     direction = false;
      //     adverb = false;
      //     noun = false;
      //   }
      //   else if ( position_in_parsed_input === 1 || last_word_type === 'verb' )
      //   {
      //     // could be "go up" - direction and adverb
      //     // could be "look up" or "put up" - adverbs
      //     // treat it like an adverb and let verbs handle it
      //     verb = false;
      //     direction = false;
      //     noun = false;
      //   }
      //   else
      //   {
      //     // in the case of a phrase like "throw ball up",
      //     // up would be an adverb
      //     // in the case of a phrase like "throw ball up the stairs",
      //     // up would be a preposition
      //     // at this moment we don't know which, so treat it like a direction
      //     // which is to say, a noun
      //     verb = false;
      //     adverb = false;
      //   }
      // }

      if (verb && noun && direction) {
        // this catches most directions
        if (position_in_parsed_input === 0) {
          // almost certainly a verb
          direction = false;
          noun = false;
        } else {
          // if it's a verb and a direction, but not an adverb
          // or a preposition, treat it as a noun
          // as in "go north" or "look north"
          direction = false;
          verb = false;
        }
      }

      if (verb && noun) {
        // consider the verb plug and the noun plug
        if (position_in_parsed_input === 0) {
          noun = false;
        } else {
          verb = false;
        }
      }

      if (verb && direction) {
        if (position_in_parsed_input === 0) {
          direction = false;
        } else {
          verb = false;
        }
      }

      if (verb && preposition) {
        if (position_in_parsed_input === 0) {
          preposition = false;
        } else {
          verb = false;
        }
      }

      /* verb ---------------------------------------- OK */

      if (verb) {
        this.game.log("log", "high", "parseInput > verb: " + verb, "Parser");
        if (count.verb === 0) firstverb = verb;
        count.verb++;
        this_turn.pushParsedWord({
          type: "verb",
          word: verb,
          properties: properties,
        });

        last_word_type = "verb";
        last_word = word;
        continue;
      }

      /* adverb ---------------------------------------- */

      // not parsing adverbs for now but keep this for later
      // this block was a git copilot auto-complete and needs to be checked before implementing
      // if( adverb )
      // {
      //   this.game.log( "log", "high", "parseInput > adverb: " + adverb, 'Parser' );
      //   count.adverb++;
      //   count.phrase++;
      //   this_turn.pushParsedWord({
      //     type:'adverb',
      //     word: adverb,
      //     properties: properties,
      //   });

      //  last_word_type = 'adverb';
      //  last_word = word;
      //  continue;
      // }

      // distinguish directions from nouns,
      // but also allow directions to be used as nouns

      /* direction ---------------------------------------- */

      if (direction) {
        this.game.log(
          "log",
          "high",
          "parseInput > direction: " + direction,
          "Parser"
        );
        count.direction++;
        count.phrase++;
        this_turn.pushParsedWord({
          type: "direction",
          word: direction,
          properties: properties,
        });

        last_word_type = "direction";
        last_word = word;
        continue;
      }

      /* preposition ---------------------------------------- OK */

      if (preposition) {
        // it's recognized as a preposition
        this.game.log(
          "log",
          "high",
          "parseInput > preposition: " + word,
          "Parser"
        );
        count.prep++;
        count.phrase++;

        // store the typed words in their original order
        this_turn.pushParsedWord({
          type: "preposition",
          word: word,
          phrase: count.phrase,
          properties: properties,
        });

        last_word_type = "preposition";
        last_word = word;
        continue;
      }

      /* string ---------------------------------------- */

      // if( string )
      // {
      //   // it's a string, but we're not handling them that way yet
      //   this_turn.pushParsedWord( { type:'string',this_turn.parsed_input_array[position_in_parsed_input] } );
      //   // save it as a string or continue to save it as a noun?
      // }

      /* noun ---------------------------------------- */

      if (noun) {
        // Treat it like a noun. We do more checks later to see
        // if it's unknown, and if it's not we want to soft prompt
        // for "oops"
        this.game.log("log", "high", "parseInput > noun: " + word, "Parser");

        count.noun++;

        this_turn.pushParsedWord({
          type: "noun",
          word: word,
          preposition: null,
          properties: properties,
          adjective: adjective,
        });

        last_word_type = "noun";
        last_word = word;
        continue;
      }

      /* exclusion ---------------------------------------- */

      if (exclusion) {
        // it's an exclusionary noun, like "take all but thing"
        // the last noun will be the one we want to exclude from

        this.game.log(
          "log",
          "high",
          "parseInput > exclude noun: " + word,
          "Parser"
        );

        // remove the leading '-' which has done its job
        word = word.slice(1);

        if (last_word_type === "noun") {
          let l = this_turn.parsed_sentence.length - 1;
          this_turn.parsed_sentence[l].exclusion = word;
        } else {
          // this should not happen
          this_turn.pushParsedWord({
            type: "exclusion",
            word: word,
            properties: properties,
          });
        }
        // END BLOCK

        last_word_type = "exclusion";
        last_word = word;
        continue;
      }

      /* number ---------------------------------------- */

      if (number) {
        // it's a number
        this.game.log("log", "high", "parseInput > number: " + word, "Parser");
        count.number++;
        count.phrase++;
        // store the typed words in their original order
        this_turn.pushParsedWord({
          type: "number",
          word: word,
          properties: properties,
        });

        last_word_type = "number";
        last_word = word;
        continue;
      }

      /* adjective ---------------------------------------- */

      if (adjective) {
        // it's an adjective
        this.game.log(
          "log",
          "high",
          "parseInput > adjective: " + word,
          "Parser"
        );
        count.adjective++;
        this_turn.pushParsedWord({
          type: "adjective",
          word: word,
          properties: properties,
        });

        last_word_type = "adjective";
        last_word = word;
        continue;
      }

      /* unknown ---------------------------------------- */

      // it's unknown
      this.game.log("log", "high", "parseInput > unknown: " + word, "Parser");
      last_word_type = "unknown";
      this_turn.pushParsedWord({
        type: "unknown",
        word: word,
        properties: properties,
      });

      last_word = word;
    } // for position_in_parsed_input loop

    return true;
  }; // parseSentence
})();

// parseStrings.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Look for "strings", meaning arbitrary 
   * quote delimited substrings that aren't meant 
   * to be parsed, and replace with the GlobalString 
   * placeholder class.
   * <br><br>
   * Example:<br>
   * type "foo" on keyboard<br>
   * Becomes:<br>
   * type global_string on keyboard<br>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#parseStrings
   * @param {String} input Player input.
   * @returns {String}
   */
   p.parseStrings = function Parser_parseStrings( input ) 
  {
    //this.game.log( "log", "medium", "parseStrings receive: " + input , 'Parser' );
    this.game.world.global_string.set({'values':[]});

    // originally only searched for double quotes
    //var re = /"(.*?)"/g; 

    // now search for both double and single quotes
    var re1 = /"(.*?)"/g; // search for double quotes
    var re2 = /'(.*?)'/g; // search for single quotes
    var reS = [ re1, re2 ];

    for( var i = 0; i < reS.length; i++ )
    {
      var current;
      var counter = 0;
      //while (current = re.exec(input)) 
      while (current = reS[i].exec(input)) 
      {
        this.game.log( "log", "high", "parseStrings > found quoted substring " + counter + ": " + current[0], 'Parser' );
        input = input.replace( current[0], "global_string" );
        this.game.getInput().strings.push( current[0] );
        this.game.world.global_string.values.push( current[0] );
        counter++;
      }    
    }  

    this.game.log( "log", "high", "parseInput.js > parseStrings return: " + input, 'Parser' );
    return input;
  
  }

}());

// parseVerb.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Handle verb input. Verify a string against dictionary verbs. 
   * If string is a verb alias (ex: 'look at' is an alias for 'examine'), 
   * replace it with the primary verb.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#parseVerb
   * @param {String} verb One word from input string.
   * @returns {String}
   */
   p.parseVerb = function Parser_parseVerb( verb ) 
  {
		//console.log( "parseVerb",verb );
    var keys = Object.keys( this.dictionary.verbs );
    for( var i = 0; i < keys.length; i++) 
    {
      if( this.dictionary.testVerbSynonyms( verb, keys[i] ) ) 
      {
        return this.dictionary.verbs[ keys[i] ].name;
      }
    }
    return false;
	}

}());

// printNounDisambiguation.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   *
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#printNounDisambiguation
   * @param {Object} params
   */
  p.printNounDisambiguation = function Parser_printNounDisambiguation(params) {
    var parsedNoun = params.parsedNoun;
    var nounIndex = params.nounIndex;
    var output_class = "";
    var definite_names = [];
    var names = [];
    //console.warn( "parsedNoun",parsedNoun );

    // is parsedNoun plural?
    // and we need the singular form?

    var msg = "Which did $(we) mean? ";
    //+ parsedNoun.deserialized_input
    //+ ("undefined" !== typeof parsedNoun.singular ? parsedNoun.singular : "")

    // present choices in ordered list
    if (this.game.settings.show_disambiguation_as_ordered_list) {
      msg += "<ol>";
      for (var i = 0; i < parsedNoun.matches.qualified.length; i++) {
        msg += "<li>";
        msg +=
          " the " + this.game.getAsset(parsedNoun.matches.qualified[i]).name;
        msg += "</li>";
      }
      msg += "</ol>";
    }
    // present choices in paragraph
    else {
      for (var i = 0; i < parsedNoun.matches.qualified.length; i++) {
        var asset = this.game.getAsset(parsedNoun.matches.qualified[i]);
        var name = asset.name;
        var definite_name = asset.definite_name;

        if (i === parsedNoun.matches.qualified.length - 1) {
          msg += "or ";
        }

        if (this.game.settings.show_disambiguation_as_numbered_paragraph) {
          msg += `<span class='choice'>${i + 1}) </span>`;
        }

        names.push(name);
        definite_names.push(definite_name);

        if (i === 0) {
          definite_name = A.propercase(definite_name);
        }
        msg += definite_name;

        if (i < parsedNoun.matches.qualified.length - 1) {
          msg += ", ";
        }

        if (i === parsedNoun.matches.qualified.length - 1) {
          msg += "? ";
        }
      }
    }

    // save for next turn disambiguation
    this.input_history[0].setDisambiguate({
      ["noun" + nounIndex]: true,
      index: nounIndex,
      //names: names,
      //definite_names: definite_names,
    });

    if (msg) this.game.print(msg, output_class);
    return;
  };
})();

// qualifyParsedNoun.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Exclude nouns found by parseNoun that don't meet qualifications for verb found by parseVerb.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#qualifyParsedNoun
   * @param {Object} params
   * @returns {adventurejs.parsedNoun}
   */
  p.qualifyParsedNoun = function Parser_qualifyParsedNoun(params) {
    this.game.log("log", "high", "qualifyParsedNoun.js > BEGIN", "Parser");
    //console.warn( "qualifyParsedNoun params: ", params );
    var input = this.game.getInput();
    var parsedNoun = params.parsedNoun;
    var parsedVerb = params.parsedVerb;
    var nounIndex = params.nounIndex;
    var player = this.game.getPlayer();
    var output_class = "";
    // var roomObjects = this.game.getCurrentRoom().getListableContents();
    // var playerObjects = player.getListableContents();
    var msg = "";
    var prettyverb = this.dictionary.verbs[parsedVerb].prettyname;

    var i, index, query, msg;
    var mustBe =
      this.dictionary.verbs[parsedVerb]["phrase" + nounIndex].noun_must_be;

    if (mustBe.known) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.known receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      let qualified_id, unparsed_input;
      if (1 === parsedNoun.matches.qualified.length) {
        qualified_id = parsedNoun.matches.qualified[0];
      }
      parsedNoun.matches.qualified = this.selectKnown(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        /**
         * Try to get original player input for this object.
         * Player might have entered a partial name for this.
         * Since player doesn't know this object, if they input
         * a partial name, we might accidentally reveal too
         * much information if we return the full name.
         * ex player asks for "sword" and we return "cursed bronze sword"
         * Now player knows there is a cursed bronze sword.
         */
        if ("undefined" !== typeof qualified_id) {
          unparsed_input =
            this.game.getInput().replacements[qualified_id].source;
        }
        if ("undefined" !== typeof unparsed_input) {
          this.game.debug(
            `F1056 | qualifyParsedNoun.js | ${parsedVerb} phrase ${nounIndex}.noun.mustBe.known`
          );
          msg += `$(We) don't know of any ${unparsed_input}. `;
        } else {
          this.game.debug(
            `F1057 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.known`
          );

          // This response doesn't read well if player has asked for a substance.
          // msg += "$(We) don't know of anything matching that description. ";

          // This response is a little too anonymous.
          // msg += "$(We) don't see any of that here. ";

          // This response is sketchy because player input might have been substituted
          // with a list of possible matches.
          msg += `$(We) don't know of any ${A.deserialize(parsedNoun.input)}. `;
        }
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none known ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > known " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.present) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.present receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      let qualified_id, unparsed_input;
      if (1 === parsedNoun.matches.qualified.length) {
        qualified_id = parsedNoun.matches.qualified[0];
      }
      parsedNoun.matches.qualified = this.selectPresent(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        if (!parsedNoun.matches.qualified.length) {
          this.game.debug(
            `F1067 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.present`
          );
          // try to get original player input for this object
          if ("undefined" !== typeof qualified_id) {
            unparsed_input =
              this.game.getInput().replacements[qualified_id].source;
          }
          if ("undefined" !== typeof unparsed_input) {
            msg += `There doesn't appear to be any ${unparsed_input} present. `;
          } else {
            msg += `There doesn't appear to be any ${parsedNoun.deserialized_input} present. `;
          }
        }
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none present ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > present " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.present_if_tangible) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.present receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      let qualified_id, unparsed_input;

      if (!parsedNoun.matches.qualified.length) {
        qualified_id = parsedNoun.matches.qualified[0];
      }

      parsedNoun.matches.qualified = this.selectPresentIfTangible(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        if (!parsedNoun.matches.qualified.length) {
          this.game.debug(
            `F1596 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.present_if_tangible`
          );
          // try to get original player input for this object
          if ("undefined" !== typeof qualified_id) {
            unparsed_input =
              this.game.getInput().replacements[qualified_id].source;
          }
          if ("undefined" !== typeof unparsed_input) {
            msg += `There doesn't appear to be any ${unparsed_input} present. `;
          } else {
            msg += `There doesn't appear to be any ${parsedNoun.deserialized_input} present. `;
          }
        }
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none present_if_tangible ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > present " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.direction) {
      if (false === parsedNoun.matches.direction) {
        this.game.debug(
          `F1054 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.direction`
        );
        msg += `It appears that $(we) meant to specify a direction, but that wasn't recognized as such. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none direction ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > direction " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.not_direction) {
      if (parsedNoun.matches.direction) {
        this.game.debug(
          `F1055 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_direction`
        );
        msg += `$(We) can't ${prettyverb} a direction. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_direction ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_direction " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.not_global) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_global receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotGlobal(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1058 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_global`
        );
        msg += `$(We) can't ${input.input}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_global ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_global " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.not_scenery) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_scenery receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotScenery(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1059 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_scenery`
        );
        msg += `$(We) can't ${input.input}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_scenery ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_scenery " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.not_exit) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_exit receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotExit(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1060 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_exit`
        );
        msg += `$(We) can't ${input.input}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_exit ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_exit " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.intangible) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.intangible receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectIntangible(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1061 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.intangible`
        );
        msg += `No intangible "${parsedNoun.deserialized_input}" to ${prettyverb}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none intangible ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > intangible " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.not_substance) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_substance receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotSubstance(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1062 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_substance`
        );
        msg += `$(We) need to specify a source. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_substance ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_substance " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.matter) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.matter receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectMatter(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1534 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.matter`
        );
        msg += `$(We) can't ${prettyverb} ${parsedNoun.deserialized_input}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none matter ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > matter " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.tangible) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.tangible receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectTangible(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1063 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.tangible`
        );
        msg += `$(We) don't see any ${parsedNoun.deserialized_input} to ${prettyverb}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none tangible ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > tangible " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    // if(mustBe.tangible_or_substance)
    // {
    //   this.game.log( "log", "high", "qualifyParsedNoun.js > mustBe.tangible_or_substance receives: " + parsedNoun.matches.qualified , 'Parser' );
    //   parsedNoun.matches.qualified = this.selectTangibleOrSubstance( parsedNoun.matches.qualified );
    //   if( !parsedNoun.matches.qualified.length )
    //   {
    //     this.game.debug(` | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.tangible_or_substance`);
    //     msg += `$(We) don't see any "${parsedNoun.deserialized_input}" $(we) can ${this.dictionary.verbs[ parsedVerb ].prettyname}. `;
    //     if(msg) this.game.print( msg, output_class );
    //     this.game.log( "log", "high", "qualifyParsedNoun.js > none tangible_or_substance " , 'Parser' );
    //     return false;
    //   }
    //   this.game.log( "log", "high", "qualifyParsedNoun.js > tangible_or_substance " + parsedNoun.matches.qualified , 'Parser' );
    // }

    if (mustBe.global_substance) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.global_substance receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectGlobalSubstance(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1064 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.global_substance`
        );
        msg += `$(We) can't ${prettyverb} that. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none global_substance ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > tangible " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.substance) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.substance receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectSubstance(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1065 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.substance`
        );
        msg += `$(We) can't ${prettyverb} that. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none substance ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > substance " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.character) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.character receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      let qualified_id;
      if (1 === parsedNoun.matches.qualified.length)
        qualified_id = parsedNoun.matches.qualified[0];
      parsedNoun.matches.qualified = this.selectCharacter(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1066 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.character`
        );

        let prep = this.game.getInput().getPreposition(nounIndex) || "";
        let dobj = "";
        if (nounIndex === 2)
          dobj = this.game.getInput().getAsset(1)?.articlename || "";
        if ("undefined" !== typeof qualified_id) {
          msg += `$(We) can't ${prettyverb} ${dobj} ${prep} ${
            this.game.getAsset(qualified_id).articlename
          }. `;
        }
        // otherwise offer generic response
        else {
          msg += `$(We) don't know of anyone named "${parsedNoun.deserialized_input}". `;
        }

        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none character",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > character " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.player_parent) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.player_parent receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      let qualified_id;
      if (1 === parsedNoun.matches.qualified.length)
        qualified_id = parsedNoun.matches.qualified[0];
      parsedNoun.matches.qualified = this.selectPlayerParent(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1069 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.player_parent`
        );
        // if we'd already narrowed qualified list down to
        // one object we can use its name in the response
        if ("undefined" !== typeof qualified_id) {
          msg += `$(We're) not on ${
            this.game.getAsset(qualified_id).articlename
          }. `;
        }
        // otherwise offer generic response
        else {
          msg += `$(We're) not on that. `;
        }
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none player_parent ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > player_parent " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.not_player_parent) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_player_parent receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotPlayerParent(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1071 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_player_parent`
        );
        // if there was one unambiguous reference to parent
        // we can use its name in the response
        if (parsedNoun.matches.unambiguous) {
          msg += `$(We're) already on ${
            this.game.world[parsedNoun.matches.unambiguous].articlename
          }. `;
        }
        // otherwise offer generic response
        else {
          msg += `$(We're) already on that. `;
        }
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_player_parent ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_player_parent " +
          parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.singular) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.singular receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectSingular(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1073 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.singular`
        );
        msg += `$(We'll) have to do that one at a time. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none singular ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > singular " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.in_inventory_if_takeable) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.in_inventory_if_takeable receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      let qualified_id;
      if (1 === parsedNoun.matches.qualified.length)
        qualified_id = parsedNoun.matches.qualified[0];
      parsedNoun.matches.qualified = this.selectInInventoryIfTakeable(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1074 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.in_inventory_if_takeable`
        );
        if ("undefined" !== typeof qualified_id) {
          var object = this.game.world[qualified_id];
          msg += `$(We're) not carrying ${object.articlename}. `;
        } else {
          let it = parsedNoun.deserialized_input;
          msg += `$(We're) not carrying any${
            it === "all" ? "thing" : " " + it
          }. `;
        }

        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none in_inventory_if_takeable ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > in_inventory_if_takeable " +
          parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.in_inventory) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.in_inventory receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      let qualified_id;
      if (1 === parsedNoun.matches.qualified.length)
        qualified_id = parsedNoun.matches.qualified[0];
      parsedNoun.matches.qualified = this.selectInInventory(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1075 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.in_inventory`
        );
        if ("undefined" !== typeof qualified_id) {
          var object = this.game.world[qualified_id];
          msg += `$(We're) not carrying ${object.articlename}. `;
        } else {
          let it = parsedNoun.deserialized_input;
          msg += `$(We're) not carrying any${
            it === "all" ? "thing" : " " + it
          }. `;
        }

        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none in_inventory ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > in_inventory " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.in_hands) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.in_hands receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectInHands(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1076 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.in_hands`
        );
        msg += `$(We're) not holding any ${parsedNoun.deserialized_input}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none in_hands ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > in_hands " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.not_in_hands) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_in_hands receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotInHands(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1077 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_in_hands`
        );
        msg += `$(We're) carrying the ${parsedNoun.deserialized_input}. `;

        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_in_hands ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_in_hands " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.held) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.held receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectHeld(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1716 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.held`
        );
        msg += `$(We're) not holding any ${parsedNoun.deserialized_input}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none held ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > held " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.not_in_inventory) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_in_inventory receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotInInventory(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1078 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_in_inventory`
        );
        msg += `$(We're) carrying the ${parsedNoun.deserialized_input}. `;

        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_in_inventory ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_in_inventory " +
          parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.worn) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.worn receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectWorn(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1079 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.worn`
        );
        msg += `$(We're) not wearing any ${parsedNoun.deserialized_input}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none is.worn ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > is.worn " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.not_worn) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_worn receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotWorn(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1080 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_worn`
        );
        msg += `$(We're) wearing the ${parsedNoun.deserialized_input}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_worn ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_worn " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if ("all" === parsedNoun.input && mustBe.not_worn_if_all) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_worn_if_all receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotWornIfAll(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1081 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_worn_if_all`
        );
        msg += `$(We're) not carrying anything. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_worn_if_all ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_worn_if_all " +
          parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if ("all" === parsedNoun.input && mustBe.not_nested_inventory_if_all) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.not_nested_inventory_if_all receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectNotNestedInventoryIfAll(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1082 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.not_nested_in_inventory_if_all`
        );
        msg += `$(We're) not carrying anything. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none not_nested_inventory_if_all ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > not_nested_inventory_if_all " +
          parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.visible) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.visible receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectVisible(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1083 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.visible`
        );
        msg += `$(We) can't see any ${parsedNoun.deserialized_input}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none visible ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > visible " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.reachable) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.reachable receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectReachable(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1084 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.reachable`
        );
        msg += `$(We) can't reach the ${parsedNoun.deserialized_input}`;
        if (player.isNested()) {
          msg += ` from your position ${player.getPostureGerund()} ${player.getNestPreposition()} ${
            player.getNestAsset().articlename
          }`;
        } else if (player.posture !== "stand") {
          msg += ` while ${player.getPostureGerund()}`;
          msg += `${player.isOnFloor() ? " on the floor" : ""}`;
        }
        msg += `. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none reachable ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > reachable " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.reachable_if_tangible) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.reachable_if_tangible receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectReachableIfTangible(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1176 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.reachable`
        );
        msg += `$(We) can't reach the ${parsedNoun.deserialized_input}`;
        if (player.isNested()) {
          msg += ` from your position ${player.getPostureGerund()} ${player.getNestPreposition()} ${
            player.getNestAsset().articlename
          }`;
        }
        msg += `. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none reachable ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > reachable_if_tangible " +
          parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.takeable) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.takeable receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectTakeable(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length && "all" === parsedNoun.input) {
        this.game.debug(
          `F1085 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.takeable`
        );
        msg += `There's nothing takeable in reach. `;
        this.game.print(msg, output_class);
        return false;
      }
      if (!parsedNoun.matches.qualified.length) {
        var thatOrThem = "that";
        if (parsedNoun.input.split("&").length > 1) {
          thatOrThem = "them";
        }
        if (parsedNoun.isPlural || parsedNoun.isGroup) {
          thatOrThem = "them";
        }
        this.game.debug(
          `F1086 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.takeable`
        );
        msg += `$(We) can't take ${thatOrThem}. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none takeable ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > takeable " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    if (mustBe.extant) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > mustBe.extant receives: " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.matches.qualified = this.selectExtant(
        parsedNoun.matches.qualified
      );
      if (!parsedNoun.matches.qualified.length) {
        this.game.debug(
          `F1310 | qualifyParsedNoun.js | ${parsedVerb} phrase${nounIndex}.noun.mustBe.extant`
        );
        msg += `Was there any ${parsedNoun.deserialized_input}? $(We) can't recall. `;
        this.game.print(msg, output_class);
        this.game.log(
          "log",
          "high",
          "qualifyParsedNoun.js > none visible ",
          "Parser"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > known " + parsedNoun.matches.qualified,
        "Parser"
      );
    }

    // check qualified for exact match(es)
    if (1 < parsedNoun.matches.qualified.length) {
      var exactMatches = [];
      for (i = 0; i < parsedNoun.matches.qualified.length; i++) {
        var object = this.game.getAsset(parsedNoun.matches.qualified[i]);
        if (object.id === parsedNoun.serialized_input) {
          exactMatches.push(object.id);
          continue;
        }
        for (var s = 0; s < object.synonyms.length; s++) {
          if (object.synonyms[s] === parsedNoun.serialized_input) {
            exactMatches.push(object.id);
            continue;
          }
        }
      }
      // copy exactMatches back to qualified
      if (0 < exactMatches.length) {
        parsedNoun.matches.qualified = exactMatches.splice(0);
      }
    }

    // can we narrow by class?
    var ajsclass = A.propercase(parsedNoun.serialized_input.toLowerCase());
    if (1 < parsedNoun.matches.qualified.length && adventurejs[ajsclass]) {
      var classMatches = [];
      for (i = 0; i < parsedNoun.matches.qualified.length; i++) {
        var object = this.game.getAsset(parsedNoun.matches.qualified[i]);
        if (object instanceof adventurejs[ajsclass]) {
          classMatches.push(object.id);
          continue;
        }
      }
      // copy classMatches back to qualified
      if (0 < classMatches.length) {
        parsedNoun.matches.qualified = classMatches.splice(0);
      }
    }

    /**
     *
     * If there are multiple qualified, check them all
     * for verb_hooks methods.
     *
     * If present, move them to the end of the queue.
     * This is to minimize the chances of awkward output on
     * interacting with multiple objects, for example:
     * "You take x. You take y. Oh no, taking y
     * transported you to the nether realms! You take z."
     *
     * It's possible that an author might want control over
     * this, so for instance picking up an explosive
     * preceeds all other things. Author can swap order.
     *
     * Set with:
     * game.settings.move_verb_hooks_to_end_of_queue
     */
    // @TODO this block no longer works since moving verb_hooks into verb subscriptions
    // if( 1 < parsedNoun.matches.qualified.length
    // && this.game.settings.enqueue_assets_with_verb_hooks.order === 1 )
    // {
    //   for( i = parsedNoun.matches.qualified.length - 2; i > -1; i--)
    //   {
    //     var asset = this.game.getAsset( parsedNoun.matches.qualified[i] );
    //     if( asset && asset.verb_hooks[parsedVerb] )
    //     {
    //       parsedNoun.matches.qualified = parsedNoun.matches.qualified.concat(
    //         parsedNoun.matches.qualified.splice( i, 1 )
    //       );
    //     }
    //   }
    // }

    /**
     * Samesies, but moves objects with custom verb responses to
     * beginning of queue.
     *
     * Set with:
     * game.settings.move_verb_hooks_to_end_of_queue
     */
    // @TODO this block no longer works since moving verb_hooks into verb subscriptions
    // if( 1 < parsedNoun.matches.qualified.length
    // && this.game.settings.enqueue_assets_with_verb_hooks.order === -1 )
    // {
    //   for( i = parsedNoun.matches.qualified.length - 2; i > -1; i--)
    //   {
    //     var asset = this.game.getAsset( parsedNoun.matches.qualified[i] );
    //     if( asset && asset.verb_hooks[parsedVerb] )
    //     {
    //       parsedNoun.matches.qualified = parsedNoun.matches.qualified.concat(
    //         parsedNoun.matches.qualified.splice( i, 1 )
    //       );
    //     }
    //   }
    // }

    /**
     * If there's only one qualified match, we make a shortcut
     * reference at parsedNoun.qualified_object_id, mostly for use with
     * singular verbs.
     */
    parsedNoun.matches.qualifiedIndex = 0;
    if (1 === parsedNoun.matches.qualified.length) {
      this.game.log(
        "log",
        "high",
        "qualifyParsedNoun.js > found singular qualified " +
          parsedNoun.matches.qualified,
        "Parser"
      );
      parsedNoun.qualified_object_id = parsedNoun.matches.qualified[0];
    }

    this.game.log(
      "log",
      "high",
      "qualifyParsedNoun.js > return " + parsedNoun.matches.qualified,
      "Parser"
    );
    this.game.log("log", "high", "qualifyParsedNoun.js > END", "Parser");
    return parsedNoun;
  };
})();

// qualifyParsedVerb.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * End turn if input verb can't act upon noun or in current circumstance.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#qualifyParsedVerb
   * @param {Object} params
   * @returns {adventurejs.parsedVerb}
   */
  p.qualifyParsedVerb = function Parser_qualifyParsedVerb(params) {
    this.game.log("log", "high", "qualifyParsedVerb.js > Begin", "Parser");
    if (!params.parsed_verb_name) return false;
    let dictionary_verb = this.dictionary.verbs[params.parsed_verb_name];
    if (!dictionary_verb) return false;
    let player = this.game.getPlayer();
    let room = this.game.getCurrentRoom();
    let nest = player.getPlaceAspect();
    let output_class = "";

    let msg = "";
    let qualifiers = dictionary_verb.player_must_be;

    if (qualifiers.not_on_floor) {
      if (player.isOnFloor()) {
        this.game.debug(
          `F1878 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.not_on_floor `
        );
        msg +=
          "$(We) can't do that from $(our) position " +
          player.getPostureGerund() +
          " on the ";
        if (player.isNested()) {
          msg += player.getNestAsset().name;
        } else {
          msg += "floor";
        }
        msg += ". ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.not_constrained) {
      if (player.is.constrained) {
        this.game.debug(
          `F1879 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.not_constrained `
        );
        msg +=
          A.getSAF.call(this.game, player.constrained_msg) ||
          "$(We're) constrained. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.not_under) {
      // if(  ) {
      //   msg += "The verb \""
      //   + dictionary_verb.prettyname
      //   this.game.print( msg, output_class );
      //   return false;
      //}
    }

    if (qualifiers.not_behind) {
      // if(  ) {
      //   msg += "The verb \""
      //   + dictionary_verb.prettyname
      //   this.game.print( msg, output_class );
      //   return false;
      //}
    }

    if (qualifiers.not_nested_elsewhere) {
      // if(  ) {
      //   msg += "The verb \""
      //   + dictionary_verb.prettyname
      //   this.game.print( msg, output_class );
      //   return false;
      //}
    }

    if (qualifiers.able_to_crawl) {
      this.game.debug(
        `F1410 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_crawl `
      );
      if (
        !player.can.crawl ||
        !player.getNestOrPlaceAspect().player.can.crawl
      ) {
        msg += "$(We) can't crawl right now. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_float) {
      this.game.debug(
        `F1880 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_float `
      );
      if (
        !player.can.float ||
        !player.getNestOrPlaceAspect().player.can.float
      ) {
        msg += "$(We) can't float right now. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_fly) {
      this.game.debug(
        `F1881 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_fly `
      );
      if (!player.can.fly || !player.getNestOrPlaceAspect().player.can.fly) {
        msg += "$(We) can't fly right now. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_jump) {
      this.game.debug(
        `F1012 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_jump `
      );
      if (!player.can.jump || !player.getNestOrPlaceAspect().player.can.jump) {
        msg += "$(We) can't jump right now. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_hop) {
      this.game.debug(
        `F1020 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_hop `
      );
      if (!player.can.hop || !player.getNestOrPlaceAspect().player.can.hop) {
        msg += "$(We) can't hop right now. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_hover) {
      this.game.debug(
        `F1411 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_hover `
      );
      if (
        !player.can.hover ||
        !player.getNestOrPlaceAspect().player.can.hover
      ) {
        msg += "$(We) can't hover right now. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_ride) {
      this.game.debug(
        `F1318 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_ride `
      );
      if (!player.can.ride || !player.getNestOrPlaceAspect().player.can.ride) {
        msg += "$(We) can't ride right now. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_run) {
      this.game.debug(
        `F1316 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_run `
      );
      if (!player.can.run || !player.getNestOrPlaceAspect().player.can.run) {
        msg += "$(We) can't run here. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_slither) {
      this.game.debug(
        `F1877 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_slither `
      );
      if (
        !player.can.slither ||
        !player.getNestOrPlaceAspect().player.can.slither
      ) {
        msg += "$(We) can't slither right now. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_swim) {
      this.game.debug(
        `F1882 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_swim `
      );
      if (!player.can.swim || !player.getNestOrPlaceAspect().player.can.swim) {
        msg += "$(We) can't swim here. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    if (qualifiers.able_to_walk) {
      this.game.debug(
        `F1317 | qualifyParsedVerb.js | ${dictionary_verb.name}.player_must_be.able_to_walk `
      );
      if (!player.can.walk || !player.getNestOrPlaceAspect().player.can.walk) {
        msg += "$(We) can't walk here. ";
        this.game.print(msg, output_class);
        return false;
      }
    }

    return dictionary_verb;
  };
})();

// sanitizeInput.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <ul>
   * <li>toLowerCase()</li>
   * <li>strip trailing "."</li>
   * <li>replace tabs with spaces</li>
   * <li>trim()</li>
   * <li>reduce multiple spaces to single</li>
   * <li>replace " and then " with " then "</li>
   * <li>split by periods</li>
   * <li>split by "then"</li>
   * <li>check for "again"</li>
   * </ul>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#sanitizeInput
   * @param {String} parsed_input 
   * @param {String} unparsed_input 
   * @returns {Array} [string, string]
   */
   p.sanitizeInput = function Parser_sanitizeInput(parsed_input, unparsed_input) 
  {
    //this.game.log( "log", "high", "sanitizeInput.js > receive: " + parsed_input , 'Parser' );
    // hopefully no one wants to write a case-sensitive game
		parsed_input = parsed_input.toLowerCase();

		if(parsed_input[parsed_input.length-1] === ".") 
    {
			// strip trailing period
			parsed_input = parsed_input.slice(0, -1); 
		}

		// convert tabs to spaces
		parsed_input = parsed_input.replace(/\t/g, ' ');

    parsed_input = parsed_input.trim();

		// replace multiple spaces with single
		parsed_input = parsed_input.replace(/\s+/g, ' ');

    // replace " and then " with " then "
    parsed_input = parsed_input.replace(/ and then /g, ' then ');

    var periodArray = this.splitByPeriods(parsed_input);
		var thenArray = this.splitByThens(parsed_input);
		var pushArray = [];

    /**
     * We're assuming that phrases 
     * ending in periods might include 'then',
     * but that phrases joined by 'then' 
     * don't have internal periods.
     * 
     * Ex: 
     * Go north then take thing then drop thing.
     * vs:
     * Go North. Take thing then drop thing.
     * 
     * splitByPeriods recursively tries splitByThens,
     * but splitByThens doesn't try splitByPeriods.
     */
		if( periodArray.length > 1 ) 
    {
			pushArray = periodArray;
		}
		else if( thenArray.length > 1 ) 
    {
			pushArray = thenArray;
    }

    if( 0 === pushArray.length ) 
    {
      // single clause found, use input as is

      // did player enter "again" ?
      // if so, copy last turn into this turn
      if( this.game.dictionary.testVerbSynonyms( parsed_input, "again" ) ) 
      {
        //   var msg = "$(We) haven't done anything that bears repeating. ";
        //   if(msg) this.game.print( msg, "" );  
        //   return null;
        parsed_input = unparsed_input = this.game.parser.input_history[ 0 ].input;
      }
    }

		else if( pushArray.length > 0 ) 
    {
      // player entered multiple clauses

      // is first item in queue "again"?
      // replace with last turn
      if( this.game.dictionary.testVerbSynonyms( pushArray[0], "again" ) ) 
      {
        pushArray[0] = this.game.parser.input_history[ 0 ].input;
      }

      // is any other item in queue "again"?
      // replace with the turn preceding it in the queue
      for( var i = 1; i < pushArray.length; i++ )
      {
        if( this.game.dictionary.testVerbSynonyms( pushArray[i], "again" ) ) 
        {
          pushArray[i] = pushArray[i-1];
        }
      }

			// use the first one now
			parsed_input = unparsed_input = pushArray.shift();

      // queue up the rest for subsequent turns
      for( var i = 0; i < pushArray.length; i++ )
      {
        this.input_queue.push( { 
          input: pushArray[i], 
          printInput: true
        } );
      }
    }

    //this.game.log( "log", "high", "sanitizeInput.js > complete: " + parsed_input , 'Parser' );
    return [ parsed_input, unparsed_input ];
	}
}());

// selectAll.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Get all gettable assets in current room.
   * @method adventurejs.Parser#selectAll
   * @memberOf adventurejs.Parser
   * @param {String} word
   * @returns {Array}
   */
  p.selectAll = function Parser_selectAll(word) {
    this.game.log("log", "high", "selectAll.js > received: " + word, "Parser");

    var currentRoom = this.game.getCurrentRoom();

    if (typeof word !== "string") {
      console.warn("selectAll received non-string", word);
      return [];
    }

    var roomObjects = this.game.getCurrentRoom().getListableContents();
    var playerObjects = this.game.getPlayer().getListableContents();
    var foundObjects = [];
    var exactMatch = false;

    /**
     * Word must exist in our lookup table.
     * Lookup table associates object IDs
     * with every word used by the game.
     *
     * Keywords represent multiple objects and it's possible
     * for a keyword to represent an object with the
     * exact name AND other objects with that word in their names.
     * Example: "desk" represents both "desk" and "desk drawer"
     * If there's an exact match, return that, otherwise return all matches.
     */
    var keys = Object.keys(this.game.world_lookup);

    while (keys.length > 0) {
      if (word === keys[0]) {
        for (var i = 0; i < this.game.world_lookup[keys[0]].IDs.length; i++) {
          var objectID = this.game.world_lookup[keys[0]].IDs[i];
          var object = this.game.getAsset(objectID);

          // exclude assets with no getRoomId from "all"
          // if( "undefined" === typeof object.getRoomId )
          // {
          //   continue;
          // }
          // exclude assets outside the room from "all"
          // if( object.getRoomId() !== currentRoom.id )
          // {
          //   continue;
          // }
          // no don't do these because selectAll is not for "all"
          // it's for getting all game objects

          // exclude scenery events
          if (object instanceof adventurejs.Zone) {
            continue;
          }

          // exclude all global objects from all
          // because there's nothing you can do to all globals
          // this cancels out the following global exit check
          // but was added at a later date, so leaving both in for now
          if (object.is.global) {
            //continue;
          }

          // exclude global exit if there is a local exit with its direction
          // selectPresent redundantly does this check
          if (
            object instanceof adventurejs.Exit &&
            object.is.global &&
            "undefined" !== typeof currentRoom.exits[object.direction]
          ) {
            continue;
          }

          // // never return exits from other rooms
          // // TODO will this be a problem with "ask about" ?
          // selectPresent redundantly does this check
          if (
            object instanceof adventurejs.Exit &&
            false === object.is.global &&
            object.getPlaceAssetId() !== currentRoom.id
          ) {
            continue;
          }

          /**
           * Always exclude player.
           * TODO: make this an option?
           */
          // commented this on 8/3/20 because it was preventing
          // using "me" or "myself"
          // not sure why I added it except I think it was breaking
          // something and player was appearing in "take all"
          // but that might have been a symptom of another bug that I fixed
          if (objectID === this.game._player) {
            //continue
          }

          // @todo EXAMINE THIS CODE
          // check if input is unparsed substance
          // if( object instanceof adventurejs.Substance )
          // {
          //   var containers = 0;
          //   for( var j = 0; j < roomObjects.length; j++ )
          //   {
          //     var roomObject = this.game.getAsset( roomObjects[j] );
          //     var aspect = roomObject.doesContainSubstance( object.id );
          //     if( false !== aspect )
          //     {
          //       console.warn( " - selectAll " + roomObject.id + ".doesContainSubstance( "+object.id+" ): " + roomObject.doesContainSubstance( object.id ) );

          //       // becomes for ex: bowl:in:water which can be handled by verbs
          //       // a result of asset:aspect:substance always means player asked for substance
          //       // and we found a container of that substance
          //       containers++;
          //       foundObjects.push( roomObject.id + ":" + aspect + ":" + object.id );
          //     }
          //   }
          //   if( 0 == containers )
          //   {
          //     foundObjects.push( object.id );
          //   }
          //   continue;
          // }

          //var objectID = this.game.world_lookup[ keys[0] ].IDs[i];

          let context = `selectAll.js > found world_lookup[ ${keys[0]} ].IDs[${objectID}]`;
          console.warn(context);
          if (!this.game.getInput().replacements[objectID]) {
            this.game.getInput().replacements[objectID] = {
              source: keys[0],
              context: context,
            };
          }

          foundObjects.push(objectID);
        }
      }
      keys.shift();
    }

    /**
     * Ideally, if there's an asset whose id is an exact match to the
     * input word, we'd like to return that. Chiefly we'd like this to
     * apply to substances, like "water" or "oil" or "milk", which are singular
     * in the sense that, while water may exist in multiple substances, there
     * is only one water asset. What this does is, if player inputs "take water",
     * it prevents the parser from returning something like:
     * "did you mean the sink's hot water handle or the sink's cold water handle?"
     *
     * In theory it seems like this could be applied to things other than
     * substances, but in practice, what happens is you run into cases like this:
     * there are objects called "plug" and "sink plug", and player inputs
     * "take plug" - and since "plug" is an exact match, "sink plug"
     * is always omitted from any list of possible matches.
     *
     * Have removed / reimplemented this a couple of times... still watching to
     * see if there are any unexpected side effects.
     */
    for (var i = 0; i < foundObjects.length; i++) {
      //console.warn( " - selectAll foundObjects[i]: " + foundObjects[i] );
      object = this.game.getAsset(foundObjects[i]);
      if (object.id === word && object instanceof adventurejs.Substance) {
        foundObjects = [word];
        break;
      }
    }

    this.game.log(
      "log",
      "high",
      "selectAll.js > return: " + foundObjects,
      "Parser"
    );
    return foundObjects;
  };
})();

// selectBodyOfSubstance.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not bodies 
   * of substance such as a lake or a beach.
   * @method adventurejs.Parser#selectBodyOfSubstance
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectBodyOfSubstance = function Parser_selectBodyOfSubstance(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectBodyOfSubstance.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
      var object;
      object = this.game.getAsset( list[i] );
      if( object.$is("body") )
      {
        foundObjects.push( list[i] );
      }
		}
		return foundObjects;
	}
  
}());

// selectCarried.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not carried by player.
   * @method adventurejs.Parser#selectCarried
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectCarried = function Parser_selectCarried(list) 
  {
		if(typeof list !== "object" ) 
    {
			console.warn("selectCarried received non-array", list);
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			console.log("selectCarried list[i]", list[i] );
			var object = this.game.getAsset( list[i] );
			if( object.isIn( this.game.getPlayer() ) ) 
      {
        foundObjects.push( list[i] );
			}

			// TODO but is it nested in a closed object in player?
			// and is it known? could be unseen inside an unopened thing

		}
		return foundObjects;
	}
  
}());

// selectCharacter.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not characters.
   * @method adventurejs.Parser#selectCharacter
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectCharacter = function Parser_selectCharacter(list) 
  {
		if(typeof list !== "object" ) 
    {
			console.warn("selectCharacter received non-array", list);
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );
      if( object instanceof adventurejs.Character ) 
      {
        foundObjects.push( list[i] );
			}

			// TODO sentient vs non-sentient characters?

		}
		return foundObjects;
	}
  
}());

// selectExtant.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that have been destroyed.
   * @method adventurejs.Parser#selectExtant
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectExtant = function Parser_selectExtant(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectExtant.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
      var object;
      object = this.game.getAsset( list[i] );

      if( !object.is.extant ) 
      {
        continue;
      }
      foundObjects.push( list[i] );
		}

    //console.log( "selectExtant returned " + foundObjects );
		return foundObjects;
	}
  
}());

// selectGlobalSubstance.js

 (function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not global substances.
   * @method adventurejs.Parser#selectGlobalSubstance
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectGlobalSubstance = function Parser_selectGlobalSubstance(list) 
  {
		if(typeof list !== "object" ) 
    {
			console.warn("selectGlobalSubstance received non-array", list);
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
      var object = list[i];
      var asset_aspect_substance = object.split(":");
      if( 1 < asset_aspect_substance.length ) {
        // discard substance-in-tangible
        continue;
      } else {
        object = this.game.getAsset( list[i] );
      }

      if( object instanceof adventurejs.Substance ) 
      {
        foundObjects.push( list[i] );
      }
		}

    return foundObjects;
	}
  
}());
// selectHeld.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not being held by player.
   * @method adventurejs.Parser#selectHeld
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectHeld = function Parser_selectHeld(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectHeld.js > received non-array", 'Parser' );
			return [];
		}
    var player = this.game.getPlayer();
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

      if( player.IOVisConnectedToAsset('hold',object) )
      {
        foundObjects.push( list[i] );
      }

		}
    //console.warn( "selectHeld returned " + foundObjects );
		return foundObjects;
	}
  
}());

// selectInHands.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not in player's hands.
   * @method adventurejs.Parser#selectInHands
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectInHands = function Parser_selectInHands(list) 
  {
		// we already know it's present and visible and reachable
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectInHands.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
      var object = this.game.getAsset( list[i] );
      var player = this.game.getPlayer();

      if( object instanceof adventurejs.Substance )
      {
        continue;
      }

      // if it hasn't got a parent it can't be in hands
      // not originally intended but this applies directly to substances
      if( !object.getPlaceAsset ) 
      {
        continue;
      }
      var parent = object.getPlaceAsset();
      if( !parent ) 
      {
        continue;
      }
      
      if( parent.id !== player.id 
        && !player.IOVisConnectedToAsset('hold',object) ) 
      {
        continue;
      }

      if( parent.id === player.id
      && object.is.worn ) 
      {
        continue;
      }

      foundObjects.push( list[i] );
		}

		return foundObjects;
	}
  
}());

// selectInInventory.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not in player's inventory.
   * @method adventurejs.Parser#selectInInventory
   * @memberOf adventurejs.Parser
   * @param {Array} list
   * @returns {Array}
   */
  p.selectInInventory = function Parser_selectInInventory(list) {
    if ("string" === typeof list) list = [list];
    if (!Array.isArray(list)) {
      this.game.log(
        "warn",
        "critical",
        "selectInInventory.js > received non-array",
        "Parser"
      );
      return [];
    }
    var player = this.game.getPlayer();
    var foundObjects = [];
    for (var i = 0; i < list.length; i++) {
      var object = this.game.getAsset(list[i]);

      if (object.areAnscestorsUnknown && object.areAnscestorsUnknown()) {
        continue;
      }

      if (
        !object.isIn(player) &&
        !player.IOVisConnectedToAsset("hold", object)
      ) {
        continue;
      }

      foundObjects.push(list[i]);

      // TODO but is it nested in a closed object in player?
      // and is it known? could be unseen inside an unopened thing
    }
    console.warn("selectInInventory returned " + foundObjects);
    return foundObjects;
  };
})();

// selectInInventoryIfTakeable.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not takeable from player inventory.
   * @method adventurejs.Parser#selectInInventoryIfTakeable
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectInInventoryIfTakeable = function Parser_selectInInventoryIfTakeable(list) {
    console.warn( "selectInInventoryIfTakeable received " + list );
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectInInventoryIfTakeable.js > received non-array", 'Parser' );
			return [];
		}
    var player = this.game.getPlayer();
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

      if( !object.isDOV('take') ) 
      {
        foundObjects.push( list[i] );
        continue;
      }

      if( "undefined" !== typeof object.areAnscestorsUnknown
      && object.areAnscestorsUnknown() ) 
      {
        continue;
      }

      if( !object.isIn( player ) 
      && !player.IOVisConnectedToAsset(object) )
      {
        continue;
      }

      foundObjects.push( list[i] );

			// TODO but is it nested in a closed object in player?
			// and is it known? could be unseen inside an unopened thing

		}
    console.warn( "selectInInventoryIfTakeable returned " + foundObjects );
		return foundObjects;
	}
  
}());

// selectIntangible.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all non-intangible assets.
   * @method adventurejs.Parser#selectIntangible
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectIntangible = function Parser_selectIntangible(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectIntangible.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );
			if( object instanceof adventurejs.Intangible ) 
      {
        foundObjects.push( list[i] );
			}
		}
		return foundObjects;
	}
  
}());

// selectKnown.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are unknown by player.
   * @method adventurejs.Parser#selectKnown
   * @memberOf adventurejs.Parser
   * @param {Array} list
   * @returns {Array}
   */
  p.selectKnown = function Parser_selectKnown(list) {
    if ("string" === typeof list) list = [list];
    if (!Array.isArray(list)) {
      this.game.log(
        "warn",
        "critical",
        "selectKnown.js > received non-array",
        "Parser"
      );
      return [];
    }
    var foundObjects = [];
    for (var i = 0; i < list.length; i++) {
      var object;
      object = this.game.getAsset(list[i]);

      //console.warn( "selectKnown examining " + list[i] );
      // is it a substance in a container we haven't examined?
      var sub = list[i].split(":"); // asset:aspect:substance
      if (3 === sub.length) {
        console.warn("sub", sub);
        var known = this.game.getAsset(sub[0]).aspects[sub[1]].vessel
          .vessel_is_known;
        if (!known) {
          continue;
        }
      }

      if (object instanceof adventurejs.Substance) {
        //var container = this.game.getAsset( list[i] );
        if (!object.is.known) {
          continue;
        }
      }

      /**
       * Objects become known once they're "seen" by player.
       * Omit unknown object, but also omit if any of its
       * anscestors are unknown. It's possible for a known
       * object to be inside an unknown object, but this state
       * is unlikely to happen by accident, so we'll take unknown
       * anscestors to mean the object was deliberately hidden.
       */
      if (!object.is.known) {
        continue;
      }
      if (object.areAnscestorsUnknown && object.areAnscestorsUnknown()) {
        continue;
      }
      foundObjects.push(list[i]);
    }

    //console.log( "selectKnown returned " + foundObjects );
    return foundObjects;
  };
})();

// selectMatter.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all non-matter assets.
   * @method adventurejs.Parser#selectMatter
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectMatter = function Parser_selectMatter(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectMatter.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

      if( object instanceof adventurejs.Matter ) 
      {
        foundObjects.push( list[i] );
			}
		}

    return foundObjects;
	}
  
}());
// selectNotExit.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are exits.
   * @method adventurejs.Parser#selectNotExit
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotExit = function Parser_selectNotExit(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotExit.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );
      if( false === object instanceof adventurejs.Exit ) 
      {
        foundObjects.push( list[i] );
			}
		}
		return foundObjects;
	}
  
}());
// selectNotGlobal.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all global assets.
   * @method adventurejs.Parser#selectNotGlobal
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotGlobal = function Parser_selectNotGlobal(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotGlobal.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );
			//console.log("selectNotGlobal > object",object);

      // @TODO mo'bettah handling for global floor
      if( !object.is.global 
        || object.id === "global_floor" ) 
      {
				foundObjects.push( list[i] );
			}
		}
		return foundObjects;
	}
  
}());
// selectNotInHands.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets held in player's hands.
   * @method adventurejs.Parser#selectNotInHands
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotInHands = function Parser_selectNotInHands(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotInHands.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

      if( object instanceof adventurejs.Substance )
      {
        foundObjects.push( list[i] );
        continue;
      }

      if( object instanceof adventurejs.Room )
      {
        foundObjects.push( list[i] );
        continue;
      }
      // if it hasn't got a parent, it's not in inventory
      // not originally intended but this applies directly to substances
      if( !object.getPlaceAsset ) continue;
      var parent = object.getPlaceAsset();
      if( !parent ) continue;
      if( parent.id === this.game.world._player
        && !object.is.worn ) 
        {
          continue;
        }

      foundObjects.push( list[i] );
		}

		return foundObjects;
	}
  
}());

// selectNotInInventory.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets in player's inventory.
   * @method adventurejs.Parser#selectNotInInventory
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotInInventory = function Parser_selectNotInInventory(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotInInventory.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );
			if( object.isIn( this.game.getPlayer() ) ) 
      {
          continue;
			}

      foundObjects.push( list[i] );
		}

		return foundObjects;
	}
  
}());

// selectNotNestedInventoryIfAll.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets in player's inventory.
   * @method adventurejs.Parser#selectNotNestedInventoryIfAll
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotNestedInventoryIfAll = function Parser_selectNotNestedInventoryIfAll(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotNestedInventoryIfAll.js > received non-array", 'Parser' );
			return [];
		}
    var player = this.game.getPlayer();
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

      // if it hasn't got a parent it can't be in inventory
      // not originally intended but this applies directly to substances
      if( !object.getPlaceAsset ) continue;
      var parent = object.getPlaceAsset();
      if( !parent ) continue;      
      
      // exclude inventory
      if( object.isIn( player )
      && parent.id !== player.id ) 
      {
        continue;
      }
      
      // exclude held things
      if( player.IOVisConnectedToAsset('hold',object) )
      {
        continue;
      }

      foundObjects.push( list[i] );
		}

		return foundObjects;
	}
  
}());

// selectNotPlayerParent.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are nested in player.
   * @method adventurejs.Parser#selectNotPlayerParent
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotPlayerParent = function Parser_selectNotPlayerParent(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotPlayerParent.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
      var object = this.game.getAsset( list[i] );
      var player = this.game.getPlayer();
      var currentRoom = this.game.getCurrentRoom();

      if( player.isNested() 
      && object.id === player.getNestId() )
      {
        continue;
      }

      if( false === player.isNested() 
      && object.id === currentRoom.id )
      {
        continue;
      }

      if( player.isNested() 
      && object.id === currentRoom.id
      && player.getNestAsset() instanceof adventurejs.Floor )
      {
        continue;
      }

      foundObjects.push( list[i] );

		}

		return foundObjects;
	}
  
}());

// selectNotScenery.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all scenery assets.
   * @method adventurejs.Parser#selectNotScenery
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotScenery = function Parser_selectNotScenery(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotScenery.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );
			//console.log("selectNotScenery > object",object);
      if( false === object instanceof adventurejs.Scenery ) 
      {
				foundObjects.push( list[i] );
			}
		}
		return foundObjects;
	}
  
}());
// selectNotSubstance.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all substance assets.
   * @method adventurejs.Parser#selectNotSubstance
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotSubstance = function Parser_selectNotSubstance(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotSubstance.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i], { prefer_substance: true } );
      if( false === object instanceof adventurejs.Substance ) 
      {
        foundObjects.push( list[i] );
			}
		}
		return foundObjects;
	}
  
}());
// selectNotWorn.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets worn by player.
   * @method adventurejs.Parser#selectNotWorn
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotWorn = function Parser_selectNotWorn(list) {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotWorn.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

      // TODO worn by player vs worn by other character?

      if( object.is.worn ) 
      {
        continue;
      }

      foundObjects.push( list[i] );
		}

		return foundObjects;
	}
  
}());

// selectInHands.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all worn assets if player input "all".
   * @method adventurejs.Parser#selectNotWornIfAll
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectNotWornIfAll = function Parser_selectNotWornIfAll(list) {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectNotWornIfAll.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

      // if it hasn't got a parent it can't be worn
      // not originally intended but this applies directly to substances
      if( !object.getPlaceAsset ) continue;
      var parent = object.getPlaceAsset();
      if( !parent ) continue;      
      if( parent.id !== this.game.world._player ) continue;
      if( parent.id === this.game.world._player
        && object.is.worn ) 
        {
          continue;
        }

      foundObjects.push( list[i] );
		}

		return foundObjects;
	}
  
}());

// selectPlayerParent.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets but player's parent. 
   * Should only ever return one object.
   * @method adventurejs.Parser#selectPlayerParent
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectPlayerParent = function Parser_selectPlayerParent(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectPlayerParent.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
      var object = this.game.getAsset( list[i] );
      var player = this.game.getPlayer();
      var currentRoom = this.game.getCurrentRoom();

      if( player.isNested() 
      && object.id === player.getNestId() )
      {
        foundObjects.push( list[i] );
      }

      else if( false === player.isNested() 
      && object.id === currentRoom.id )
      {
        foundObjects.push( list[i] );
      }

      else if( player.isNested() 
      && object.id === currentRoom.id
      && player.getNestAsset() instanceof adventurejs.Floor )
      {
        foundObjects.push( currentRoom.id );
      }

      if( 0 < foundObjects.length ) break;

		}

		return foundObjects;
	}
  
}());

// selectPresent.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not present in current room.
   * @method adventurejs.Parser#selectPresent
   * @memberOf adventurejs.Parser
   * @param {Array} list
   * @returns {Array}
   */
  p.selectPresent = function Parser_selectPresent(list) {
    if ("string" === typeof list) list = [list];
    if (!Array.isArray(list)) {
      this.game.log(
        "warn",
        "critical",
        "selectPresent.js > received non-array",
        "Parser"
      );
      return [];
    }
    var currentRoom = this.game.getCurrentRoom();
    var foundObjects = [];
    var roomObjects = [];
    for (var i = 0; i < list.length; i++) {
      var object;

      // check if input was already parsed by an earlier step
      // as asset:aspect:substance in which case verify the tangible
      //var asset_aspect_substance = list[i].split(":");
      // if( 3 === asset_aspect_substance.length )
      // {
      //   object = this.game.getAsset( asset_aspect_substance[2] );
      // }
      // else {
      object = this.game.getAsset(list[i]);
      // }

      /**
       * check if input is unparsed substance
       * I've commented and uncommented this a couple of times.
       * Latest uncomment on 2023.04.08
       * Needed in order to handle "water" as a substance
       * specifically in the case of "pour water" while player
       * is holding a bowl full of water.
       */
      if (object instanceof adventurejs.Substance) {
        // this version automatically returns substances as present
        // foundObjects.push( list[i] );
        // continue;

        // this version looks for substance containers
        //console.warn( " - selectPresent " + object.id + " is substance" );
        if (0 === roomObjects.length) {
          //roomObjects = currentRoom.getListableContents();
          roomObjects = currentRoom.getAllNestedContents();
        }
        roomObjects.push(currentRoom.id);
        //console.warn( "roomObjects", roomObjects );
        for (var j = 0; j < roomObjects.length; j++) {
          var roomObject = this.game.getAsset(roomObjects[j]);
          if (!roomObject.is.known) continue;
          var aspect = roomObject.doesContainSubstance(object.id);
          if (aspect) {
            console.warn(
              " - selectPresent " +
                roomObject.id +
                ".doesContainSubstance( " +
                object.id +
                " ): " +
                roomObject.doesContainSubstance(object.id)
            );
            // becomes for ex: bowl:in:water which can be handled by verbs
            foundObjects.push(roomObject.id + ":" + aspect + ":" + object.id);
          }
        }
      }

      // abstractions are always present
      if (object.is.abstract) {
        foundObjects.push(list[i]);
        continue;
      }

      // walls, floor, ceiling, scenery
      // all prefixed with "global_"
      if (object.is.global) {
        console.warn("global object", object);
        if (object instanceof adventurejs.GlobalString) {
          foundObjects.push(list[i]);
          continue;
        }

        if (object instanceof adventurejs.Floor) {
          if (this.game.getCurrentRoom().findClassInThis("Floor").length)
            continue;
        }

        // room says yes
        if (
          "undefined" !== typeof currentRoom.room_scenery[object.id] &&
          true === currentRoom.room_scenery[object.id].enabled
        ) {
          foundObjects.push(list[i]);
          console.warn(
            "selectPresent > true === currentRoom.room_scenery[ object.id ].enabled"
          );
          continue;
        }

        // room says no
        if (
          "undefined" !== typeof currentRoom.room_scenery[object.id] &&
          false === currentRoom.room_scenery[object.id].enabled
        ) {
          console.warn(
            "selectPresent > false === currentRoom.room_scenery[ object.id ].enabled"
          );
          continue;
        }

        // room says neither true nor false

        // if room has no true / false setting, check for zone

        // zone says yes
        if (
          "undefined" !== typeof this.game.world[currentRoom.zone] &&
          "undefined" !==
            typeof this.game.world[currentRoom.zone].zone_scenery[object.id] &&
          true ===
            this.game.world[currentRoom.zone].zone_scenery[object.id].enabled
        ) {
          foundObjects.push(list[i]);
          console.warn(
            "selectPresent > true === this.game.world[ currentRoom.zone ].zone_scenery[ object.id ].enabled"
          );
          continue;
        }

        // zone says no
        if (
          "undefined" !== typeof this.game.world[currentRoom.zone] &&
          "undefined" !==
            typeof this.game.world[currentRoom.zone].zone_scenery[object.id] &&
          false ===
            this.game.world[currentRoom.zone].zone_scenery[object.id].enabled
        ) {
          console.warn(
            "selectPresent > false === currentRoom.zone.zone_scenery[ object.id ].enabled"
          );
          continue;
        }

        // zone says neither true nor false

        if (object.enabled) {
          console.warn("selectPresent > true === object.enabled");
          foundObjects.push(list[i]);
        }

        continue;
      }

      // exclude global exit if there is a local exit with its direction
      if (
        object instanceof adventurejs.Exit &&
        object.is.global &&
        "undefined" !== typeof currentRoom.exits[object.direction]
      ) {
        continue;
      }

      // include global exit if there is no local exit with its direction
      if (
        object instanceof adventurejs.Exit &&
        object.is.global &&
        "undefined" === typeof currentRoom.exits[object.direction]
      ) {
        foundObjects.push(list[i]);
        continue;
      }

      // never return exits from other rooms
      // TODO will this be a problem with "ask about" ?
      if (
        object instanceof adventurejs.Exit &&
        !object.is.global &&
        object.getPlaceAssetId() !== this.game.world._currentRoom
      ) {
        continue;
      }

      if (object.id === this.game.world._currentRoom) {
        foundObjects.push(list[i]);
        continue;
      }

      if (object.isIn && object.isIn(this.game.getCurrentRoom())) {
        foundObjects.push(list[i]);
        continue;
      }

      // for substances
      // examine every item in the room for substance container
      //if( object.contains_substance)

      // if there's a global object, list that
      // if( -1 < object.id.indexOf( "global_" ) ) {
      //   //console.log( "selectPresent found " + object.name );
      //   foundObjects.push( list[i] );
      //   continue;
      // }
    }
    //console.log( "selectPresent returned " + foundObjects );
    return foundObjects;
  };
})();

// selectPresentIfTangible.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all tangible assets that are not present in current room.
   * @method adventurejs.Parser#selectPresentIfTangible
   * @memberOf adventurejs.Parser
   * @param {Array} list
   * @returns {Array}
   */
  p.selectPresentIfTangible = function Parser_selectPresentIfTangible(list) {
    if ("string" === typeof list) list = [list];
    if (!Array.isArray(list)) {
      this.game.log(
        "warn",
        "critical",
        "selectPresentIfTangible.js > received non-array",
        "Parser"
      );
      return [];
    }
    var currentRoom = this.game.getCurrentRoom();
    var foundObjects = [];
    var roomObjects = [];
    for (var i = 0; i < list.length; i++) {
      var object;

      // check if input was already parsed by an earlier step
      // as asset:aspect:substance in which case verify the tangible
      //var asset_aspect_substance = list[i].split(":");
      // if( 3 === asset_aspect_substance.length )
      // {
      //   object = this.game.getAsset( asset_aspect_substance[2] );
      // }
      // else {
      object = this.game.getAsset(list[i]);
      // }

      /**
       * check if input is unparsed substance
       * I've commented and uncommented this a couple of times.
       * Latest uncomment on 2023.04.08
       * Needed in order to handle "water" as a substance
       * specifically in the case of "pour water" while player
       * is holding a bowl full of water.
       */
      if (object instanceof adventurejs.Substance) {
        // this version automatically returns substances as present
        foundObjects.push(list[i]);
        continue;
      }

      // abstractions are always present
      if (object.is.abstract) {
        foundObjects.push(list[i]);
        continue;
      }

      // walls, floor, ceiling, scenery
      // all prefixed with "global_"
      if (object.is.global) {
        //console.warn('global object',object);
        if (object instanceof adventurejs.GlobalString) {
          foundObjects.push(list[i]);
          continue;
        }

        if (object instanceof adventurejs.Floor) {
          if (this.game.getCurrentRoom().findClassInThis("Floor").length)
            continue;
        }

        // room says yes
        if (
          "undefined" !== typeof currentRoom.room_scenery[object.id] &&
          true === currentRoom.room_scenery[object.id].enabled
        ) {
          foundObjects.push(list[i]);
          //console.warn( "selectPresent > true === currentRoom.room_scenery[ object.id ].enabled" );
          continue;
        }

        // room says no
        if (
          "undefined" !== typeof currentRoom.room_scenery[object.id] &&
          false === currentRoom.room_scenery[object.id].enabled
        ) {
          //console.warn( "selectPresent > false === currentRoom.room_scenery[ object.id ].enabled" );
          continue;
        }

        // room says neither true nor false

        // if room has no true / false setting, check for zone

        // zone says yes
        if (
          "undefined" !== typeof this.game.world[currentRoom.zone] &&
          "undefined" !==
            typeof this.game.world[currentRoom.zone].zone_scenery[object.id] &&
          true ===
            this.game.world[currentRoom.zone].zone_scenery[object.id].enabled
        ) {
          foundObjects.push(list[i]);
          //console.warn( "selectPresent > true === this.game.world[ currentRoom.zone ].zone_scenery[ object.id ].enabled" );
          continue;
        }

        // zone says no
        if (
          "undefined" !== typeof this.game.world[currentRoom.zone] &&
          "undefined" !==
            typeof this.game.world[currentRoom.zone].zone_scenery[object.id] &&
          false ===
            this.game.world[currentRoom.zone].zone_scenery[object.id].enabled
        ) {
          //console.warn( "selectPresent > false === currentRoom.zone.zone_scenery[ object.id ].enabled" );
          continue;
        }

        // zone says neither true nor false

        if (object.enabled) {
          //console.warn( "selectPresent > true === object.enabled" );
          foundObjects.push(list[i]);
        }

        continue;
      }

      // exclude global exit if there is a local exit with its direction
      if (
        object instanceof adventurejs.Exit &&
        object.is.global &&
        "undefined" !== typeof currentRoom.exits[object.direction]
      ) {
        continue;
      }

      // include global exit if there is no local exit with its direction
      if (
        object instanceof adventurejs.Exit &&
        object.is.global &&
        "undefined" === typeof currentRoom.exits[object.direction]
      ) {
        foundObjects.push(list[i]);
        continue;
      }

      // never return exits from other rooms
      // TODO will this be a problem with "ask about" ?
      if (
        object instanceof adventurejs.Exit &&
        !object.is.global &&
        object.getPlaceAssetId() !== this.game.world._currentRoom
      ) {
        continue;
      }

      if (object.id === this.game.world._currentRoom) {
        foundObjects.push(list[i]);
        continue;
      }

      if (object.isIn && object.isIn(this.game.getCurrentRoom())) {
        foundObjects.push(list[i]);
        continue;
      }

      // for substances
      // examine every item in the room for substance container
      //if( object.contains_substance)

      // if there's a global object, list that
      // if( -1 < object.id.indexOf( "global_" ) ) {
      //   //console.log( "selectPresent found " + object.name );
      //   foundObjects.push( list[i] );
      //   continue;
      // }
    }
    //console.log( "selectPresent returned " + foundObjects );
    return foundObjects;
  };
})();

// selectReachable.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not reachable by player.
   * @method adventurejs.Parser#selectReachable
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectReachable = function Parser_selectReachable(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectReachable.js > received non-array", 'Parser' );
			return [];
    }

    var player = this.game.getPlayer();
    var nest_asset = player.getNestAsset();        
    var nest_ancestor = this.game.getAsset( player.getNestAnscestorId() );

    var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
      var object, object_parent, object_ancestor, object_ancestor;
      
      // check if input was already parsed by an earlier step
      // as substance:in:tangible in which case verify the tangible
      // var asset_aspect_substance = list[i].split(":"); // asset:aspect:substance
      // if( 3 === asset_aspect_substance.length )
      // {
      //   object = this.game.getAsset( asset_aspect_substance[2] );
      // }
			// else {
        object = this.game.getAsset( list[i] );
      // }

      if(!object) continue;

      // abstractions are always reachable
      if( object.is.abstract ) 
      { 
        foundObjects.push( list[i] );
        continue;
      }  

      // if object is a plug, test against its parent
      if( object.IOVisConnectedToAnything('plug') )
      {
        object = object.getPlaceAsset();
      }

      object_parent = object.getPlaceAsset();
      object_ancestor = this.game.getAsset( object.getAncestorId() );


      // check if input is unparsed substance
      // if( object instanceof adventurejs.Substance )
      // {
      //   console.warn( " - selectReachable " + object.id + " is substance" );
      //   if( 0 === roomObjects.length )
      // {
      //     roomObjects = currentRoom.getListableContents();
      //   }
      //   //console.warn( "roomObjects", roomObjects );
      //   for( var j = 0; j < roomObjects.length; j++ )
      // {
      //     var roomObject = this.game.getAsset( roomObjects[j] );
      //     var loc = roomObject.doesContainSubstance( object.id );
      //     if( false !== loc )
      // {
      //       console.warn( " - selectReachable " + roomObject.id + ".doesContainSubstance( "+object.id+" ): " + roomObject.doesContainSubstance( object.id ) );
      //       // becomes for ex: water:in:bowl which can be handled by verbs
      //       foundObjects.push( object.id + ":" + loc + ":" + roomObject.id );
      //     }
      //   }
      //   continue;
      // }

      // player is carrying it, ok
      //if( object.isIn( player ) ) { 
      if( object.isIn( player ) ) 
      { 
        foundObjects.push( list[i] );
        continue;
      }  

      // player is in it, ok
      if( player.isNested() 
      && object.id === nest_asset.id ) 
      {
        foundObjects.push( list[i] );
        continue;
      }  

      // if player is nested and trying to get up/down
      if( player.isNested() 
      && object.direction === "down"
      || object.direction === "up" ) 
      {
        foundObjects.push( list[i] );
        continue;
      }  
  
      // if player is in/on/under/behind something
      if( player.isNested() 

        // player is not nested in object
        && object.id !== nest_asset.id

        // it's not top of the nest
        && object.id !== nest_ancestor.id

        // it's not in inventory
        //&& object_ancestor.id !== player.id 

        // it's not nested in same container as player
        && object_parent.id !== nest_asset.id

        // it's not nested in same container as player
        && object_ancestor.id !== nest_ancestor.id

        // it's not explicitly reachable from thing player is nested in
        && !nest_asset.canPlayerReachThatFromThis( object )

        // it's not inside another thing that is 
        // explicitly reachable from thing player is nested in
        && !nest_asset.canPlayerReachThatFromThis( object_ancestor )

      ){
        console.warn( "reachable excluded", object.id );
        continue;
      }

      // is player on the floor, but object not on the floor?
      // this check might be too restrictive
      if( !player.isNested()
      && player.isOnFloor()
      && !(object instanceof adventurejs.Floor)
      && object.getPlaceAssetId() !== player.getPlaceAssetId() ) 
      {
        console.warn( "Exclude " + object.name + " because player is on the floor." );
        continue;
      }

      // is player at different y height?
      // figure out y overlap
      var range = object.getYRange();
      // is player close enough on y?
      if( player.position.y < range.min || player.position.y > range.max ) 
      {
        console.warn( "Exclude " + object.name + " because player at different y." );
        continue;
      }

			/*
				TODO
				on top of a tall object?
        behind glass?
        inside something that's closed?
			*/

			foundObjects.push( list[i] );
		}

    //console.warn( "selectReachable returned " + foundObjects );
		return foundObjects;
	}
  
}());

// selectReachableIfTangible.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not reachable by player.
   * @method adventurejs.Parser#selectReachableIfTangible
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectReachableIfTangible = function Parser_selectReachableIfTangible(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectReachableIfTangible.js > received non-array", 'Parser' );
			return [];
    }

    var player = this.game.getPlayer();
    var nest_asset = player.getNestAsset();        
    var nest_ancestor = this.game.getAsset( player.getNestAnscestorId() );

    var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
      var object, object_parent, object_ancestor, object_ancestor;
      
      object = this.game.getAsset( list[i] );

      if(!object) continue;

      if( object instanceof adventurejs.Substance )
      {
        // automatically return substances as present
        foundObjects.push( list[i] );
        continue;
      }


      // abstractions are always reachable
      if( object.is.abstract ) 
      { 
        foundObjects.push( list[i] );
        continue;
      }  

      // if object is a plug, test against its parent
      if( object.IOVisConnectedToAnything('plug') )
      {
        object = object.getPlaceAsset();
      }

      object_parent = object.getPlaceAsset();
      object_ancestor = this.game.getAsset( object.getAncestorId() );

      // player is carrying it, ok
      //if( object.isIn( player ) ) { 
      if( object.isIn( player ) ) 
      { 
        foundObjects.push( list[i] );
        continue;
      }  

      // player is in it, ok
      if( player.isNested() 
      && object.id === nest_asset.id ) 
      {
        foundObjects.push( list[i] );
        continue;
      }  

      // if player is nested and trying to get up/down
      if( player.isNested() 
      && object.direction === "down"
      || object.direction === "up" ) 
      {
        foundObjects.push( list[i] );
        continue;
      }  
  
      // if player is in/on/under/behind something
      if( player.isNested() 

        // player is not nested in object
        && object.id !== nest_asset.id

        // it's not top of the nest
        && object.id !== nest_ancestor.id

        // it's not in inventory
        //&& object_ancestor.id !== player.id 

        // it's not nested in same container as player
        && object_parent.id !== nest_asset.id

        // it's not nested in same container as player
        && object_ancestor.id !== nest_ancestor.id

        // it's not explicitly reachable from thing player is nested in
        && !nest_asset.canPlayerReachThatFromThis( object )

        // it's not inside another thing that is 
        // explicitly reachable from thing player is nested in
        && !nest_asset.canPlayerReachThatFromThis( object_ancestor )

      ){
        console.warn( "reachable excluded", object.id );
        continue;
      }

      // is player on the floor, but object not on the floor?
      // this check might be too restrictive
      if( !player.isNested()
      && player.isOnFloor()
      && !(object instanceof adventurejs.Floor)
      && object.getPlaceAssetId() !== player.getPlaceAssetId() ) 
      {
        console.warn( "Exclude " + object.name + " because player is on the floor." );
        continue;
      }

      // is player at different y height?
      // figure out y overlap
      var range = object.getYRange();
      // is player close enough on y?
      if( player.position.y < range.min || player.position.y > range.max ) 
      {
        console.warn( "Exclude " + object.name + " because player at different y." );
        continue;
      }

			/*
				TODO
				on top of a tall object?
        behind glass?
        inside something that's closed?
			*/

			foundObjects.push( list[i] );
		}

    //console.warn( "selectReachable returned " + foundObjects );
		return foundObjects;
	}
  
}());

// selectSingular.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all objects that are collections.
   * @method adventurejs.Parser#selectSingular
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectSingular = function Parser_selectSingular(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectSingular.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

			if( object.is.collection ) 
      {
        continue;
      }

      foundObjects.push( list[i] );
		}

		return foundObjects;
	}
  
}());

// selectSubstance.js

 (function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not substances.
   * @method adventurejs.Parser#selectSubstance
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectSubstance = function Parser_selectSubstance(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectSubstance.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
      var object = this.game.getAsset( list[i], {prefer_substance:true} );

      if( object instanceof adventurejs.Substance ) 
      {
        foundObjects.push( list[i] );
      }
		}

    return foundObjects;
	}
  
}());
// selectTakeable.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that can't be taken by player.
   * @method adventurejs.Parser#selectTakeable
   * @memberOf adventurejs.Parser
   * @param {Array} list
   * @returns {Array}
   */
  p.selectTakeable = function Parser_selectTakeable(list) {
    // we already know it's present and visible and reachable
    if ("string" === typeof list) list = [list];
    if (!Array.isArray(list)) {
      this.game.log(
        "warn",
        "critical",
        "selectTakeable.js > received non-array",
        "Parser"
      );
      return [];
    }
    var player = this.game.getPlayer();
    var foundObjects = [];
    for (var i = 0; i < list.length; i++) {
      var object = this.game.getAsset(list[i]);

      if (!object.isDOV("take")) {
        if (
          object instanceof adventurejs.Room &&
          list[i].split(":").length === 3
        ) {
          // it's a substance in a room, which is not technically takeable,
          // but we're going to let take verb handle that
          foundObjects.push(list[i]);
        }

        continue;
      }

      // if object is a plug, test against its parent
      if (object.IOVisConnectedToAnything("plug")) {
        object = object.getPlaceAsset();
      }

      // if it has no getParent method then it's not takeable
      // not originally intended but this applies directly to substances
      if (!object.getPlaceAsset) continue;
      var parent = object.getPlaceAsset();
      if (!parent) continue;

      // player's already holding it or wearing it
      //if( parent.id === player.id ) continue;
      // going to let verbs handle this

      /**
       * If any of object's anscestors are closed we'll consider
       * the object not takeable,
       * unless it's nested in player inventory. We'll be nice and
       * let player access their inventory without having to
       * open every damned container.
       *
       * In theory we could do the same for any nested & known objects,
       * but that could raise unpredictable conflicts in situations
       * like taking objects from NPCs, or inadvertently triggering
       * or bypassing custom functions.
       */
      //if( false === object.areAnscestorsClosed()
      if (
        object.areAnscestorsClosed &&
        object.areAnscestorsClosed() &&
        !object.isIn(player)
      ) {
        continue;
      }
      // TODO
      // check if parent is transparent

      /**
       * We don't handle this here because author is likely
       * to want complex interaction on trying to take something
       * from a character. Leaving it commented for later exploration.
       */
      // if( parent instanceof adventurejs.Character
      //   && false === parent.isIOV("take")
      // ) {
      //   continue;
      // }

      foundObjects.push(list[i]);
    }

    return foundObjects;
  };
})();

// selectTangible.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all non-tangible assets.
   * @method adventurejs.Parser#selectTangible
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectTangible = function Parser_selectTangible(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectTangible.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

      if( object instanceof adventurejs.Tangible
      // || object instanceof adventurejs.Substance
      || object instanceof adventurejs.Room
      || object instanceof adventurejs.Exit 
      //|| object instanceof adventurejs.Floor 
      //|| object instanceof adventurejs.Ceiling 
      || object instanceof adventurejs.Scenery 
      || ( object.is.global /*&& !object.is.abstract @todo handle abstractions */ ) ) 
      {
        foundObjects.push( list[i] );
			}
		}

    return foundObjects;
	}
  
}());
// selectTangibleOrSubstance.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all non-tangible assets.
   * @method adventurejs.Parser#selectTangibleOrSubstance
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectTangibleOrSubstance = function Parser_selectTangibleOrSubstance(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectTangibleOrSubstance.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );

      if( object instanceof adventurejs.Tangible
      || object instanceof adventurejs.Substance
      || object instanceof adventurejs.Room
      || object instanceof adventurejs.Exit 
      //|| object instanceof adventurejs.Floor 
      //|| object instanceof adventurejs.Ceiling 
      || object instanceof adventurejs.Scenery 
      || ( object.is.global /*&& !object.is.abstract @todo handle abstractions */ ) ) 
      {
        foundObjects.push( list[i] );
			}
		}

    return foundObjects;
	}
  
}());
// selectVisible.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not visible to player.
   * @method adventurejs.Parser#selectVisible
   * @memberOf adventurejs.Parser
   * @param {Array} list
   * @returns {Array}
   * @todo consider global darkness
   */
  p.selectVisible = function Parser_selectVisible(list) {
    if ("string" === typeof list) list = [list];
    if (!Array.isArray(list)) {
      this.game.log(
        "warn",
        "critical",
        "selectVisible.js > received non-array",
        "Parser",
      );
      return [];
    }
    // we already know it's present
    var player = this.game.getPlayer();
    var currentRoom = this.game.getCurrentRoom();
    var foundObjects = [];
    var roomObjects = [];

    for (var i = 0; i < list.length; i++) {
      var object;

      // check if input was already parsed by an earlier step
      // as substance:in:tangible in which case verify the tangible
      // var asset_aspect_substance = list[i].split(":");
      // if( 3 === asset_aspect_substance.length )
      // {
      //   object = this.game.getAsset( asset_aspect_substance[2] );
      // }
      // else {
      object = this.game.getAsset(list[i]); // may return substance
      // }

      // abstractions are always visible
      if (object.is.abstract) {
        foundObjects.push(list[i]);
        continue;
      }

      // global objects are always visible, barring darkness
      // @TODO probably some complexities to explore here,
      // like seeing sun, moon, sky from underground
      if (object.is.global) {
        foundObjects.push(list[i]);
        continue;
      }

      // if object is a plug, test against its parent
      if (object.IOVisConnectedToAnything("plug")) {
        object = object.getPlaceAsset();
      }

      // check if input is unparsed substance
      // if( object instanceof adventurejs.Substance )
      // {
      //   if( 0 === roomObjects.length )
      // {
      //     roomObjects = currentRoom.getListableContents();
      //   }
      //   for( var j = 0; j < roomObjects.length; j++ )
      // {
      //     var roomObject = this.game.getAsset( roomObjects[j] );
      //     var loc = roomObject.doesContainSubstance( object.id );
      //     if( false !== loc )
      // {
      //       console.warn( " - selectVisible " + roomObject.id + ".doesContainSubstance( "+object.id+" ): " + roomObject.doesContainSubstance( object.id ) );
      //       // becomes for ex: water:in:bowl which can be handled by verbs
      //       foundObjects.push( object.id + ":" + loc + ":" + roomObject.id );
      //     }
      //   }
      //   continue;
      // }

      /*
				TODO

				get ambient light level
				- get light provided by all lightsources?
				get object's min_light_required_to_see

				hidden in a container - visible? or reachable?
				also consider container's opacity

      */

      if (object.is.hidden) {
        continue;
      }

      // if it has no parent, and it's not a room,
      // then it's not present in the world
      if (!object.getPlaceAsset() && !(object instanceof adventurejs.Room)) {
        continue;
      }

      /**
       * If object's anscestor is closed we'll consider it not visible
       * unless it's nested in player inventory. We'll be nice and
       * let player access their inventory without having to
       * open every damned container.
       *
       * In theory we could do the same for any nested & known objects,
       * but that could raise unpredictable problems in situations like taking
       * objects from NPCs, or inadvertently triggering custom functions.
       */
      //console.warn( 'selectVisible > areAnscestorsClosed()',object.areAnscestorsClosed() );
      if (
        object.areAnscestorsClosed &&
        object.areAnscestorsClosed() &&
        !object.isIn(player)
      ) {
        continue;
      }
      // TODO
      // check if parent is transparent
      // drain with plug
      // bottle with plug

      foundObjects.push(list[i]);
    }

    //console.log( "selectVisible returned " + foundObjects );
    return foundObjects;
  };
})();

// selectWorn.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Exclude from a list of assets all assets that are not worn by player.
   * @method adventurejs.Parser#selectVisible
   * @memberOf adventurejs.Parser
   * @param {Array} list 
   * @returns {Array}
   */
   p.selectWorn = function Parser_selectWorn(list) 
  {
    if("string" === typeof list) list = [list];
		if( !Array.isArray( list ) ) 
    {
      this.game.log( "warn", "critical", "selectWorn.js > received non-array", 'Parser' );
			return [];
		}
		var foundObjects = [];
		for(var i = 0; i < list.length; i++) 
    {
			var object = this.game.getAsset( list[i] );
      if( !object.place ) continue;
      var parent = object.getParentAsset();
      if( !parent ) continue;        
      if( parent.id !== this.game.getPlayer().id ) continue;
      if( !object.is.worn ) continue;

      foundObjects.push( list[i] );
		}

		return foundObjects;
	}
  
}());

// splitByPeriods.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Split distinct sentences by period.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#splitByPeriods
   * @param {String} input 
   * @returns {Array}
   */
   p.splitByPeriods = function Parser_splitByPeriods( input ) 
  {
    var inputArray = input.split('.');
    for( var i = inputArray.length - 1; i > -1; i-- ) 
    {
      inputArray[i] = inputArray[i].trim();
      if( " " === inputArray[i] 
      || "" === inputArray[i] ) 
      {
        inputArray.splice( i, 1 );
      }
    }
		inputArray.forEach(function(clause,index) 
    {
			var thenArray = this.splitByThens(clause);
			if(thenArray.length>1) 
      {
				var arrayFront = inputArray.slice(0,index);
				var arrayBack = inputArray.slice(index+1,inputArray.length+1);
				inputArray = arrayFront.concat(thenArray.concat(arrayBack));
			}
		}, this );
		return inputArray;
  }  
}());

// splitByThens.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * Each clause separated by 'then' is a distinct input.
   * We treat clauses as unrelated without depencencies
   * and stack each into a queue.
   * <br><br>
   * Example: "take sword then go north"
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#splitByThens
   * @param {String} input 
   * @returns {String}
   */
   p.splitByThens = function Parser_splitByThens(input) 
  {
    input = input.split(' then ' );
    /**
     * We also do a comma test here because English 
     * speakers may be inclined to use a comma  
     * before "then", as in:
     * 
     *  take sword, then go north
     * 
     * We want to strip that comma if we find it, but note that
     * in parseInput.js, commas are being substitued 
     * as a shorthand for " and ", so we have two different
     * comma searches in an effort to catch either case.
     */
    for( var i = 0; i < input.length; i++ ) 
    {
      input[i].trim();
      if( "," === input[i].charAt( input[i].length-1 ) )
      {
        input[i] = input[i].slice(0,-1);
      }
    }
		return input;
	}

}());

// stripArticles.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * Convert some common compound prepositions into single words
   * to streamline preposition handling.
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#stripArticles
   * @param {String} input Player input.
   * @returns {String}
   */
   p.stripArticles = function Parser_stripArticles( parsed_input ) 
  {

		parsed_input = parsed_input.replace(/ the /g, " ");
		parsed_input = parsed_input.replace(/ a /g, " ");
		parsed_input = parsed_input.replace(/ an /g, " ");
		//input = input.replace(/ some /g, " ");

    this.game.log( "log", "high", "parseInput.js > stripArticles return: " + parsed_input, 'Parser' );
    return parsed_input;
  
  }

}());

// stripConjunctions.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Parser.prototype;

  /**
   * <p>
   * In order to handle sentences with multiple clauses 
   * connected by conjunctions 'and' or 'but', we convert
   * them to symbols we can use down the line.
   * </p>
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#stripConjunctions
   * @param {String} input Player input.
   * @returns {String}
   */
   p.stripConjunctions = function Parser_stripConjunctions( input ) 
  {    

    /* *
     * Convert " and " to "&" for later noun parsing
     * We've already removed instances of " and then " 
     * and we're assuming that any other use of "and" is in 
     * the form of "verb noun and noun".
     * We also look for ", and" as in "take x, and y"  
     * which seems less likely to be input, but not impossible.
     * Another possibility: "look between noun and noun" - may need a lookBetweenAnd verb
     * "put noun between noun and noun" - might need a putBetweenAnd verb
     */
    input = input.replace(/, and /g, "&");
    input = input.replace(/ and /g, "&");


    /* *
     * Also convert ", " to "&", for instances of:
     *  take sword, shield
     * 
     * There is an additional comma check in splitByThens,
     * because we assume English speakers will input things like
     *  take sword, then go north
     * But in that case we want to strip the comma.
     */
		input = input.replace(/, /g, "&");


    /* *
     * Convert " but " to " -". Used  
     * to omit specific items from collections.
     * Example:
     *  take all but sword
     */
    input = input.replace(/ but /g, " -");

		return input;
  }  
}());

// verifySentence.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * After parse, verify each word in sentence.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#verifySentence
   */
  p.verifySentence = function Parser_parseSentence() {
    let this_turn = this.input_history[0];
    this.game.log(
      "log",
      "high",
      "verifySentence.js > " + this_turn.input,
      "Parser"
    );

    let count = {
      noun: 0,
      prep: 0,
      verb: 0,
      adverb: 0,
      adjective: 0,
      direction: 0,
      exclusion: 0,
      unknown: 0,
      string: 0,
      phrase: 0,
    };
    let firstverb;

    for (
      let position = 0;
      position < this_turn.parsed_sentence.length;
      position++
    ) {
      let this_word = this_turn.parsed_sentence[position];
      let last_word = this_turn.parsed_sentence[position - 1];
      let next_word = this_turn.parsed_sentence[position + 1];
      let msg = "";

      this.game.debug(
        `F1203 | verifySentence.js | ${this_word.type}/${this_word.word} `
      );

      // ----------------------------------------
      // verb
      // ----------------------------------------

      if (this_word.type === "verb") {
        // we don't accept double verbs except for "oops verb"
        if (
          last_word &&
          last_word.type === "verb" &&
          last_word.word !== "oops"
        ) {
          // too many verbs
          this.game.debug(
            `F1198 | verifySentence.js | input found two verbs in a row`
          );
          msg += this.getUnparsedMessage(this_turn.input);
          this.game.print(msg);
          return false;
        }
        count.verb++;
        this_turn.verified_sentence_structure += "verb ";
        this_turn.verified_sentence["verb" + count.verb] = {
          verb: this_word.word,
          verb_properties: this_word.properties,
        };

        continue;
      } // verb

      // ----------------------------------------
      // adverb
      // ----------------------------------------

      // if (this_word.type === "adverb") {
      // adverbcount++;
      // this_turn.verified_sentence_structure += "adverb ";
      // this_turn.verified_sentence['phrase'+count.phrase] = {
      //   adverb: adverb
      // }

      //   continue;
      // } // adverb

      // ----------------------------------------
      // direction
      // ----------------------------------------

      // if (this_word.type === "direction") {

      //   continue;
      // } // direction

      // ----------------------------------------
      // preposition
      // ----------------------------------------
      // @TODO any special handling for preposition is direction?

      if (this_word.type === "preposition") {
        if (last_word && last_word.type === "preposition") {
          // too many prepositions
          this.game.debug(
            `F1030 | verifySentence.js | parser found two or more prepositions`
          );
          msg += this.getUnparsedMessage(this_turn.input);
          this.game.print(msg);
          return false;
        }
        count.prep++;
        count.phrase++; // a preposition starts a new phrase
        this_turn.verified_sentence_structure += "preposition ";
        this_turn.verified_sentence["phrase" + count.phrase] = {
          preposition: this_word.word,
          preposition_properties: this_word.properties,
        };

        continue;
      } // preposition

      // ----------------------------------------
      // string
      // ----------------------------------------

      // if(this_word.type==="string") {
      //   continue;
      // } // string

      // ----------------------------------------
      // noun
      // ----------------------------------------

      // noun and itself ----------------------------------------
      // @TODO we have no other handling for itself yet

      if (this_word.type === "noun" && this_word.word === "itself") {
        if (!this_turn.verified_sentence["phrase" + count.phrase]?.noun) {
          this.game.debug(`F1862 | verifySentence.js | itself has no referent`);
          msg += this.getUnparsedMessage(this_turn.input);
          this.game.print(msg);
          return false;
        }
        if (last_word && last_word.type !== "preposition") {
          count.phrase++; // a new noun starts a new phrase
        }
        this_turn.verified_sentence_structure += "noun ";
        this_turn.verified_sentence["phrase" + count.phrase].noun = {
          noun: this_turn.verified_sentence["phrase" + (count.phrase - 1)].noun,
          noun_properties: this_word.properties,
        };
        // if there is a prior phrase...
        if (
          this_turn.verified_sentence["phrase" + (count.phrase - 1)].parsedNoun
        ) {
          // copy that phrase's noun to this phrase
          this_turn.verified_sentence["phrase" + count.phrase].parsedNoun =
            new adventurejs.ParsedNoun().set(
              this_turn.verified_sentence["phrase" + (count.phrase - 1)]
                .parsedNoun
            );
        }

        continue;
      } // itself

      // spatial_direction aka up/down/in/out ----------------------------------------

      if (
        this_word.type === "noun" &&
        this_word.properties.spatial_direction &&
        last_word &&
        last_word.type === "verb" &&
        next_word &&
        next_word.type === "noun"
      ) {
        // player has likely said something like "climb up tree"
        // we typically parse directions as nouns but in cases like this
        // we want to treat the direction as a preposition

        this.game.debug(
          ` | verifySentence.js | ${this_word.word} appears to be a spatial direction / preposition for ${next_word.word}`
        );

        count.phrase++;
        this_turn.verified_sentence["phrase" + count.phrase] = {}; // add new phrase
        this_turn.verified_sentence["phrase" + count.phrase].preposition =
          this_word.word;

        continue;
      } // this_word.properties.spatial_direction

      // noun and this_word.adjective ----------------------------------------

      if (
        this_word.type === "noun" &&
        this_word.adjective &&
        next_word &&
        next_word.type === "noun"
      ) {
        // word is both noun and adjective
        // if next word is noun then it's likely that
        // this is an adjective for the next word
        // if we treat the two nouns as one phrase,
        // do they have an unambiguous match?

        // first try getting an asset
        let found_asset_id;
        let found_asset = this.game.getAsset(
          this_word.word + " " + next_word.word
        );
        if (found_asset) found_asset_id = found_asset.id;

        // otherwise parseNoun which does a wider search
        if (!found_asset) {
          let parse_both = this.parseNoun(
            this_word.word + " " + next_word.word
          );
          found_asset_id = parse_both.matches.unambiguous;
          found_asset = this.game.getAsset(found_asset_id);
        }

        if (!found_asset_id) {
          this.game.debug(
            `F1219 | verifySentence.js | ${this_word.word} appears to be an adjective for ${next_word.word} and no ${this_word.word} ${next_word.word} was found`
          );
          msg += `$(We) don't know of any ${this_word.word} ${next_word.word}. `;
          this.game.print(msg, this_turn.output_class);
          return false;
        }

        // we found a noun that matches both words

        this.game.debug(
          `F1863 | verifySentence.js | ${found_asset_id} was found to match ${this_word.word} + ${next_word.word} `
        );

        this_word.asset = found_asset;
        this_word.word = found_asset_id;

        position++; // advance past next word

        // allow to go on to default noun handling
      } // noun and adjective

      // noun default ----------------------------------------

      if (this_word.type === "noun") {
        if (last_word && last_word.type !== "preposition") {
          count.phrase++;
          this_turn.verified_sentence["phrase" + count.phrase] = {}; // add new phrase
        }
        // save the noun
        this_turn.verified_sentence["phrase" + count.phrase].noun =
          this_word.word;
        // carry forward properties from parseSentence
        this_turn.verified_sentence["phrase" + count.phrase].noun_properties =
          this_word.properties;
        // save any exclusions
        if (this_word.exclusion) {
          this_turn.verified_sentence["phrase" + count.phrase].exclusion =
            this_word.exclusion;
        }
        this_turn.verified_sentence_structure += "noun ";
        count.noun++;

        continue;
      } // noun

      // ----------------------------------------
      // adjective
      // ----------------------------------------

      if (this_word.type === "adjective") {
        // Adjectives are tricky because nouns can have them defined in
        // their names, like "red door", and nouns can also have specific
        // adjectives assigned to them, so that "red" and "door" will find
        // the "door" asset with adjective "red". If player entered an
        // adjective that resolved to a noun, that noun will have been recorded
        // and probably our sentence structure will have two nouns in it,
        // something that we won't catch here, so we'll have to check again
        // in handleSentence.js.

        // We only end up here if an
        // adjective has been typed that is not attached to a noun. For
        // instance, no noun in the game uses "violet" but we understand that
        // "violet" is an adjective and if a user inputs "x violet door"
        // we can say "you don't see any violet door".

        if (next_word && next_word.type === "noun") {
          this.game.debug(
            `F1218 | verifySentence.js | ${this_word.word} appears to be an adjective for ${next_word.word} and no ${this_word.word} ${next_word.word} was found`
          );
          msg += `$(We) don't know of any ${this_word.word} ${next_word.word}. `;
          this.game.print(msg, this_turn.output_class);
          return false;
        } // adjective + noun

        continue;
      } // adjective

      // ----------------------------------------
      // unknown
      // ----------------------------------------

      if (this_word.type === "unknown") {
        // @TODO: soft prompt for "oops"
        this_turn.unknown_word = this_word.word;
        this.game.debug(
          `F1200 | verifySentence.js | ${this_word.word} is unknown`
        );
        msg += `The word <em class='unparsed'>${this_word.word}</em> wasn't recognized. `;
        this.game.print(msg, this_turn.output_class);
        return false;
      } // unknown
    }

    // trim the sentence structure
    this_turn.verified_sentence_structure =
      this_turn.verified_sentence_structure.trim();

    return true;
  }; // verifySentence
})();

// verifySentenceStructure.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Parser.prototype;

  /**
   * Verify that the active verb accepts the sentence structure.
   * @memberOf adventurejs.Parser
   * @method adventurejs.Parser#verifySentenceStructure
   * @param {Object} input A reference to the current turn's input object.
   * @param {Object} this_turn A reference to the current turn's input object.
   */
  p.verifySentenceStructure = function Parser_verifySentenceStructure() {
    var this_turn = this.input_history[0];
    this.game.log(
      "log",
      "high",
      "verifySentenceStructure.js > " + this_turn.verified_sentence_structure,
      "Parser"
    );

    let verb_name = this_turn.getVerb(1);
    if (
      verb_name &&
      this.game.dictionary.verbs[verb_name] &&
      this.game.dictionary.verbs[verb_name].accepts_structures.length
    ) {
      var verb = this.game.dictionary.verbs[verb_name];
      var valid = verb.accepts_structures;
      var structure = this_turn.verified_sentence_structure;
      var found = false;
      for (var j = 0; j < valid.length; j++) {
        if (valid[j] === structure) {
          found = true;
          break;
        }
      }

      if (!found) {
        let msg = "";
        msg += this.getUnparsedMessage(this_turn.input);
        this.game.debug(
          `F1199 | verifySentenceStructure.js | ${verb_name} doesn't accept structure > ${this_turn.verified_sentence_structure} `
        );
        this.game.print(msg);
        return false;
      }
    }

    return true;
  }; // verifySentenceStructure
})();

// ParsedNoun.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.ParsedNoun
   * @param {Object|adventurejs.Asset} asset
   * @ajsinternal
   * @ajsnavheading FrameworkReference
   * @summary Special class used to store metadata about an asset
   * and lists of all possible matches for that asset.
   * @classdesc
   * <p>
   * <strong>ParsedNoun</strong> is a special class constructed by
   * {@link adventurejs.Parser#parseNoun|Parser.parseNoun()},
   * and used to store metadata about an asset and lists of all
   * possible matches for that asset. This is an internal class
   * that authors should not need to construct.
   * </p>
   */
  class ParsedNoun {
    constructor(asset) {
      // @TODO should be able to do this but ParsedNoun has no context for game
      // if( asset && "string" === typeof asset )
      // {
      //   asset = this.game.getAsset( asset );
      // }
      if (!asset) asset = null;

      /**
       *
       * @var {String} adventurejs.ParsedNoun#
       * @default
       */
      this.class = "ParsedNoun";

      /**
       *
       * @var {Boolean} adventurejs.ParsedNoun#exclude
       * @default false
       */
      this.exclude = false;

      /**
       *
       * @var {String} adventurejs.ParsedNoun#plural
       * @default ""
       */
      this.plural = "";

      /**
       *
       * @var {Boolean} adventurejs.ParsedNoun#isPlural
       * @default false
       */
      this.isPlural = false;

      /**
       *
       * @var {Boolean} adventurejs.ParsedNoun#isGroup
       * @default false
       */
      this.isGroup = false;

      /**
       *
       * @var {String} adventurejs.ParsedNoun#singular
       * @default ""
       */
      this.singular = "";

      /**
       *
       * @var {String} adventurejs.ParsedNoun#type
       * @default ""
       */
      this.type = "";

      /**
       *
       * @var {String} adventurejs.ParsedNoun#input
       * @default ""
       */
      this.input = asset === null ? "" : asset.name;

      /**
       *
       * @var {String} adventurejs.ParsedNoun#serialized_input
       * @default ""
       */
      this.serialized_input = asset === null ? "" : asset.id;

      /**
       *
       * @var {String} adventurejs.ParsedNoun#deserialized_input
       * @default ""
       */
      this.deserialized_input = asset === null ? "" : asset.name;

      /**
       *
       * @var {String} adventurejs.ParsedNoun#qualified_object_id
       * @default
       */
      this.qualified_object_id = asset === null ? undefined : asset.id;

      /**
       *
       * @var {Object} adventurejs.ParsedNoun#matches
       * @default { all:[], direction:false, qualified:[], qualifiedIndex:0, unambiguous:""}
       */
      this.matches = {
        all: [],
        direction: false,
        substance: false,
        qualified: [],

        // qualifiedIndex exists because there is a scenario where
        // a verb can act without disambiguation upon one asset
        // out of a group returned by the parser
        qualifiedIndex: 0,

        // we set unamiguous but never really rely on it due to the
        // scenario described above - safer to use ParsedNoun.asset_id
        unambiguous: "",
      };

      if (null !== asset) {
        this.matches.all = [asset.id];
        this.matches.qualified = [asset.id];
        this.matches.qualifiedIndex = 0;
        this.matches.unambiguous = asset.id;
      }

      /**
       *
       * @var {String} adventurejs.ParsedNoun#preposition
       * @default ""
       */
      this.preposition = "";

      /**
       *
       * @var {Boolean} adventurejs.ParsedNoun#is_assumed
       * @default false
       */
      this.is_assumed = false;

      return this;
    }

    /**
     * Getter function looks for a qualified object id, and if it
     * doesn't find one, it returns the first qualified match.
     * @var {Getter} adventurejs.ParsedNoun#object_id
     * @returns {String}
     */
    get object_id() {
      if ("undefined" !== typeof this.qualified_object_id) {
        return this.qualified_object_id;
      } else if (this.matches.qualified.length > 0) {
        return this.matches.qualified[this.matches.qualifiedIndex];
      } else return null;
    }

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     * @method adventurejs.Atom#set
     * @memberOf adventurejs.Atom
     * @param {Object} props A generic object containing properties to copy to the Object instance.
     * @returns {Object} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(props) {
      return A.deepSet.call(this.game, props, this);
    }
  }

  adventurejs.ParsedNoun = ParsedNoun;
})();

// RestoreManager.js
(function () {
  /*global adventurejs A aria*/
  "use strict";

  /**
   *
   * @class adventurejs.RestoreManager
   * @ajsinternal
   * @ajsnavheading FrameworkReference
   * @param {Game} game A reference to the game instance.
   * @summary Manages the process of restoring saved games.
   * @todo Restore from adventurejs.com web server.
   * @classdesc
   * <p>
   * <strong>RestoreManager</strong> manages the job of restoring
   * saved games. It contains all the methods needed to create the
   * Restore pop-up screen. RestoreManager can restore a game from
   * a local save file, from browser cookies, or from the
   * <a href="https://adventurejs.com">adventurejs.com</a>
   * web server.
   * </p>
   * <p>
   * RestoreManager is created automatically
   * by {@link adventurejs.Game|Game}. This is an internal class that
   * authors should not need to construct or modify. However, if
   * you'd like to try, you can find styles for the Save & Restore
   * pop-ups in <a href="/css/adventurejs.css">adventurejs.css</a>.
   * All relevant styles are prefixed with '.save_' or '.restore_'.
   * </p>
   */
  class RestoreManager {
    constructor(game) {
      /**
       * A reference back to the main {@link adventurejs.Game|Game} object.
       * @var {Object} adventurejs.RestoreManager#game
       * @default {}
       */
      this.game = game;

      /**
       * Collection of HTML elements: the tabs used to navigate
       * between the different restore methods.
       * @var {Array} adventurejs.RestoreManager#restoreTabs
       * @default []
       */
      this.restoreTabs = [];

      /**
       * Collection of HTML elements: the panes containing the
       * different restore methods.
       * @var {Array} adventurejs.RestoreManager#restorePanes
       * @default []
       */
      this.restorePanes = [];

      /**
       * Collection of HTML elements: the action buttons for
       * the different restore methods.
       * @var {Array} adventurejs.RestoreManager#restoreButtons
       * @default []
       */
      this.restoreButtons = [];

      /**
       * Div element to contain the Restore pop-up.
       * @var {HTMLElement} adventurejs.RestoreManager#restoreDisplay
       * @default {}
       */
      this.restoreDisplay = document.createElement("div");
      this.restoreDisplay.classList.add("ajs-restore-display");
      this.game.display.displayEl.appendChild(this.restoreDisplay);

      this.restoreOuter = document.createElement("div");
      this.restoreOuter.classList.add("restore_outer");
      this.restoreDisplay.appendChild(this.restoreOuter);

      this.restoreInner = document.createElement("div");
      this.restoreInner.classList.add("restore_inner");
      this.restoreOuter.appendChild(this.restoreInner);

      // -----------------
      // CLOSE BUTTON
      // -----------------

      /**
       * Button element to close the Restore pop-up.
       * @var {HTMLElement} adventurejs.RestoreManager#restoreClose
       * @default {}
       */
      this.restoreClose = document.createElement("button");
      this.restoreClose.classList.add("restore_close", "close_button");
      this.restoreClose.type = "button";
      this.restoreClose.value = "Close";
      this.restoreClose.innerHTML = "X";
      this.restoreClose.name = "restoreClose";
      this.restoreClose.manager = this;
      this.restoreInner.appendChild(this.restoreClose);
      this.restoreClose.addEventListener("click", function () {
        this.manager.clickButton_Close();
      });

      // -----------------
      // TITLE BAR
      // -----------------
      /**
       * P element to close the Restore pop-up's title bar.
       * @var {HTMLElement} adventurejs.RestoreManager#restoreDisplayTitle
       * @default {}
       */
      this.restoreDisplayTitle = document.createElement("p");
      this.restoreDisplayTitle.classList.add("restore_display_title");
      this.restoreDisplayTitle.innerHTML = "RESTORE GAME";
      this.restoreInner.appendChild(this.restoreDisplayTitle);

      // -----------------
      // TABS
      // -----------------
      /**
       * Div element to contain the Restore pop-up's tabs.
       * @var {HTMLElement} adventurejs.RestoreManager#restoreRowTabs
       * @default {}
       */
      this.restoreRowTabs = document.createElement("div");
      this.restoreRowTabs.classList.add("restore_row_tabs");
      this.restoreInner.appendChild(this.restoreRowTabs);

      // -----------------
      // FILE TAB
      // -----------------
      /**
       * Button element to navigate to 'Restore from File' option.
       * @var {HTMLElement} adventurejs.RestoreManager#restoreTab_File
       * @default {}
       */
      this.restoreTab_File = document.createElement("button");
      this.restoreTab_File.classList.add(
        "restore_tab_file",
        "active",
        "restore_tab"
      );
      this.restoreTab_File.type = "button";
      this.restoreTab_File.value = "Restore from File";
      this.restoreTab_File.innerHTML = "Restore from File";
      this.restoreTab_File.name = "restoreTab_File";
      this.restoreTab_File.manager = this;
      this.restoreRowTabs.appendChild(this.restoreTab_File);
      this.restoreTab_File.addEventListener("click", function () {
        if (false === this.classList.contains("active")) {
          this.manager.selectTab(this);
        }
      });
      this.restoreTabs.push(this.restoreTab_File);

      // -----------------
      // BROWSER TAB
      // -----------------
      /**
       * Button element to navigate to 'Restore from Browser' option.
       * @var {HTMLElement} adventurejs.RestoreManager#restoreTab_Browser
       * @default {}
       */
      this.restoreTab_Browser = document.createElement("button");
      this.restoreTab_Browser.classList.add(
        "restore_tab_browser",
        "restore_tab"
      );
      this.restoreTab_Browser.type = "button";
      this.restoreTab_Browser.value = "Restore from Browser";
      this.restoreTab_Browser.innerHTML = "Restore from Browser";
      this.restoreTab_Browser.name = "restoreTab_Browser";
      this.restoreTab_Browser.manager = this;
      this.restoreRowTabs.appendChild(this.restoreTab_Browser);
      this.restoreTab_Browser.addEventListener("click", function () {
        if (false === this.classList.contains("active")) {
          this.manager.selectTab(this);
          this.manager.getLocalStorageList();
        }
      });
      this.restoreTabs.push(this.restoreTab_Browser);

      // -----------------
      // SERVER TAB
      // -----------------
      /**
       * Button element to navigate to 'Restore from Server' option.
       * @var {HTMLElement} adventurejs.RestoreManager#restoreTab_Server
       * @default {}
       */
      this.restoreTab_Server = document.createElement("button");
      this.restoreTab_Server.classList.add("restore_tab_server", "restore_tab");
      this.restoreTab_Server.type = "button";
      this.restoreTab_Server.value = "Restore from Server";
      this.restoreTab_Server.innerHTML = "Restore from Server";
      this.restoreTab_Server.name = "restoreTab_Server";
      this.restoreTab_Server.manager = this;
      this.restoreRowTabs.appendChild(this.restoreTab_Server);
      this.restoreTab_Server.addEventListener("click", function () {
        if (false === this.classList.contains("active")) {
          this.manager.selectTab(this);
        }
      });
      this.restoreTabs.push(this.restoreTab_Server);

      // -----------------
      // PANES
      // -----------------
      /**
       * Div element to contain Restore panes.
       * @var {HTMLElement} adventurejs.RestoreManager#restoreRowPanes
       * @default {}
       */
      this.restoreRowPanes = document.createElement("div");
      this.restoreRowPanes.classList.add("restore_row_panes");
      this.restoreInner.appendChild(this.restoreRowPanes);

      // -----------------
      // FILE PANE
      // -----------------
      /**
       * Div element to contain 'Restore from File' pane.
       * @var {HTMLElement} adventurejs.RestoreManager#restorePane_File
       * @default {}
       */
      this.restorePane_File = document.createElement("div");
      this.restorePane_File.classList.add(
        "restore_pane_file",
        "restore_pane",
        "active"
      );
      this.restorePane_File.innerHTML += "";
      this.restorePane_File.name = "restorePane_File";
      this.restorePane_File.manager = this;
      this.restorePanes.push(this.restorePane_File);

      // check that this browser supports the methods
      // needed for save/restore of local files
      this.fileReaderUnsupported =
        "undefined" === typeof window.File ||
        "undefined" === typeof window.FileReader ||
        "undefined" === typeof window.FileList ||
        "undefined" === typeof window.Blob;
      var a = document.createElement("a");
      this.downloadUnsupported = "undefined" === typeof a.download;
      //document.removeChild(a);

      if (this.fileReaderUnsupported || this.downloadUnsupported) {
        this.restorePane_File.classList.add("unsupported_feature");
      }

      this.restorePane_File_QA = document.createElement("div");
      this.restorePane_File_QA.classList = "restore_pane_qa";
      this.restorePane_File.appendChild(this.restorePane_File_QA);
      this.restorePane_File_QA.innerHTML =
        "" +
        "<p class='restore_pane_qa_q'>What's this?</p>" +
        "<p class='restore_pane_qa_a'>" +
        "Use this option to restore a save you downloaded using the " +
        '<span class="bootstrap_blue ">Save to File</span> ' +
        "option. If, when you saved, your browser didn't offer " +
        "you a file dialog to choose your download location, " +
        "then your save file was probably downloaded to " +
        "your computer's default Download folder. " +
        "</p>";
      this.restorePane_File_QA.addEventListener("click", function () {
        this.classList.toggle("active");
      });

      this.restoreRowPanes.appendChild(this.restorePane_File);
      this.restoreTab_File.restorePane = this.restorePane_File;
      this.restoreTab_File.restorePaneQA = this.restorePane_File_QA;

      // CHOOSE FILE

      this.restoreInputContainer_File = document.createElement("div");
      this.restoreInputContainer_File.classList.add(
        "restore_input_container_file",
        "restore_input_container",
        "supported"
      );
      this.restorePane_File.appendChild(this.restoreInputContainer_File);

      this.restoreInput_File = document.createElement("input");
      this.restoreInput_File.classList.add(
        "restore_input_file",
        "restore_input"
      );
      this.restoreInputContainer_File.appendChild(this.restoreInput_File);
      this.restoreInput_File.type = "file";
      this.restoreInput_File.accept = ".json";
      this.restoreInput_File.name = "restoreInput_File";
      this.restoreInput_File.manager = this;
      this.restoreInput_File.id = this.game.game_name + "_restoreInput_File";

      this.restoreInput_File.addEventListener(
        "change",
        function (e) {
          console.log("restoreInput_File.click");
          console.log("--", e.target.files[0]);
          console.log("--", e.target.value);

          // we've set our file input to accept=".json", but just in case
          if (".json" !== e.target.value.substring(e.target.value.length - 5)) {
            e.target.value = "";
            alert("Selected file is not a JSON file.");
            return false;
          }
          this.manager.restoreButton_File.classList.remove("inactive");
        },
        false
      );

      // https://tympanus.net/codrops/2015/09/15/styling-customizing-file-inputs-smart-way/
      // method for styling inputs - but content to keep native style for now
      // this.restoreLabelFile = document.createElement("label");
      // this.restoreLabelFile.classList.add( "restore_label_file", "restore_label" );
      // this.restoreLabelFile.setAttribute("for", this.game.game_name + "_restoreInput_File" );
      // this.restoreLabelFile.innerHTML = "Choose a file";
      // this.restoreInputContainer_File.appendChild( this.restoreLabelFile );

      // RESTORE BUTTON

      this.restoreButtonContainer_File = document.createElement("div");
      this.restoreButtonContainer_File.classList.add(
        "restore_button_container_file",
        "restore_button_container",
        "supported"
      );
      this.restorePane_File.appendChild(this.restoreButtonContainer_File);

      this.restoreButton_File = document.createElement("button");
      this.restoreButton_File.classList.add(
        "restore_button_file",
        "restore_button",
        "inactive"
      );
      this.restoreButton_File.type = "button";
      this.restoreButton_File.value = "Restore from File";
      this.restoreButton_File.innerHTML = "Restore from File";
      this.restoreButton_File.name = "restoreButton_File";
      this.restoreButton_File.manager = this;

      this.restoreButtonContainer_File.appendChild(this.restoreButton_File);
      this.restoreButton_File.addEventListener("click", function () {
        this.manager.clickRestoreButton_File();
      });

      this.restoreButtons.push(this.restoreButton_File);

      // UNSUPPORTED MESSAGE

      this.restoreWarningContainer_File = document.createElement("div");
      this.restoreWarningContainer_File.classList.add(
        "restore_warning_container_file",
        "restore_warning_container",
        "unsupported"
      );
      this.restorePane_File.appendChild(this.restoreWarningContainer_File);

      this.restoreWarning_File = document.createElement("div");
      this.restoreWarning_File.classList =
        "restore_pane_warning alert alert-danger";
      this.restoreWarningContainer_File.appendChild(this.restoreWarning_File);
      this.restoreWarning_File.innerHTML =
        "" +
        "<p class='restore_pane_warning'>" +
        "Unfortunately, your web browser doesn't appear to support " +
        "this save/restore method. Please try one of the other methods, " +
        "or try playing with a different web browser. " +
        "</p>";

      // -----------------
      // BROWSER PANE
      // -----------------
      /**
       * Div element to contain 'Restore from Browser' pane.
       * @var {HTMLElement} adventurejs.RestoreManager#restorePane_Browser
       * @default {}
       */
      this.restorePane_Browser = document.createElement("div");
      this.restorePane_Browser.classList.add(
        "restore_pane_browser",
        "restore_pane"
      );
      this.restorePane_Browser.name = "restorePane_Browser";
      this.restorePane_Browser.manager = this;
      this.restorePanes.push(this.restorePane_Browser);

      this.restorePane_Browser_QA = document.createElement("div");
      this.restorePane_Browser_QA.classList = "restore_pane_qa";
      this.restorePane_Browser.appendChild(this.restorePane_Browser_QA);
      this.restorePane_Browser_QA.innerHTML =
        "" +
        "<p class='restore_pane_qa_q'>What's this?</p>" +
        "<p class='restore_pane_qa_a'>" +
        "Use this option to restore a save you downloaded using the " +
        '<span class="bootstrap_blue ">Save to Browser</span> ' +
        "option. It will only find saves you made while playing the game" +
        "on this browser on this computer at this web domain. " +
        "</p>";
      this.restorePane_Browser_QA.addEventListener("click", function () {
        this.classList.toggle("active");
      });

      this.restoreRowPanes.appendChild(this.restorePane_Browser);
      this.restoreTab_Browser.restorePane = this.restorePane_Browser;
      this.restoreTab_Browser.restorePaneQA = this.restorePane_Browser_QA;

      // LISTBOX
      // example with aria tagging
      // https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-scrollable.html

      // instantiate a new listbox
      // var exListbox = new aria.Listbox(document.getElementById('ss_elem_list'));

      this.restoreListboxContainer_Browser = document.createElement("div");
      this.restoreListboxContainer_Browser.classList.add(
        "restore_listbox_container_browser",
        "restore_listbox_container"
      );
      this.restorePane_Browser.appendChild(
        this.restoreListboxContainer_Browser
      );

      this.restoreListboxLabel_Browser = document.createElement("p");
      this.restoreListboxLabel_Browser.classList.add(
        "restore_listbox_label_browser",
        "restore_listbox_label",
        "listbox_label"
      );
      this.restoreListboxContainer_Browser.appendChild(
        this.restoreListboxLabel_Browser
      );
      this.restoreListboxLabel_Browser.innerHTML =
        "Select a saved game to restore:";
      this.restoreListboxLabel_Browser.id =
        this.game.game_name + "_restoreListboxLabel_Browser";

      this.restoreListbox_Browser = document.createElement("ul");
      this.restoreListbox_Browser.classList.add(
        "restore_listbox_browser",
        "restore_listbox",
        "listbox"
      );
      this.restoreListboxContainer_Browser.appendChild(
        this.restoreListbox_Browser
      );
      this.restoreListbox_Browser.id =
        this.game.game_name + "_restoreListbox_Browser";
      this.restoreListbox_Browser.setAttribute(
        "aria-labelledby",
        this.restoreListboxLabel_Browser.id
      );
      this.restoreListbox_Browser.role = "listbox";
      this.restoreListbox_Browser.setAttribute("tabindex", "0");

      this.restoreObserver_Browser = new MutationObserver(function (mutation) {
        if (mutation[0].attributeName !== "aria-activedescendant") {
          return;
        }
        var selection = mutation[0].target.getAttribute(
          mutation[0].attributeName
        );
        //if( document.getElementById( selection ).classList.contains( "focused" ) ) {
        if (
          null !==
          document.getElementById(selection).getAttribute("aria-selected")
        ) {
          console.log(selection);
          this.manager.restoreButton_Browser.classList.remove("inactive");
        }
      });
      this.restoreObserver_Browser.manager = this;

      this.restoreObserver_Browser.observe(this.restoreListbox_Browser, {
        // childList: true,
        attributes: true,
      });

      // RESTORE BUTTON

      this.restoreButtonContainer_Browser = document.createElement("div");
      this.restoreButtonContainer_Browser.classList.add(
        "restore_button_container_browser",
        "restore_button_container"
      );
      this.restorePane_Browser.appendChild(this.restoreButtonContainer_Browser);

      this.restoreButton_Browser = document.createElement("button");
      this.restoreButton_Browser.classList.add(
        "restore_button_browser",
        "restore_button"
      );
      this.restoreButton_Browser.type = "button";
      this.restoreButton_Browser.value = "Restore from Browser";
      this.restoreButton_Browser.innerHTML = "Restore from Browser";
      this.restoreButton_Browser.name = "restoreButton_Browser";
      this.restoreButton_Browser.manager = this;

      this.restoreButtonContainer_Browser.appendChild(
        this.restoreButton_Browser
      );
      this.restoreButton_Browser.addEventListener("click", function () {
        this.manager.clickRestoreButton_Browser();
      });

      this.restoreButtons.push(this.restoreButton_Browser);

      // -----------------
      // SERVER PANE
      // -----------------
      /**
       * Div element to contain 'Restore from Server' pane.
       * @var {HTMLElement} adventurejs.RestoreManager#restorePane_Server
       * @default {}
       */
      this.restorePane_Server = document.createElement("div");
      this.restorePane_Server.classList.add(
        "restore_pane_server",
        "restore_pane"
      );
      this.restorePane_Server.name = "restorePane_Server";
      this.restorePane_Server.manager = this;
      this.restorePanes.push(this.restorePane_Server);

      this.restorePane_Server_QA = document.createElement("div");
      this.restorePane_Server_QA.classList = "restore_pane_qa";
      this.restorePane_Server.appendChild(this.restorePane_Server_QA);
      this.restorePane_Server_QA.innerHTML =
        "" +
        "<p class='restore_pane_qa_q'>What's this?</p>" +
        "<p class='restore_pane_qa_a'>" +
        "Use this option to restore a game you saved using the " +
        '<span class="bootstrap_blue ">Save to Server</span> ' +
        "option. You will need to log in to the adventurejs server " +
        "if you haven't already. " +
        "</p>";
      this.restorePane_Server_QA.addEventListener("click", function () {
        this.classList.toggle("active");
      });
      this.restoreRowPanes.appendChild(this.restorePane_Server);
      this.restoreTab_Server.restorePane = this.restorePane_Server;
      this.restoreTab_Server.restorePaneQA = this.restorePane_Server_QA;

      // RESTORE BUTTON

      this.restoreButtonContainer_Server = document.createElement("div");
      this.restoreButtonContainer_Server.classList.add(
        "restore_button_container_server",
        "restore_button_container"
      );
      this.restorePane_Server.appendChild(this.restoreButtonContainer_Server);

      this.restoreButton_Server = document.createElement("button");
      this.restoreButton_Server.classList.add(
        "restore_button_server",
        "restore_button"
      );
      this.restoreButton_Server.type = "button";
      this.restoreButton_Server.value = "Restore from Server";
      this.restoreButton_Server.innerHTML = "Restore from Server";
      this.restoreButton_Server.name = "restoreButton_Server";
      this.restoreButton_Server.manager = this;

      this.restoreButtonContainer_Server.appendChild(this.restoreButton_Server);
      this.restoreButton_Server.addEventListener("click", function () {
        this.manager.clickRestoreButton_Server();
      });

      this.restoreButtons.push(this.restoreButton_Server);
    }

    /**
     * Open the Restore pop-up window.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#openDisplay
     * @kind function
     */
    openDisplay() {
      this.resetDisplay();
      this.restoreDisplay.classList.add("active");
    }

    /**
     * Reset the Restore pop-up window.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#resetDisplay
     * @kind function
     */
    resetDisplay() {
      this.restoreInput_File.value = "";
      this.restoreButton_File.classList.add("inactive");
      this.restoreButton_Browser.classList.add("inactive");
      this.restoreButton_Server.classList.add("inactive");
    }

    /**
     * Close the Restore pop-up window.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#closeDisplay
     * @kind function
     */
    closeDisplay() {
      console.warn("RestoreManager.js closeDisplay");
      this.restoreDisplay.classList.remove("active");
      this.selectTab(this.restoreTab_File);
      this.restoreButtons.forEach(function (button) {
        button.classList.add("inactive");
      });
    }

    /**
     * Function that gets called by the Close button.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#clickButton_Close
     * @kind function
     */
    clickButton_Close() {
      console.log("clickButton_Close");
      this.closeDisplay();
      var msg = "Restore cancelled.";
      this.game.print(msg);
      return;
    }

    // -----------------
    // FILE PANE
    // -----------------

    /**
     * Restore the seleted save file.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#clickRestoreButton_File
     * @kind function
     */
    clickRestoreButton_File() {
      console.log("clickRestoreButton_File");
      var fileReader = new FileReader();
      // forward closured fileReader.onload event
      // to a more useful scope
      fileReader.onload = (function (manager) {
        return function (e) {
          manager.fileReaderOnload(e);
        };
      })(this);
      fileReader.readAsText(this.restoreInput_File.files[0], "UTF-8");
    }

    /**
     * Complete the restore operation and close the pop-up.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#fileReaderOnload
     * @kind function
     */
    fileReaderOnload(e) {
      console.log("fileReaderOnload");
      console.log(e);

      this.closeDisplay();
      var restored = A.restoreWorld.call(this.game, e.target.result);

      if (false === restored) {
        var msg = "Restore failed!";
        this.game.print(msg);
        return false;
      }

      var msg = "Game restored.";
      this.game.print(msg);
      return;
    }

    // -----------------
    // BROWSER PANE
    // -----------------
    // https://blog.logrocket.com/the-complete-guide-to-using-localstorage-in-javascript-apps-ba44edb53a36/

    /**
     * Restore the seleted save file.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#clickRestoreButton_Browser
     * @kind function
     */
    clickRestoreButton_Browser() {
      console.log("clickRestoreButton_Browser");

      var saveName = this.restoreListbox_Browser.getAttribute(
        "aria-activedescendant"
      );

      var restored = this.game.restoreWorld(window.localStorage[saveName]);

      this.closeDisplay();

      if (false === restored) {
        var msg = "Restore failed!";
        this.game.print(msg);
        return false;
      }

      var msg = "Game restored.";
      this.game.print(msg);
      return;
    }

    /**
     * Get a list of saved games stored in browser cookies.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#getLocalStorageList
     * @kind function
     */
    getLocalStorageList() {
      this.resetLocalStorageListBox();

      var storage = window.localStorage;
      for (var key in storage) {
        // if( this.game.titleSerialized !== key.substr( 0, this.game.titleSerialized.length ) ) // @deprecated
        if (
          this.game.titleSerialized !==
          key.substring(0, this.game.titleSerialized.length)
        ) {
          continue;
        }
        var li = document.createElement("li");
        li.id = key;
        //li.innerHTML = key;
        li.innerHTML = key.substring(this.game.titleSerialized.length + 1);

        li.setAttribute("role", "option");
        this.restoreListbox_Browser.appendChild(li);
      }
      if (0 < this.restoreListbox_Browser.childNodes.length) {
        this.restoreListbox_Browser.setAttribute(
          "aria-activedescendant",
          this.restoreListbox_Browser.childNodes[0].id
        );
      }
      this.restoreListboxInstance_Browser = new aria.Listbox(
        this.restoreListbox_Browser
      );
      this.restoreListbox_Browser.focus();
      // TODO why doesn't this focus work?
    }

    /**
     * Reset local storage listbox.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#resetLocalStorageListBox
     * @kind function
     */
    resetLocalStorageListBox() {
      if (
        !this.restoreListbox_Browser.innerHTML &&
        "undefined" === typeof this.restoreListboxInstance_Browser
      ) {
        // already empty
        return;
      }
      if ("undefined" !== typeof this.restoreListboxInstance_Browser) {
        delete this.restoreListboxInstance_Browser;
      }
      for (
        var i = this.restoreListbox_Browser.childNodes.length - 1;
        i > -1;
        i--
      ) {
        // TODO remove? or repurpose?
        this.restoreListbox_Browser.removeChild(
          this.restoreListbox_Browser.childNodes[i]
        );
      }
      this.restoreListbox_Browser.innerHTML = "";
      return;
    }

    // -----------------
    // SERVER PANE
    // -----------------

    /**
     * Restore the seleted save file.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#clickRestoreButton_Server
     * @kind function
     */
    clickRestoreButton_Server() {
      console.log("clickRestoreButton_Server");
    }

    /**
     * Make a selected tab active.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#selectTab
     * @kind function
     */
    selectTab(selectedTab) {
      this.restoreTabs.forEach(function (tabButton) {
        if (tabButton !== selectedTab) {
          tabButton.classList.remove("active");
          tabButton.restorePane.classList.remove("active");
          tabButton.restorePaneQA.classList.remove("active");
        } else {
          tabButton.classList.add("active");
          tabButton.restorePane.classList.add("active");
        }
      }, selectedTab);
    }

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     * @memberOf adventurejs.RestoreManager
     * @method adventurejs.RestoreManager#set
     * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
     * @returns {adventurejs.RestoreManager} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(props) {
      // if (props != null) {
      //   for (var n in props) {
      //     this[n] = props[n];
      //   }
      // }
      // return this;
      return A.deepSet.call(this.game, props, this);
    }
  }
  adventurejs.RestoreManager = RestoreManager;
})();

// SaveManager.js

// https://eligrey.com/demos/FileSaver.js/
// https://www.dropzonejs.com/
// https://gist.github.com/liabru/11263260#file-save-file-local-js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   *
   * @class adventurejs.SaveManager
   * @ajsnavheading FrameworkReference
   * @param {Game} game A reference to the game instance.
   * @summary Manages the process of saving games.
   * @todo Save to adventurejs.com web server.
   * @classdesc
   * <p>
   * <strong>SaveManager</strong> manages the job of saving games.
   * It contains all the methods needed to create the
   * Save pop-up screen. SaveManager can save a game to
   * a local save file, to browser cookies, or to the
   * <a href="https://adventurejs.com">adventurejs.com</a>
   * web server.
   * </p>
   * <p>
   * SaveManager is created automatically
   * by {@link adventurejs.Game|Game}. This is an internal class that
   * authors should not need to construct or modify. However, if
   * you'd like to try, you can find styles for the Save & Restore
   * pop-ups in <a href="/css/adventurejs.css">adventurejs.css</a>.
   * All relevant styles are prefixed with '.save_' or '.restore_'.
   * </p>
   */
  class SaveManager {
    constructor(game) {
      /**
       * A reference back to the main {@link adventurejs.Game|Game} object.
       * @var {Object} adventurejs.SaveManager#game
       * @default {}
       */
      this.game = game;

      /**
       * Collection of HTML elements: the tabs used to navigate
       * between the different save methods.
       * @var {Array} adventurejs.SaveManager#saveTabs
       * @default []
       */
      this.saveTabs = [];

      /**
       * Collection of HTML elements: the panes containing the
       * different save methods.
       * @var {Array} adventurejs.SaveManager#savePanes
       * @default []
       */
      this.savePanes = [];

      /**
       * Collection of HTML elements: the action buttons for
       * the different save methods.
       * @var {Array} adventurejs.SaveManager#saveButtons
       * @default []
       */
      this.saveButtons = [];

      /**
       * Div element to contain the Save pop-up.
       * @var {HTMLElement} adventurejs.RestoreManager#saveDisplay
       * @default {}
       */
      this.saveDisplay = document.createElement("div");
      this.saveDisplay.classList.add("ajs-save-display");
      this.game.display.displayEl.appendChild(this.saveDisplay);

      this.saveOuter = document.createElement("div");
      this.saveOuter.classList.add("save_outer");
      this.saveDisplay.appendChild(this.saveOuter);

      this.saveInner = document.createElement("div");
      this.saveInner.classList.add("save_inner");
      this.saveOuter.appendChild(this.saveInner);

      // -----------------
      // CLOSE BUTTON
      // -----------------

      /**
       * Button element to close the Save pop-up.
       * @var {HTMLElement} adventurejs.SaveManager#restoreClose
       * @default {}
       */
      this.saveClose = document.createElement("button");
      this.saveClose.classList.add("save_close", "close_button");
      this.saveClose.type = "button";
      this.saveClose.value = "Close";
      this.saveClose.innerHTML = "X";
      this.saveClose.name = "saveClose";
      this.saveClose.manager = this;
      this.saveInner.appendChild(this.saveClose);
      this.saveClose.addEventListener("click", function () {
        this.manager.clickButton_Close();
      });

      // -----------------
      // TITLE BAR
      // -----------------
      /**
       * P element to close the Save pop-up's title bar.
       * @var {HTMLElement} adventurejs.SaveManager#saveDisplayTitle
       * @default {}
       */
      this.saveDisplayTitle = document.createElement("p");
      this.saveDisplayTitle.classList.add("save_display_title");
      this.saveDisplayTitle.innerHTML = "SAVE GAME";
      this.saveInner.appendChild(this.saveDisplayTitle);

      // -----------------
      // FILENAME INPUT
      // -----------------
      /**
       * Div element to contain the Save row input.
       * @var {HTMLElement} adventurejs.SaveManager#saveRowInput
       * @default {}
       */
      this.saveRowInput = document.createElement("div");
      this.saveRowInput.classList.add("save_row_input");
      this.saveInner.appendChild(this.saveRowInput);

      this.saveInputLabel = document.createElement("p");
      this.saveInputLabel.classList.add("save_input_label");
      this.saveInputLabel.innerHTML = "Enter a name for your save file:";
      this.saveRowInput.appendChild(this.saveInputLabel);

      this.saveInput = document.createElement("input");
      this.saveInput.setAttribute("id", this.game.name + "_" + "save_input");
      this.saveInput.classList.add("save_input");
      this.saveInput.pattern = "[_A-Za-z0-9\\-]{64}";
      this.saveInput.manager = this;
      this.saveRowInput.appendChild(this.saveInput);
      this.saveInput.addEventListener("input", function () {
        this.manager.saveInputOninput(this);
      });
      this.saveInput.addEventListener("onkeydown", function () {
        this.manager.saveInputOninput(this);
      });

      // -----------------
      // TABS
      // -----------------
      /**
       * Div element to contain the Save pop-up's tabs.
       * @var {HTMLElement} adventurejs.SaveManager#saveRowTabs
       * @default {}
       */
      this.saveRowTabs = document.createElement("div");
      this.saveRowTabs.classList.add("save_row_tabs");
      this.saveInner.appendChild(this.saveRowTabs);

      // -----------------
      // FILE TAB
      // -----------------
      /**
       * Button element to navigate to 'Save to File' option.
       * @var {HTMLElement} adventurejs.SaveManager#saveTab_File
       * @default {}
       */
      this.saveTab_File = document.createElement("button");
      this.saveTab_File.classList.add("save_tab_file", "active", "save_tab");
      this.saveTab_File.type = "button";
      this.saveTab_File.value = "Save to File";
      this.saveTab_File.innerHTML = "Save to File";
      this.saveTab_File.name = "saveTab_File";
      this.saveTab_File.manager = this;
      this.saveRowTabs.appendChild(this.saveTab_File);
      this.saveTab_File.addEventListener("click", function () {
        if (false === this.classList.contains("active")) {
          this.manager.selectTab(this);
          //this.manager.clickSaveButton_File();
        }
      });
      this.saveTabs.push(this.saveTab_File);

      // -----------------
      // BROWSER TAB
      // -----------------
      /**
       * Button element to navigate to 'Save to Browser' option.
       * @var {HTMLElement} adventurejs.SaveManager#saveTab_Browser
       * @default {}
       */
      this.saveTab_Browser = document.createElement("button");
      this.saveTab_Browser.classList.add("save_tab_browser", "save_tab");
      this.saveTab_Browser.type = "button";
      this.saveTab_Browser.value = "Save to Browser";
      this.saveTab_Browser.innerHTML = "Save to Browser";
      this.saveTab_Browser.name = "saveTab_Browser";
      this.saveTab_Browser.manager = this;
      this.saveRowTabs.appendChild(this.saveTab_Browser);
      this.saveTab_Browser.addEventListener("click", function () {
        if (false === this.classList.contains("active")) {
          this.manager.selectTab(this);
          //this.manager.clickButton_Browser();
        }
      });
      this.saveTabs.push(this.saveTab_Browser);

      // -----------------
      // SERVER TAB
      // -----------------
      /**
       * Button element to navigate to 'Save to Server' option.
       * @var {HTMLElement} adventurejs.SaveManager#saveTab_Server
       * @default {}
       */
      this.saveTab_Server = document.createElement("button");
      this.saveTab_Server.classList.add("save_tab_server", "save_tab");
      this.saveTab_Server.type = "button";
      this.saveTab_Server.value = "Save Server";
      this.saveTab_Server.innerHTML = "Save to Server";
      this.saveTab_Server.name = "saveTab_Server";
      this.saveTab_Server.manager = this;
      this.saveRowTabs.appendChild(this.saveTab_Server);
      this.saveTab_Server.addEventListener("click", function () {
        if (false === this.classList.contains("active")) {
          this.manager.selectTab(this);
          //this.manager.clickButton_Server();
        }
      });
      this.saveTabs.push(this.saveTab_Server);

      // -----------------
      // PANES
      // -----------------
      /**
       * Div element to contain Save panes.
       * @var {HTMLElement} adventurejs.SaveManager#saveRowPanes
       * @default {}
       */
      this.saveRowPanes = document.createElement("div");
      this.saveRowPanes.classList.add("save_row_panes");
      this.saveInner.appendChild(this.saveRowPanes);

      // -----------------
      // FILE PANE
      // -----------------
      /**
       * Div element to contain 'Save to File' pane.
       * @var {HTMLElement} adventurejs.SaveManager#savePane_File
       * @default {}
       */
      this.savePane_File = document.createElement("div");
      this.savePane_File.classList.add("save_pane_file", "save_pane", "active");
      this.savePane_File.innerHTML += "";
      this.savePane_File.name = "savePane_File";
      this.savePane_File.manager = this;
      this.savePanes.push(this.savePane_File);

      // check that this browser supports the methods
      // needed for save/restore of local files
      this.fileReaderUnsupported =
        "undefined" === typeof window.File ||
        "undefined" === typeof window.FileReader ||
        "undefined" === typeof window.FileList ||
        "undefined" === typeof window.Blob;
      var a = document.createElement("a");
      this.downloadUnsupported = "undefined" === typeof a.download;
      //document.removeChild(a);

      if (this.fileReaderUnsupported || this.downloadUnsupported) {
        this.savePane_File.classList.add("unsupported_feature");
      }

      this.savePane_File_QA = document.createElement("div");
      this.savePane_File_QA.classList = "save_pane_qa";
      this.savePane_File.appendChild(this.savePane_File_QA);
      // TODO accessibility
      // https://getbootstrap.com/docs/4.0/components/collapse/#accessibility
      this.savePane_File_QA.innerHTML =
        "" +
        "<p class='save_pane_qa_q'>What's this?</p>" +
        "<p class='save_pane_qa_a'>" +
        'The <span class="bootstrap_blue ">Save to File</span> ' +
        "option will download a saved game file to your computer's hard drive. " +
        "<br/><br/>PRO: You can restore these save files in any browser that can run " +
        "this game, and copy them to other computers. " +
        "<br/><br/>CON: For reasons of security, the browser won't open a file dialog " +
        "to let you choose where to put it. " +
        "It should go to your browser's default Download folder. " +
        "</p>";
      this.savePane_File_QA.addEventListener("click", function () {
        this.classList.toggle("active");
      });

      this.saveRowPanes.appendChild(this.savePane_File);
      this.saveTab_File.savePane = this.savePane_File;
      this.saveTab_File.savePaneQA = this.savePane_File_QA;

      // SAVE BUTTON

      this.saveButtonContainer_File = document.createElement("div");
      this.saveButtonContainer_File.classList.add(
        "save_button_container_file",
        "save_button_container",
        "supported"
      );
      this.savePane_File.appendChild(this.saveButtonContainer_File);

      this.saveButton_File = document.createElement("button");
      this.saveButton_File.classList.add("save_button_file", "save_button");
      this.saveButton_File.type = "button";
      this.saveButton_File.value = "Save to File";
      this.saveButton_File.innerHTML = "Save to File";
      this.saveButton_File.name = "saveButton_File";
      this.saveButton_File.manager = this;

      this.saveButtonContainer_File.appendChild(this.saveButton_File);
      this.saveButton_File.addEventListener("click", function () {
        this.manager.clickSaveButton_File();
      });

      this.saveButtons.push(this.saveButton_File);

      // UNSUPPORTED MESSAGE

      this.saveWarningContainer_File = document.createElement("div");
      this.saveWarningContainer_File.classList.add(
        "save_warning_container_file",
        "save_warning_container",
        "unsupported"
      );
      this.savePane_File.appendChild(this.saveWarningContainer_File);

      this.saveWarning_File = document.createElement("div");
      this.saveWarning_File.classList =
        "restore_pane_warning alert alert-danger";
      this.saveWarningContainer_File.appendChild(this.saveWarning_File);
      this.saveWarning_File.innerHTML =
        "" +
        "<p class='save_pane_warning'>" +
        "Unfortunately, your web browser doesn't appear to support " +
        "this save/restore method. Please try one of the other methods, " +
        "or try playing with a different web browser. " +
        "</p>";

      // -----------------
      // BROWSER PANE
      // -----------------
      /**
       * Div element to contain 'Save to Browser' pane.
       * @var {HTMLElement} adventurejs.SaveManager#savePane_Browser
       * @default {}
       */
      this.savePane_Browser = document.createElement("div");
      this.savePane_Browser.classList.add("save_pane_browser", "save_pane");
      this.savePane_Browser.name = "savePane_Browser";
      this.savePane_Browser.manager = this;
      this.savePanes.push(this.savePane_Browser);

      this.savePane_Browser_QA = document.createElement("div");
      this.savePane_Browser_QA.classList = "save_pane_qa";
      this.savePane_Browser.appendChild(this.savePane_Browser_QA);
      // TODO accessibility
      // https://getbootstrap.com/docs/4.0/components/collapse/#accessibility
      this.savePane_Browser_QA.innerHTML =
        "" +
        "<p class='save_pane_qa_q'>What's this?</p>" +
        "<p class='save_pane_qa_a'>" +
        'The <span class="bootstrap_blue ">Save to Browser</span> ' +
        "option will let you save your game to your web browser's " +
        '<span class="bootstrap_blue ">Local Storage</span>. ' +
        "It's like a cookie, but bigger. " +
        "<br/><br/>PRO: Easy to manage saves if you " +
        "only play the game in this browser on this computer. " +
        "Best for short games that you're unlikely to replay. " +
        "<br/><br/>CON: Storage is limited. You can only access these saves from " +
        "this browser on this computer. " +
        "If you clear your browser's cache, you may erase your saved games. " +
        "</p>";
      this.savePane_Browser_QA.addEventListener("click", function () {
        this.classList.toggle("active");
      });

      this.saveRowPanes.appendChild(this.savePane_Browser);
      this.saveTab_Browser.savePane = this.savePane_Browser;
      this.saveTab_Browser.savePaneQA = this.savePane_Browser_QA;

      // SAVE BUTTON

      this.saveButtonContainer_Browser = document.createElement("div");
      this.saveButtonContainer_Browser.classList.add(
        "save_button_container_browser",
        "save_button_container"
      );
      this.savePane_Browser.appendChild(this.saveButtonContainer_Browser);

      this.saveButton_Browser = document.createElement("button");
      this.saveButton_Browser.classList.add(
        "save_button_browser",
        "save_button"
      );
      this.saveButton_Browser.type = "button";
      this.saveButton_Browser.value = "Save to Browser";
      this.saveButton_Browser.innerHTML = "Save to Browser";
      this.saveButton_Browser.name = "saveButton_Browser";
      this.saveButton_Browser.manager = this;

      this.saveButtonContainer_Browser.appendChild(this.saveButton_Browser);
      this.saveButton_Browser.addEventListener("click", function () {
        this.manager.clickButton_Browser();
      });

      this.saveButtons.push(this.saveButton_Browser);

      // -----------------
      // SERVER PANE
      // -----------------
      /**
       * Div element to contain 'Save to Server' pane.
       * @var {HTMLElement} adventurejs.SaveManager#savePane_Server
       * @default {}
       */
      this.savePane_Server = document.createElement("div");
      this.savePane_Server.classList.add("save_pane_server", "save_pane");
      this.savePane_Server.name = "savePane_Server";
      this.savePane_Server.manager = this;
      this.savePanes.push(this.savePane_Server);

      this.savePane_Server_QA = document.createElement("div");
      this.savePane_Server_QA.classList = "save_pane_qa";
      this.savePane_Server.appendChild(this.savePane_Server_QA);
      // TODO accessibility
      // https://getbootstrap.com/docs/4.0/components/collapse/#accessibility
      this.savePane_Server_QA.innerHTML =
        "" +
        "<p class='save_pane_qa_q'>What's this?</p>" +
        "<p class='save_pane_qa_a'>" +
        'The <span class="bootstrap_blue ">Save to Server</span> ' +
        "option will let you save your game to the adventurejs.com web server. " +
        "<br/><br/>PRO: It's easy to manage your saved games, and you can " +
        "restore them to any browser on any computer that runs this game." +
        "<br/><br/>CON: Saved games will be unavailable while you are offline." +
        "</p>";
      this.savePane_Server_QA.addEventListener("click", function () {
        this.classList.toggle("active");
      });
      this.saveRowPanes.appendChild(this.savePane_Server);
      this.saveTab_Server.savePane = this.savePane_Server;
      this.saveTab_Server.savePaneQA = this.savePane_Server_QA;

      // SAVE BUTTON

      this.saveButtonContainer_Server = document.createElement("div");
      this.saveButtonContainer_Server.classList.add(
        "save_button_container_server",
        "save_button_container"
      );
      this.savePane_Server.appendChild(this.saveButtonContainer_Server);

      this.saveButton_Server = document.createElement("button");
      this.saveButton_Server.classList.add("save_button_server", "save_button");
      this.saveButton_Server.type = "button";
      this.saveButton_Server.value = "Save to Server";
      this.saveButton_Server.innerHTML = "Save to Server";
      this.saveButton_Server.name = "saveButton_Server";
      this.saveButton_Server.manager = this;

      this.saveButtonContainer_Server.appendChild(this.saveButton_Server);
      this.saveButton_Server.addEventListener("click", function () {
        this.manager.clickButton_Server();
      });

      this.saveButtons.push(this.saveButton_Server);
    }

    /**
     * Open the Save pop-up window.
     * @memberOf adventurejs.SaveManager
     * @method adventurejs.SaveManager#openDisplay
     * @kind function
     */
    openDisplay() {
      this.saveDisplay.classList.add("active");
      // set a default save name
      this.saveInput.value =
        this.game.titleSerialized + "_" + new Date().getTime().toString();
      // delay because the select doesn't work without it
      setTimeout(
        function (saveManager) {
          saveManager.saveInput.select();
        },
        50,
        this
      );
    }

    /**
     * Close the Save pop-up window.
     * @memberOf adventurejs.SaveManager
     * @method adventurejs.SaveManager#closeDisplay
     * @kind function
     */
    closeDisplay() {
      this.saveDisplay.classList.remove("active");
      this.selectTab(this.saveTab_File);
      this.saveButtons.forEach(function (button) {
        button.classList.add("inactive");
      });
    }

    /**
     * Function that gets called by the Close button.
     * @memberOf adventurejs.SaveManager
     * @method adventurejs.SaveManager#clickButton_Close
     * @kind function
     */
    clickButton_Close() {
      console.log("clickButton_Close");
      this.closeDisplay();
      var msg = "Save cancelled.";
      this.game.print(msg);
      return;
    }

    /**
     * Save to file.
     * @memberOf adventurejs.SaveManager
     * @method adventurejs.SaveManager#clickSaveButton_File
     * @kind function
     * @todo Investigate FileSaver.js
     */
    clickSaveButton_File() {
      console.log("clickSaveButton_File");
      var inputFileName = this.sanitizeInputFileName();

      // DEPRECATED pulled last snapshot from undo history
      //var text = this.game.world_history[0];
      // NEW get diff between baseline and current
      var text = A.getBaselineDiff.call(this.game);

      var blob = new Blob([text], { type: "application/json" });
      var anchor = document.createElement("a");
      anchor.download = inputFileName + ".json";
      anchor.href = (window.webkitURL || window.URL).createObjectURL(blob);
      anchor.dataset.downloadurl = [
        "application/json",
        anchor.download,
        anchor.href,
      ].join(":");
      anchor.click();
      URL.revokeObjectURL(anchor.href);

      this.closeDisplay();
      var msg =
        "Game saved! " +
        "<span class='text-success'>" +
        inputFileName +
        ".json" +
        "</span> " +
        "has been saved to your Downloads folder.";
      this.game.print(msg);
      return true;
    }

    /**
     * Save game to browser cookie.
     * <br><br>
     * Player can name their save however they want. However, we always
     * prepend the game name because local storage applies
     * to all pages on a given domain, meaning that all saves for all
     * games played at, i.e., adventurejs.com will be saved in the same
     * local storage. And, local storage appears not to have any method
     * for nesting data, so we can't have a parent object or 'folder'.
     * Instead, we need to name them in such a way that we
     * can identify them by game.
     * @memberOf adventurejs.SaveManager
     * @method adventurejs.SaveManager#clickButton_Browser
     * @kind function
     */
    clickButton_Browser() {
      console.log("clickButton_Browser");
      var inputFileName = this.sanitizeInputFileName();

      //if( this.game.titleSerialized !== inputFileName.substr( 0, this.game.titleSerialized.length ) ) // @deprecated
      if (
        this.game.titleSerialized !==
        inputFileName.substring(0, this.game.titleSerialized.length)
      ) {
        inputFileName = this.game.titleSerialized + "_" + inputFileName;
      }

      var storage = window.localStorage;

      // DEPRECATED pulled last snapshot from undo history
      //storage.setItem( inputFileName, this.game.world_history[0] );
      // NEW get diff between baseline and current
      storage.setItem(inputFileName, A.getBaselineDiff.call(this.game));

      this.closeDisplay();
      var msg = "Game saved to your browser's Local Storage!";
      this.game.print(msg);
      return true;
    }

    /**
     * Save game to server.
     * @memberOf adventurejs.SaveManager
     * @method adventurejs.SaveManager#clickButton_Server
     * @kind function
     * @todo Everything.
     */
    clickButton_Server() {
      console.log("clickButton_Server");
      var inputFileName = this.sanitizeInputFileName();
      // TODO ...
    }

    /**
     * OnInput or OnKeyDown, activate or deactivate save buttons
     * depending on state of input field. Deactivate if empty,
     * otherwise activate.
     * @memberOf adventurejs.SaveManager
     * @method adventurejs.SaveManager#
     * @kind function
     */
    saveInputOninput(saveInput) {
      var activeState = saveInput.value === "" ? "add" : "remove";
      //var buttons = document.querySelectorAll('.save_tab');
      this.saveButtons.forEach(function (saveButton) {
        saveButton.classList[activeState]("inactive");
      }, activeState);
    }

    // LOCAL STORAGE ???
    // can do a saved file browser for cookies...& maybe server...& local storage?
    // go back to cookie/local/server buttons as tabs?

    /**
     * Sanitize input file name. Permitted characters are
     * a-z, A-Z, 0-9, accented vowels Ã¡Ã©Ã­Ã³ÃºÃ±Ã¼, _underscore, and -hyphen.
     * @memberOf adventurejs.SaveManager
     * @method adventurejs.SaveManager#sanitizeInputFileName
     * @kind function
     */
    sanitizeInputFileName() {
      console.log("validate input");
      console.log("this.saveInput.value", this.saveInput.value);
      var inputFileName = this.saveInput.value;
      inputFileName = inputFileName.replace(/ /gim, "_");
      inputFileName = inputFileName.replace(/[^a-zA-Z0-9Ã¡Ã©Ã­Ã³ÃºÃ±Ã¼_-]/gim, "");
      if (!inputFileName) {
        inputFileName =
          this.game.titleSerialized + "_" + new Date().getTime().toString();
      }
      return inputFileName;
    }

    /**
     * Make a selected tab active.
     * @memberOf adventurejs.SaveManager
     * @method adventurejs.SaveManager#selectTab
     * @kind function
     */
    selectTab(selectedTab) {
      this.saveTabs.forEach(function (tabButton) {
        if (tabButton !== selectedTab) {
          tabButton.classList.remove("active");
          tabButton.savePane.classList.remove("active");
          tabButton.savePaneQA.classList.remove("active");
        } else {
          tabButton.classList.add("active");
          tabButton.savePane.classList.add("active");
        }
      }, selectedTab);
    }

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     * @method adventurejs.SaveManager#set
     * @param {Object} props A generic object containing properties to copy to the DisplayObject instance.
     * @returns {adventurejs.SaveManager} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(props) {
      // if (props != null) {
      //   for (var n in props) {
      //     this[n] = props[n];
      //   }
      // }
      // return this;
      return A.deepSet.call(this.game, props, this);
    }
  }
  adventurejs.SaveManager = SaveManager;
})();

// UserManager.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * Explanation of the class.
   * @class adventurejs.UserManager
   * @ajsnavheading FrameworkReference
   * @param {Game} game A reference to the game instance.
   * @summary Interface for a user account logged in to adventurejs.com.
   * @todo Everything.
   * @classdesc
   * <p>
   * <strong>UserManager</strong> is a (placeholder for a)
   * special class to be constructed by
   * {@link adventurejs.Game|Game},
   * and used to interface with the user account
   * that is logged in to
   * <a href="https://adventurejs.com">adventurejs.com</a>
   * </p>
   */
  class UserManager {
    constructor(game) {
      this.game = game;

      // login tutorial at tutorialrepublic
      // https://www.tutorialrepublic.com/php-tutorial/php-mysql-login-system.php

      // https://stackoverflow.com/questions/1054022/best-way-to-store-password-in-database
      // https://stackoverflow.com/questions/947618/how-to-best-store-user-information-and-user-login-and-password
      // https://stackoverflow.com/questions/258299/what-is-the-best-way-to-keep-passwords-configurable-without-having-them-too-eas
      // https://stackoverflow.com/questions/674904/salting-your-password-best-practices
    }
  }
  adventurejs.UserManager = UserManager;
})();

// Scorecard.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.Scorecard
   * @ajsinternal
   * @param {Game} game A reference to the game instance.
   * @ajsnavheading FrameworkReference
   * @summary Manages score for a {@link adventurejs.Game|Game} instance.
   * @classdesc
   * <p>
   * <strong>Scorecard</strong> is a repository for Game score
   * options. Scorecard is created automatically
   * by {@link adventurejs.Game|Game}. This is an internal class
   * that authors should not need to construct. However,
   * authors can set scoring options from their game file as
   * shown below, and call score updates from custom scripts.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">var MyGame = new adventurejs.Game( "MyGame", "GameDisplay" );
   * MyGame.scorecard.set({
   *   score_events: {
   *     "unlock door": { points: 1, complete: false, bonus: false, message: '', recorded: false },
   *     "unlock chest": { points: 1, complete: false, bonus: false, recorded: message: '', false },
   *     "drink potion": { points: 1, complete: false, bonus: false, recorded: message: '', false },
   *   }
   * });
   * </code></pre>
   */
  class Scorecard {
    constructor(game) {
      this.game = game;
      this.game.world._scorecard = {
        initialize: {
          complete: true,
          points: 0,
          recorded: true,
          message: "",
          bonus: false,
        },
      };
      this.score = 0;
      this.newscore = 0;
      this.diff = 0;
      this.aggregate_updates = true;
      this.score_message = "";
      this.score_format = {};
      this.aggregate_updates = false;

      // set scorecard to listen for end of turn,
      // then check to see if score has changed,
      // and if it has, print score updates
      this.game.reactor.addEventListener("inputParseComplete", function (e) {
        this.game.scorecard.updateScore();
      });
    }

    /**
     * Create a new event.
     * @method adventurejs.Scorecard#createEvent
     * @returns {String}
     */
    createEvent() {
      let event = {
        points: 0,
        complete: false,
        bonus: false,
        recorded: false,
        message: "",
      };
      return JSON.stringify(event);
    }

    /**
     * Mark the selected event as complete and update the score.
     * @method adventurejs.Scorecard#completeEvent
     * @param {String} event A string matching an event key.
     * @returns {Boolean}
     */
    completeEvent(event) {
      if (!this.game.world._scorecard[event]) return false;
      this.game.world._scorecard[event].complete = true;
      return true;
    }

    /**
     * Get the current score.
     * @method adventurejs.Scorecard#updateScore
     */
    updateScore() {
      let score = 0;
      let total = 0;
      let msg = "";

      for (var prop in this.game.world._scorecard) {
        //console.warn('getScore prop:',prop);
        if (!this.game.world._scorecard[prop].bonus) {
          total += this.game.world._scorecard[prop].points;
        }
        if (this.game.world._scorecard[prop].complete) {
          score += this.game.world._scorecard[prop].points;
        }
      }
      this.total = total;
      this.newscore = score;

      msg += this.aggregate_updates
        ? this.aggregateUpdates()
        : this.stackUpdates();

      this.score = score;
      this.game.display.setScore(this.formatScore(score, total));
      if (msg) this.game.print(msg);
      return true;
    }

    /**
     * Print score updates in the aggregate.
     * @method adventurejs.Scorecard#aggregateUpdates
     */
    aggregateUpdates() {
      let msg = "";
      if (this.newscore !== this.score) {
        let pole = this.newscore > this.score ? "up" : "down";
        let diff = this.newscore - this.score;
        let s = Math.abs(diff) > 1 ? "s" : "";
        this.diff = diff;

        // the aggregate uses a single message setting
        msg = this.score_message
          ? A.getSAF.call(this.game, this.score_message, this)
          : `[ ** $(Our) score went ${pole} by ${diff} point${s} ** ]`;

        msg = `<span class="score_msg ${pole}">${msg}</span>`;
      }
      return msg;
    }

    /**
     * Print score updates in a stack.
     * @method adventurejs.Scorecard#stackUpdates
     */
    stackUpdates() {
      let msg = "";
      for (let prop in this.game.world._scorecard) {
        if (
          this.game.world._scorecard[prop].complete &&
          !this.game.world._scorecard[prop].recorded
        ) {
          let eventmsg = "";
          let diff = this.game.world._scorecard[prop].points;
          let pole = diff > 0 ? "up" : "down";
          let s = Math.abs(diff) > 1 ? "s" : "";
          this.diff = diff;
          this.game.world._scorecard[prop].recorded = true;
          if (this.game.world._scorecard[prop].message) {
            eventmsg = A.getSAF.call(
              this.game,
              this.game.world._scorecard[prop].message,
              this
            );
          } else {
            eventmsg = this.score_message
              ? A.getSAF.call(this.game, this.score_message, this)
              : `[ ** $(Our) score went ${pole} by ${diff} point${s} ** ]`;
          }
          msg += `<span class="score_msg ${pole}">${eventmsg}</span>`;
        }
      }
      return msg;
    }

    /**
     * Format the score/total before printing it to display.
     * @method adventurejs.Scorecard#setScore
     */
    formatScore(score, total) {
      // @TODO add a more robust check for score_format
      if (Object.keys(this.score_format).length)
        return A.getSAF.call(this.game, this.score_format, this);
      else return `${score}/${total}`;
    }

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     * @method adventurejs.Scorecard#set
     * @param {Object} props A generic object containing properties to copy to the instance.
     * @returns {adventurejs.Scorecard} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(scorecard) {
      if (scorecard.score_events) {
        for (var event in scorecard.score_events) {
          this.game.world._scorecard[event] = JSON.parse(this.createEvent());

          // we accept a number in the form of
          // "open window": 1,
          if ("number" === typeof scorecard.score_events[event]) {
            this.game.world._scorecard[event].points =
              scorecard.score_events[event];
            continue;
          }

          // or we accept an object with any subset of fields
          // "take andy": { points: 1 },
          for (var prop in scorecard.score_events[event]) {
            this.game.world._scorecard[event][prop] = JSON.parse(
              JSON.stringify(scorecard.score_events[event][prop])
            );
          }
        }
      }
      if ("undefined" !== scorecard.aggregate_updates)
        this.aggregate_updates = scorecard.aggregate_updates;
      if (scorecard.score_message) this.score_message = scorecard.score_message;
      if (scorecard.score_format) this.score_format = scorecard.score_format;
      return this;
    }
  }
  adventurejs.Scorecard = Scorecard;
})();

// Settings.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   *
   * @class adventurejs.Settings
   * @ajsinternal
   * @param {Game} game A reference to the game instance.
   * @ajsnavheading FrameworkReference
   * @summary Manages settings for a {@link adventurejs.Game|Game} instance.
   * @classdesc
   * <p>
   * <strong>Settings</strong> is a repository for global Game
   * options. Settings is created automatically
   * by {@link adventurejs.Game|Game}. This is an internal class
   * that authors should not need to construct. However,
   * authors can set options from their game file as
   * shown below, or change them during runtime
   * with calls to <a href="#set">MyGame.settings.set()</a>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">var MyGame = new adventurejs.Game( "MyGame", "GameDisplay" );
   * MyGame.settings.set({
   *   max_undos: 20,
   *   show_room_names_in_exit_descriptions: false,
   *   can_auto_open_apertures: false
   * });
   * </code></pre>
   */
  class Settings {
    constructor(game) {
      this.game = game;

      /**
       * Each level of undo stores a snapshot of the entire
       * game state in memory. Raising a game's undo count
       * will increase its memory requirements.
       * @var {Number} adventurejs.Settings#max_undos
       * @default 10
       */
      this.max_undos = 10;

      /**
       * Console logging: control the types of statements that print to console.
       * Useful for debugging.
       * 0 = critical ( warnings & errors only )
       * 1 = high
       * 2 = medium
       * 3 = low
       * @var {Number} adventurejs.Settings#log_level
       * @default 1
       */
      this.log_level = 1;

      /**
       * Trace log statements: control which log levels call console.trace()
       * Useful for debugging.
       * @var {Number} adventurejs.Settings#log_trace_level
       * @default 0
       */
      this.log_trace_level = 0;

      /**
       * Console logging: control what keywords print to console.
       * Warnings and Errors will print regardless of settings.
       * See the available list of keywords below. Comment any
       * to remove those from console output.
       * @var {Number} adventurejs.Settings#log_level
       * @default 1
       */
      this.log_keywords = {
        tutorial: true,
        exit: true,
        character: true,
        tangible: true,
        behavior: true /* onX functions */,
        copyoperations: true /* clone, merge, diff, restore, save */,
        dictionary: true,
        display: true,
        game: true,
        parser: true,
        print: true,
        room: true,
        saverestore: true,
        vessel: true,
        substanceemitter: true,
        substancemixer: true,
        travel: true,
        utility: true,
        verb: true,
        verbs: true,
      };

      /**
       * If set true, when player tries to go in a direction that hasn't
       * got an {@link adventurejs.Exit|Exit},
       * print the current room's Exits as a reminder
       * of what Exits are available. Though this is a global setting,
       * {@link adventurejs.Room|Rooms}
       * can have their own setting. Room setting overrides global setting.
       * @var {Boolean} adventurejs.Settings#when_travel_fails_list_exits
       * @default true
       */
      this.when_travel_fails_list_exits = true;

      /**
       * If set true,
       * {@link adventurejs.Exit|Exit} descriptions can include
       * the name of the {@link adventurejs.Room|Room} that the
       * Exit leads to. (The logic for this may also consider other
       * conditions such as whether the player knows about the
       * other Room.) Though this is a global setting,
       * Exits can have their own setting. Exit setting overrides
       * global setting.
       * @var {Boolean} adventurejs.Settings#show_room_names_in_exit_descriptions
       * @default true
       */
      this.show_room_names_in_exit_descriptions = true;

      /**
       * If set true,
       * {@link adventurejs.Exit|Exit} descriptions can include
       * the name of the {@link adventurejs.Room|Room} that the
       * Exit leads to once player knows about the destination Room.
       * Generally player must visit a room to know about it, but
       * there can be exceptions.
       * Though this is a global setting,
       * Exits can have their own setting. Exit setting overrides
       * global setting.
       * @var {Boolean} adventurejs.Settings#show_room_names_in_exit_descriptions_only_when_room_is_known
       * @default false
       */
      this.show_room_names_in_exit_descriptions_only_when_room_is_known = false;

      /**
       * If set true,
       * {@link adventurejs.Exit|Exit} descriptions can include
       * the name of the {@link adventurejs.Room|Room} that the
       * Exit leads to once player has used the Exit.
       * Though this is a global setting,
       * Exits can have their own setting. Exit setting overrides
       * global setting.
       * @var {Boolean} adventurejs.Settings#show_room_names_in_exit_descriptions_only_after_exit_has_been_used
       * @default true
       */
      this.show_room_names_in_exit_descriptions_only_after_exit_has_been_used = true;

      /**
       * If true, disambiguation prompts will present an ordered
       * list rather than plain text.
       * <br><br>
       * 'Disambiguation' means the player has asked for an object
       * that could refer to multiple things, and the
       * {@link adventurejs.Parser|Parser}
       * hasn't been able to narrow it down to one object.
       * Let's say there are three cats of different colors in the room.
       * Normally the game would ask the player:
       * <pre class="display">
       * which cat did you mean, the orange cat, the black cat, or the piebald cat?
       * </pre>
       * If this is true, prompts will look like this instead:
       * <pre class="display">
       * Which cat did you mean?
       * 1) the orange cat
       * 2) the black cat
       * 3) the piebald cat
       * </pre>
       * When this is done, the player can enter 1, 2, or 3 and the parser
       * will understand their choice.
       * <br><br>
       * For more information about Disambiguation, see
       * <a href="/doc/NextSteps_Disambiguation.html">How to Disambiguate</a>
       * @var {Boolean} adventurejs.Settings#show_disambiguation_as_ordered_list
       * @default false
       */
      this.show_disambiguation_as_ordered_list = false;

      /**
       * If true, disambiguation prompts will present a plain text
       * paragraph with numbered options in it.
       * <br><br>
       * 'Disambiguation' means the player has asked for an object
       * that could refer to multiple things, and the
       * {@link adventurejs.Parser|Parser}
       * hasn't been able to narrow it down to one object.
       * Let's say there are three kinds of pizza in the room.
       * Normally the game would ask the player:
       * <pre class="display">
       * Which pizza did you mean, the pepperoni pizza,
       * the pineapple pizza, or the vegetable pizza?
       * </pre>
       * If this is true, numbers will be inserted into the text,
       * like this:
       * <pre class="display">
       * Which pizza did you mean, 1) the pepperoni pizza,
       * 2) the pineapple pizza, or 3) the vegetable pizza?
       * </pre>
       * When this is done, the player can enter 1, 2, or 3 and the parser
       * will understand their choice.
       * <br><br>
       * For more information about Disambiguation, see
       * <a href="/doc/NextSteps_Disambiguation.html">How to Disambiguate</a>
       * @var {Boolean} adventurejs.Settings#
       * @default true
       */
      this.show_disambiguation_as_numbered_paragraph = true;

      /**
       * If true, when player enters a blank line,
       * treat it as if player typed "look".
       * Otherwise play dumb.
       * @var {Boolean} adventurejs.Settings#if_input_is_empty_print_room_description
       * @default false
       */
      this.if_input_is_empty_print_room_description = false;

      /**
       * if_input_is_empty_print_this can return string or array or function.
       * @var {String|Array|Function} adventurejs.Dictionary#if_input_is_empty_print_this
       * @default "I didn't see any input."
       */
      this.if_input_is_empty_print_this = `I didn't see any input. `;

      /**
       * When the parser can't understand a player's input, it prints
       * a generic statement using this string. The statement is
       * also used in some other arbitrary places, which is to say,
       * players may see it a lot.
       * If you would like to customize this output
       * you can do so by setting this property to your preferred
       * output and including $(input) as a token to be replaced
       * with the player's input. For example:
       * <pre class="display"><code class="language-javascript">MyGame.settings.set({
       *   if_parser_has_no_response_print_this: "I didn't understand <em class='unparsed'>$(input)</em>. ",
       * });
       * </code></pre>
       * This example wraps the player's input in an <em> element so that
       * it can be styled differently from the rest of the output. This
       * isn't required and you can omit the <em> if you prefer.
       * And in fact you don't even need to include the original input
       * if you prefer not to. Just omit <code>$(input)</code> from your
       * string and the string will be printed as you set it.
       * <br><br>
       * <code>if_parser_has_no_response_print_this</code> supports the use of
       * <code>{@link adventurejs.Game#getStringOrArrayOrFunction|getStringOrArrayOrFunction}</code>
       * meaning that you can vary it up if you like by setting it to
       * a rotating array of strings or a contextually aware function.
       * @var {Boolean} adventurejs.Settings#if_parser_has_no_response_print_this
       * @default true
       */
      this.if_parser_has_no_response_print_this = `I don't understand what you mean by <em class='unparsed'>$(input)</em>. `;

      /**
       * If true, when player enters just a noun,
       * treat it as if player typed "examine x".
       * Otherwise play dumb.
       * @var {Boolean} adventurejs.Settings#if_input_is_an_asset_name_examine_it
       * @default true
       */
      this.if_input_is_an_asset_name_examine_it = true;

      /**
       * We're all about strings here. Your job as an author is
       * to write lots and lots and lots of them. Sometimes it
       * gets boring seeing the same string over and over again,
       * and you just want to show some alternates.
       * Some properties let you do that through the use of
       * {@link adventurejs.Game#getStringOrArrayOrFunction|getStringOrArrayOrFunction}.
       * You can feed getStringOrArrayOrFunction a string
       * or an array or a function (that returns a string).
       * If you provide an array, this setting determines
       * whether strings in the array are presented in sequence,
       * or randomly. If this setting is true, arrays
       * will be randomized.
       * <br><br>
       * For more information, see
       * <a href="/doc/Scripting_StringArrayFunction.html">How to Use String|Array|Function</a>
       * @var {Boolean} adventurejs.Settings#randomize_arrays_in_getStringOrArrayOrFunction
       * @default true
       * @todo List properties that this applies to.
       */
      this.randomize_arrays_in_getStringOrArrayOrFunction = true;

      /**
       * When players apply a verb to a group of objects,
       * such as "take all",
       * if any of those objects have a verb hook,
       * that may create awkward output. For example, let's say
       * there are four medallions and one is cursed, using
       * verb_hooks.take,
       * and the player inputs "take all medallions":
       * <pre class="display">
       * "You take the gold medallion. You take the brass medallion.
       * Oh no, taking the onyx medallion transported you to the
       * nether realms! You take the silver medallion."
       * </pre>
       * This option tries to provide a little bit of control over that
       * by saying: if player picks up these four objects, take the cursed
       * one last. It doesn't solve all problems. For instance, if
       * two of our medallions each took the player to a different location,
       * that might break something. Some situations can't be solved
       * programmatically and just come down to good game design.
       * <br><br>
       * Alternately, you may want to handle assets with verb_hooks
       * first. Let's say you have an explosive item, and if player inputs
       * "take all" you want the explosive to be picked up first and then
       * end the turn in order to prevent other items from handled in the
       * same turn.
       * <br><br>
       * For more information on verb_hooks, see
       * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>
       * <br><br>
       * Valid values are: -1 (move to beginning of queue), 0 (leave in place),
       * 1 (move to end of queue).
       * Warning: may cause undesired side effects.
       * @var {Boolean} adventurejs.Settings#move_verb_hooks_to_end_of_queue
       * @default true
       */
      // @TODO this block no longer works since moving verb_hooks into verb subscriptions
      this.enqueue_assets_with_verb_hooks = { order: 1 }; // valid values: -1, 0, 1

      /**
       * See the explanation for
       * <a href="#move_verb_hooks_to_end_of_queue">move_verb_hooks_to_end_of_queue</a>
       * above. This reverses that. When using a verb on multiple items,
       * you can choose to move items with custom functions to the beginning
       * of the queue. If this option is set true, it will override
       * move_verb_hooks_to_end_of_queue. Included for
       * completionism. Warning: this may cause undesired side effects.
       * @var {Boolean} adventurejs.Settings#move_verb_hooks_to_start_of_queue
       * @default false
       */
      // @TODO this block no longer works since moving verb_hooks into verb subscriptions
      this.move_verb_hooks_to_start_of_queue = false;

      /**
       * If true, {@link goTo} {@link adventurejs.Verb|Verb} will
       * {@link open} closed {@link adventurejs.Aperture|Apertures} that
       * lie between the start {@link adventurejs.Room|Room}
       * and the destination Room, but only if player has already
       * opened those Apertures before.
       * @var {Boolean} adventurejs.Settings#can_auto_open_apertures
       * @default true
       */
      this.can_auto_open_apertures = true;

      /**
       * If true, {@link goTo} {@link adventurejs.Verb|Verb} will
       * {@link unlock} locked {@link adventurejs.Aperture|Apertures} that
       * lie between the start {@link adventurejs.Room|Room}
       * and the destination Room, but only if player has already
       * unlocked those Apertures before
       * and is carrying any necessary {@link adventurejs.Key|Keys}.
       * @var {Boolean} adventurejs.Settings#can_auto_unlock_apertures
       * @default true
       */
      this.can_auto_unlock_apertures = true;

      /**
       * If true, {@link goTo} {@link adventurejs.Verb|Verb} will
       * {@link unseal} sealed {@link adventurejs.Aperture|Apertures} that
       * lie between the start {@link adventurejs.Room|Room}
       * and the destination Room, but only if player has already
       * unsealed those Apertures and is carrying any necessary {@link adventurejs.Key|Keys}.
       * @var {Boolean} adventurejs.Settings#can_auto_unseal_apertures
       * @default true
       */
      this.can_auto_unseal_apertures = true;

      /**
       * If true, when player {@link tie_noun1_to_noun2|ties} a
       * {@link adventurejs.Rope|Rope} to another asset,
       * {@link adventurejs.Game|Game} will move the asset into
       * player's inventory, using
       * {@link adventurejs.Tangible#onMoveThatToThis|player.onMoveThatToThis()}.
       * <br><br>
       * If the asset in that situation is coded with a verb event hook,
       * it has the potential to cause undesirable side effects.
       * It's an unlikely edge case, but if you find yourself in
       * that situation, try setting this to false to avoid side effects.
       * @var {Boolean} adventurejs.Settings#on_tie_rope_to_takeable_object_take_object
       * @default true
       */
      this.on_tie_rope_to_takeable_object_take_object = true;

      /**
       * If true, when player ties a rope to its maximum number
       * of tied points, will remove rope from player's inventory.
       * <br><br>
       * If the rope in that situation has a verb event hook for
       * {@link drop},
       * it has the potential to cause undesirable side effects.
       * It's an unlikely edge case, but if you find yourself in
       * that situation, try setting this to false to avoid side effects.
       * @var {Boolean} adventurejs.Settings#on_tie_rope_to_max_objects_drop_rope
       * @default true
       */
      this.on_tie_rope_to_max_objects_drop_rope = true;

      /**
       * If true, and player unties a rope they are not holding, which
       * is tied to an object that is not in the player's inventory,
       * if the rope is takeable, player will take it.
       * <br><br>
       * If the rope in that situation has a verb event hook for
       * {@link drop},
       * it has the potential to cause undesirable side effects.
       * It's an unlikely edge case, but if you find yourself in
       * that situation, try setting this to false to avoid side effects.
       * @var {Boolean} adventurejs.Settings#on_untie_rope_from_object_outside_inventory_take_rope
       * @default true
       */
      this.on_untie_rope_from_object_outside_inventory_take_rope = true;

      /**
       * Standard value for drinking, in ml. If player
       * {@link drink|drinks} from a
       * {@link adventurejs.Vessel|Vessel},
       * this is the quantity of liquid that will be removed from it
       * (unless the Vessel has custom drink logic).
       * @var {Number} adventurejs.Settings#mouthful
       * @default 100
       */
      this.mouthful = 100;

      /**
       * Standard value for holding in hands, in ml. Generally
       * if player tries to interact with substances without a container
       * they're given some kind of "slips through your fingers" message
       * but in the case of something like "throw sand" when player is
       * on a beach, we'll let them throw a handful of sand,
       * and if the containing object is not infinite, subtract this
       * amount from it.
       * @var {Number} adventurejs.Settings#handful
       * @default 100
       */
      this.handful = 100;

      /**
       * Room temperature in celsius.
       * @var {Number} adventurejs.Settings#room_temperature
       * @default 20
       * @todo celsius/farenheit conversion
       */
      this.room_temperature = 20;

      /**
       * States lookup for substances.
       * @var {Object} adventurejs.Settings#states
       */
      this.states = {
        SOLID: "SOLID",
        LIQUID: "LIQUID",
        GAS: "GAS",
      };

      /**
       * The <code>pronouns</code> setting is a lookup table
       * for use with <code>person</code>.
       * @var {Object} adventurejs.Settings#pronouns
       */
      this.pronouns = {
        FIRST: "first",
        SECOND: "second",
        PLURAL: "plural",
        MALE: "male",
        FEMALE: "female",
        NONBINARY: "nonbinary",
        NONHUMAN: "nonhuman",
      };

      /**
       * The <code>person</code> setting allows you to change
       * the pronouns in all of the default response strings
       * built-in to Adventurejs. For instance, if take
       * has a response that says <code>You pick up the axe.</code>
       * you can change the word You to I in this and all other
       * responses by setting person from seconds to first.
       * @var {String} adventurejs.Settings#person
       */
      this.person = this.pronouns.SECOND;

      // settings so far unused

      this.ambient_gravity = 1;
      this.ambient_light = 1;
      this.light_sources_are_cumulative = false;
      this.ambient_sound = 0;

      this.things_float_on_water = true;
      this.things_sink_in_water = true;
      this.things_disappear_in_water = true;

      this.things_rise_in_low_gravity = true;
      this.things_fall_in_high_gravity = true;
      this.things_disappear_in_space = true;

      this.verbosity = 0;
      this.print_verbose_room_descriptions_on_first_visit = true;
      this.min_verbosity = -2;
      this.max_verbosity = 1;
      // only -2 to 1 are supported
      // -2 = briefer, -1 = brief, 0 = description, 1 = verbose

      /**
       * If <code>print_debug_messages</code> is true, some failure responses may print
       * additional information to the game display.
       * Intended as a debugging aid.
       * @var {String} adventurejs.Settings#print_debug_messages
       */
      this.print_debug_messages = false;

      /**
       * If true, room/zone events will print. See
       * <a href="/doc/NextSteps_SceneEvents.html">Scene Events</a>
       * for more information.
       * @var {Boolean} adventurejs.Settings#enable_events
       * @default true
       */
      this.enable_events = true;

      /**
       * If player inputs something like
       * "throw rock at water", the word "water" may be
       * ambiguous because multiple water containers are
       * present: a glass of water, a bottle of water, a lake.
       * If any of those containers is a body of water like
       * a lake or ocean, we can probably assume that the
       * player meant "throw rock in lake". If
       * <code>throw_at_substance_prefers_bodies</code>
       * is true, the verb <code>throw</code>'s logic will
       * make that assumption, rather than prompting player
       * to specify an indirect object.
       * @var {Boolean} adventurejs.Settings#throw_at_substance_prefers_bodies
       * @default true
       */
      this.throw_at_substance_prefers_bodies = true;

      /**
       * If true, some verbs, on receiving input of sentence
       * structure "verb noun" may infer an indirect object
       * if one is required and player is carrying it.
       * This pattern is intended
       * chiefly for locks and keys, with the idea being that
       * if player inputs "unlock door" while carrying a door
       * key, the game can infer the door key instead of
       * prompting the player for a key, which may seem
       * obnoxious in some circumstances.
       * It works with lock / unlock, seal / unseal, open / close,
       * and some others.
       * @var {Boolean} adventurejs.Settings#try_to_infer_indirect_objects
       * @default true
       */
      this.try_to_infer_indirect_objects = true;

      /**
       * If true, <code>try_to_infer_indirect_objects</code> will
       * only be applied once a player has already interacted
       * with the direct object. This pattern is intended to
       * prevent giving away puzzle solutions. For example,
       * perhaps there are many keys but only one that opens
       * a certain lock, and determining which key opens the
       * lock is part of a puzzle. If this is set to true,
       * it would prevent players from being able to unlock
       * the door without trying all the keys to find the
       * correct one.
       * @var {Boolean} adventurejs.Settings#infer_indirect_objects_only_after_interaction
       * @default true
       */
      this.infer_indirect_objects_only_after_interaction = true;

      /**
       * If true, when <code>try_to_infer_indirect_objects</code>
       * results in multiple assets, prompt player to select one.
       * @var {Boolean} adventurejs.Settings#if_inferred_multiple_indirect_objects_then_prompt
       * @default true
       */
      this.if_inferred_multiple_indirect_objects_then_prompt = false;

      /**
       * Set the visibility of the compass rose in the status bar.
       * @var {Boolean} adventurejs.Settings#show_compass_rose_in_status
       * @default true
       */
      this._show_compass_rose_in_status = true;

      /* *
       * Set the status bar compass rose to show a magnified
       * version on hover.
       * @var {Boolean} adventurejs.Settings#magnify_compass_rose_on_hover
       * @default true
       */
      // Object.defineProperty(this, 'magnify_compass_rose_on_hover', {
      //   configurable: true,
      //   get() { return this.__magnify_compass_rose_on_hover; },
      //   set(value) {
      //     this.__magnify_compass_rose_on_hover = value;
      //     if(this.game.display) this.game.display.exitsContainerEl.classList[value?'add':'remove']('magnify');
      //   },
      // });
      // this.magnify_compass_rose_on_hover = false;

      /* *
       * When we initialize assets, By default we add
       * the name, each word of the name and each pair
       * of words in the name. In some situations this
       * may be excessive and lead to the parser
       * misinterpreting phrases.
       * @var {Boolean} adventurejs.Settings#split_asset_names_for_world_lookup
       * @default true
       */
      //this.split_asset_names_for_world_lookup = true;

      /**
       * We can track the user's y position. This option sets the maximum distance that the
       * player can reach vertically, ie when climbing an object like a tree. 1 is considered
       * to be about the height of a person.
       * @var {Boolean} adventurejs.Settings#reach_height
       * @default 1
       */
      this.reach_height = 1;

      /**
       * We can track the user's x/z position. This option sets the maximum distance that the
       * player can reach horizontally within a room. 0.33 is considered to be about arm's length.
       * @var {Boolean} adventurejs.Settings#reach_length
       * @default .33
       */
      this.reach_length = 0.33;

      /**
       * We can track the user's y position. This option sets the default distance that the
       * player travels vertically, ie when climbing an object like a tree. 1 is considered
       * to be about the height of a person.
       * @var {Boolean} adventurejs.Settings#climb_height
       * @default 1
       */
      this.climb_height = 1;

      /**
       * We can track the user's x/z position. This option sets the default distance that the
       * player travels horizontally when moving within a room. 1 is considered to be about
       * the height of a person.
       * @var {Boolean} adventurejs.Settings#stride_length
       * @default .33
       */
      this.stride_length = 0.33;

      /**
       * We can track the user's x/z position. This option sets the maximum distance that the
       * player travels horizontally when moving within a room. 1 is considered to be about
       * the height of a person.
       * @var {Boolean} adventurejs.Settings#jump_length
       * @default 1
       */
      this.jump_length = 1;

      /**
       * We can track the user's x/z position. This option sets whether
       * x/z are considered in determining reachability. By default,
       * all tangible assets are positioned at x:0,y:0,z:0, and reachability
       * checks don't consider x/z (though y is always considered). Now imagine
       * you have a dorm room with a bed and a desk, where the bed is at
       * x:3 and the desk is across the room at x:-3. If this property is true,
       * then their relative distance apart will be taken into account
       * when determining reachability.
       * @var {Boolean} adventurejs.Settings#xz_determines_reachability
       * @default false
       */
      this.xz_determines_reachability = true;
    }

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     * @method adventurejs.Settings#set
     * @param {Object} props A generic object containing properties to copy to the instance.
     * @returns {adventurejs.Settings} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(props) {
      return A.deepSet.call(this.game, props, this);
    }

    get show_compass_rose_in_status() {
      return this._show_compass_rose_in_status;
    }
    set show_compass_rose_in_status(value) {
      this._show_compass_rose_in_status = value;
      if (this.game.display)
        this.game.display.exitsContainerEl.classList[value ? "remove" : "add"](
          "hidden"
        );
    }
  }
  adventurejs.Settings = Settings;
})();

// Reactor.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.Reactor
   * @ajsinternal
   * @ajsnavheading FrameworkReference
   * @param {Game} game A reference to the game instance.
   * @summary Manages event listening for custom events.
   * @classdesc
   * <p>
   * <strong>Reactor</strong> manages event listening for custom
   * events, by creating
   * a DOM element to do the listening, and then hooking into
   * the element's DOM methods.
   * Reactor is created automatically
   * by {@link adventurejs.Game|Game}. This is an internal class that
   * authors should not need to construct or modify.
   * </p>
   */

  //http://jsfiddle.net/2vqof4zs/156/

  class Reactor {
    constructor(game) {
      /**
       * A reference back to the main {@link adventurejs.Game|Game} object.
       * @var {Object} adventurejs.Reactor#game
       * @default {}
       */
      this.game = game;

      /**
       * Create a text node / HTML element to act as a listener for
       * custom events.
       * @var {HTMLElement} adventurejs.Reactor#target
       * @default {}
       */
      this.target = document.createTextNode(null);

      /**
       * Give the text node / HTML element a reference back to the Game.
       * @var {Object} adventurejs.Reactor.target#game
       * @default {}
       */
      this.target.game = game;

      /**
       * Hook game.reactor to target.addEventListener.
       * @var {Object} adventurejs.Reactor#addEventListener
       * @default {}
       */
      this.addEventListener = this.target.addEventListener.bind(this.target);

      /**
       * Hook game.reactor to target.removeEventListener.
       * @var {Object} adventurejs.Reactor#removeEventListener
       * @default {}
       */
      this.removeEventListener = this.target.removeEventListener.bind(
        this.target
      );

      /**
       * Hook game.reactor to target.dispatchEvent.
       * @var {Object} adventurejs.Reactor#dispatchEvent
       * @default {}
       */
      this.dispatchEvent = this.target.dispatchEvent.bind(this.target);
    }
  }
  adventurejs.Reactor = Reactor;
})();

// Events.js
(function () {
  /*global adventurejs A*/
  "use strict";

  // https://stackoverflow.com/questions/15308371/custom-events-model-without-using-dom-events-in-javascript

  // initEvent deprecated - but not createEvent? - use CustomEvent instead
  // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent
  // https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events

  /**
   * @class adventurejs.Events
   * @ajsnavheading FrameworkReference
   * @param {Game} game A reference to the game instance.
   * @summary Events fire at beginning / end of each turn, and can be exploited.
   * @classdesc
   * <p>
   * We only fire a few events, all at the beginning and end of a turn:
   * <code>inputEnter</code>,
   * <code>inputParseBegin</code>,
   * <code>inputParseComplete</code>, and
   * <code>inputQueueNext</code>
   * (which fires between queued inputs).
   * Authors can hook into these to run custom code.
   * For example, you could write a series of random in-game background
   * events tied to specific {@link adventurejs.Room|Rooms},
   * to print additional text to the {@link adventurejs.Display|Display}
   * after parsing has completed.
   * </p>
   * <h3>Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.reactor.addEventListener('inputParseComplete', function()
   * {
   *   var random = Math.random() * 100;
   *   switch (MyGame.world._currentRoom.name)
   *   {
   *     case "Frigid Wastes":
   *       if( random < 10 )
   *       {
   *         MyGame.print(
   *           "You're struck by a flash of blinding light as
   *           sunlight reflects off the packed ice.", "random"
   *         );
   *       }
   *       break;
   *     case "Desert Wastes":
   *       if( random > 5 && random < 10 )
   *       {
   *         MyGame.print(
   *           "Heat haze shimmers off the distant dunes.", "random"
   *         );
   *       }
   *       else if( random > 10 && random <  15 )
   *       {
   *         MyGame.print(
   *           "You feel the sand shift beneath your feet.", "random"
   *         );
   *       }
   *       break;
   *   }
   * });
   * </code></pre>
   */
  class Events {
    constructor(game) {
      /**
       * A reference back to the main {@link adventurejs.Game|Game} object.
       * @var {Object} adventurejs.Events#game
       * @default {}
       */
      this.game = game;

      /**
       * Event to be fired on player enters input.
       * @var {Event} adventurejs.Events#inputEnter
       */
      this.inputEnter = document.createEvent("Event");
      this.inputEnter.initEvent("inputEnter", true, true);

      /**
       * Event to be fired on input parse begin.
       * @var {Event} adventurejs.Events#inputParseBegin
       */
      this.inputParseBegin = document.createEvent("Event");
      this.inputParseBegin.initEvent("inputParseBegin", true, true);

      /**
       * Event to be fired on input parse complete.
       * @var {Event} adventurejs.Events#inputParseComplete
       */
      this.inputParseComplete = document.createEvent("Event");
      this.inputParseComplete.initEvent("inputParseComplete", true, true);

      /**
       * Event to be fired on queue next input when parsing a queue.
       * @var {Event} adventurejs.Events#inputQueueNext
       */
      this.inputQueueNext = document.createEvent("Event");
      this.inputQueueNext.initEvent("inputQueueNext", true, true);

      // this.playerChangeLocation = document.createEvent('Event');
      // this.playerChangeLocation.initEvent("playerChangeLocation", true, true);

      this.game.reactor.addEventListener("inputEnter", function (e) {
        var msg = "Event > inputEnter";
        this.game.log("log", "high", msg, "events");
      });

      this.game.reactor.addEventListener("inputParseBegin", function (e) {
        var msg = "Event > inputParseBegin";
        this.game.log("log", "high", msg, "events");
      });

      this.game.reactor.addEventListener("inputParseComplete", function (e) {
        var msg = "Event > inputParseComplete";
        this.game.log("log", "high", msg, "events");
        e.target.game.updateDisplayVerbs();
        e.target.game.updateDisplayInventory();
        // e.target.game.updateDisplayRoom();
        // e.target.game.updateDisplayCompasses();
        e.target.game.printRoomZoneEvents();
        e.target.game.callIntervals();
      });

      this.game.reactor.addEventListener("inputQueueNext", function (e) {
        var msg = "Event > inputQueueNext";
        this.game.log("log", "high", msg, "events");
      });

      // this.game.reactor.addEventListener('playerChangeLocation', function(event, other){
      // var msg = "Event > playerChangeLocation";
      // this.game.log( "log", "high", msg , 'events' );
      // });
    }
  }
  adventurejs.Events = Events;
})();

// Game.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @class adventurejs.Game
   * @ajsconstruct var MyGame = new adventurejs.Game( "MyGame", "MyGameDisplay" )
   * @ajsnavheading FrameworkReference
   * @param {String} [game_name = ""]
   * A string that matches the name
   * of the var used to store the new <strong>Game</strong> instance.
   * Used to give the game a reference back to itself, relative to the
   * browser window. If no name is provided, the instance name will
   * default to "MyGame".
   * <!--This name gets scoped to
   * window, and is used by all classes as a reference back to the game
   * instance. Instead of storing 'this.game', objects store
   * 'this.game_name', and refer back to the game by calling
   * window[this.game_name]. We do this to avoid circular object
   * references, which create problems when writing/reading json, which
   * we use to manage save/restore operations.-->
   * The chief reason you might want to use a custom game_name
   * is if you want to run multiple instance of adventure.js on a
   * single page; give them distinct names to prevent them from colliding.
   * You also may want to refer to your Game instance if you write any
   * custom javascript.
   * @param {String} [displayElId = ""]
   * A string that matches the ID of an existing DOM element into which
   * to insert the game {@link adventurejs.Display|Display}. If no
   * ID is provided, a DOM element will be created with an ID of
   * "MyGameDisplay" and class of "ajs-display", and appended to <BODY>.
   * @summary Constructs a new game object.
   * @classdesc
   * <p>
   * <strong>Game</strong> is used to construct a new game instance.
   * This instance contains the entire game and all of its methods.
   * If you open the browser inspector window, go to the console, and
   * type "MyGame" (or whatever game_name you have provided),
   * you can see the properties scoped to the Game object.
   * Every object in the game is given a reference back to the main
   * Game object. This means that you can run multiple games in a
   * single HTML page.
   * </p>
   * <h3 class="example">Example:</h3>
   * <p>
   * A minimal game defines at least one {@link adventurejs.Room|Room}
   * and one {@link adventurejs.Player|Player}
   * {@link adventurejs.Character|Character}. If you
   * don't provide either of these, one will be created automatically.
   * </p>
   * <pre class="display"><code class="language-javascript">var MyGame = new adventurejs.Game( "MyGame", "MyGameDisplay" )
   * .set({
   *   title: "Welcome Game",
   *   author: "Ivan Cockrum",
   *   description: "This is my great game! Thanks for playing!",
   *   version: "0.0.1",
   * });
   *
   * MyGame.createAsset({
   *   class: "Room",
   *   name: "Welcome Room",
   *   descriptions:{ look: "You've entered the Welcome Room. " },
   * });
   *
   * MyGame.createAsset({
   *   class: "Player",
   *   name: "Guest",
   *   is: { active: true, },
   *   place: { in: "Welcome Room" },
   * });
   * </code></pre>
   *
   **/
  class Game {
    constructor(game_name = "MyGame", displayElId = "MyGameDisplay") {
      this.class = "Game";

      this.game_states = {
        static: -1,
        construction: 0,
        validateAssets: 1,
        createDeferredAssets: 2,
        initializeAssets: 3,
        sortLookupValues: 4,
        worldSetDefaultAssets: 5,
        worldSaveBaseline: 6,
        playing: 7,
      };
      this.game_state = this.game_states.construction;

      /**
       * A reference back to this <strong>Game</strong> object.
       * Chiefly used for consistency so we can refer to this.game,
       * which is how we refer back to the Game from many functions.
       * @var {Object} adventurejs.Game#game
       * @default {}
       */
      this.game = window[game_name] = this;

      /**
       * game_name holds a copy of the variable name used to store
       * the current game instance, to which every asset in the game world
       * holds a reference. (By default, we use "MyGame", but you can use
       * any name.) The variable is scoped to window, and in order
       * to get the game object, we call window[this.game_name].
       * Though it would be easier to use a direct object reference,
       * doing so creates a circular reference, which complicates
       * JSON encoding, which is how we save/restore the game state.
       * @var {String} adventurejs.Game#game_name
       */
      this.game_name = game_name;

      /**
       * @member
       */
      // event management
      this.reactor = new adventurejs.Reactor(this);
      this.events = new adventurejs.Events(this);

      /**
       * <code>settings</code> is a singleton class
       * that stores all the game's global settings.
       * @var {Object} adventurejs.Game#settings
       */
      this.settings = new adventurejs.Settings(this);

      this.log("log", 1, "Game.js > Constructing " + this.game_name + ".");

      //this.version = "0.0.0";

      /**
       * <code>world</code> stores all the game asset
       * objects. It also stores a handful of variables
       * such as _player and _currentRoom which are used
       * for convenience. It also stores any global vars
       * created by the game's author. This last is done
       * to give authors a place to store vars that can
       * be written out with saved games.
       * @var adventurejs.Game#world
       */
      this.world = {};

      /**
       * <code>world._vars</code> is a namespace for
       * authors to store any custom vars that they
       * would like to be written out with saved games,
       * so that they can be restored along with other
       * saved game data in order to retain game state.
       * @var adventurejs.Game#world_lookup
       */
      this.world._vars = {};

      this.world._game_name = this.game_name;
      this.world._currentRoom = "";
      this.world._player = "";
      this.world._version = "";
      this.world._title = "";
      this.world._titleSerialized = "";
      this.world._author = "";
      this.world._score = "";
      this.world._timestamp = new Date().getTime().toString();
      this.world._intervals = {};

      /**
       * <code>baseline</code> stores a copy of the initial
       * game world, for comparison in save/restore and undo.
       * @var adventurejs.Game#baseline
       */
      this.baseline = { world: {} };
      // this.baseline = { world: {}, vars: {} };

      /**
       * <code>world_lookup</code> stores a lookup table
       * containing indexed keywords for all game assets.
       * @var adventurejs.Game#world_lookup
       */
      this.world_lookup = {};

      /**
       * <code>class_lookup</code> stores a lookup table
       * containing the ids of all assets by class.
       * @var adventurejs.Game#class_lookup
       */
      this.class_lookup = {};

      /**
       * <code>room_lookup</code> stores an array
       * containing the ids of all rooms.
       * @var adventurejs.Game#room_lookup
       */
      this.room_lookup = [];

      /**
       * <code>image_lookup</code> stores a lookup table
       * for optional images supplied by author.
       * @var adventurejs.Game#image_lookup
       */
      this.image_lookup = {};

      // create dictionary
      this.dictionary = new adventurejs.Dictionary(this);

      // create standard dictionary verbs
      this.dictionary.initStandardVerbs();

      this.display = new adventurejs.Display(displayElId, this);

      // create parser
      this.parser = new adventurejs.Parser(this).set({ display: this.display });

      this.saveManager = new adventurejs.SaveManager(this);

      this.restoreManager = new adventurejs.RestoreManager(this);

      this.userManager = new adventurejs.UserManager(this);

      // create global objects
      this.createAsset({ class: "All", name: "all" });
      this.createGlobalExits();
      this.createGlobalWalls();
      this.createGlobalFloors();
      this.createGlobalCeilings();
      this.createGlobalScenery();
      this.createAsset({
        class: "GlobalString",
        id: "global_string",
      }); // for string-in-string

      /**
       * <code>scorecard</code> is a singleton class
       * that stores all the game's score events
       * and functions for managing score.
       * @var {Object} adventurejs.Game#scorecard
       */
      this.scorecard = new adventurejs.Scorecard(this);

      /* *
       * <code>compasses</code> is an array that
       * stores references to any custom compasses.
       * @var {Object} adventurejs.Game#compasses
       */
      // this.compasses = [];

      /* *
       * <code>verbdocks</code> is an array that
       * stores references to any custom verbdocks.
       * @var {Object} adventurejs.Game#verbdocks
       */
      // this.verbdocks = [];

      /**
       * <code>inventorydocks</code> is an array that
       * stores references to any custom inventorydocks.
       * @var {Object} adventurejs.Game#inventorydocks
       */
      // this.inventorydocks = [];

      this.deferredObjects = [];
      this.description = "";
      this.world_history = [];

      return this;
    }

    initialize(params) {
      return this;
    }

    /**
     * Takes an input and immediately forwards it to the parser.
     * @memberOf adventurejs.Game
     * @method adventurejs.Game#sendToParser
     */
    sendToParser(value) {
      this.game.reactor.dispatchEvent(this.game.events.inputEnter);
      this.parser.input_string = value;
      this.parser.parseInput(value);
      this.display.clearInput();
    }

    /**
     * An alias to method display.sendToInput.
     * @memberOf adventurejs.Game
     * @method adventurejs.Game#sendToInput
     */
    sendToInput(value) {
      this.display.sendToInput(value);
    }

    /**
     * An alias to method display.clearInput.
     * @memberOf adventurejs.Game
     * @method adventurejs.Game#clearInput
     */
    clearInput(value) {
      this.display.clearInput();
    }

    // Getter / Setter Properties
    // These few props have getter/setter methods in order to pass
    // values to the display.

    /**
     * Get/set game title and pass to Display.
     * @var {String} adventurejs.Game#title
     * @default ""
     */
    get title() {
      return this.__title;
    }
    set title(title) {
      this.display.set({ title: (this.__title = title) });
      // double underscore solves recursion
      this.titleSerialized = A.serialize(title);
      this.world._title = title;
      this.world._titleSerialized = A.serialize(title);
    }

    /**
     * Get/set game author and pass to Display.
     * @var {String} adventurejs.Game#author
     * @default ""
     */
    get author() {
      return this.__author;
    }
    set author(author) {
      this.display.set({ author: (this.__author = author) });
      // double underscore solves recursion
      this.world._author = author;
    }

    /**
     * Concatenate room name + player situation
     * and save to game.displayRoomName. If there's
     * a room image, update that.
     * @memberOf adventurejs.Game
     * @method adventurejs.Game#updateDisplayRoom
     */
    updateDisplayRoom() {
      var player = this.getPlayer();
      var situation = "";
      var nest_asset = player.getNestAsset();
      let room = this.game.getAsset(this.world._currentRoom);

      if (nest_asset) {
        situation = ` (${player.getPostureGerund()} 
        ${player.getNestPreposition()} 
        ${nest_asset.articlename})`;
      } else if (player.isOnFloor()) {
        situation = ` (${player.getPostureGerund()} on the floor)`;
      }
      // @TODO floating in water or zero-G

      situation = situation
        ? `<span class='situation'>${situation}</span>`
        : "";
      let name = room.name + (situation && situation);

      //this.display.set({ "room" : name });
      this.display.setRoomName(name).setRoomImage(room.image);
      //this.display.setRoomImage(room.image);
      // @TODO set image
    }

    /**
     * Write current room's exits to the display's compass rose.
     * @memberOf adventurejs.Game
     * @method adventurejs.Game#updateDisplayCompasses
     */
    updateDisplayCompasses() {
      let exitnames = "";
      let exits = this.getCurrentRoom().exits;
      for (var id in exits) {
        let exit = this.getAsset(exits[id]);
        if (exit.destination) exitnames += ` ${exit.direction}`;
      }
      this.display.updateCompasses(exitnames);
    }

    /**
     * Update the verbs in verb docks.
     * @memberOf adventurejs.Game
     * @method adventurejs.Game#updateDisplayVerbs
     * @TODO this has no logic yet
     */
    updateDisplayVerbs() {
      this.display.updateVerbDocks();
    }

    /**
     * Update the inventory in inventory docks.
     * @memberOf adventurejs.Game
     * @method adventurejs.Game#updateDisplayInventory
     */
    updateDisplayInventory() {
      // getInventory doesn't return nested items
      // this.display.updateInventoryDocks( this.game.getPlayer().getInventory() );

      // getAllNestedContents might reveal unknown nested items
      this.display.updateInventoryDocks(
        this.game.getPlayer().getAllNestedContents()
      );
    }

    /* *
     * Get/set game room name and pass to Display.
     * @var {String} adventurejs.Game#displayRoomName
     * @default ""
     */
    // Object.defineProperty(p, "displayRoomName",
    // {
    // 	get: function()
    //   {
    // 		return this.__displayRoomName;
    // 	},
    // 	set: function(displayRoomName)
    //   {
    // 		this.display.set({ "room" : this.__displayRoomName = displayRoomName });
    // 		// double underscore solves recursion
    // 	}
    // });

    /**
     * Get/set game score and pass to Display.
     * @var {String} adventurejs.Game#score
     * @default ""
     */
    get score() {
      return this.__score;
    }
    set score(score) {
      this.display.set({ score: (this.__score = score) });
      this.world._score = score;
    }

    /**
     * Get/set game version and pass to Display.
     * @var {String} adventurejs.Game#version
     * @default ""
     */
    get version() {
      return this.__version;
    }
    set version(version) {
      this.display.set({ version: (this.__version = version) });
      // double underscore solves recursion
      this.world._version = version;
    }

    // SHORTCUT ALIASES FOR AUTHORS

    /**
     * Convenience method to get the player.
     * @var {Object} adventurejs.Game#player
     * @deprecated Use game.getPlayer() instead.
     */
    get player() {
      return this.getAsset(this.world._player);
    }

    /**
     * Convenience method to get the player's current room.
     * @var {Object} adventurejs.Game#currentRoom
     * @deprecated Use game.getCurrentRoom() instead.
     */
    get currentRoom() {
      return this.world[this.world._currentRoom];
    }

    /**
     * Convenience method to get this turn's input.
     * @var {Object} adventurejs.Game#input
     * @deprecated Use game.getInput() instead.
     */
    get input() {
      return this.parser.input_history[0];
    }

    /**
     * Convenience method to get last turn.
     * @var {Object} adventurejs.Game#last_turn
     * @deprecated Use game.getLastTurn() instead.
     */
    get last_turn() {
      return this.parser.input_history[1];
    }

    // PARSER SHORTCUT METHODS FOR AUTHORS

    createCustomParser(parser) {
      return this.parser.createCustomParser(parser);
    }
    enableCustomParser(parser) {
      return this.parser.enableCustomParser(parser);
    }
    disableCustomParser(parser) {
      return this.parser.disableCustomParser(parser);
    }

    /**
     * Convenience method is a shortcut to
     * game.parser.input_history[ 0 ].appendToOutput().
     * Provides a method for author to append custom
     * text after default output for the turn.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#appendToOutput
     * @param {String} msg
     * @returns {boolean}
     */
    appendToOutput(msg) {
      return this.input.appendToOutput(msg);
    }

    /**
     * This convenience method is a shortcut to
     * game.parser.input_history[ 0 ].overrideOutput().
     * Provides a method for author to override default
     * text output for the turn.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#appendToOutput
     * @param {String} msg
     * @returns {boolean}
     */
    overrideOutput(msg) {
      return this.input.overrideOutput(msg);
    }

    /**
     * This convenience method is a shortcut to
     * game.parser.input_history[ 0 ].prependToOutput().
     * Provides a method for author to prepend custom
     * text before default output for the turn.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#prependToOutput
     * @param {String} msg
     * @returns {boolean}
     */
    prependToOutput(msg) {
      return this.input.prependToOutput(msg);
    }

    // DICTIONARY SHORTCUT METHODS FOR AUTHORS

    /**
     * This convenience method is a shortcut to
     * {@link adventurejs.Dictionary#getStringLookup|game.dictionary.getStringLookup()}.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#getStringLookup
     * @param {object} verbs
     * @returns {object}
     */
    getStringLookup(type, value) {
      return this.dictionary.getStringLookup(type, value);
    }

    /**
     * Get the dictionary verb corresponding to provided string.
     * This convenience method is a shortcut to
     * {@link adventurejs.Dictionary#getVerb|game.dictionary.getVerb()}.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#getVerb
     * @param {string} verb
     * @returns {object}
     */
    getVerb(verb) {
      return this.dictionary.getVerb(verb);
    }

    /**
     * This convenience method is a shortcut to
     * {@link adventurejs.Dictionary#disableVerbs|game.dictionary.disableVerbs()}.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#disableVerbs
     * @param {object} verbs
     * @returns {object}
     */
    disableVerbs(verbs) {
      return this.dictionary.disableVerbs(verbs);
    }

    /**
     * This convenience method is a shortcut to
     * {@link adventurejs.Dictionary#disableAllVerbsBut|game.dictionary.disableAllVerbsBut()}.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#disableAllVerbsBut
     * @param {object} verbs
     * @returns {object}
     */
    disableAllVerbsBut(verbs) {
      return this.dictionary.disableAllVerbsBut(verbs);
    }

    /**
     * This convenience method is a shortcut to
     * {@link adventurejs.Dictionary#enableVerbs|game.dictionary.enableVerbs()}.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#enableVerbs
     * @param {object} verbs
     * @returns {object}
     */
    enableVerbs(verbs) {
      return this.dictionary.enableVerbs(verbs);
    }

    /**
     * This convenience method is a shortcut to
     * {@link adventurejs.Dictionary#createVerb|game.dictionary.createVerb()}.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#createVerb
     * @param {object} verb
     * @returns {object}
     */
    createVerb(verb) {
      return this.dictionary.createVerb(verb);
    }

    /**
     * This convenience method is a shortcut to
     * {@link adventurejs.Dictionary#replaceVerb|game.dictionary.replaceVerb()}.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#replaceVerb
     * @param {object} oldVerb
     * @param {object} newVerb
     * @returns {object}
     */
    replaceVerb(oldVerb, newVerb) {
      newVerb = this.dictionary.replaceVerb(oldVerb, newVerb);
      return newVerb;
    }

    /**
     * This convenience method is a shortcut to
     * {@link adventurejs.Dictionary#combineVerbs|game.dictionary.combineVerbs()}.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#combineVerbs
     * @param {object} verbs
     * @param {object} intoVerb
     * @returns {object}
     */
    combineVerbs(verbs, intoVerb) {
      intoVerb = this.dictionary.combineVerbs(verbs, intoVerb);
      return intoVerb;
    }

    /**
     * <strong>patchVerb</strong> enables an author to revise the properties
     * of an existing verb. For example, let's say you want to revise the
     * verb "plug" so that it works in the dark - meaning that players
     * it can operate on assets the player can't see. You might copy the
     * <code>plug.phrase1</code> and in your game file, call patchVerb with
     * line <code>visible: true</code> removed.
     * <pre class="display"><code class="language-javascript">MyGame.patchVerb({
     *   name: "plug",
     *   phrase1:{
     *     accepts_noun: true,
     *     requires_noun: true,
     *     accepts_preposition: true,
     *     noun_must_be:
     *     {
     *       known: true,
     *       tangible: true,
     *       present: true,
     *       <span class="strikethrough">visible: true,</span>
     *       reachable: true,
     *     },
     *   },
     * });</code></pre>
     * <br><br>
     * ( game.patchVerb() actually forwards to
     * {@link adventurejs.Dictionary#patchVerb|game.dictionary.patchVerb()} ).
     * @memberof adventurejs.Game
     * @method adventurejs.Game#patchVerb
     * @param {object} patch_verb
     * @returns {object}
     */
    patchVerb(patch_verb) {
      patch_verb = this.dictionary.patchVerb(patch_verb);
      return patch_verb;
    }

    /**
     * Intervals are callback functions used to fire in-game events
     * every turn. For example, turn on a water faucet and the faucet
     * pours water every turn until it's turned off.
     * registerInterval adds functions to the list.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#registerInterval
     * @param {string} id id of Asset which owns the function.
     * @param {string} callback The function to call on interval.
     * @todo add number of turns as a param and only call per x turn
     */
    registerInterval(id, callback) {
      //console.warn( "Game_registerInterval " + id + ", " + callback );
      if ("undefined" === typeof this.world._intervals[id]) {
        this.world._intervals[id] = {};
      }
      this.world._intervals[id][callback] = true;
    }

    /**
     * Intervals are callback functions used to fire in-game events
     * every turn. For example, turn on a water faucet and the faucet
     * pours water every turn until it's turned off.
     * unregisterInterval removes callback functions from the list.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#unregisterInterval
     * @param {string} id id of Asset which owns the function.
     * @param {string} callback The function to call on interval.
     */
    unregisterInterval(id, callback) {
      //console.warn( "Game_unregisterInterval " + id + ", " + callback );
      if ("undefined" === typeof this.world._intervals[id]) {
        return;
      }
      if ("undefined" === typeof this.world._intervals[id][callback]) {
        return;
      }
      delete this.world._intervals[id][callback];
      if (0 === Object.keys(this.world._intervals[id]).length) {
        delete this.world._intervals[id];
      }
    }

    /**
     * callIntervals uses pointers to asset properties to
     * print messages or apply custom logic every turn.
     * For example, turn on a water faucet and have
     * the faucet pour water every turn until it's turned
     * off, or turn on a radio and have it play music lyrics.
     * Properties can be strings or arrays or functions.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#unregisterInterval
     */
    callIntervals() {
      var game = this;
      Object.keys(this.world._intervals).forEach(function (id) {
        Object.keys(game.world._intervals[id]).forEach(function (callback) {
          let results;
          let asset;
          asset = game.getAsset(id);
          if (!asset || !asset[callback]) return;
          results = A.getSAF.call(game, asset[callback], asset);
          if ("string" === typeof results) game.print(results);
        });
      });
    }

    /**
     * This convenience property is a shortcut to game.world._vars,
     * which is a container for any custom variables set by authors.
     * Variables stored here are saved within the scope of data that
     * gets written to save files.
     * @memberof adventurejs.Game
     * @method adventurejs.Game#unregisterInterval
     */
    get vars() {
      return this.world._vars;
    }
  }
  adventurejs.Game = Game;
})();

// $directions.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Convenience method to get the exit directions of the current room asset.
   * @method adventurejs.Game#$directions
   * @memberOf adventurejs.Game
   * @returns {Object}
   */
  p.$directions = function Game_directions() {
    return this.getAsset(this.world._currentRoom).$directions();
  };
})();

// $exits.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Convenience method to get the exits of the current room asset.
   * @method adventurejs.Game#$exits
   * @memberOf adventurejs.Game
   * @returns {Object}
   */
  p.$exits = function Game_exits() {
    return this.getAsset(this.world._currentRoom).$exits();
  };
})();

// constructAsset.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Takes a generic object and returns a classed object.
   * @method adventurejs.Game#constructAsset
   * @memberOf adventurejs.Game
   * @param {Object} source A generic object containing properties to copy to a game object.
   * @returns {Object} Returns an instance of whatever class was defined.
   */
  p.constructAsset = function Game_constructAsset(source) {
    var id;
    var dest;

    /**
     * Most classes convert name to ID,
     * with the exception of Exits
     * which use location + direction.
     */
    if (source.class === "Exit") {
      id = A.serialize(
        source.place[Object.keys(source.place)[0]] + " " + source.direction
      );
    } else if (source.name) {
      id = A.serialize(source.name);
    }

    if (!this.class_lookup[source.class]) this.class_lookup[source.class] = [];
    this.class_lookup[source.class].push(id);

    /**
     * if author has set source.place
     * ensure that the name of its parent object is serialized
     */
    if (
      "object" === typeof source.place &&
      Object.keys(source.place).length > 0
    ) {
      source.place[Object.keys(source.place)[0]] = A.serialize(
        source.place[Object.keys(source.place)[0]]
      );
    }

    // create new class object with serialized name
    dest = new adventurejs[source.class](id, this.game_name);

    /**
     * Give it a reference back to game.
     * We can't give game objects a direct reference because
     * circular references cause problems when writing saves out to JSON.
     * Instead we save the instance name that is scoped to window,
     * and get it with object.game property.
     *
     */
    dest.game_name = this.game_name;

    /**
     * We allow author to define noun & plural as strings, but we
     * actually store those as a nested array in singlePluralPairs,
     * eg [ ["key","keys"] ];
     *
     * We don't expect authors to define singlePluralPairs themselves,
     * but we do allow for it, for cases of advanced users.
     */
    if ("undefined" === typeof source.singlePluralPairs) {
      source.singlePluralPairs = [];
    }

    // strip spaces
    if ("string" === typeof source.noun) source.noun = source.noun.trim();
    if ("string" === typeof source.plural) source.plural = source.plural.trim();

    // TODO singlePluralPairs setup was being duplicated here and in Asset.js
    // are we losing anything if we shut down this one?
    // make new pair
    // if( "string" === typeof source.noun
    //   && "string" === typeof source.plural
    //   && "" !== source.noun
    //   && "" !== source.plural
    // ) {
    //   source.singlePluralPairs.push( [ source.noun, source.plural ] );
    // }
    // the base class may already have noun/plural pairs so append those
    //source.singlePluralPairs = source.singlePluralPairs.concat( dest.singlePluralPairs );

    /**
     * HANDLE ASPECTS
     * Look for uninitialized Aspects in game file.
     * Tangible Assets have Aspects, aka aspects,
     * which are containers for in/on/under etc.
     * Some predefined Tangible subclasses, like Table or Bathtub, may have
     * preset Aspects for things like 'on' or 'in'. But, in case author has
     * defined properties for an Aspect that hasn't been defined for this class
     * of asset, we'll be nice and instantiate an Aspect for them.
     * Also, if we encounter an aspect that is not in our dictionary's list of
     * prepositions, add the preposition to the dictionary.
     */
    if (source.aspects && dest.aspects) {
      // did we receive an array?
      if (Array.isArray(source.aspects)) {
        // authors are invited to use arrays as a shorthand to create aspects
        // aspects: [ 'on', 'under', 'behind' ],
        for (var i = 0; i < source.aspects.length; i++) {
          var aspect = source.aspects[i];
          if (dest.aspects[aspect]) {
            dest.aspects[aspect].enabled = true;
          } else {
            dest.aspects[aspect] = new adventurejs.Aspect(
              aspect,
              this.game_name
            ).set({ parent_id: id, enabled: true });
          }
        }
        delete source.aspects;
      } else {
        for (var aspect in source.aspects) {
          // Has dest got an Aspect instance here?
          if (!dest.aspects[aspect]?.class) {
            dest.aspects[aspect] = new adventurejs.Aspect(
              aspect,
              this.game_name
            ).set({ parent_id: id, enabled: true });
          }

          if (source.aspects[aspect].vessel) {
            if ("boolean" === typeof source.aspects[aspect].vessel) {
              // we accept aspects:{on:{vessel:true}} as a shortcut
              if (dest.aspects[aspect].vessel?.class) {
                // if existing vessel, set enabled
                dest.aspects[aspect].enabled = source.aspects[aspect].vessel;
              } else if (source.aspects[aspect].vessel) {
                // only if true, create new vessel
                dest.aspects[aspect].vessel = new adventurejs.Vessel(
                  aspect,
                  this.game_name
                ).set({ parent_id: id, enabled: true });
              }
              // else if false and no vessel, do nothing

              // since source vessel was boolean, delete so it doesn't get cloned
              delete source.aspects[aspect].vessel;
            } // vessel is not boolean
            else {
              if (!dest.aspects[aspect].vessel?.class) {
                dest.aspects[aspect].vessel = new adventurejs.Vessel(
                  aspect,
                  this.game_name
                ).set({ parent_id: id, enabled: true });
              }
            }
          }

          // if aspect is an unknown preposition, add it to dictionary
          if (-1 === this.game.dictionary.prepositions.indexOf(aspect)) {
            this.game.dictionary.prepositions.push(aspect);
          }

          // we allow authors to set aspects to true/false as a shortcut
          // which we write to aspect.enabled - if we got one of those
          // we want to set it & delete it so it doesn't get cloned
          if (
            true === source.aspects[aspect] ||
            false === source.aspects[aspect]
          ) {
            dest.aspects[aspect].enabled = source.aspects[aspect];
            delete source.aspects[aspect];
          }
        } // for
      }
    }

    /**
     * HANDLE VERB SUBSCRIPTIONS
     * Each asset subscribes to verbs to allow them to act upon it.
     * VerbSubscriptions are pre-defined for classes, but if author
     * has added new VerbSubscriptions or modifiers to pre-defined
     * ones, we want to merge them in.
     */
    var object = ["dov", "iov"];
    for (var of = 0; of < object.length; of++) {
      if (source && source[object[of]]) {
        // is source[ object[of] ] an array?
        if (Array.isArray(source[object[of]])) {
          dest.setObjectOfVerbs(object[of], source[object[of]]);
        } else {
          for (var verb in source[object[of]]) {
            dest.setVerbSubscription(object[of], {
              [verb]: source[object[of]][verb],
            });
          }
        }
        // we've copied everything we need from source and
        // we don't want to recopy in the clone block, so...
        delete source[object[of]];
      }
    }

    // ALL OTHER PROPERTIES
    var keys = Object.keys(source);
    for (var i = 0; i < keys.length; i++) {
      var prop = keys[i];

      // ignore native prototype properties
      if (!Object.prototype.hasOwnProperty.call(source, prop)) continue;

      // if("undefined" !== typeof source[ prop ].class
      // && "undefined" !== typeof dest[ prop ]
      // && "undefined" === typeof dest[ prop ].class)
      // {
      //   dest[ prop ] = new adventurejs[ source[ prop ].class ]( source[ prop ].id, this.game_name );
      // }

      // convert strings to arrays as needed
      if ("string" === typeof source[prop] && Array.isArray(dest[prop])) {
        source[prop] = source[prop].toLowerCase().split(",");
      }

      if (Array.isArray(source[prop])) {
        // trim spaces
        for (var p = 0; p < source[prop].length; p++) {
          if ("string" === typeof source[prop][p]) {
            source[prop][p] = source[prop][p].trim();
          }
        }

        /*
         * Some classes may have predefined words for some properties,
         * and we don't want to overwrite those.
         * If author has added more words we want
         * to concat rather than replace.
         *
         * Example: Say we have class SteelSword with adjectives=["steel"]
         * and author creates an instance and adds adjectives=["sharp"]
         * We need to ensure that both "steel sword" and "sharp sword" will work.
         */
        source[prop] = source[prop].concat(dest[prop]);
      }
    }

    /**
     * Clone remaining properties from the generic source
     * to the dest using the Set() method of Atom,
     * which is the superclass for all game objects.
     */
    dest.set(source);

    // if( source.class === "Exit" ) {
    //   var directionSynonyms = this.game.dictionary.directionLookup[ source.direction ];
    //   for( var i = 0; i < directionSynonyms.length; i++ )
    // {
    //     dest.adjectives.push( directionSynonyms[i] );
    //   }
    // }

    return dest;
  };
})();

//createAsset.js
(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({ "class":"foo", "name":"bar", [...] })</code></pre>
   * <p>
   * <strong>createAsset()</strong> is a constructor function
   * available to authors, for creating all instances of
   * {@link adventurejs.Asset|Asset}
   * and its subclasses, which includes most
   * of the objects you'd put in a game world.
   * </p>
   * <p>
   * The function takes one parameter: a generic
   * object containing properties to be passed into a class instance.
   * For most asset classes, the only required
   * properties are 'class' and 'name'. You'd likely also want
   * to specify 'location', though that's not a required property.
   * Otherwise, an author only needs to define the properties
   * they wish to revise away from default settings.
   * </p>
   * <p>
   * For example, to create a simple brass key with
   * default settings and put it in a particular location:
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   "class":"Key",
   *   "name":"brass key",
   *   place: { in: "desk drawer" },
   * });
   * </code></pre>
   * <p>
   * At runtime, <strong>createAsset()</strong> returns a new instance
   * of the given class, uses
   * the given name to create an id, validates the object properties,
   * initializes the new object, and then adds it to the game world.
   * Failure to pass any of these steps will throw an error to
   * the console.
   * </p>
   * <p>
   * For more examples of how to use createAsset, see
   * <a href="/doc/AssetReference__Overview.html">About Assets</a>
   * and other How To docs under Get Started.
   * </p>
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createAsset
   * @kind function
   * @param {Object} asset A generic object with properties to copy into a new classed object.
   * @returns {Object} A new Asset of the class specified in asset.class.
   */
  p.createAsset = function Game_createAsset(asset) {
    /*
     * Test whether it's a generic object
     * because there was an early version
     * where we were passing in classed objects,
     * some of which might still be valid.
     */
    if (asset.constructor.name === "Object") {
      asset = this.validateAssetPrecursor(asset);
      if (asset) {
        asset = this.constructAsset(asset);
      } else {
        return false;
      }
    }

    // has it already been defined?
    if (this.world[asset.id]) {
      var msg = `Warning: createAsset id ${asset.id} is used more than once. `;
      if (asset.class === "Exit") {
        msg += `This could happen if you define an exit in a room's exits property and also as a separate exit asset. `;
      }
      this.game.log("error", 0, msg, "Game");
      return false;
    }

    // add classed object to game world
    this.world[asset.id] = asset;

    return asset;
  };
})();

//createCompass.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * <strong>createCompass</strong> is an alias to method 
   * game.display.createCompass()
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createCompass
   * @param {Object} properties A generic object with properties used to construct a compass.
   * @returns {Object} A new compass object.
   * 
   */
	p.createCompass = function Game_createCompass( properties )
  {
    return this.display.createCompass(properties);
	}  
}());

// createDeferredAssets.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Create objects - mainly exits - that were defined
   * within other unclassed generic objects.
   * <br><br>
   * Objects created here also need to be validated,
   * since they were added to the deferred list during
   * the initial validation pass and therefore missed validation.
   * @method adventurejs.Game#createDeferredAssets
   * @memberOf adventurejs.Game
   */
  p.createDeferredAssets = function Game_createDeferredAssets() {
    for (var i = 0; i < this.deferredObjects.length; i++) {
      var newObject = this.game.createAsset(this.deferredObjects[i]);

      if (false === newObject) {
        return false;
      }

      if (false === newObject.validate(this)) {
        return false;
      }

      newObject.is.validated = true;
    }
    return true;
  };
})();

//createGlobalCeilings.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Create global ceiling (although there's only one).
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createGlobalCeilings
   * @kind function
   */
  p.createGlobalCeilings = function Game_createGlobalCeilings() {
    //console.warn( "createGlobalCeilings" );
    for (var i = 0; i < A.GlobalAssets.Ceilings.length; i++) {
      var ceiling = A.GlobalAssets.Ceilings[i];

      this.world.global_ceiling = new adventurejs.Ceiling(
        "ceiling",
        this.game_name
      );
      this.world.global_ceiling.set({
        is: {
          global: true,
          known: true,
          seen: true,
        },

        name: ceiling.name,
        class: "Ceiling",
        id: "global_ceiling",
        singlePluralPairs: [["ceiling", "ceilings"]],
        adjectives: [],
      });

      if (ceiling.descriptions.look) {
        this.world.global_ceiling.descriptions.look = ceiling.descriptions.look;
      }
    }
  };
})();

// createGlobalExits.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Create global exits.
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createGlobalExits
   * @kind function
   */
  p.createGlobalExits = function Game_createGlobalExits() {
    for (var i = 0; i < A.GlobalAssets.Exits.length; i++) {
      var exit = A.GlobalAssets.Exits[i];

      this.world["global_" + exit.direction] = new adventurejs.Exit(
        exit.direction,
        this.game_name
      );
      this.world["global_" + exit.direction].game_name = this.game_name;
      this.world["global_" + exit.direction].set({
        is: {
          global: true,
          known: true,
          seen: true,
        },
        name: "non-existant " + exit.direction + " exit",
        direction: exit.direction,
        class: "Exit",
        id: "global_" + exit.direction,
        game_name: this.game_name,

        singlePluralPairs: [
          ["exit", "exit"],
          ["passage", "passage"],
        ],
        //adjectives: [ exit.direction ],
        //adjectives: this.game.dictionary.directionLookup[ exit.direction ],
      });

      if (exit.descriptions.look) {
        this.world["global_" + exit.direction].descriptions.look =
          exit.descriptions.look;
      }
    }
  };
})();

// createGlobalFloors.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Create global floors (although there's only one).
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createGlobalFloors
   * @kind function
   */
  p.createGlobalFloors = function Game_createGlobalFloors() {
    //console.warn( "createGlobalFloors" );
    for (var i = 0; i < A.GlobalAssets.Floors.length; i++) {
      var floor = A.GlobalAssets.Floors[i];

      this.world.global_floor = new adventurejs.Floor("floor", this.game_name);
      this.world.global_floor.set({
        is: {
          global: true,
          known: true,
          seen: true,
        },
        name: floor.name,
        class: "Floor",
        id: "global_floor",
        descriptions: { look: floor.description },
        singlePluralPairs: [["floor", "floors"]],
        adjectives: [],
      });
    }
  };
})();

//createGlobalScenery.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Create global scenery.
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createGlobalScenery
   * @kind function
   */
  p.createGlobalScenery = function Game_createGlobalScenery() {
    //console.warn( "createGlobalScenery" );
    for (var i = 0; i < A.GlobalAssets.Scenery.length; i++) {
      var scenery_precursor = A.GlobalAssets.Scenery[i];
      //console.warn( scenery );
      var id = "global_" + A.serialize(scenery_precursor.name);
      //var id = A.serialize( scenery_precursor.name );
      var description;
      if (
        scenery_precursor.descriptions &&
        scenery_precursor.descriptions.look
      ) {
        description = scenery_precursor.descriptions.look;
      } else if (scenery_precursor.description) {
        description = scenery_precursor.description;
      } else {
        description = "";
      }

      this.world[id] = new adventurejs.Scenery(id, this.game_name);
      this.world[id].game_name = this.game_name;
      this.world[id].set(scenery_precursor);
      this.world[id].set({
        is: {
          global: true,
          known: true,
          seen: true,
        },
        name: scenery_precursor.name,
        class: "Scenery",
        descriptions: { look: description },
        //id: id,
        game_name: this.game_name,

        singlePluralPairs: [],
        adjectives: [],
      });
    }
  };
})();

// createGlobalWalls.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Create global walls.
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createGlobalWalls
   * @kind function
   */
  p.createGlobalWalls = function Game_createGlobalWalls() {
    //console.warn( "globalWalls", this.globalWalls );
    for (var i = 0; i < A.GlobalAssets.Walls.length; i++) {
      var wall = A.GlobalAssets.Walls[i];

      var description;
      if (wall.descriptions && wall.descriptions.look) {
        description = wall.descriptions.look;
      } else if (wall.description) {
        description = wall.description;
      } else {
        description = "";
      }

      this.world["global_" + wall.direction + "_wall"] = new adventurejs.Wall(
        wall.direction + " wall",
        this.game_name
      );
      this.world["global_" + wall.direction + "_wall"].set({
        is: {
          global: true,
          known: true,
          seen: true,
        },
        name: wall.direction + " wall",
        direction: wall.direction,
        class: "Wall",
        id: "global_" + wall.direction + "_wall",

        singlePluralPairs: [["wall", "walls"]],
        adjectives: [wall.direction],
      });
      this.world["global_" + wall.direction + "_wall"].descriptions.look =
        description;
      this.world["global_" + wall.direction + "_wall"].enabled = wall.enabled;
    }
  };
})();

//createImageDock.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * <strong>createImageDock</strong> is an alias to method 
   * game.display.createImageDock()
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createImageDock
   * @param {Object} properties A generic object with properties used to construct an image dock.
   * @returns {Object} A new image dock object.
   */
	p.createImageDock = function Game_createImageDock( properties )
  {
    return this.display.createImageDock(properties);
	}
}());

//createImageLookup.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * <strong>createImageLookup()</strong> is a method 
   * used to create an image lookup. Generally used for
   * setting room background images.
   * The function takes one parameter: a generic 
   * object containing an array of image id/url pairs.
   * 
   * <pre class="display"><code class="language-javascript">MyGame.createImageLookup({
   *   images: [
   *     { id: "desert", image: "images/backgrounds/desert.jpg" },
   *     { id: "sea", image: "images/backgrounds/sea.jpg" },
   *     { id: "mountains", image: "images/backgrounds/mountains.jpg" },
   *     { id: "dungeon", image: "images/backgrounds/dungeon.jpg" },
   *     { id: "throneroom", image: "images/backgrounds/throneroom.jpg" },
   *   ],
   * });
   * </code></pre>
   * 
   * The image library is accessible at game.image_lookup.
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createImageLookup
   * @kind function
   * @param {Object} asset A generic object with properties to copy into the image library.
   * @returns {Object} A reference to the image lookup.
   */
	p.createImageLookup = function Game_createImageLookup( properties )
  {
    if(properties.images){
      for(var item in properties.images)
      {
        this.image_lookup[ properties.images[item].id ] = properties.images[item].image;
      }
    }
    return this.image_lookup;
	}  
}());

//createInventoryDock.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * <strong>createInventoryDock</strong> is an alias to method 
   * game.display.createInventoryDock()
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createInventoryDock
   * @param {Object} properties A generic object with properties used to construct an inventory dock.
   * @returns {Object} A new inventory dock object.
   */
	p.createInventoryDock = function Game_createInventoryDock( properties )
  {
    return this.display.createInventoryDock(properties);
	}
}());

//createVerbDock.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * <strong>createVerbDock</strong> is an alias to method 
   * game.display.createVerbDock()
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#createVerbDock
   * @param {Object} properties A generic object with properties used to construct the verb dock.
   * @returns {Object} A new verb dock object.
   */
	p.createVerbDock = function Game_createVerbDock( properties )
  {
    return this.display.createVerbDock(properties);
	}  
}());

// debug.js
(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Prep the supplied string for printing to the display.
   * @method adventurejs.Game#debug
   * @memberOf adventurejs.Game
   * @param {String} token
   */
  p.debug = function Game_print(msg) {
    if (!this.game.settings.print_debug_messages) return;
    if (!msg) return;

    let token_array = msg.split("|");
    if (token_array.length > 1) {
      for (var i = 0; i < token_array.length; i++) {
        token_array[i] =
          "<span class='debug_" + i + "'>" + token_array[i] + "</span>";
      }
      msg = token_array.join("");
    }
    msg = '<em class="debug">' + msg + "</em>";

    // send to display
    if (msg) this.display.print(msg);
  };
})();

// findSubstanceBodyOrHeld.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Find assets containing the specified substance.
   * @method adventurejs.Game#findSubstanceBodyOrHeld
   * @memberOf adventurejs.Game
   * @param {String} asset_id
   * @returns {Array}
   */
  p.findSubstanceBodyOrHeld = function Game_findSubstanceBodyOrHeld(asset_id) {
    this.game.log(
      "log",
      "high",
      "findSubstanceBodyOrHeld.js > received: " + asset_id,
      "Parser"
    );

    if (typeof asset_id !== "string") {
      // console.warn("findSubstanceBodyOrHeld received non-string", asset_id);
      return [];
    }

    var containers = this.game
      .findSubstanceContainers(asset_id, [
        "Present",
        "Known",
        "Visible",
        "BodyOfSubstance",
      ])
      .concat(
        this.game.findSubstanceContainers(asset_id, [
          "Present",
          "Known",
          "Visible",
          "InHands",
        ])
      );

    this.game.log(
      "log",
      "high",
      "findSubstanceBodyOrHeld.js > return: " + JSON.stringify(containers),
      "Parser"
    );
    return containers;
  };
})();

// findSubstanceContainers.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Find assets containing the specified substance.
   * @method adventurejs.Game#findSubstanceContainers
   * @memberOf adventurejs.Game
   * @param {String} asset_id
   * @param {Array} selects
   * @returns {Array}
   */
  p.findSubstanceContainers = function Game_getSubstanceContainers(
    asset_id,
    selects
  ) {
    this.game.log(
      "log",
      "high",
      "findSubstanceContainers.js > received: " + asset_id,
      "Parser"
    );

    if (typeof asset_id !== "string") {
      // console.warn("findSubstanceContainers received non-string", asset_id);
      return [];
    }

    var containers;
    if ("string" === typeof selects) selects = selects.split(" ");
    for (var i = 0; i < selects.length; i++) {
      containers = this.parser["select" + selects[i]](
        i == 0 ? asset_id : containers
      );
    }

    this.game.log(
      "log",
      "high",
      "findSubstanceContainers.js > return: " + containers,
      "Parser"
    );
    return containers;
  };
})();

// get.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * <strong>getAsset</strong> or shortcut <strong>get</strong>
   * takes a string representing an asset name or id and tries
   * to return an asset object.
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#getAsset
   * @param {String} identifier Name or ID of a game object.
   * @param {Object} params Used to check for 'prefer_substance' in cases of looking for substances in containers.
   * @returns {String} An object ID.
   */
  p.getAsset = p.$ = function Game_getAsset(identifier, params) {
    // did we get an asset?
    if (identifier && "object" === typeof identifier && identifier.id) {
      return identifier;
    }

    // did we get something other than a string?
    if ("string" !== typeof identifier) {
      this.game.log(
        "warn",
        "low",
        "Game_getAsset received invalid identifier. ",
        "Game"
      );
      return false;
    }

    if ("undefined" === typeof params) {
      params = {};
    }

    var object;

    // When parsing asset:aspect:substance we can set a parsednoun
    // to a string that looks like "bowl:in:water"
    // That's handled elsewhere - here we're only returning the last param
    var asset_aspect_substance = identifier.split(":"); // asset:aspect:substance
    switch (asset_aspect_substance.length) {
      case 3:
        if (
          "undefined" !== typeof params.prefer_substance &&
          true === params.prefer_substance
        ) {
          identifier = asset_aspect_substance[2];
        } else {
          identifier = asset_aspect_substance[0];
        }
        break;
      case 2:
        console.warn("game.getAsset received " + identifier);
        return null;
      default:
        break;
    }

    // what other special props might we want to return from here?

    if ("player" === identifier) {
      object = this.world.getPlayer();
    } else if ("currentRoom" === identifier) {
      object = this.world.getCurrentRoom();
    } else {
      object = this.world[A.serialize(identifier)];
    }

    if (typeof object !== "undefined") {
      return object;
    }

    return false;
  };
})();

// getCurrentRoom.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * Convenience method to get the current room asset. 
   * @method adventurejs.Game#getCurrentRoom
   * @memberOf adventurejs.Game
   * @returns {Object}
   */
   p.getCurrentRoom = p.$room = function Game_getCurrentRoom() 
  {
    return this.getAsset( this.world._currentRoom );
	}
	
}());

// getCurrentRoomExits.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   *
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#getCurrentRoomExits
   * @returns {String} A formatted list of exits.
   */
  p.getCurrentRoomExits = function Game_getCurrentRoomExits() {
    // loop through exits, which are nested objects
    // we need index/length to handle our punctuation logic
    // but we don't get that by enumerating properties
    // so instead we use object.keys
    var room = this.world[this.world._currentRoom];
    var exits = Object.keys(room.exits);
    var exitID, exit, destinationID, destination;
    var closed = [];
    var output = "";

    //console.log( exits );
    for (var i = exits.length - 1; i > -1; i--) {
      exitID = room.exits[exits[i]];
      exit = this.world[exitID]; // EtoS
      var destinationID = this.world[exit.destinationID];
      if ("undefined" === typeof destinationID) {
        exits.splice(i, 1);
      }
      if (exit.is.closed) {
        closed.push(exit);
        exits.splice(i, 1);
      }
    }

    if (!exits.length && !closed.length) {
      // no exits
      return false;
    }

    // this will need to be more sophisticated,
    // checking against visibility and knowledge
    if (exits.length) output += "$(We) can go ";

    for (var i = 0; i < exits.length; i++) {
      //console.log( "EXITS",this.world[ this.world._currentRoom ].exits[exits[i]].name );
      exitID = room.exits[exits[i]];
      exit = this.world[exitID];
      destination = this.world[exit.destinationID];

      // last item in the list
      if (exits.length > 1 && i === exits.length - 1) {
        output += "or ";
      }

      // depending on settings, we're going to want
      // a custom for_exits_list
      // just the direction name
      // or the direction name + name of destination
      var for_exits_list = A.getSAF.call(
        this.game,
        exit.descriptions.for_exits_list
      );

      if (for_exits_list) {
        output += `<span class="custom-exit-name">${for_exits_list}</span>`;
        //output += for_exits_list;
      } else {
        // get exit name and if logic permits,
        // also get preposition, article, destination name
        output += `<span class="extended-exit-name">${this.getExtendedExitName(
          exit,
          destination
        )}</span>`;
      } // else

      if (i === exits.length - 1) {
        output += ". ";
      } else {
        output += ", ";
      }
    }

    if (closed.length) {
      output += `${closed.length > 1 ? "Ways " : "A way "} `;
      for (var i = 0; i < closed.length; i++) {
        let lookup = this.game.dictionary.directionLookup[closed[i].direction];
        if (i > 0 && i < closed.length - 1) {
          output += ", ";
        }
        if (closed.length > 1 && i === closed.length - 1) {
          output += " and ";
        }
        if (i === 0 && lookup.article) output += `to ${lookup.article} `;
        output += closed[i].direction;
      }
      output += `${closed.length > 1 ? " are" : " is"} blocked. `;
    }

    return `<span class="room_exits">${output}</span>`;
  };
})();

// getCurrentRoomFloor.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Convenience method to get the current room's floor.
   * @method adventurejs.Game#getCurrentRoomFloor
   * @memberOf adventurejs.Game
   * @returns {Object}
   */
  p.getCurrentRoomFloor = function Game_getCurrentRoomFloor() {
    //return this.getAsset( this.world._currentRoom );
    var floor;
    var current_room = this.getCurrentRoom();
    var floors = current_room.findClassInThis("Floor");
    if (floors.length) {
      floor = this.game.getAsset(floors[0]);
    } // otherwise use the global floor
    else {
      floor = this.game.getAsset("global_floor");
    }
    return floor || null;
  };
})();

// getCustomSuccessMessage.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Check to see if an Asset has a custom success message for the specified verb.
   * @method adventurejs.Game#getCustomSuccessMessage
   * @memberOf adventurejs.Game
   * @param {Object} asset A game asset.
   * @param {String} verbName A verb name.
   * @returns {Boolean}
   */
  p.getCustomSuccessMessage = function Game_getCustomSuccessMessage(
    asset,
    verbName
  ) {
    if (!asset) return false;
    if ("string" !== typeof verbName) return false;
    if (asset.verb_success_hooks && asset.verb_success_hooks[verbName]) {
      var msg = A.getSAF.call(this.game, asset.verb_success_hooks[verbName]);
      if ("string" === typeof msg) {
        return msg;
      }
    }
    return false;
  };
})();

// getExitFromDirection.js

   (function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * Does current room have an exit in that direction?
   * If not use global exit.
   * Always applies to currentRoom.
   * If no exit found, returns false.
   * @method adventurejs.Game#getExitFromDirection
   * @memberOf adventurejs.Game
   * @param {String} direction
   * @returns {Object} An exit.
   */
   p.getExitFromDirection = function Game_getExitFromDirection( direction )
  {
    var exit = false;
    if( "undefined" !== typeof this.game.world[ this.game.world._currentRoom + "_" + direction ] ) 
    {
      exit = this.game.world[ this.game.world._currentRoom + "_" + direction ];
    } 
    else if( "undefined" !== typeof this.game.world[ "global_" + direction ] ) 
    {
      exit =  this.game.world[ "global_" + direction ];
    }
    return exit;
  }
  
}());

// getExtendedExitName.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * 
   * @method adventurejs.Game#getExtendedExitName
   * @memberOf adventurejs.Game
   * @param {Object} exit
   * @param {Object} destination
   * @returns {String}
   */
   p.getExtendedExitName = function Game_getExtendedExitName( exit, destination )
  {

    // add the direction
    var output = `<span class="exit-direction">${exit.direction}</span>`;

    var preposition = " to ";
    var definite_article = destination.definite_article;
    var destName = destination.name;//destination.name;
    var addDest = true;
    var currentRoom = this.game.getCurrentRoom();
    var settings = this.settings;

    // test conditions that may prevent printing destination

    if( false === settings.show_room_names_in_exit_descriptions
      || false === currentRoom.show_room_names_in_exit_descriptions ) 
      {
        addDest = false;
      }
  
    if( !destination.is.known
      && ( settings.show_room_names_in_exit_descriptions_only_when_room_is_known 
        || currentRoom.show_room_names_in_exit_descriptions_only_when_room_is_known ) ) 
        {
          addDest = false;
        }
    
    if( !exit.is.used
      && ( settings.show_room_names_in_exit_descriptions_only_after_exit_has_been_used 
        || currentRoom.show_room_names_in_exit_descriptions_only_after_exit_has_been_used ) ) 
        {
          addDest = false;
        }

    if (addDest) 
    {
      output += `${preposition} ${definite_article?definite_article+' ':''} 
        <span class="exit-destination">${destName}</span>`;
    }

    return output;
  }  
}());

// getGlobalAssetDescription.js

 (function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * <p>
   * Global assets are a bit (perhaps overly) complicated. 
   * They exist as singular objects in the game world, and 
   * they can be enabled/disabled and have their descriptions 
   * overridden per room and per zone. 
   * </p>
   * <p>
   * For example: <br/>
   * 
   * <li><code>MyGame.world.global_air</code> is an asset</li>
   * 
   * <li><code>MyGame.world.room.room_scenery.global_air</code>
   * is a simple object that can be used to determine whether 
   * a global asset is available in a given room. </li>
   * 
   * <li><code>MyGame.world.zone.zone_scenery.global_air</code>
   * is a simple object that can be used to determine whether 
   * a global asset is available in a given zone. </li>
   * 
	 * Though global asset is singular, its description can be 
	 * overridden by descriptions set in room_scenery and zone_scenery.
   * </p>
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#getGlobalAssetDescription
	 * @param {Object|String} asset
   * @returns {String} A description of the specified asset id.
   */
   p.getGlobalAssetDescription = function Game_getGlobalAssetDescription(asset, property )
  {
    //          defined  enabled  described
    //   room   _        _        _           all slots can be  
    //   zone   _        _        _           true, false, or
    // global   _        _        _           null/undefined

    // if defined is null we check next level
    // if defined is false at any stage we stop
    // if any level is enabled but not described, 
    //   try to get description from next level

    if("string" === typeof asset) asset = this.game.getAsset(asset);
    if( !(asset instanceof adventurejs.Asset ) ) return '';

    // property may be something other than 'description'
    // and while global asset may have multiple descriptions,
    // overrides likely only have one description 
    var defaultprop = 'description';
    if( "string" !== typeof property ) property = defaultprop;

    var currentRoom = this.game.getCurrentRoom();

		var defined_in_room;
		var enabled_in_room; // true, false, or null/undefined
		var described_in_room;

		var defined_in_zone;
		var enabled_in_zone; // true, false, or null/undefined
		var described_in_zone;

		var defined_in_game;
		var enabled_in_game; // true, false, or null/undefined
		var described_in_game;

    // get room settings
    defined_in_room = currentRoom.room_scenery[ asset.id ];
    if( "undefined" !== typeof defined_in_room )
    {
      enabled_in_room = defined_in_room.enabled; 
      described_in_room = defined_in_room[property] || defined_in_room[defaultprop];
    }

    // get zone settings
    if ( "undefined" !== typeof this.game.world[ currentRoom.zone ] ) 
    {
      defined_in_zone = this.game.world[ currentRoom.zone ].zone_scenery[ asset.id ];
    }
    if( defined_in_zone ) {
      enabled_in_zone = defined_in_zone.enabled;
      described_in_zone = defined_in_zone[property]||defined_in_zone[defaultprop];
    }

    // get global settings
    // no need to ask if undefined because we received the global asset
    enabled_in_game = asset.enabled;
    described_in_game = asset.descriptions[property]||asset.descriptions[defaultprop];

    //console.warn('enabled_in_room',enabled_in_room);
    //console.warn('enabled_in_zone',enabled_in_zone);
    //console.warn('enabled_in_game',enabled_in_game);

    // if room explicitly says no, exit
    if( false === enabled_in_room )
    {
      return '';
    }
    // if room explicitly says yes, use room or zone or global
    else if( true === enabled_in_room )
    {
      return( described_in_room || described_in_zone || described_in_game);
    }
    // if zone explicitly says no, exit
    else if( false === enabled_in_zone )
    {
      return '';
    }
    // if zone explicitly says yes, use zone or global
    else if( true === enabled_in_zone )
    {
      return( described_in_zone || described_in_game);
    }
    // if game explicitly says no, exit
    else if( false === enabled_in_game )
    {
      return '';
    }
    // if game explicitly says yes, use global
    else if( true === enabled_in_game )
    {
      return( described_in_game);
    }

    // ideally we never arrive here
		return '';
  }
  
}());

// getInput.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * Convenience method to get this turn's input. 
   * @method adventurejs.Game#getInput
   * @memberOf adventurejs.Game
   * @returns {Object}
   */
   p.getInput = p._input = function Game_getInput() 
  {
    return this.parser.input_history[ 0 ];
	}
	
}());

// getLastTurn.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * Convenience method to get this turn's input. 
   * @method adventurejs.Game#getLastTurn
   * @memberOf adventurejs.Game
   * @returns {Object}
   */
   p.getLastTurn = function Game_getLastTurn() 
  {
    return this.parser.input_history[ 1 ];
	}
	
}());

// getPlayer.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * Convenience method to get the player asset. 
   * @method adventurejs.Game#getPlayer
   * @memberOf adventurejs.Game
   * @returns {Object}
   */
   p.getPlayer = p.$player = function Game_getPlayer() 
  {
    return this.getAsset( this.world._player );
	}
	
}());

// getPrintableObjectList.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * 
   * @method adventurejs.Game#getPrintableObjectList
   * @memberOf adventurejs.Game
   * @param {Object} objects An array of object ID strings.
   * @param {Object} exclusions An array of of object ID strings to exclude.
   * @returns {String} A formatted string.
   */
   p.getPrintableObjectList = function Game_getPrintableObjectList( params ) 
  {
    this.game.log('log','high',"Tangible.js > "+this.id+" getPrintableObjectList", 'Tangible' );
		//console.log( "getPrintableObjectList", params.objects );
    var objects = params.objects;
    var exclusions = params.exclusions;
    var list = "";
    var definite = false;

    if( "undefined" !== typeof params.article 
    && "definite" === params.article ) 
    {
      definite = true;
    }

    // remove any exclusions from objects list
    if( "undefined" !== typeof exclusions ) 
    {
      // convert params string to array if needed
      if( "string" === typeof exclusions ) 
      {
        exclusions = [ exclusions ];
      }
      objects = objects.filter( 
        function(objects) 
        { 
          return exclusions.indexOf( objects ) < 0; 
        } 
      )
    }

    for( var i = 0; i < objects.length; i++ ) 
    {
      // objects is a list of ids - get the full object 
      var object = this.getAsset( objects[i] );

      object.setKnown();
      object.setSeen();

      if( i > 0 && i < objects.length - 1 ) 
      {
        list += ", ";
      }
      if( objects.length > 1 && i === objects.length-1 ) 
      {
        list += " and ";
      }
      list += definite?object.definite_name:object.indefinite_name;
      //list += " ";
      //list += object.name;
    }
	
		return list;
	}
	
}());

//getWordCount.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * <p>
   * <strong>getWordCount()</strong> is a utility method to get 
   * a count of all the unique words the game "knows".
   * </p>
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#getWordCount
   * @kind function
   * @returns {Array} 
   */
	p.getWordCount = function Game_getWordCount()
  {
    let unique_words = [];
    let keys = Object.keys(this.world_lookup);
    for( let index in keys )
    { 
      let key = keys[index];
      let words = key.split(" "); 
      for(let ind in words)
      { 
        let word = words[ind];
        if( -1 === word.indexOf('_')
          && -1 === unique_words.indexOf(word)) unique_words.push(word);
      } 
    } 

    keys = Object.keys(this.dictionary.verb_lookup);
    for( let index in keys )
    { 
      let word = keys[index];
      if(-1 === unique_words.indexOf(word)) unique_words.push(word);
      let sins = this.dictionary.verb_lookup[word].synonyms;
      for( let s in sins )
      {
        let sin = sins[s];
        if(-1 === unique_words.indexOf(sin)) unique_words.push(sin);
      }
    } 

    unique_words = unique_words.concat( this.dictionary.adjectives );
    unique_words = unique_words.concat( this.dictionary.adverbs );
    unique_words = unique_words.concat( this.dictionary.prepositions );

    return(unique_words); 
  }    
}());

//initializeAssets.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Initialize all game assets.
   * @method adventurejs.Game#initializeAssets
   * @memberOf adventurejs.Game
   */
  p.initializeAssets = function Game_initializeAssets() {
    for (var prop in this.world) {
      if ("_" === prop.charAt(0)) {
        continue;
      }

      // there's no good reason why there'd be
      // an undefined object, but, you know
      if ("undefined" === typeof this.world[prop].initialize) {
        console.warn(
          "initialize() not found on " +
            this.world[prop].constructor.name +
            " " +
            this.world[prop].name
        );
        return false;
      }
      var initializedProp = this.world[prop].initialize(this);
      if (!initializedProp) {
        console.warn(
          "Failed to initialize " +
            this.world[prop].constructor.name +
            " " +
            this.world[prop].name
        );
        return false;
      }
      this.world[prop].set({ is: { initialized: true } });
    }
    return true;
  };
})();

// listCurrentRoomContents.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   *
   * @method adventurejs.Game#listCurrentRoomContents
   * @memberOf adventurejs.Game
   * @param {Object} room
   * @returns {String}
   */
  p.listRoomContents = function Game_listRoomContents(room) {
    this.game.log("log", 1, "Game.listRoomContents", "Game");
    var roomContentsByID = A.clone.call(this.game, room.getAllContents()); // array of strings
    var listableObjects = [];
    var objectsWithListableContents = [];
    var objectsTiedToOtherThings = [];
    var output = "";

    // exclude player from list
    roomContentsByID.splice(roomContentsByID.indexOf(this.world._player), 1);

    // exclude exits from list ?

    // TODO needs to check against lighting and visibility

    for (i = roomContentsByID.length - 1; i > -1; i--) {
      object = this.game.getAsset(roomContentsByID[i]);
      //console.log( object );

      if (!object) {
        this.game.log(
          "warn",
          "critical",
          "listRoomContents found an undefined object in room " +
            room.name +
            ".",
          "Game"
        );
        continue;
      }

      if (object.is.hidden) {
        continue;
      }

      object.setKnown();
      object.setSeen();

      if (object.is.listed_in_room) {
        listableObjects.push(object);
      }

      if (object.hasListableContents()) {
        if (object.is.listed_in_room || object.is.unlisted_but_list_children) {
          objectsWithListableContents.push(object);
        }
      }
    } // for

    // if the list is empty return
    if (!listableObjects.length && !objectsWithListableContents.length) {
      return false;
    }

    if (0 < listableObjects.length) {
      output += "$(We) can see ";
    }

    for (var i = 0; i < listableObjects.length; i++) {
      var object = listableObjects[i];

      if (listableObjects.length > 1 && i === listableObjects.length - 1) {
        output += " and ";
      }

      output += object.indefinite_article;

      output += " ";

      var name = A.getSAF.call(this, object.name);
      /* TODO
          should check for descriptions.exits
          before defaulting to name

          2023.10.02 - is name a suitable field for getSAF?
      */

      if (object.print_bold) name = "<strong>" + name + "</strong>";
      if (object.print_italic) name = "<em>" + name + "</em>";
      output += name;

      if (object.dov.tie?.with_params.connections.length > 0) {
        objectsTiedToOtherThings.push(object);
        output +=
          " (tied to " +
          this.game.getPrintableObjectList({
            objects: object.dov.tie.with_params.connections,
          }) +
          ")";
      }

      if (i === listableObjects.length - 1) {
        output += " here. ";
      } else {
        output += ", ";
      }
    }

    if (objectsWithListableContents.length > 0) {
      //console.warn("objectsWithListableContents",objectsWithListableContents);
      for (var i = 0; i < objectsWithListableContents.length; i++) {
        output += objectsWithListableContents[i].getPrintableListOfContents({
          caller: "room",
        });
      }
    }

    return output;
  };
})();

//log.js
(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * Custom logging function.
   * @method adventurejs.Game#log
   * @memberOf adventurejs.Game
   * @param {String|Number} method 0=log, 1=warn, 2=error 
   * @param {String|Number} level 0=critical, 1=high, 2=medium, 3=low
   * @param {*} msg Message for console.
   */
	p.log = function Game_log( method, level, msg, keyword )
  {
    // no logging below 0
    if( 0 > this.game.settings.log_level ) 
    {
      return;
    }
    
    if( "string" !== typeof keyword ) keyword = "";

    // exclude keywords that haven't been included
    if( method==="log" && true !== this.game.settings.log_keywords[ keyword.toLowerCase() ] )
    {
      return;
    }

    // don't log above current level
    var levels = [ "critical", "high", "medium", "low" ];
    if( "string" === typeof level )
    {
      level = levels.indexOf( level );
    }
    if( level > this.game.settings.log_level ) 
    {
      return;
    }

    var methods = [ "log", "warn", "error" ];
    if( "undefined" === typeof method 
    || null === method ) 
    {
      method = "log";
    }
    if( "number" === typeof method ) 
    {
      method = methods[ method ];
    }

    if( Array.isArray( msg ) ) 
    {
      msg = msg.join(" ");
    }

    var warnOrErr = "";
    var style = 'background: #36e400; font-weight:bold; color: #2b2b2b;padding:1px;margin-right:3px;';
    if(method === "warn") {
      warnOrErr = "warning";
      style='background: #e5d254; font-weight:bold; color: #493c35;margin-right:3px;';
    }
    else if(method === "error") {
      warnOrErr = "error";
      style='background: #ef866d; font-weight:bold; color: #4a3532;margin-right:3px;';
    }
    if( "undefined" !== typeof console[ method ] ) 
    {
      console[ method ]( 
        "%c ajs " + "%c " + msg,
        style, 
        ''
      );
      if( level <= this.game.settings.log_trace_level ) 
      { 
        console.groupCollapsed("Trace..."); 
        console.trace(); 
        console.groupEnd(); 
      }
    }
				
		return;
	}  
}());

// play.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Validate and initialize all classed game objects in world.
   * Validation is internal to each object.
   * Initialization draws connections to other objects.
   * @method adventurejs.Game#play
   * @memberOf adventurejs.Game
   * @returns adventurejs.Game
   */
  p.play = function Game_play() {
    var startPlayTime = new Date().getTime();
    this.game.log("log", 1, "Game.play().", "Game");
    this.game.log("log", 1, "Game.play > Validating objects.", "Game");

    this.game_state = this.game_states.validateAssets;
    if (!this.validateAssets()) {
      return false;
    }

    this.game.log("log", 1, "Game.play > Creating deferred objects.", "Game");
    this.game_state = this.game_states.createDeferredAssets;
    if (!this.createDeferredAssets()) {
      return false;
    }

    this.game.log("log", 1, "Game.play > Initializing objects.", "Game");
    this.game_state = this.game_states.initializeAssets;
    if (!this.initializeAssets()) {
      return false;
    }

    this.game.log("log", 1, "Game.play > Sorting lookup values.", "Game");
    this.game_state = this.game_states.sortLookupValues;
    this.sortLookupValues();

    this.game_state = this.game_states.worldSetDefaultAssets;
    // if no rooms were created, create one
    if (0 === this.room_lookup.length) {
      this.createAsset({
        class: "Room",
        name: "Empty Room",
        descriptions: {
          look: "The emptiest room $(we've) ever seen.",
          brief: "The emptiest room ever.",
          verbose: "This is, by far, the emptiest room $(we've) ever seen.",
        },
      });
      this.game.world.empty_room.validate();
      this.game.world.empty_room.initialize();
    }

    // if no players were created, create one
    if (!this.world._player) {
      this.createAsset({
        class: "Player",
        name: "Unnamed Hero",
        is: { active: true },
        place: { in: this.room_lookup[0] },
      });
      this.game.world.unnamed_hero.validate();
      this.game.world.unnamed_hero.initialize();
    }

    this.game_state = this.game_states.setPlayerRoom;
    var player = this.getPlayer();
    var startRoom = player.getPlaceAsset();
    var params = {};
    player.is.active = true;
    if (player.isNested()) {
      var nestprep = player.getNestPreposition();
      var nestobject = player.getNestAsset();
      params.nestobject = nestobject;
      params.nestprep = nestprep;
    }
    if (!startRoom) startRoom = this.getAsset(this.room_lookup[0]);
    this.setPlayerRoom(startRoom, params);
    this.updateDisplayInventory();

    this.scorecard.updateScore();

    this.game_state = this.game_states.worldSaveBaseline;

    // save baseline world for later comparisons

    // this.baseline.world = A.cloneWorld.call(this, this.world);
    this.baseline.world = A.clone.call(this, this.world);
    // @TODO cloneWorld is a specialized function but I don't remember
    // specifically why it was useful vs...
    // my generic clone function, which seems to work ok and much faster

    this.game.log(
      "log",
      "high",
      `Game.play > READY! Startup took 
      ${(new Date().getTime() - startPlayTime) / 1000} seconds.`,
      "Game"
    );

    //this.game.display.inputEl.focus();

    this.game_state = this.game_states.playing;

    return this;
  };
})();

// print.js
(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Prep the supplied string for printing to the display.
   * @method adventurejs.Game#print
   * @memberOf adventurejs.Game
   * @param {String} msg
   * @param {String} classes
   */
  p.print = function Game_print(msg, classes) {
    if ("undefined" === typeof msg) msg = "";
    if ("undefined" === typeof classes) classes = "";

    /**
     * Extra output can be conditionally prepended/appended by sub functions,
     * like background events such as running water, or by custom code
     * from author.
     * If any prepended/appended output is found, print it, then move it,
     * to ensure it doesn't get printed again, while still
     * keeping a record of it.
     */

    if (this.input?.printer?.override.length) {
      msg = this.input.printer.override.join(" ");
      //reset override
      this.input.printer.overriden = this.input.printer.overriden.concat(
        this.input.printer.override
      );
      this.input.printer.override = [];
    }

    if (this.input?.printer?.prepend.length) {
      msg = this.input.printer.prepend.join(" ") + msg;
      this.input.printer.prepended = this.input.printer.prepended.concat(
        this.input.printer.prepend
      );
      this.input.printer.prepend = [];
    }

    if (this.input?.printer?.append.length) {
      msg += this.input.printer.append.join(" ");
      this.input.printer.appended = this.input.printer.appended.concat(
        this.input.printer.appended
      );
      this.input.printer.append = [];
    }

    if (!msg) return;
    // condense multiple spaces
    msg = msg.replace(/  +/g, " ");

    // expand compressed prepositions
    // and hope noone uses "fromin" as an asset name?
    msg = msg.replace(/ outfrombehind /g, " out from behind ");
    msg = msg.replace(/ outfromunder /g, " out from under ");
    msg = msg.replace(/ infront /g, " in front ");
    msg = msg.replace(/ frombehind /g, " from behind ");
    msg = msg.replace(/ fromin /g, " from in ");
    msg = msg.replace(/ fromon /g, " from on ");
    msg = msg.replace(/ fromunder /g, " fromunder ");

    this.game.log("log", "high", msg, "Print");
    msg = A.substituteCustomTemplates.call(this, msg);
    msg = A.substituteHTMLTags.call(this, msg);
    // send to display
    if (msg) this.display.print(msg, classes);
  };
})();

// printCurrentRoom.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Print room description to game display.
   * Includes input, room name, and room description.
   * Calling the function with params.verbose set to true
   * will override global verbosity settings and try to
   * print a verbose description.
   * <br><br>
   * For example:
   * <pre class="code">printCurrentRoom( { verbose: true } )</pre>
   * @method adventurejs.Game#printCurrentRoom
   * @memberOf adventurejs.Game
   * @param {Object} params
   * @todo Formalize handling for description/brief/verbose descriptions
   */
  p.printCurrentRoom = function Game_printCurrentRoom(
    params = { verbose: false }
  ) {
    this.game.log("log", 1, "Game.printCurrentRoom", "Game");
    // if( "undefined" === typeof params ) params = {};
    // if( "undefined" === typeof params.verbose ) params.verbose = false;
    var currentRoom = this.world[this.world._currentRoom];
    var desc = "description";
    var v = this.settings.verbosity;

    // first print room name
    this.print(currentRoom.name, "room_name");

    // first visit or params.verbose=true used by look / examine
    if (
      params.verbose ||
      (!currentRoom.is.seen &&
        this.settings.print_verbose_room_descriptions_on_first_visit)
    ) {
      v = 1;
    }

    // try to choose a description based on verbosity setting
    // ensure that author has written something
    if (1 === v && !currentRoom.descriptions.verbose) v = 0;
    if (-2 === v && !currentRoom.descriptions.briefer) v = -1;
    if (-1 === v && !currentRoom.descriptions.brief) v = 0;
    switch (v) {
      case -2:
        desc = "briefer";
        break;
      case -1:
        desc = "brief";
        break;
      case 1:
        desc = "verbose";
        break;
      default:
        desc = "look";
        break;
    }
    if (!currentRoom.descriptions[desc]) desc = "look";

    this.print(
      A.getSAF.call(this, currentRoom.descriptions[desc], currentRoom),
      "room_description"
    );
    this.printCurrentRoomExits();
    this.printCurrentRoomContents();

    return this;
  };
})();

// printCurrentRoomContents.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * 
   * @method adventurejs.Game#printCurrentRoomContents
   * @memberOf adventurejs.Game
   */
   p.printCurrentRoomContents = function Game_printCurrentRoomContents(){
    this.game.log( "log", 1, "Game.printCurrentRoomContents", 'Game' );
		var contents = this.listRoomContents( this.world[ this.world._currentRoom ] );
		if( contents ) this.print( contents );			
		return true;
	}
  
}());

// printCurrentRoomExits.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * 
   * @method adventurejs.Game#printCurrentRoomExits
   * @memberOf adventurejs.Game
   */
   p.printCurrentRoomExits = p._printExits = function Game_printCurrentRoomExits(){
		var exits = this.getCurrentRoomExits();
		if( exits ) this.print( exits );
		return true;
	}
  
}());

// printInput.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * 
   * @method adventurejs.Game#printInput
   * @memberOf adventurejs.Game
   * @param {String} input
   */
   p.printInput = function Game_printInput( input) {
		this.display.printInput(input);
	}
  
}());

// printPlayerInventory.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   *
   * @method adventurejs.Game#printPlayerInventory
   * @memberOf adventurejs.Game
   */
  p.printPlayerInventory = function Game_printPlayerInventory() {
    //this.print( this.world[this.world._player].getPrintableListOfContentsAt("in") );
    var player = this.game.getPlayer();
    var nest_preposition = player.getNestPreposition();
    var nest_parent_id = player.getNestId();
    var nest_parent_object = player.getNestAsset();

    var output = "";
    var carried = [];
    var openCarried = [];
    var worn = [];
    var riding = [];
    var holding = [];
    var carriedtied = [];
    var holdingtied = [];
    var handsempty = true;

    var contents = player.aspects.in.contents;
    var holding = player.IOVgetConnections();

    if (0 === contents.length) {
      output += "$(We're) not carrying anything. ";
    }

    for (var i = 0; i < contents.length; i++) {
      // list worn, ridden, and carried objects separately

      // worn
      if (this.game.getAsset(contents[i]).is.worn) {
        worn.push(contents[i]);
      }

      // ridden
      else if (
        this.game.getAsset(contents[i]).is.rideable &&
        contents[i] === nest_parent_id
      ) {
        riding.push(contents[i]);
      }

      // carried
      else {
        carried.push(contents[i]);
      }
    }

    // it shouldn't be possible to ride more than one thing
    // but we're gonna cover the bases
    if (0 < riding.length) {
      for (var i = 0; i < riding.length; i++) {
        var object = this.game.getAsset(riding[i]);
        output +=
          "$(We're) " +
          player.getPostureGerund() +
          " " +
          nest_preposition +
          " " +
          object.articlename +
          ". ";
      }
    }

    if (0 < carried.length) {
      handsempty = false;
      output += "$(We're) carrying ";
      for (var i = 0; i < carried.length; i++) {
        var object = this.game.getAsset(carried[i]);

        if (
          object.hasAspectAt("in") &&
          object.aspects.in.contents.length > 0 &&
          false === object.is.closed
        ) {
          openCarried.push(object.id);
        }

        if (object.dov.tie?.with_params.connections.length > 0) {
          carriedtied.push(object.id);
        }
      }
      output += this.game.getPrintableObjectList({ objects: carried });
      output += ". ";
    }
    if (0 < carriedtied.length) {
      for (var i = 0; i < carriedtied.length; i++) {
        var object = this.game.getAsset(carriedtied[i]);
        output += object.Articlename + " $(we're) carrying is tied to ";
        output += this.game.getPrintableObjectList({
          objects: object.dov.tie.with_params.connections,
          article: "definite",
        });
        output += ". ";
      }
    }

    if (0 < holding.length) {
      for (var i = 0; i < holding.length; i++) {
        var object = this.game.getAsset(holding[i]);
        if (object.dov.tie?.with_params.connections.length > 0) {
          holdingtied.push(object.id);
        }
      }
      handsempty = false;
      output += "$(We're) holding ";
      output += this.game.getPrintableObjectList({
        objects: holding,
      });
      output += ". ";
    }

    if (0 < holdingtied.length) {
      for (var i = 0; i < holdingtied.length; i++) {
        var object = this.game.getAsset(holdingtied[i]);
        output += object.Articlename + " $(we're) holding is tied to ";
        output += this.game.getPrintableObjectList({
          objects: object.dov.tie?.with_params.connections,
          article: "definite",
        });
        output += ". ";
      }
    }

    if (handsempty) {
      output += "$(Our) hands are empty. ";
    }

    if (openCarried.length > 0) {
      for (var i = 0; i < openCarried.length; i++) {
        var object = this.game.getAsset(openCarried[i]);
        output += object.Articlename + " $(we're) carrying contains ";
        output += this.game.getPrintableObjectList({
          objects: object.aspects.in.contents,
        });
        output += ". ";
      }
    }

    if (worn.length > 0) {
      output += "$(We're) wearing ";
      for (var i = 0; i < worn.length; i++) {
        var object = this.game.getAsset(worn[i]);
        object.setKnown();
        object.setSeen();

        if (worn.length > 1 && i === worn.length - 1) {
          output += " and ";
        }
        output += object.indefinite_article;
        output += " ";
        output += object.name;
        if (object.is.closed) {
          output += ", which is closed";
        }
        if (
          object.isDOV("close") &&
          object.hasAspectAt("in") &&
          object.aspects.in.contents.length > 0
        ) {
          output += ", which contains ";
          output += this.game.getPrintableObjectList({
            objects: object.aspects.in.contents,
          });
        }

        if (i === worn.length - 1) {
          output += ". ";
        }
        if (i !== worn.length - 1 && worn.length > 2) {
          output += ", ";
        }
      }
    }

    //"In the x you see..."

    //"You're wearing..."

    //"In the x you see..."

    this.print(output);
    return;
  };
})();

// printRoomZoneEvents.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   *
   * @method adventurejs.Game#printRoomZoneEvents
   * @memberOf adventurejs.Game
   */
  p.printRoomZoneEvents = function Game_printRoomZoneEvents(e) {
    this.game.log("log", "low", "printRoomZoneEvents", "Game");
    if (this.game.getInput().soft_prompt.enabled) return;
    if (this.game.getInput().disambiguate.enabled) return;
    var currentRoom = this.game.getCurrentRoom();
    var room_events;
    var msg = "";
    var source;

    // scenery events disabled
    if (false === this.game.settings.enable_events) {
      return;
    }

    // does currentRoom have scenery events?
    if ("undefined" !== typeof currentRoom.room_events) {
      source = currentRoom.id + ".room_events";
      room_events = currentRoom.room_events;
    }

    // or does it have a zone
    else if (
      "undefined" !== typeof currentRoom.zone &&
      "undefined" !== typeof this.game.world[currentRoom.zone] &&
      "undefined" !== typeof this.game.world[currentRoom.zone].zone_events
    ) {
      source = currentRoom.id + ".zone.zone_events";
      room_events = this.game.world[currentRoom.zone].zone_events;
    }

    // we got some events
    if ("undefined" !== typeof room_events) {
      // ensure that we have randomize setting
      if ("undefined" === typeof room_events[0].randomize) {
        room_events[0].randomize =
          this.game.settings.randomize_arrays_in_getStringOrArrayOrFunction;
      }
      // ensure that we have index
      if ("undefined" === typeof room_events[0].index) {
        room_events[0].index = 0;
      }

      // ensure that we have frequency setting
      if ("undefined" === typeof room_events[0].frequency) {
        room_events[0].frequency = 1;
      }

      // if frequency is less than 1, roll for event
      // if we roll over frequency, bail out
      if (1 > room_events[0].frequency) {
        var rand = Math.random(1);
        if (rand > room_events[0].frequency) return;
      }

      source += ", randomize " + room_events[0].randomize;
      source += ", index " + room_events[0].index;
      source += ", frequency " + room_events[0].frequency;
      this.game.debug(
        `F1132 | printRoomZoneEvents.js |found zone events in ${source}`
      );
      msg += A.getSAF.call(this.game, room_events);
      if (msg) this.game.print(msg);
      return;
    }
  };
})();

// printWithInput.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * 
   * @method adventurejs.Game#printWithInput
   * @memberOf adventurejs.Game
   * @param {String} msg
   * @param {String} classes
   */
   p.printWithInput = function Game_printWithInput( msg, classes ) 
  {
		this.display.printWithInput( msg, classes );
	}
  
}());

// set.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * This is a shallow copy for setting global properties on
   * the main game object. Returns the game object for chaining.
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#set
	 * @param {Object} props A generic object containing properties to copy to the Game instance.
	 * @returns {adventurejs.Game} Returns the instance the method is called on (useful for chaining calls.)
	 * @chainable
   */
   p.set = function Game_set(props) {
		if (props != null) {
			for (var n in props) { this[n] = props[n]; }
		}
		return this;
	};  
}());

//setGlobalDescriptions.js

(function() {
  /*global adventurejs A*/ 
  "use strict";

	var p = adventurejs.Game.prototype;

  /**
   * A method to let author set default descriptions for global 
   * objects such as sun, moon, sky, floor, walls.
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#setGlobalDescriptions
   * @kind function
   * @param {Object} globals A list of globle Scenery Assets.
   */
   p.setGlobalDescriptions = function Game_setGlobalDescriptions( globals )
  {
    //console.warn( globals );

    var globalsKeys = Object.keys( globals );
    for( var i = 0; i < globalsKeys.length; i++ ) 
    {
      var id = globalsKeys[i];
      var global_precursor = globals[ id ];
      var global_asset = this.game.world[ id ];

      if( "undefined" === typeof global_asset )
      {
        var see = "See adventurejs.Game#setGlobalDescriptions for info about setting global descriptions. ";
        var msg = "setGlobalDescriptions received an id for which there is no global object. ";
        this.game.log("warn","critical",msg + see, 'Game' );
        continue; // @todo make new global?
      }

      var description;
      if( global_precursor.descriptions
      && global_precursor.descriptions.look )
      {
        description = global_precursor.descriptions.look;
      }
      else if ( global_precursor.description )
      {
        description = global_precursor.description;
      }
      else
      {
        description = "";
      }

      var enabled = global_precursor.enabled;

      //id = "global_" + id;

      if( "undefined" !== typeof global_asset )
      {
        global_asset.descriptions.look = description;
        global_asset.enabled = enabled;
      }
    }

    return this;
  }
    
}());

// setPlayerRoom.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Move player to the specified room.
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#setPlayerRoom
   * @param {Object} newRoom A room object to which to move player.
   * @param {Object} params
   */
  p.setPlayerRoom = function Game_setPlayerRoom(newRoom, params) {
    this.game.log("log", "high", "setPlayerRoom.js > " + newRoom.name, "Game");

    var output_class = "";
    if (
      "undefined" !== typeof params &&
      "undefined" !== typeof params.output_class
    ) {
      output_class = params.output_class;
    }

    var currentRoomID = this.world._currentRoom;
    var currentRoomObj = this.world[currentRoomID];
    var player = this.getPlayer();
    var nest_parent_object = player.getNestAsset();
    var results, msg;
    if (player.has_tied_things_that_drag_on_travel) {
      var dragged_things = player.getTiedThingsThatDragOnTravel();
    }

    //console.warn( "dragged_things",dragged_things);

    // old room can take action on exit
    if (
      "" !== currentRoomID &&
      "undefined" !== typeof currentRoomObj &&
      "undefined" !== Object.keys(currentRoomObj) &&
      0 < Object.keys(currentRoomObj).length
    ) {
      // remove player id string from old room's inventory
      results = currentRoomObj.onRemoveThatFromThis(player); // string
      if ("undefined" !== typeof results) return results;

      if (player.isNested() && nest_parent_object.is.rideable) {
        // did away with the need for this by moving
        // simple vehicles into player inventory
        // but leaving the check for other potential uses
        // results = currentRoomObj.onRemoveThatFromThis( nest_parent_object );
        // if( false === results ) { return false; }
        // else if ( null === results ) { return null; }
      }

      // if player is dragging anything at the end of a rope,
      // its parent, whether room or thing, can act on it too
      if ("undefined" !== typeof dragged_things) {
        for (var i = 0; i < dragged_things.length; i++) {
          var dragged_thing = this.game.getAsset(dragged_things[i]);
          //console.warn( "dragged_thing",dragged_thing );
          //console.warn( "dragged_thing.getPlaceAsset()",dragged_thing.getPlaceAsset() );
          results = dragged_thing
            .getPlaceAsset()
            .onRemoveThatFromThis(dragged_thing);
          if ("undefined" !== typeof results) return results;
        }
      }
    }

    // set player's location to new room id string
    // add player ID string to new room's inventory
    results = newRoom.onMoveThatToThis(player, "in"); // string
    if ("undefined" !== typeof results) return results;

    // reset player's coordinates, in case player had to do something
    // like climb a ladder to reach this room
    // TODO flying? zero-G? underwater?
    player.position = Object.assign(
      player.position,
      newRoom.aspects.in.player.initial_position
    );

    if (player.isNested() && nest_parent_object.is.rideable) {
      // did away with the need for this by moving
      // simple vehicles into player inventory
      // but leaving the check for other potential uses
      // results = newRoom.onMoveThatToThis( nest_parent_object, "in" ); // string
      // if( false === results ) { return false; }
      // else if ( null === results ) { return null; }
    }

    // if player is dragging anything at the end of a rope,
    // new room can act on that too
    if ("undefined" !== typeof dragged_things) {
      for (var i = 0; i < dragged_things.length; i++) {
        var dragged_thing = this.game.getAsset(dragged_things[i]);
        results = newRoom.onMoveThatToThis(dragged_thing, "in");
        if ("undefined" !== typeof results) return results;
      }
    }

    // set new room
    this.world._currentRoom = newRoom.id; // string

    if (
      "undefined" !== typeof params &&
      "undefined" !== typeof params.nestobject &&
      "undefined" !== typeof params.nestprep
    ) {
      results = player.onNestThisToThat(params.nestobject, params.nestprep);
      if (A.isFalseOrNull(results)) {
        this.game.log(
          "error",
          "high",
          "Game.play > setPlayerRoom > onNestThisToThat failed to nest player in " +
            params.nestobject.id +
            ". ",
          "Game"
        );
      }
    }
    this.updateDisplayRoom();
    this.updateDisplayCompasses();

    var directions = Object.keys(newRoom.exits);
    for (var i = 0; i < directions.length; i++) {
      var exit = this.getAsset(newRoom.id + "_" + directions[i]);
      exit.setKnown();
      exit.setSeen();
    }

    // parsed input can be set excludeRoomDescriptions
    // at the moment "go to" is the only invoker
    if (
      "undefined" !== typeof this.parser.input_queue[0] &&
      "undefined" !==
        typeof this.parser.input_queue[0].excludeRoomDescriptions &&
      this.parser.input_queue[0].excludeRoomDescriptions
    ) {
      return;
    }

    if ("undefined" !== typeof dragged_things) {
      for (var i = 0; i < dragged_things.length; i++) {
        var dragged_thing = this.game.getAsset(dragged_things[i]);
        var rope_asset = dragged_thing.getThingThisIsTiedToPlayerBy();
        msg = "$(We) drag " + dragged_thing.articlename + " along";
        if ("undefined" !== typeof rope_asset) {
          msg += " at the end of " + rope_asset.articlename;
        }
        msg += ". ";
      }
    }

    // print input, room name, room description
    if (msg) this.game.print(msg, output_class);
    this.printCurrentRoom();
  };
})();

// sortLookupValues.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Sort lookupTable values that contain multiple IDs.
   * @method adventurejs.Game#sortLookupValues
   * @memberOf adventurejs.Game
   */
  p.sortLookupValues = function Game_sortLookupValues() {
    // sort entries within table
    for (var prop in this.game.world_lookup) {
      var lookupValue = this.game.world_lookup[prop].IDs;

      /**
       * Lookup prop contains multiple values.
       * We need them sorted by longest to shortest word count.
       *
       * Ex:
       * world_lookup["brass_key"]: ["brass_key", "melted_brass_key", "broken_brass_key"]
       *
       *
       * During gameplay we run combineCompoundPhrases on user input,
       * so for example we're comparing "melted brass key" we don't want
       * to find "brass key" first which would leave "melted" orphaned.
       *
       */
      if (lookupValue.length > 1) {
        // sort it by word count from high to low
        var sortedLookupValues = [];

        // first get the longest word count
        var wordCount = 0;
        for (var i = 0; i < lookupValue.length; i++) {
          var length = lookupValue[i].split("_").length;
          if (length > wordCount) {
            wordCount = length;
          }
        }

        // now loop down from longest to shortest
        for (var w = wordCount; w > 0; w--) {
          // and check each item to see
          // if it matches current word count
          for (var i = 0; i < lookupValue.length; i++) {
            var length = lookupValue[i].split("_").length;

            if (length === w) {
              // if this item's word count matches current w
              // add this item to new sorted array
              sortedLookupValues.push(lookupValue[i]);
            }
          }
        }

        // write the sorted array back to the lookup table
        this.game.world_lookup[prop].IDs = sortedLookupValues;
      }
    }
  };
})();

// tryTravel.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Tries to move the player in the specified direction.
   * @memberOf adventurejs.Game
   * @method adventurejs.Game#tryTravel
   * @param {String} direction
   * @param {Object} params
   */
  p.tryTravel = function Game_tryTravel(direction, params) {
    this.game.log("log", "high", "tryTravel.js > " + direction, "Travel");
    var input = this.game.getInput();
    var currentRoom = this.getCurrentRoom();
    var player = this.game.getPlayer();
    var nest_parent_object = player.getNestAsset();
    var nest_preposition = player.getNestPreposition();
    var exitID = currentRoom.exits[direction]; // may be no exit
    var msg = "";
    var results;
    if ("undefined" === typeof params) params = {};

    // TODO: constraint message
    if (player.is.constrained) {
      this.game.debug(`F1103 | tryTravel.js |player.is.constrained`);
      msg +=
        A.getSAF.call(this.game, player.constrained_msg) ||
        "$(We) can't go anywhere. ";
      if (msg) this.game.print(msg, input.output_class);
      return null;
    }

    // player is holding something like a rope or a railing
    if (player.IOVgetConnectionCount("hold") > 0) {
      this.game.debug(
        `F1133 | tryTravel.js | ${player.id}.iov.hold.with_params.connections.length is ${player.iov.hold.with_params.connections.length}`
      );
      msg += `$(We'll) have to let go of ${this.game.getPrintableObjectList({
        objects: player.IOVgetConnections("hold"),
      })}. `;
      if (msg) this.game.print(msg, input.output_class);
      return null;
    }

    // is player nested in something?
    if (player.isNested()) {
      // by default, can't reach an exit while nested
      // but there are exceptions
      var canReach = false;
      var reachableThings;

      if (nest_parent_object.is.rideable) {
        canReach = true;
      }

      // is player nested behind/in/on/under something
      // that can reach this direction?
      if (nest_parent_object.hasAspectAt(nest_preposition)) {
        reachableThings =
          nest_parent_object.aspects[nest_preposition]
            .things_player_can_reach_from_this_aspect;
        // @todo this no longer works - need to call canPlayerReach( direction )
        if (-1 < reachableThings.indexOf(direction)) {
          canReach = true;
        }
      }

      // is player nested on top of something that can reach this direction?
      if (!canReach && player.isNestedOnTop()) {
        // try the convenience prop first
        reachableThings =
          nest_parent_object.things_player_can_reach_from_top_of_this;
        if (true === A.isIdInMixedArray(direction, reachableThings))
          canReach = true;
        // if not, try the aspect positions
        if (!canReach) {
          reachableThings =
            nest_parent_object.aspects[nest_preposition]
              .things_player_can_reach_from_positions_of_this_aspect.top;
          if (true === A.isIdInMixedArray(direction, reachableThings))
            canReach = true;
        }
      }

      // is player nested on bottom of something that can reach this direction?
      if (!canReach && player.isNestedOnBottom()) {
        // try the convenience prop first
        reachableThings =
          nest_parent_object.things_player_can_reach_from_bottom_of_this;
        if (true === A.isIdInMixedArray(direction, reachableThings))
          canReach = true;
        // if not, try the aspect positions
        if (!canReach) {
          reachableThings =
            nest_parent_object.aspects[nest_preposition]
              .things_player_can_reach_from_positions_of_this_aspect.bottom;
          if (true === A.isIdInMixedArray(direction, reachableThings))
            canReach = true;
        }
      }

      if (false === canReach) {
        this.game.debug(
          `F1134 | tryTravel.js | ${direction} is unreachable from ${nest_preposition} ${nest_parent_object.id}`
        );
        msg += `$(We'll) have to get ${player.getPrettyUnnestPreposition()} ${
          nest_parent_object.articlename
        } first. `;
        if (msg) this.game.print(msg, input.output_class);
        return null;
      }
    }

    // does this room have an exit in the specified direction?
    if ("undefined" === typeof exitID) {
      this.game.debug(`F1115 | tryTravel.js |exitID is undefined`);

      //var directionObject = this.game.world[ "global_" + direction ];
      var direct_object = this.game.world["global_" + direction];

      // console.warn( "global!" );
      // console.warn( direct_object.id );
      var global_description;
      var currentRoom_scenery_object =
        currentRoom.room_scenery[direct_object.id];
      var currentRoomZone = this.game.world[currentRoom.zone];
      var currentRoomZone_scenery_object;
      if ("undefined" !== typeof currentRoomZone) {
        currentRoomZone_scenery_object =
          currentRoomZone.zone_scenery[direct_object.id];
      }

      // try to get current room's scenery settings
      // description can be left undefined
      if (
        "undefined" !== typeof currentRoom_scenery_object &&
        true === currentRoom_scenery_object.enabled &&
        "undefined" !== typeof currentRoom_scenery_object.description
      ) {
        // console.warn( "USE CURRENT ROOM SCENERY OBJECT DESCRIPTION" );
        this.game.debug(
          `F1116 | tryTravel.js |use room.room_scenery description for ${currentRoom.id}.room_scenery.${direct_object.id}`
        );
        global_description = currentRoom_scenery_object.description;
      }

      // otherwise try to get current room's zone scenery settings
      else if (
        "undefined" !== typeof currentRoomZone &&
        "undefined" !== typeof currentRoomZone_scenery_object &&
        true === currentRoomZone_scenery_object.enabled &&
        "undefined" !== typeof currentRoomZone_scenery_object.description
      ) {
        this.game.debug(
          `F1117 | tryTravel.js |use room.zone.zone_scenery description for ${currentRoom.zone}.zone_scenery.${direct_object.id}`
        );
        // console.warn( "USE CURRENT ROOM ZONE SCENERY OBJECT DESCRIPTION" );
        global_description = currentRoomZone_scenery_object.description;
      }

      // otherwise if room enables object,
      // try to get object's native (aka global) description
      else if (
        "undefined" !== typeof currentRoom_scenery_object &&
        true === currentRoom_scenery_object.enabled &&
        "undefined" !== typeof direct_object.description
      ) {
        this.game.debug(
          `F1118 | tryTravel.js |use room.room_scenery description for ${direct_object.id}.description`
        );
        // console.warn( "USE GLOBAL ASSET DESCRIPTION" );
        global_description = direct_object.description;
      }

      if ("undefined" !== typeof global_description) {
        msg += A.getSAF.call(this.game, global_description);
      }

      if (
        this.settings.when_travel_fails_list_exits ||
        this.world[this.world._currentRoom].when_travel_fails_list_exits
      ) {
        this.game.debug(
          `F1120 | tryTravel.js | ${this.game_name}.settings.when_travel_fails_list_exits or ${currentRoom.id}.when_travel_fails_list_exits`
        );
        var exits = this.getCurrentRoomExits();
        if (exits) msg += " " + exits;
      }
      this.print(msg, input.output_class);
      return;
    }

    // ok we think there's an exit
    var exit = this.world[exitID];
    this.game.log(
      "log",
      "high",
      "tryTravel.js > found exit: ",
      exit.id,
      "Travel"
    );

    // is there actually an exit object?
    if ("undefined" === typeof exit) {
      this.game.debug(`F1104 | tryTravel.js |no exit found matching ${exitID}`);
      msg += `That doesn't appear to be an exit. `;
      this.print(msg, input.output_class);
      return;
    }

    if ("undefined" !== typeof exit.aperture && "" !== exit.aperture) {
      var aperture = this.game.world[exit.aperture];
      var key_assets;
      var locked_msg = `${aperture.Articlename} is closed and locked. `;
      var sealed_msg = `${aperture.Articlename} is sealed. `;
      var closed_msg = `${aperture.Articlename} is closed. `;

      this.game.log(
        "log",
        "high",
        "tryTravel.js > found aperture " + aperture.id,
        "Travel"
      );

      //
      // LOCKED
      //
      if (aperture.isDOV("unlock") && aperture.is.locked) {
        key_assets = player.getIOVkeys("unlock", aperture);

        // if door is locked and player hasn't got key, pass
        if (!aperture.DOVallowWithNothing("unlock") && !key_assets.length) {
          this.game.debug(
            `F1105 | tryTravel.js | ${aperture.id}.is.locked and player hasn't got a key`
          );
          this.print(msg + locked_msg);
          return;
        }

        // never auto-unlock apertures the player hasn't already unlocked
        // 6/30/22 CHANGE: if aperture is locked and player didn't lock it
        if (
          !aperture.didDoVerbs({
            related_verbs: ["lock", "unlock", "pick", "open", "close"],
          })
        ) {
          this.game.debug(
            `F1106 | tryTravel.js | ${aperture.id}.is.locked and player did not lock it - no auto unlock on first unlock`
          );
          this.print(msg + locked_msg);
          return;
        }

        // check aperture settings for auto unlock
        if (!aperture.can.auto_unlock) {
          this.game.debug(
            `F1107 | tryTravel.js | ${aperture.id}.is.locked and .can.auto_unlock is false`
          );
          this.print(msg + locked_msg);
          return;
        }
      }

      //
      // SEALED
      //
      if (aperture.isDOV("unseal") && aperture.is.sealed) {
        key_assets = player.getIOVkeys("unseal", aperture);

        // has player got a key?
        if (!aperture.DOVallowWithNothing("unseal") && !key_assets.length) {
          this.game.debug(
            `F1108 | tryTravel.js | ${aperture.id}.is.sealed and player hasn't got a key`
          );
          this.print(msg + sealed_msg);
          return;
        }

        // never auto-unseal apertures the player hasn't already unsealed
        // 6/30/22 CHANGE: if aperture is sealed and player didn't seal it
        if (!aperture.didDoVerbs({ related_verbs: ["seal", "unseal"] })) {
          this.game.debug(
            `F1111 | tryTravel.js | ${aperture.id}.is.sealed and player did not seal it - no auto unseal on first unseal`
          );
          this.print(msg + sealed_msg);
          return;
        }

        // check aperture settings for auto unlock
        if (!aperture.can.auto_unseal) {
          this.game.debug(
            `F1109 | tryTravel.js | ${aperture.id}.is.sealed and .can.auto_unseal is false`
          );
          this.print(msg + sealed_msg);
          return;
        }
      }

      //
      // CLOSED
      //
      if (aperture.isDOV("open") && aperture.is.closed) {
        key_assets = player.getIOVkeys("open", aperture);

        // has player got a key?
        if (!aperture.DOVallowWithNothing("open") && !key_assets.length) {
          this.game.debug(
            `F1108 | tryTravel.js | ${aperture.id}.is.closed and player hasn't got a key`
          );
          this.print(msg + closed_msg);
          return;
        }

        // never auto-open apertures the player hasn't already opened
        // 6/30/22 CHANGE: if aperture is closed and player didn't close it
        if (!aperture.didDoVerbs({ related_verbs: ["open", "close"] })) {
          this.game.debug(
            `F1719 | tryTravel.js | ${aperture.id}.is.closed and player did not close it - no auto unseal on first unseal`
          );
          this.print(msg + closed_msg);
          return;
        }

        // check aperture settings for auto open
        if (!aperture.can.auto_open) {
          this.game.debug(
            `F1110 | tryTravel.js | ${aperture.id}.is.closed and .can.auto_open is false`
          );
          this.print(closed_msg);
          return;
        }
      }

      // check if aperture is hidden
      if (aperture.is.hidden) {
        this.game.debug(`F1112 | tryTravel.js | ${aperture.id}.is.hidden`);
        msg += `Hmm. You don't see any exit ${exit.direction}. `;
        this.print(msg, input.output_class);
        return;
      }
    } // if aperture

    // direction is valid but has no destination, try to print description
    if ("undefined" === typeof exit.destinationID && exit.descriptions.look) {
      this.game.log(
        "log",
        "high",
        "tryTravel.js > " +
          exit.direction +
          " has no destination. Printing description.",
        "Travel"
      );
      this.game.debug(
        `F1112 | tryTravel.js | ${exit.id}.destinationID is blank or undefined`
      );
      this.print(msg + A.getSAF.call(this, exit.descriptions.look));
      return;
    }

    // is player holding a rope that is tied to something in the room?
    // @TODO expand this to include other attachment types
    // such as things that are plugged into each other
    if (player.hasRopesThatBlockTravel()) {
      var ropes = player.getRopesThatBlockTravel();
      var rope = this.game.getAsset(ropes[0]);
      var object_rope_is_tied_to;
      for (var i = 0; i < rope.dov.tie?.with_params.connections.length; i++) {
        if (player.id !== rope.dov.tie?.with_params.connections[i]) {
          object_rope_is_tied_to = this.game.getAsset(
            rope.dov.tie?.with_params.connections[i]
          );
        }
      }
      this.game.debug(`F1113 | tryTravel.js |player.hasRopesThatBlockTravel`);
      msg = `$(We're) preventing from leaving by ${rope.articlename}`;
      if ("undefined" !== typeof object_rope_is_tied_to) {
        msg += ` tied to ${object_rope_is_tied_to.articlename}`;
      }
      msg += `. `;

      if (msg) this.game.print(msg, input.output_class);
      return null;
    }

    if (player.isNested() && false === nest_parent_object.is.rideable) {
      results = player.onUnnestThisFromThat(nest_parent_object);
      if ("undefined" !== typeof results) return results;
    }

    // doSuccess
    // direction is valid and destination exists
    if ("undefined" !== typeof exit.destinationID) {
      this.game.log(
        "log",
        "high",
        "tryTravel.js > Direction is valid and destination exists.",
        "Travel"
      );
      this.game.debug(
        `F1876 | tryTravel.js | doSuccess, travel to ${exit.destinationID}`
      );

      // TODO add logic for hidden exits
      exit.setUsed();
      var addPeriod = false;
      if ("undefined" !== typeof aperture) {
        if (aperture.is.locked && aperture.can.auto_unlock) {
          /*&& this.game.settings.can_auto_unlock_apertures*/
          msg += `$(We) unlock ${aperture.articlename}`;
          addPeriod = true;
          aperture.setLocked(false); //.locked = false;
          aperture.incrementDoVerbCount("unlock");
        }

        if (aperture.is.sealed && aperture.can.auto_unseal) {
          /*&& this.game.settings.can_auto_unseal_apertures*/
          msg += `$(We) unseal ${aperture.articlename}`;
          addPeriod = true;
          aperture.setSealed(false); //is.sealed = false;
          aperture.incrementDoVerbCount("unseal");
        }

        if (aperture.is.closed && aperture.can.auto_open) {
          /*&& this.game.settings.can_auto_open_apertures*/
          if (!msg) {
            msg += `$(We) open ${aperture.articlename}`;
          } else {
            msg += ", and then open it";
          }
          //+ ". ";
          addPeriod = true;
          aperture.setClosed(false);
          aperture.incrementDoVerbCount("open");
        }

        if (addPeriod) msg += ". ";
        aperture.setUsed();

        if ("undefined" !== typeof aperture.linked_asset) {
          this.game.world[aperture.linked_asset].setUsed();
        }
      }

      var newRoomID = exit.destinationID;
      var newRoomObj = this.world[newRoomID];
      for (var exitProp in newRoomObj.exits) {
        var newRoomExitID = newRoomObj.exits[exitProp];
        var newRoomExitObj = this.world[newRoomExitID];
        if (newRoomExitObj.destinationID === currentRoom.id) {
          newRoomExitObj.setUsed();
        }
      }

      if (player.isNested() && nest_parent_object.is.rideable) {
        //   results = newRoom.onMoveThatToThis( nest_parent_object, "in" ); // string
        //   if( false === results ) { return false; }
        //   else if ( null === results ) { return null; }
        msg += `$(We) ride ${nest_parent_object.articlename} `;
        if (this.game.dictionary.verbs[direction].is_spatial_direction) {
          //msg += "to ";
        } else if (this.game.dictionary.verbs[direction].is_compass_direction) {
          msg += `to the `;
        }
        msg += `${direction}. `;
      } else if (params.with) {
        msg += `$(We) push `;
        msg += this.game.getPrintableObjectList({
          objects: params.with,
          article: "definite",
        });
        msg += ` `;
        if (this.game.dictionary.verbs[direction].is_spatial_direction) {
          //msg += "to ";
        } else if (this.game.dictionary.verbs[direction].is_compass_direction) {
          msg += `to the `;
        }
        msg += `${direction}. `;
        if ("string" === typeof params.with) {
          params.with = [params.with];
        }
        for (var i = 0; i < params.with.length; i++) {
          var object = this.game.getAsset(params.with[i]);
          object.moveFrom(object.getPlaceAsset());
          object.moveTo("in", newRoomObj);
        }
      } else if (exit.descriptions && exit.descriptions.travel) {
        msg += A.getSAF.call(this.game, exit.descriptions.travel);
      } else {
        msg +=
          this.game.dictionary.verbs[input.input_verb] &&
          this.game.dictionary.verbs[input.input_verb].type.travel
            ? `$(We) ${input.input_verb} `
            : `$(We) ${player.getPostureVerb()} `;

        if (this.game.dictionary.verbs[direction].is_spatial_direction) {
          // relative directions include "port" and "starboard",
          // "left" and "right", etc
          //msg += "to ";
        }
        // else if(this.game.dictionary.verbs[direction].is_compass_direction)
        // {
        //   msg += "to the ";
        // }
        msg +=
          direction +
          " to " +
          (newRoomObj.use_definite_article_in_lists
            ? newRoomObj.definite_article + " "
            : "") +
          newRoomObj.name +
          ". ";
      }

      this.game.print(msg, input.output_class);
      this.setPlayerRoom(this.world[newRoomID], params);
      return true;
    }

    // final fallback
    this.game.debug(`F1114 | tryTravel.js |no ${direction} exit found`);
    msg += `There doesn't appear to be an exit ${direction}. `;
    if (
      this.settings.when_travel_fails_list_exits ||
      this.world[this.world._currentRoom].when_travel_fails_list_exits
    ) {
      this.game.debug(
        `F1119 | tryTravel.js | ${this.game_name}.settings.when_travel_fails_list_exits is true`
      );
      var exits = this.getCurrentRoomExits();
      if (exits) msg += " " + exits;
    }
    this.print(msg, input.output_class);
  };
})();

// validateAssetPrecursor.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Validate unclassed precursor object prior to creating an asset.
   * Generic objects must have at minimum a valid class and a name.
   * Name is used to generate ID.
   * Exits are the exception, where ID is generated from location + direction.
   * @method adventurejs.Game#validateAssetPrecursor
   * @memberOf adventurejs.Game
   * @param {Object} child A generic object.
   * @returns {Object} A classed object.
   */
  p.validateAssetPrecursor = function Game_validateAssetPrecursor(child) {
    // has it got a class?
    if (typeof child.class === "undefined") {
      this.game.log("error", "critical", [
        "Whatever this is, it needs a class definition.",
        child,
      ]);
      return false;
    }

    // all classes are initial uppercase
    // so let's ensure that is true
    //child.class = A.propercase( child.class );

    // is its class a valid class?
    if (typeof adventurejs[child.class] === "undefined") {
      this.game.log(
        "error",
        "critical",
        "This object, " +
          child.name +
          ", has an unrecognized class, " +
          child.class +
          ". If you think this is in error, double check " +
          "that you spelled its class correctly. " +
          "Remember, class names are case sensitive."
      );
      return false;
    }

    // has it got a name?
    let nameless = ["Exit", "GlobalString"];
    if (
      typeof child.name === "undefined" &&
      nameless.indexOf(child.class) === -1
    ) {
      this.game.log("error", "critical", [
        "This " + child.class + " has no name.",
        child,
      ]);
      return false;
    }

    // if it has a noun property, is the noun a string?
    if ("undefined" !== typeof child.noun && "string" !== typeof child.noun) {
      this.game.log(
        "error",
        "critical",
        child.class +
          " " +
          child.name +
          "'s noun property is not a string, and it should be. "
      );
      return false;
    }

    // if it has a plural property, is the plural a string?
    if (
      "undefined" !== typeof child.plural &&
      "string" !== typeof child.plural
    ) {
      this.game.log(
        "error",
        "critical",
        child.class +
          " " +
          child.name +
          "'s plural property is not a string, and it should be. "
      );
      return false;
    }

    // if it has a noun property, does it also have a plural prop?
    if (
      "undefined" !== typeof child.noun &&
      "string" === typeof child.noun &&
      "string" !== typeof child.plural
    ) {
      this.game.log(
        "error",
        "critical",
        child.class +
          " " +
          child.name +
          "'s has a custom noun property but no plural property. "
      );
      return false;
    }

    // if it has a plural property, does it also have a noun prop?
    if (
      "undefined" !== typeof child.plural &&
      "string" === typeof child.plural &&
      "string" !== typeof child.noun
    ) {
      this.game.log(
        "error",
        "critical",
        child.class +
          " " +
          child.name +
          "'s has a custom plural property but no noun property. "
      );
      return false;
    }

    // if it has custom noun/plural pairs written as a string
    // is the string formatted correctly?
    // and convert it into an array
    if (
      "undefined" !== typeof child.singlePluralPairs &&
      "string" === typeof child.singlePluralPairs
    ) {
      child.singlePluralPairs = child.singlePluralPairs.split(",");
      for (var i = 0; i < child.singlePluralPairs.length; i++) {
        child.singlePluralPairs[i] = child.singlePluralPairs[i].trim();
      }
      if (
        child.singlePluralPairs.length !==
        Math.floor(child.singlePluralPairs.length * 0.5 * 2)
      ) {
        this.game.log(
          "error",
          "critical",
          child.class +
            " " +
            child.name +
            "'s singlePluralPairs property has an odd number of items. " +
            "It should have an even number of noun/plural pairs."
        );
        return false;
      }
      var tempArray = [];
      for (var i = 0; i < child.singlePluralPairs.length; i += 2) {
        tempArray.push([
          child.singlePluralPairs[i],
          child.singlePluralPairs[i + 1],
        ]);
      }
      child.singlePluralPairs = tempArray;
    }

    // if it has custom noun/plural pairs in an array,
    // is the array formatted correctly?
    if (
      "undefined" !== typeof child.singlePluralPairs &&
      Array.isArray(child.singlePluralPairs)
    ) {
      for (var i = 0; i < child.singlePluralPairs.length; i++) {
        if (
          false === Array.isArray(child.singlePluralPairs[i]) ||
          2 !== child.singlePluralPairs[i].length
        ) {
          this.game.log(
            "error",
            "critical",
            child.class +
              " " +
              child.name +
              "'s singlePluralPairs property has an array item which isn't a pair. " +
              "It should have an even number of noun/plural pairs."
          );
          return false;
        }
      }
    }

    // SUCCESS!

    return child;
  };
})();

// validateAssets.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * Validate all assets in world.
   * @method adventurejs.Game#validateAssets
   * @memberOf adventurejs.Game
   */
  p.validateAssets = function Game_validateAssets() {
    for (var prop in this.world) {
      if ("_" === prop.charAt(0)) {
        // we use _underscore to store vars in the world object for save/restore
        continue;
      }

      // explicitly testing for false here because some
      // asset classes may return undefined and that's ok
      if (false === this.world[prop].validate(this)) {
        return false;
      } else {
        this.world[prop].is.validated = true;

        var msg =
          "Validated " +
          this.world[prop].constructor.name +
          " " +
          this.world[prop].name;
        this.game.log("log", 3, msg, "Game");
      }
    }
    return true;
  };
})();

// Atom.js
(function () {
  /*global adventurejs A*/
  "use strict";
  /**
   * @class adventurejs.Atom
   * @ajsinternal
   * @ajsnavheading FrameworkReference
   * @param {String} game_name A reference back to the top level
   * game object, by way of window[game_name]. Done this way
   * rather than using an object reference in order to avoid circular
   * references, because they're difficult to parse into JSON, the
   * method that's used for saving/restoring game data.
   * @param {String} name The name of the object in the game world,
   * ie "brass lantern". The name is also used to create the object's
   * <a href="#id">id</a> by means of removing periods and spaces and
   * converting to lowercase.
   * @summary Experimental class made with Javascript ES6 class keyword.
   * @classdesc
   * <strong>Atom</strong> is a bedrock class that is used as the
   * prime ancestor for all in-game classes. It defines several
   * important base properties including <a href="#name">name</a>,
   * <a href="#class">class</a>, <a href="#id">id</a>,
   * and the <a href="#set">set</a> method.
   * Authors should not need to instantiate or subclass Atom.
   * Start with the {@link adventurejs.Tangible|Tangible} class
   * to create new physical Assets, or the
   * {@link adventurejs.Intangible|Intangible} class to create
   * new abstract Assets.
   */
  class Atom {
    constructor(name, game_name) {
      /**
       * game_name stores the name of
       * the current game instance as scoped to window.
       * (By default, we use "MyGame", but you can use
       * any name.) In order
       * to refer to the game object, we use window[this.game_name].
       * We store a string instead of the object itself in order to
       * avoid problems caused by circular references during
       * JSON encoding, which is used extensively for managing game
       * state and saved games.
       * @alias game_name
       * @type {string}
       * @memberof adventurejs.Atom
       */
      this.game_name = game_name;

      /**
       * Class identifier to be provided in the asset definition.
       * All game objects start as generic objects that get passed to
       * {@link adventurejs.Game#createAsset|createAsset},
       * which uses an object's class field to specify
       * a class constructor.
       * @alias class
       * @type {string}
       * @memberof adventurejs.Atom
       */
      this.class = "Atom";

      // Name should only be undefined when restoring from JSON.
      if ("undefined" !== typeof name) {
        /**
         * Class identifier to be provided in the asset definition.
         * All game objects start as generic objects that get passed to
         * {@link adventurejs.Game#createAsset|createAsset},
         * which uses an object's class field to specify
         * a class constructor.
         * @alias name
         * @type {string}
         * @memberof adventurejs.Atom
         */
        this.name = name;

        if (this.name) {
          /**
           * A unique ID for the game asset, based on the object name
           * provided in the asset definition.
           * @alias id
           * @type {string}
           * @memberof adventurejs.Atom
           */
          this.id = A.serialize(name);
        }

        /**
         * A unique numerical ID for the game asset. Currently unused but
         * included as a potential alternative to id.
         * @alias UID
         * @type {string}
         * @memberof adventurejs.Atom
         */
        this.UID = adventurejs.UID.get();
      }
    }

    /**
     * Name returns the name of the class instance
     * with the first character uppercased.
     * @var {String} adventurejs.Atom#Name
     */
    get Name() {
      return A.propercase(this.name);
    }

    get self() {
      return this;
    }

    /**
     * Returns the top level game object. Use <code class="property">this.game</code>.
     * @var {Getter} adventurejs.Atom#game
     * @returns {adventurejs.Game}
     */
    get game() {
      return window[this.game_name] || false;
    }

    /**
     * Provides a chainable shortcut method for setting a number of properties on the instance.
     * @method adventurejs.Atom#set
     * @memberOf adventurejs.Atom
     * @param {Object} props A generic object containing properties to copy to the Object instance.
     * @returns {Object} Returns the instance the method is called on (useful for chaining calls.)
     * @chainable
     */
    set(props) {
      return A.deepSet.call(this.game, props, this);
    }

    /**
     * A method to test whether the Atom is an instance of a given class.
     * @method adventurejs.Atom#hasClass
     * @memberOf adventurejs.Atom
     * @param {String} prop Name of the class to test for.
     * @returns {Boolean}
     */
    hasClass(classname) {
      if (!classname || "string" !== typeof classname) return false;
      if (!adventurejs[classname]) {
        // classes have leading capitalization so we'll make an effort
        // to see if that's the problem
        classname = A.propercase(classname);
      }
      if (!adventurejs[classname]) {
        return false;
      }
      return this instanceof adventurejs[classname];
    }

    /**
     * <strong>getInheritance</strong> is a utility method to get
     * an asset's inheritance chain. Returns a list of class names
     * from high to low.
     * @method adventurejs.Atom#getInheritance
     * @memberOf adventurejs.Atom
     * @returns {Array}
     */
    getInheritance() {
      var proto = ".__proto__";
      var chain = "this" + proto;
      var classlist = [];
      var classname;
      while (classname !== "Atom") {
        classname = eval(chain).constructor.name;
        classlist.push(classname);
        chain += proto;
      }
      return classlist;
    }
  }

  adventurejs.Atom = Atom;
})();

// StateManager.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager
   * @augments adventurejs.Atom
   * @class adventurejs.StateManager
   * @ajsnavheading FrameworkReference
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @param {String} parent_id The ID of the containing asset instance.
   * @summary A container for state variables.
   * @classdesc
   * <p>
   * <strong>StateManager</strong> is a special class used
   * for storing general state variables. For example,
   * <a href="/doc/adventurejs.Tangible.html#property_is">tangible.is</a>
   * is used to store states such as
   * <a href="/doc/adventurejs.Tangible.html#property_is_closed">tangible.is.closed</a>,
   * <a href="/doc/adventurejs.Tangible.html#property_is_locked">tangible.is.locked</a>,
   * <a href="/doc/adventurejs.Tangible.html#property_is_global">tangible.is.global</a>,
   * etc.
   * This is done chiefly for organizational purposes. With hundreds of
   * properties per asset, it seemed cleaner
   * to group similar types of properties into clusters and access them
   * through dot notation, rather than leave hundreds of properties
   * floating around the top level of each object. The reason to make it a
   * classed object rather than a generic object (as we do for some collections)
   * is so we can add prototype methods and properties that have access to scope
   * of <code>this</code> (meaning the parent asset) and <code>game</code>
   * (the top level game object).
   * <br><br>
   * State containers and their values are passed down the inheritance chain.
   * For example: {@link adventurejs.Tangible|Tangible} inherits from
   * {@link adventurejs.Asset|Asset}, and
   * <a href="/doc/adventurejs.Asset.html#property_is_global">asset.is.global</a>
   * is available on
   * <a href="/doc/adventurejs.Tangible.html#property_is_global">tangible.is.global</a>.
   * It's also possible to override
   * inherited nested properties. For example:
   * {@link adventurejs.Exit|Exit} inherits
   * <a href="/doc/adventurejs.Tangible.html#property_is_closed">tangible.is.closed</a>
   * and
   * <a href="/doc/adventurejs.Tangible.html#property_is_locked">tangible.is.locked</a>,
   * but overrides them with new definitions in order to account
   * for Exit's relationship to the linked class
   * {@link adventurejs.Aperture|Aperture}.
   **/

  class StateManager extends adventurejs.Atom {
    constructor(name = "is", game_name, parent_id) {
      super(name, game_name);
      this.class = "StateManager";
      if ("string" === typeof parent_id && parent_id) {
        this.parent_id = parent_id;
      } else this.parent_id = "";

      return this;
    }

    get parent() {
      return this.game.getAsset(this.parent_id);
    }

    /**
     * See if there is a linked asset, such as an other side of a door,
     * and set this value for it. Intended primarily for open/closed,
     * locked/unlocked, sealed/unsealed, and known / seen / used.
     * @param {*} value
     * @param {String} property
     */
    setLinkedAssetState(property, value) {
      var parent = this.parent;
      if (parent && parent.linked_asset) {
        var linked_asset = this.game.getAsset(parent.linked_asset);
        if (linked_asset && linked_asset[this.name])
          linked_asset[this.name][property] = value;
      }
    }

    /**
     * Set linked values such as open/close. Also see if there is a linked asset,
     * such as an other side of door, and set the same values for it.
     * @param {Boolean} value
     * @param {String} posprep
     * @param {String} negprep
     */
    setUnstate(value, posprop, negprop) {
      this[posprop] = value;
      this[negprop] = "boolean" === typeof value ? !value : value;
      var parent = this.parent;
      if (parent && parent.linked_asset) {
        var linked_asset = this.game.getAsset(parent.linked_asset);
        if (linked_asset && linked_asset[this.name]) {
          linked_asset[this.name][posprop] = this[posprop];
          linked_asset[this.name][negprop] = this[negprop];
        }
      }
    }
  } // class State

  adventurejs.StateManager = StateManager;
})();

// Aspect_Player.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Aspect_Player
   * @augments adventurejs.StateManager
   * @class adventurejs.Aspect_Player
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for properties pertaining to room/player interactions.
   * @classdesc
   * <p>
   * <strong>Aspect_Player</strong> is a state management class
   * for {@link adventurejs.Room|Rooms}
   * and {@link adventurejs.Aspect|Aspects}
   * used to store a variety of properties that determine
   * how a player can interact with a room or within an
   * aspect that the player is nested in.
   **/

  class Aspect_Player extends adventurejs.StateManager {
    constructor(name = "player", game_name, parent_id, preposition) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Aspect_Player";

      this.posture = "stand";
      this.preposition = preposition;
      this.initial_position = { x: 0, y: 0, z: 0 };
      this.can = {
        bounce: false /*locomotion*/,
        crawl: false /*locomotion*/,
        enter: false,
        exit: false,
        float: false /*locomotion*/,
        hear: false /* sensory */,
        hide: false,
        hop: false /*locomotion*/,
        hover: false /*locomotion*/,
        jump: false /*locomotion*/,
        kneel: false /* posture */,
        lie: false /* posture */,
        ride: false /*locomotion*/,
        run: false /*locomotion*/,
        see: false /* sensory */,
        sit: false /* posture */,
        slither: false /*locomotion*/,
        stand: false /* posture */,
        swim: false /*locomotion*/,
        walk: false /*locomotion*/,
      };

      return this;
    }
  }
  adventurejs.Aspect_Player = Aspect_Player;
})();

// VerbSubscription.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.VerbSubscription
   * @augments adventurejs.VerbSubscription
   * @class adventurejs.VerbSubscription
   * @ajsnavheading FrameworkReference
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A standardized format for attaching verb subscriptions to assets.
   * @classdesc
   * <p>
   * <strong>VerbSubscription</strong> is in tryout vs
   * using unclassed objects.
   * </p>
   * <p>
   * <strong>VerbSubscription</strong> is a special class
   * used to create a standardized format for managing
   * verb subscriptions on assets at
   * asset.dov[verb] and
   * asset.iov[verb].
   * This is meant to provide a clean and orderly way to
   * specify what verbs are supported by individual assets
   * or asset classes.
   * <br><br>
   * VerbSubscriptions and their values are passed down the
   * inheritance chain. For example:
   * <code>asset.dov.examine</code>
   * is available on {@link adventurejs.Matter|Matter},
   * and inherited by
   * {@link adventurejs.Tangible|Tangible},
   * which means that all Tangible
   * subclasses can be examined.
   **/
  class VerbSubscription extends adventurejs.Atom {
    constructor(name, game_name, _this_id) {
      super(name, game_name);
      this.class = "VerbSubscription";

      if ("string" === typeof _this_id && _this_id) {
        this._this_id = _this_id;
      }

      /**
       * <strong>try_count: 0</strong> is used to track the number of times
       * the verb is attempted on this object.
       * @var {String} adventurejs.VerbSubscription#try_count
       */
      this.try_count = 0;

      /**
       * <strong>do_count: 0</strong> is used to track the number of times
       * the verb is successfully applied to this object.
       * @var {String} adventurejs.VerbSubscription#do_count
       */
      this.do_count = 0;

      /**
       * <strong>name: ''</strong> the name of the verb.
       * @var {String} adventurejs.VerbSubscription#name
       */
      this.name = "";

      /**
       * <strong>inherited_from: 'Asset'</strong> the name of the class this verb is inherited from. Since these properties aren't distinctly documented, this is offered as a convenience method for tracking down inherited verb settings.
       * @var {String} adventurejs.VerbSubscription#inherited_from
       */
      this.inherited_from = "Asset";

      /**
       * <strong>enabled: true</strong> allows changing the state of an asset's responsiveness to a given verb. If set false, a subscribed asset will not respond to the verb. This is useful for temporarily disabling verbs for specific assets, for example if you had a door that could not be unlocked until another action was completed.
       * @var {Boolean} adventurejs.VerbSubscription#enabled
       */
      this.enabled = true;

      /**
       * <strong>automatically: true</strong> allows for some verbs to be performed automatically if context calls for it, for example, when unlocking a door in order to pass through it. This takes precedence over global settings.
       * @var {Boolean} adventurejs.VerbSubscription#automatically
       */
      this.automatically = true;

      /**
       * <strong>automatically_after_use: true</strong> if automatically is set true, this sets it so that a verb can only be applied automatically after a player has already used it manually. This is to prevent automatic use of tools from breaking puzzles. For example, imagine one door with many keys but only one that works; if choosing the right key is part of the puzzle, this option prevents players from simply saying "unlock door" and having the right key automatically selected for them.
       * @var {Boolean} adventurejs.VerbSubscription#automatically_after_use
       */
      this.automatically_after_use = true;

      /**
       * <strong>once: false</strong> if true, asset can only be successfully used once with given verb, but is left in place after use.
       * @var {Boolean} adventurejs.VerbSubscription#once
       */
      this.once = false;

      /**
       * <strong>then_disable: false</strong> if true, asset can only be successfully used once with given verb, but is left in place after use.
       * @var {Boolean} adventurejs.VerbSubscription#then_disable
       */
      this.then_disable = false;

      /**
       * <strong>then_destroy: false</strong> allows author to specify that this asset should be destroyed after using. By default, then_destroy is set to a boolean. If true, asset is destroyed after a successful use regardless. then_destroy may provide a string or array or function subject to getStringOrArrayOrFunction().
       * @var {Boolean|*} adventurejs.VerbSubscription#then_destroy
       * @getSAF
       */
      this.then_destroy = false;

      /**
       * <strong>with_anything: true</strong> pertains only to indirect objects. If true, this asset can be used as an indirect object of this verb with any direct object.
       * @var {Boolean} adventurejs.VerbSubscription#with_anything
       */
      this.with_anything = false;

      /**
       * <strong>with_assets: []</strong> allows author to define a single asset that can interact with this one using the given verb, for example "unlock door with key" where key is the only asset that can unlock door.
       * @var {Array} adventurejs.VerbSubscription#with_assets
       */
      this.with_assets = [];
      // this.with;

      /**
       * <strong>with_classes: []</strong> allows author to define an entire class that can interact with this asset using the given verb, for example "unlock door with skeleton key" where any instance of the class SkeletonKey can unlock door.
       * @var {Array} adventurejs.VerbSubscription#with_classes
       */
      this.with_classes = [];
      // this.with_any;
      // this.with_all;

      /**
       * <strong>with_nothing: true</strong> pertains only to direct objects. If true, the specified verb can be applied to the direct object without the use of any indirect object.
       * @var {Boolean} adventurejs.VerbSubscription#with_nothing
       */
      this.with_nothing = false;

      /**
       * <strong>with_params: {}</strong> is an optional collection of verb-specific parameters that are copied from the verb that is being subscribed to. For example, plug includes with_params.connections for tracking which assets are plugged to which.
       * @var {Object} adventurejs.VerbSubscription#with_params
       */
      this.with_params = {};
      // this.params;
      // this.connections;
      // this.max_connections;

      /**
       * <strong>on_success: ''</strong> is an optional parameter. It is set as a string by default, but may provide a string or array or function to be served by getStringOrArrayOrFunction(). If it returns a string, that string will be appended to the verb's default success message.
       * @var {String|*} adventurejs.VerbSubscription#on_success
       * @getSAF
       */
      this.on_success = "";

      /**
       * <strong>on_first_success: ''</strong> is an optional parameter. It is set as a string by default, but may provide a string or array or function to be served by getStringOrArrayOrFunction(). If it returns a string, that string will be appended to the verb's default success message.
       * @var {String|*} adventurejs.VerbSubscription#on_first_success
       * @getSAF
       */
      this.on_first_success = "";

      /**
       * <strong>on_failure: ''</strong> is an optional parameter. It is set as a string by default, but may provide a string or array or function to be served by getStringOrArrayOrFunction(). If it returns a string, that string will be appended to the verb's default failure message.
       * @var {String|*} adventurejs.VerbSubscription#on_failure
       * @getSAF
       */
      this.on_failure = "";

      /**
       * <strong>on_first_failure: ''</strong> is an optional parameter. It is set as a string by default, but may provide a string or array or function to be served by getStringOrArrayOrFunction(). If it returns a string, that string will be appended to the verb's default failure message.
       * @var {String|*} adventurejs.VerbSubscription#on_first_failure
       * @getSAF
       */
      this.on_first_failure = "";

      this.doBeforeTry = null;
      this.doAfterTry = null;
      this.doBeforeSuccess = null;
      this.doAfterSuccess = null;

      return this;
    }

    get _this_id() {
      return this.__this_id;
    }
    set _this_id(id) {
      id = A.serialize(id);
      this.__this_id = id;
    }

    get _this() {
      return this.game.getAsset(this._this_id);
    }

    /**
     * Enable this verb on its parent asset.
     * @memberOf adventurejs.VerbSubscription
     * @method adventurejs.VerbSubscription#enable
     */
    enable() {
      this.enabled = true;
    }

    /**
     * Disable this verb on its parent asset.
     * @memberOf adventurejs.VerbSubscription
     * @method adventurejs.VerbSubscription#disable
     */
    disable() {
      this.enabled = false;
    }

    /**
     * Increment this verb subscription's do_count.
     * @memberOf adventurejs.VerbSubscription
     * @method adventurejs.VerbSubscription#incrementDoCount
     */
    incrementDoCount() {
      this.do_count++;
    }

    /**
     * Increment this verb subscription's try_count.
     * @memberOf adventurejs.VerbSubscription
     * @method adventurejs.VerbSubscription#incrementTryCount
     */
    incrementTryCount() {
      this.try_count++;
    }

    /**
     * Check whether this verb has been successfully applied.
     * @memberOf adventurejs.VerbSubscription
     * @var {Getter} adventurejs.VerbSubscription#did_do
     */
    get did_do() {
      return this.do_count > 0;
    }

    /**
     * Check whether this verb has been tried.
     * @memberOf adventurejs.VerbSubscription
     * @var {Getter} adventurejs.VerbSubscription#did_try
     */
    get did_try() {
      return this.try_count > 0;
    }
  }
  adventurejs.VerbSubscription = VerbSubscription;
})();

// SubstanceMixer.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.SubstanceMixer
   * @ajsconstruct var mixer = new adventurejs.SubstanceMixer( this.game.game_name )
   * @augments adventurejs.Atom
   * @class adventurejs.SubstanceMixer
   * @ajsinternal
   * @ajsnavheading BaseClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @summary Shaken, not stirred.
   * @todo Solid+liquid->slurry.
   * @classdesc
   * <p>
   * <strong>SubstanceMixer</strong> is a special internal class
   * that is instantiated whenever
   * {@link adventurejs.Substance|Substances} are mixed
   * together from two (or in theory, more) sources.
   * For instance, if player pours a glass full of liquid
   * into a bowl that also contains liquid, we make a new
   * SubstanceMixer to handle the interaction. This is
   * true even if both Vessels contain the same
   * Substance. SubstanceMixer handles:
   * <ul>
   * <li>temperature conversion, if SubstancesContainers are
   * at different temperatures</li>
   * <li>volume operations - comparing available volume in
   * source and destination, removing part or all from
   * source as needed</li>
   * <li>mixwith handling, if two Substances are set to mix
   * with each other to form a third Substance</li>
   * <li>overflow of the target container if needed</li>
   * </ul>
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class SubstanceMixer extends adventurejs.Atom {
    constructor(game_name) {
      super(undefined, game_name);
      this.game_name = game_name;

      this.class = "SubstanceMixer";
      //this.game_name = game_name;

      /**
       * <b>source_input</b> might be an asset id or a tri-part
       * asset:aspect:substance id string. We're prepared to
       * handle either to get an asset, or receive an asset object directly.
       * @var {String} adventurejs.SubstanceMixer#source_input
       * @default ""
       */
      this.source_input = "";

      /**
       * <b>source_asset</b> is an asset with a vessel that contains the source substance.
       * @var {Object|null} adventurejs.SubstanceMixer#source_asset
       * @default null
       */
      this.source_asset = null;

      /**
       * <b>source_aspect</b> is the asset aspect that contains
       * the source substance.
       * @var {String} adventurejs.SubstanceMixer#source_aspect
       * @default ""
       */
      this.source_aspect = "";

      /**
       * <b>source_vessel</b> is a reference to the Vessel object in the source asset.
       * @var {Object|null} adventurejs.SubstanceMixer#source_vessel
       * @default null
       */
      this.source_vessel = null;

      /**
       * <b>source_substance_asset</b> is the asset of the substance that is contained.
       * @var {Object|null} adventurejs.SubstanceMixer#source_substance_asset
       * @default null
       */
      this.source_substance_asset = null;

      /**
       * <b>source_substance_id</b> is the id of the substance asset that is contained, ie 'sand' or 'water'.
       * @var {String} adventurejs.SubstanceMixer#source_substance_id
       * @default ""
       */
      this.source_substance_id = "";

      /**
       * <b>source_split</b> is used to store the provided source_input if it is a tri-part string.
       * @var {Array|String|null} adventurejs.SubstanceMixer#source_split
       * @default null
       */
      this.source_split = null;

      /**
       * <b>source_volume</b> is the volume of the substance in the source vessel.
       * @var {int} adventurejs.SubstanceMixer#source_volume
       * @default 0
       */
      this.source_volume = 0;

      /**
       * <b>source_volume_used</b> stores the volume of the source substance that has been used.
       * @var {int} adventurejs.SubstanceMixer#source_volume_used
       * @default 0
       */
      this.source_volume_used = 0;

      /**
       * <b>target_input</b> might be an asset id or a tri-part
       * asset:aspect:substance id string. We're prepared to
       * handle either to get an asset, or receive an asset object directly.
       * @var {String} adventurejs.SubstanceMixer#target_input
       * @default ""
       */
      this.target_input = "";

      /**
       * <b>target_asset</b> is an asset with a vessel that receives the source substance.
       * @var {Object|null} adventurejs.SubstanceMixer#target_asset
       * @default null
       */
      this.target_asset = null;

      /**
       * <b>target_aspect</b>  is the asset aspect which will receive
       * the source substance.
       * @var {String} adventurejs.SubstanceMixer#target_aspect
       * @default ""
       */
      this.target_aspect = "";

      /**
       * <b>target_vessel</b> is a reference to the Vessel object in the target asset.
       * @var {Object|null} adventurejs.SubstanceMixer#target_vessel
       * @default null
       */
      this.target_vessel = null;

      /**
       * <b>target_substance_asset</b> is the asset of the substance that is
       * contained by the target asset.
       * @var {Object|null} adventurejs.SubstanceMixer#target_substance_asset
       * @default null
       */
      this.target_substance_asset = null;

      /**
       * <b>target_substance_id</b> is the id of the substance asset that
       * is contained in the target asset, ie 'sand' or 'water'.
       * @var {String} adventurejs.SubstanceMixer#target_substance_id
       * @default ""
       */
      this.target_substance_id = "";

      /**
       * <b>target_split</b> is used to store the provided target_input if it is a tri-part string.
       * @var {Array|String|null} adventurejs.SubstanceMixer#target_split
       * @default null
       */
      this.target_split = null;

      /**
       * <b>target_volume</b> is the volume of the substance in the target vessel.
       * @var {float} adventurejs.SubstanceMixer#target_volume
       * @default 0.0
       */
      this.target_volume = 0.0;

      /**
       * <b>target_freevolume</b> is the free volume of the substance in the target vessel.
       * @var {float} adventurejs.SubstanceMixer#target_freevolume
       * @default 0.0
       */
      this.target_freevolume = 0.0;

      /**
       * <b>output_substance_asset</b> is the asset of the substance that
       * results from mixing (which may just be the source substance).
       * @var {Object|null} adventurejs.SubstanceMixer#output_substance_asset
       * @default null
       */
      this.output_substance_asset = null;

      /**
       * <b>output_substance_id</b> is the id of the substance asset that
       * is that results from mixing, ie 'sand' or 'water'.
       * @var {String} adventurejs.SubstanceMixer#output_substance_id
       * @default ""
       */
      this.output_substance_id = "";

      /**
       * <b>target_already_full</b> is used to indicate that the target vessel
       * is already full.
       * @var {Boolean} adventurejs.SubstanceMixer#target_already_full
       * @default false
       */
      this.target_already_full = false;

      /**
       * <b>did_fill_target</b> is used to indicate that the target vessel
       * was filled by the source substance.
       * @var {Boolean} adventurejs.SubstanceMixer#did_fill_target
       * @default false
       */
      this.did_fill_target = false;

      /**
       * <b>did_mix_substances</b>
       * @var {Boolean} adventurejs.SubstanceMixer#did_mix_substances
       * @default false
       */
      this.did_mix_substances = false;

      /**
       * <b>did_displace_substance</b> is used if no mixwiths
       * are provided. Source substance will simply displace
       * target substance.
       * @var {Boolean} adventurejs.SubstanceMixer#did_displace_substance
       * @default false
       */
      this.did_displace_substance = false;

      /**
       * <b>can_drain_target</b> is used to indicate that the target vessel
       * can be drained.
       * @var {Boolean} adventurejs.SubstanceMixer#can_drain_target
       * @default false
       */
      this.can_drain_target = false;

      /**
       * <b>did_overflow_target</b> may be set to true
       * if the source is an emitter that emits a greater
       * volume than the target can hold.
       * @var {Boolean} adventurejs.SubstanceMixer#did_overflow_target
       * @default false
       */
      this.did_overflow_target = false;

      /**
       * <b>can_overflow_target</b> overrides did_overflow_target
       * if it's true. It's used by fill verb, the idea being that,
       * while an automated emitter might overflow a target,
       * a person consciously filling a vessel would not.
       * @var {Boolean} adventurejs.SubstanceMixer#can_overflow_target
       * @default false
       */
      this.can_overflow_target = false;
    }

    /**
     * Mix two substances. This function acts upon the source /
     * target objects, and saves its results to the
     * SubstanceMixer object for reference by the caller.
     * @memberof adventurejs.SubstanceMixer
     * @method adventurejs.SubstanceMixer#mix
     * @returns {boolean}
     */
    mix() {
      // SOURCE ASSET
      // asset:aspect:substance
      this.source_split = this.source_input.split(":");
      if (!this.source_asset) {
        // regardless of whether player input a substance containing object
        // or they entered a substance and we parsed asset:aspect:substance,
        // source_split[0] will be the container
        this.source_asset = this.game.getAsset(this.source_split[0]);
      }
      if (Object(this.source_asset) !== this.source_asset) {
        this.game.log(
          "warn",
          0,
          "SubstanceMixer.source_asset undefined",
          "SubstanceMixer"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > source_asset " + this.source_asset.id,
        "SubstanceMixer"
      );

      // SOURCE ASPECT
      // check for input that was parsed into "bowl:in:water" format
      if (!this.source_aspect) {
        if (1 < this.source_split.length) {
          // if they entered a substance and we parsed asset:aspect:substance,
          // source_split[1] will be the aspect
          this.source_aspect = this.source_split[1];
        } else {
          // we did not receive a triplet, presumably player referred
          // directly to container, not substance, so get
          // the object's substance location...
          this.source_aspect = this.source_asset.getAspectWithVessel();
        }
      }
      if (!this.source_aspect) {
        this.game.log(
          "warn",
          0,
          "SubstanceMixer.source_aspect undefined",
          "SubstanceMixer"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > source_aspect " + this.source_aspect,
        "SubstanceMixer"
      );

      // SOURCE SUBSTANCE
      if (!this.source_substance_id) {
        if (3 === this.source_split.length) {
          // asset:aspect:substance
          this.source_substance_id = this.source_split[2];
        } else {
          this.source_substance_id =
            this.source_asset.aspects[this.source_aspect].vessel.substance_id;
        }
      }
      if (!this.source_substance_id) {
        this.game.log(
          "warn",
          0,
          "SubstanceMixer.source_substance_id undefined",
          "SubstanceMixer"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > source_substance_id " + this.source_substance_id,
        "SubstanceMixer"
      );

      // SOURCE SUBSTANCE CONTAINER
      if (!this.source_vessel) {
        // ... and then get the substance
        this.source_vessel =
          this.source_asset.aspects[this.source_aspect].vessel; //.substance_id;
      }
      if (!this.source_vessel) {
        this.game.log(
          "warn",
          0,
          "SubstanceMixer.source_vessel undefined",
          "SubstanceMixer"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > source_vessel " + this.source_vessel.id,
        "SubstanceMixer"
      );

      // SOURCE SUBSTANCE ASSET
      if (this.source_substance_id) {
        // get substance object by id from lookup table
        this.source_substance_asset = this.game.getAsset(
          this.source_substance_id
        );
      }
      if (Object(this.source_substance_asset) !== this.source_substance_asset) {
        this.game.log(
          "warn",
          0,
          "SubstanceMixer.source_substance_asset undefined",
          "SubstanceMixer"
        );
        return false;
      }
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > source_substance_asset " +
          this.source_substance_asset.id,
        "SubstanceMixer"
      );

      // TARGET ASSET
      this.target_split = this.target_input.split(":");
      if (!this.target_asset) {
        this.target_asset = this.game.getAsset(this.target_split[0]);
      }
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > target_asset " + this.target_asset.id,
        "SubstanceMixer"
      );

      // TARGET ASPECT
      if (!this.target_aspect && 1 < this.target_split.length) {
        this.target_aspect = this.target_split[1];
      }
      console.warn("target_asset", this.target_asset);
      console.warn("target_aspect", this.target_aspect);
      if (!this.target_aspect) {
        // we did not receive a triplet, presumably player referred
        // directly to container, not substance, so get
        // the object's substance location...
        this.target_aspect = this.target_asset.getAspectWithVessel();
      }
      console.warn("target_aspect", this.target_aspect);
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > target_aspect " + this.target_aspect,
        "SubstanceMixer"
      );

      // TARGET SUBSTANCE
      if (!this.target_substance_id && 2 < this.target_split.length) {
        this.target_substance_id = this.target_split[2];
      }
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > target_substance_id " + this.target_substance_id,
        "SubstanceMixer"
      );

      // TARGET SUBSTANCE CONTAINER
      if (!this.target_vessel) {
        // ... and the substance it contains
        this.target_vessel =
          this.target_asset.aspects[this.target_aspect].vessel;
      }
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > target_vessel " + this.target_vessel.id,
        "SubstanceMixer"
      );

      // TARGET SUBSTANCE ASSET
      if (!this.target_substance_id) {
        // ... and the substance it contains
        this.target_substance_id = this.target_vessel.substance_id;
      }
      if (this.target_substance_id) {
        // get the substance object from its id
        this.target_substance_asset = this.game.getAsset(
          this.target_substance_id
        );
      }
      this.game.log(
        "log",
        "high",
        "SubstanceMixer.js > target_substance_id " + this.target_substance_id,
        "SubstanceMixer"
      );

      // Is target a drain or has target got a drain?
      this.can_drain_target = this.target_vessel.can_drain;

      // Is target draining or a body of water?
      // Either case effectively means it can accept
      // infinite volume without mixing substance or temp.
      if (
        Infinity === this.target_vessel.volume ||
        this.target_vessel.can_drain === true
      ) {
        // Is source an emitter?
        if (this.source_asset instanceof adventurejs.SubstanceEmitter) {
          /**
           * @todo source emitter mixed into infinite/draining target?
           */
          // ? check this.source_asset.volume_of_flow_per_turn ?
        } // Or is source a container?
        else {
          // if the source is finite and the target is infinite,
          // target will take all of source
          // and we will not mix
          if (
            false ===
              this.source_asset instanceof adventurejs.SubstanceEmitter &&
            isFinite(this.source_vessel.volume)
          ) {
            this.game.log(
              "log",
              "high",
              "SubstanceMixer.js > target is infinite, source is finite, so target will take all of source",
              "SubstanceMixer"
            );
            this.source_vessel.volume = 0;
          }
        }
      } else {
        // Target is not draining nor is it a body of water

        // if target contains a different substance from source
        // see if there's a mixwith for the two substances
        // also mix temps
        // TODO multiple substance mixing

        if (
          Object(this.source_substance_asset) === this.source_substance_asset &&
          this.target_vessel.volume > 0 &&
          this.target_substance_id != this.source_vessel.substance_id
        ) {
          // if either substance has a mixwith for the other
          if (
            this.source_vessel.substance.mixwith[
              this.target_vessel.substance_id
            ]
          ) {
            this.output_substance_id =
              this.source_vessel.substance.mixwith[
                this.target_vessel.substance_id
              ];
            this.did_mix_substances = true;
          } else if (
            this.target_vessel.substance.mixwith[
              this.source_vessel.substance_id
            ]
          ) {
            this.output_substance_id =
              this.target_vessel.substance.mixwith[
                this.source_vessel.substance_id
              ];
            this.did_mix_substances = true;
          }

          // otherwise the source substance simply displaces the target substance
          else {
            this.output_substance_id = this.source_vessel.substance_id;
            this.did_displace_substance = true;
          }
        } else {
          this.output_substance_id = this.source_vessel.substance_id;
        }

        this.output_substance_asset = this.game.getAsset(
          this.output_substance_id
        );

        // current source level
        this.source_volume = this.source_vessel.getVolume();

        // current target level
        if (this.did_displace_substance) this.target_vessel.volume = 0;
        this.target_volume = this.target_vessel.volume;
        this.target_freevolume =
          this.target_vessel.maxvolume - this.target_volume;
        this.target_already_full =
          this.target_vessel.volume === this.target_vessel.maxvolume;

        if (this.source_volume > this.target_freevolume) {
          // target is full so set it to its maxvolume
          this.target_vessel.volume = this.target_vessel.maxvolume;

          if (
            this.source_asset instanceof adventurejs.SubstanceEmitter ||
            !isFinite(this.source_vessel.volume)
          ) {
            // it's assumed that emitters are automated and won't
            // stop emitting just because the target is full
            // so it overflows regardless of overflow setting
            if (this.can_overflow_target) {
              this.did_overflow_target = true;
            }

            if (this.target_already_full) {
              // let's arbitrarily say that we're pouring an amount
              // equal to half the target's free volume - an even mix
              this.source_volume_used = this.source_volume;
            } else {
              this.source_volume_used = this.target_freevolume;
            }
          }

          // else if ( !isFinite( this.source_vessel.volume ) )
          // {
          //   // source is infinite but we need to determine quantity used
          //   // for mixtemps calculation further down the line
          // }

          // else if( false === this.target_already_full
          // && Infinity === this.target_vessel.volume )
          // {
          //   // don't overflow
          // }
          else if (
            !this.target_already_full &&
            (!this.target_vessel.can_overflow || !this.can_overflow_target)
          ) {
            // target is not full and not can_overflow

            // subtract poured volume from source
            // and don't overflow target
            //this.source_asset.aspects[ this.source_aspect ].vessel.volume = this.source_asset.aspects[ this.source_aspect ].vessel.volume - this.target_freevolume;
            this.source_vessel.volume =
              this.source_vessel.volume - this.target_freevolume;
            this.source_volume_used = this.target_freevolume;
          } else if (
            this.target_already_full &&
            !this.target_vessel.can_overflow &&
            !this.can_overflow_target
          ) {
            // target is full and not can_overflow
            // do nothing...?
          } else if (
            this.target_vessel.can_overflow &&
            this.can_overflow_target
          ) {
            // overflow target and set source volume to zero
            this.source_volume_used = this.source_vessel.volume;
            //this.source_asset.aspects[ this.source_aspect ].vessel.volume = 0;
            this.source_vessel.volume = 0;
            this.did_overflow_target = true;
          } else {
            // subtract poured volume from source
            this.source_asset.aspects[this.source_aspect].vessel.volume =
              this.source_asset.aspects[this.source_aspect].vessel.volume -
              this.target_freevolume;
            this.source_volume_used = this.target_freevolume;
          }
        } // this.source_volume is not > this.target_freevolume
        else {
          // add source volume to target volume
          this.target_vessel.volume =
            this.target_vessel.volume + this.source_volume;

          if (this.source_asset instanceof adventurejs.SubstanceEmitter) {
            // @TODO figure out rate of flow
            // temp: set to free volume
            this.source_volume_used = this.target_freevolume;
          } else if (!isFinite(this.source_vessel.volume)) {
            this.source_volume_used = this.target_freevolume;
          } else {
            // empty source
            this.source_volume_used = this.source_vessel.volume;
            //this.source_asset.aspects[ this.source_aspect ].vessel.volume = 0;
            this.source_vessel.volume = 0;
          }
        }

        this.target_vessel.substance_id = this.output_substance_id;

        //this.mixTemps();
        if (!isFinite(this.target_volume)) {
          // recipient is infinite, no temperature change
        } else if (this.target_volume <= 0) {
          this.target_vessel.temperature = Number(
            this.source_vessel.temperature
          );
        } else if (this.target_volume > 0) {
          // liters to grams
          // grams = liters Ã 1000 Ã ingredient density

          // grams to liters
          // liters = grams / ( 1000 x ingredient density )

          // Mixing Liquids and/or Solids - Final Temperatures
          // Calculate the final temperature when liquids or solids are mixed
          // https://www.engineeringtoolbox.com/temperature-mixing-liquid-solids-d_1754.html

          var m1 =
            this.source_volume_used * this.source_substance_asset.density;
          var cp1 = this.source_substance_asset.specific_heat;
          var t1 = this.source_vessel.temperature;

          var m2 = this.target_volume * this.target_substance_asset.density;
          var cp2 = this.target_substance_asset.specific_heat;
          var t2 = this.target_vessel.temperature;

          console.warn(
            "m1",
            m1,
            "cp1",
            cp1,
            "t1",
            t1,
            "m2",
            m2,
            "cp2",
            cp2,
            "t2",
            t2
          );

          var temperature; // = this.target_vessel.room_temperature;

          if (
            !isNaN(m1) &&
            !isNaN(cp1) &&
            !isNaN(t1) &&
            !isNaN(m2) &&
            !isNaN(cp2) &&
            !isNaN(t2)
          ) {
            temperature =
              (m1 * cp1 * t1 + m2 * cp2 * t2) / (m1 * cp1 + m2 * cp2);
            this.target_vessel.temperature = Number(temperature);
          }

          this.game.log(
            "log",
            "high",
            "SubstanceMixer.js > source temp " + this.source_vessel.temperature,
            "SubstanceMixer"
          );
          this.game.log(
            "log",
            "high",
            "SubstanceMixer.js > target temp " + this.target_vessel.temperature,
            "SubstanceMixer"
          );
          this.game.log(
            "log",
            "high",
            "SubstanceMixer.js > mixed temp " + temperature,
            "SubstanceMixer"
          );
        } // mixTemps
      }

      this.did_fill_target =
        this.target_vessel.volume === this.target_vessel.maxvolume;

      if (this.source_substance_asset) {
        this.game.log(
          "log",
          "high",
          "SubstanceMixer.js > source_substance_asset " +
            this.source_substance_asset.id,
          "SubstanceMixer"
        );
        this.source_substance_asset.setKnown();
      }
      if (this.target_substance_asset) {
        this.game.log(
          "log",
          "high",
          "SubstanceMixer.js > target_substance_asset " +
            this.target_substance_asset.id,
          "SubstanceMixer"
        );
        this.target_substance_asset.setKnown();
      }
      //if( "undefined" !== typeof this.output_substance_asset )
      if (Object(this.output_substance_asset) === this.output_substance_asset) {
        this.game.log(
          "log",
          "high",
          "SubstanceMixer.js > output_substance_asset " +
            this.output_substance_asset.id,
          "SubstanceMixer"
        );
        this.output_substance_asset.setKnown();
      }

      // check for custom logic
      var results = this.source_asset.onSubtractSubstanceFromThis(
        this.source_substance_asset
      );
      if ("undefined" !== typeof results) return results;

      // check for custom logic
      results = this.target_asset.onAddSubstanceToThis(
        this.source_substance_asset
      );
      if ("undefined" !== typeof results) return results;

      return;
    }

    // liters to grams
    // grams = liters Ã 1000 Ã ingredient density

    // grams to liters
    // liters = grams / ( 1000 x ingredient density )

    // Mixing Liquids and/or Solids - Final Temperatures
    // Calculate the final temperature when liquids or solids are mixed
    // https://www.engineeringtoolbox.com/temperature-mixing-liquid-solids-d_1754.html

    // p.mixTemps = function SubstanceMixer_mixTemps(){
    //   //var m1  = this.source_volume * this.source_substance_asset.density;
    //   var m1  = this.source_volume_used * this.source_substance_asset.density;
    //   var cp1 = this.source_substance_asset.specific_heat;
    //   var t1  = this.source_vessel.temperature;

    //   var m2  = this.target_volume * this.target_substance_asset.density;
    //   var cp2 = this.target_substance_asset.specific_heat;
    //   var t2  = this.target_vessel.temperature;

    //   var temperature;

    //   if(m1 && cp1 && t1 && m2 && cp2 && t2)
    //   {
    //     temperature = ( m1 * cp1 * t1 + m2 * cp2 * t2 ) / ( m1 * cp1 + m2 * cp2 );
    //   }
    //   //return Conv.rounding(temperature);
    //   //console.warn( "SubstanceMixer.mixTemps > " + temperature );
    //   return temperature;
    // }

    // Mix Liquids of Different Temperatures
    // https://rechneronline.de/chemie-rechner/mix-temperatures.php

    // p.mixTempOfLiquids = function SubstanceMixer_mixTempOfLiquids( source, target ){

    //   // our measure of volume is stored in milliliters
    //   // water is roughly 1 gram per milliliter but other substances are not
    //   var m1 = source.volume; // 'amount' in source script
    //   var c1 = source.heat_capacity; // 'heat capacity' in source script // ex: water = 4.2
    //   var t1 = source.temperature;

    //   var m2 = target.volume; // 'amount' in source script;
    //   var c2 = target.heat_capacity; // 'heat capacity' in source script // ex: water = 4.2
    //   var t2 = target.temperature;

    //   var result;

    //   if (m1 && m2) {
    //       target.volume = m1 + m2;
    //   }
    //   if (!isNaN(t1) && !isNaN(t2))
    //       result = ( ( m1 * c1 * t1 ) + ( m2 * c2 * t2 ) ) / ( ( m1 * c1 ) + ( m2 * c2 ) );

    //   return result;

    // }
  }
  adventurejs.SubstanceMixer = SubstanceMixer;
})();

// Asset.js
(function () {
  /*global adventurejs A*/
  "use strict";
  /**
   * @augments adventurejs.Atom
   * @class adventurejs.Asset
   * @ajsconstruct MyGame.createAsset({ "class":"Asset", "name":"foo" })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajsnavheading BaseClasses
   * @summary Framework class that is the ancestor for all classes in the game world.
   * @tutorial AssetReference__Overview
   * @classdesc
   * <p>
   * <strong>Asset</strong> is subclassed from the
   * foundational class {@link adventurejs.Atom|Atom},
   * and is the most basic game world class
   * from which all other asset classes,
   * {@link adventurejs.Tangible|Tangible},
   * {@link adventurejs.Substance|Substance}, and
   * {@link adventurejs.Intangible|Intangible},
   * are derived. Besides setting
   * the prototypal validation and initialization functions,
   * it also defines many common properties used to determine
   * how assets appear in printed statements. It's unlikely
   * that authors would want to subclass Asset directly as
   * it has few properties, unless it's to create a whole new
   * low-level Asset type.
   * </p>
   **/
  class Asset extends adventurejs.Atom {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Asset";

      /**
       * <strong>is</strong> is a generalized container for
       * asset states. Many states are / can be stored here.
       * A chief benefit of this is being able to get specific
       * states by testing <code>asset.is.state</code>.
       * Note that there is also an asset.$is() method which
       * is related to this, but is a distinct function.
       * @var {Object} adventurejs.Asset#is
       */
      this.is = new adventurejs.Asset_Is("is", this.game_name, this.id).set({
        parent_id: this.id,
      });

      /**
       * <strong>can</strong> is a generalized container for
       * asset boolean properties.
       * @var {Object} adventurejs.Asset#can
       */
      this.can = new adventurejs.Asset_Can("can", this.game_name, this.id).set({
        parent_id: this.id,
      });

      /**
       * <strong>must</strong> is a generalized container for
       * asset boolean properties.
       * @var {Object} adventurejs.Asset#must
       */
      this.must = new adventurejs.Asset_Must(
        "must",
        this.game_name,
        this.id
      ).set({
        parent_id: this.id,
      });

      /**
       * <strong>dov</strong> is a container for direct object
       * verb subscriptions.
       * @var {Boolean} adventurejs.Asset#dov
       * @default {}
       */
      this.dov = {};

      this.setDOV("think");

      /**
       * <strong>iov</strong> is a container for direct object
       * verb subscriptions.
       * @var {Boolean} adventurejs.Asset#iov
       * @default {}
       */
      this.iov = {};

      this.setIOV("ask");
      this.setIOV("tell");

      /**
       * <strong>quirks</strong> is a container for setting how
       * to handle ambiguous verbs based on context. For example,
       * if player inputs "stand" while sitting in a chair with
       * <code>quirks.stand_means_get_off</code> set to true, player
       * will get off the chair, as opposed to trying to stand in
       * place on the chair.
       * @var {Object} adventurejs.Asset#quirks
       */
      this.quirks = {};

      /**
       * Set to true to have an object's name be printed bold.
       * @var {Boolean} adventurejs.Asset#print_bold
       * @default false
       */
      this.print_bold = false;

      /**
       * Set to true to have an object's name be printed italic.
       * @var {Boolean} adventurejs.Asset#print_italic
       * @default false
       */
      this.print_italic = false;

      /**
       * Almost all assets will be listed in the world_lookup table
       * that is used to find assets from player input ,
       * with some exceptions, such as SceneryZones.
       * @var {Boolean} adventurejs.Asset#exclude_from_lookup
       * @default false
       */
      this.exclude_from_lookup = false;

      /**
       * Object names are split into individual words for the world_lookup table.
       * For example, given an object named "crystal sword", adventurejs creates
       * lookup table entries for "crystal" and "sword". This lets the game
       * recognize either word as player input, such as "get crystal" or
       * "swing sword".<br><br>
       * But, an author might want to name a thing, eg, "hole in the ground",
       * in which case we wind up with lookup table entries for "hole" and
       * "in" and "the" and "ground", which is likely to lead to bad input parsing.
       * To avoid name splitting, set split_name_for_world_lookup to false.
       * The object's full name will still be added to the lookup.
       * @var {Boolean} adventurejs.Asset#split_name_for_world_lookup
       * @default true
       *
       */
      this.split_name_for_world_lookup = true;

      /**
       * A list of descriptions for a variety of contexts. Only
       * <code class="property">description</code> is required, all others
       * are optional. Most of these apply only to Tangible Asset.
       * <ul>
       * <li><code class="property">descriptions.description</code> - </li>
       * <li><code class="property">descriptions.brief</code> - used for room descriptions if player has typed "brief"</li>
       * <li><code class="property">descriptions.verbose</code> - used for room descriptions if player has typed "verbose"</li>
       * <li><code class="property">descriptions.listen</code> - used if player types "listen" or "listen to thing"</li>
       * <li><code class="property">descriptions.in</code> - used if player types "look in thing"</li>
       * <li><code class="property">descriptions.through</code> - used if player types "look through thing"</li>
       * <li><code class="property">descriptions.smell</code> - used if player types "smell thing"</li>
       * <li><code class="property">descriptions.taste</code> - used if player types "taste thing"</li>
       * <li><code class="property">descriptions.touch</code> - used if player types "touch thing"</li>
       * <li><code class="property">descriptions.careful</code> - used if player types "carefully examine thing"</li>
       * </ul>
       * @var {Object} adventurejs.Asset#descriptions
       */
      this.descriptions = {
        look: "",
        brief: "",
        verbose: "",
      };

      /**
       * Collection is a special property that lets one object
       * stand in for a group of objects.
       * For example, object desk has three drawers:
       * top_drawer, middle_drawer, bottom_drawer.
       * desk_drawers is a scenery object attached to desk which
       * intercepts player input like "examine drawers", so that author
       * can return a response like "You see three drawers."
       * @var {Getter/Setter} adventurejs.Asset#collection
       *
       */
      this.collection = [];

      this.name = "";

      /**
       * Used to determine whether to display a name or proper name.
       * @var {Boolean} adventurejs.Asset#name_is_proper
       * @default false
       */
      this.name_is_proper = false;

      /**
       * The asset's proper name, as provided in the game file. Assets
       * can have both a name and a proper name. Used chiefly for
       * characters, so that, for example, an asset can be both 'cat' and
       * 'Mister Whiskers'.
       * @var {String} adventurejs.Asset#propername
       */
      this.propername = "";

      /**
       * The asset's preferred definite article.
       * Can be overridden in game file.
       * @var {String} adventurejs.Asset#definite_article
       * @default 'the'
       */
      this.definite_article = "the"; // TODO but maybe not? honorific? "Mr." "Mrs."

      /**
       * The asset's preferred indefinite article.
       * Can be overridden in game file.
       * @var {String} adventurejs.Asset#indefinite_article
       * @default 'a'
       */
      this.indefinite_article = "a"; // "a" or "an", or "the" if the object is singular

      /**
       * A preference for how an asset's name appears when it is printed
       * in certain contexts. Chiefly used for room names.
       * For example, you might name a room 'Sitting Room', but want it
       * to appear as 'the Sitting Room' in some contexts for narrative clarity.
       * Can be overridden in game file.
       * @var {Boolean} adventurejs.Asset#use_definite_article_in_lists
       * @default false
       */
      this.use_definite_article_in_lists = false;

      /**
       * An option to prevent definite/indefinite articles from
       * appearing before an asset name. Used chiefly for characters,
       * to prevent phrases such as "the Mrs. Beasley".
       * Can be overridden in game file.
       * @var {Boolean} adventurejs.Asset#dont_use_articles
       * @default false
       */
      this.dont_use_articles = false;

      /**
       * <strong>noun</strong> is a string representing the type of asset
       * this is, for example 'mug' or 'rock'. Players can input this word
       * to refer to any asset of its type.
       * @var {String} adventurejs.Asset#noun
       *
       */
      this.noun = "";

      /**
       * <strong>pronoun</strong> is a string representing the generic
       * pronoun.
       * @var {String} adventurejs.Asset#pronoun
       *
       */
      this.pronoun = "it";

      /**
       * <strong>singlePluralPairs</strong> is a collection of strings
       * representing the singular and plural forms of this asset, for
       * example ['mug', 'mugs']. Players can use the singular to refer
       * to a single asset or the plural to refer to a group of assets.
       * These are stored in pairs so we can check for correspondence
       * between the forms.
       * @var {Array} adventurejs.Asset#singlePluralPairs
       *
       */
      this.singlePluralPairs = [];

      /**
       * <strong>plural</strong> is a string representing multiple assets
       * of this type, for example 'swords'. Players can input this word
       * to refer to groups of assets.
       * @var {String} adventurejs.Asset#plural
       *
       */
      this.plural = "";

      /**
       * <strong>group</strong> is a string representing a collective
       * category. For example, chair, bed, and desk all share a group
       * of furniture. Players can input this word
       * to refer to any asset of its type.
       * @var {String} adventurejs.Asset#noun
       *
       */
      this.group = [];

      /**
       * <strong>synonyms</strong> is a collection of alternate words that
       * can be used to refer to this asset. For example, an object called
       * 'rock' might have synonyms of ['pebble', 'stone'].
       * Players can input synonyms to refer to this asset.
       * @var {String} adventurejs.Asset#noun
       *
       */
      this.synonyms = [];

      /**
       * A list of adjectives defined for this asset in the game file.
       * Some asset classes may have predefined adjectives.
       * If a class has predefined adjectives, and an author creates
       * an instance of the class with custom adjectives, the custom
       * adjectives will be appended to the predefined ones.
       * @var {Getter/Setter} adventurejs.Asset#adjectives
       */
      this.adjectives = [];

      /**
       * <strong>did_do_verb</strong> is used to track
       * which verbs have acted upon this object.
       * This is  a backup of the verb counter used
       * in verb subscriptions.
       * @var {Object} adventurejs.Asset#did_do_verb
       */
      this.did_do_verb = {};

      /**
       * <strong>did_do_verb_count</strong> is used to track
       * the number of times that given verbs have acted
       * upon this object.
       * This is  a backup of the verb counter used
       * in verb subscriptions.
       * @var {Object} adventurejs.Asset#did_do_verb_count
       */
      this.did_do_verb_count = {};

      /**
       * <strong>did_try_verb</strong> is used to track
       * which verbs have been tried upon this object.
       * This is  a backup of the verb counter used
       * in verb subscriptions.
       * @var {Object} adventurejs.Asset#did_try_verb
       */
      this.did_try_verb = {};

      /**
       * <strong>did_try_verb_count</strong> is used to track
       * the number of times that given verbs have been tried
       * upon this object.
       * This is  a backup of the verb counter used
       * in verb subscriptions.
       * @var {Object} adventurejs.Asset#did_try_verb_count
       */
      this.did_try_verb_count = {};

      /**
       * <strong>image</strong> is used to store the id
       * of an image in game.image_lookup that is
       * associated with this asset.
       * @var {String} adventurejs.Asset#image
       */
      this.image = "";

      /**
       * <strong>redirected_verbs</strong> is an object used
       * for storing verb redirections via redirectVerb().
       * @var {Boolean} adventurejs.Tangible#redirected_verbs
       * @default {}
       */
      this.redirected_verbs = {};
    }

    /**
     * Getter function returns asset name preceded by its definite article,
     * example: 'the asset'.
     * @var {Getter} adventurejs.Asset#definite_name
     * @returns {String}
     */
    get definite_name() {
      //return this.definite_article + " " + this.name;
      var name = this.definite_article + " " + this.name;
      if (this.print_bold) name = "<strong>" + name + "</strong>";
      if (this.print_italic) name = "<em>" + name + "</em>";
      return name;
    }

    /**
     * Getter function returns asset name preceded by its indefinite article,
     * example: 'an asset'.
     * @var {Getter} adventurejs.Asset#indefinite_name
     * @returns {String}
     */
    get indefinite_name() {
      //return this.indefinite_article + " " + this.name;
      var name = this.indefinite_article + " " + this.name;
      if (this.print_bold) name = "<strong>" + name + "</strong>";
      if (this.print_italic) name = "<em>" + name + "</em>";
      return name;
    }

    /**
     * Getter function returns asset name preceded either by definite
     * article or indefinite article, depending on what's set
     * for the asset's use_definite_article_in_lists property.
     * @var {Getter} adventurejs.Asset#article_name
     * @returns {String}
     */
    get article_name() {
      var article = this.use_definite_article_in_lists
        ? this.definite_article
        : this.indefinite_article;
      return article + " " + this.name;
    }

    /**
     * Getter function returns asset name or proper name, depending
     * on settings.
     * @var {Getter} adventurejs.Asset#articlename
     * @returns {String}
     */
    get articlename() {
      var name;
      if (this.propername) {
        name = this.propername;
      } else if (this.name_is_proper) {
        name = this.name;
      } else {
        name = this.definite_article + " " + this.name;
      }
      if (this.print_bold) name = "<strong>" + name + "</strong>";
      if (this.print_italic) name = "<em>" + name + "</em>";
      return name;
    }

    /**
     * Returns this.articlename with propercase.
     * @var {Getter} adventurejs.Asset#Articlename
     * @returns {String}
     */
    get Articlename() {
      return A.propercase(this.articlename);
    }

    get adjectives() {
      return this.__adjectives;
    }
    set adjectives(arr) {
      if (false === Array.isArray(this.__adjectives)) {
        this.__adjectives = [];
      }
      this.__adjectives = arr;
    }

    /**
     * An alias to descriptions.look.
     * @var {*} adventurejs.Asset#description
     */
    get description() {
      if (
        Array.isArray(this.descriptions.look) ||
        "string" === typeof this.descriptions.look ||
        "function" === typeof this.descriptions.look
      ) {
        return this.descriptions.look;
      }
      if (
        "object" === typeof this.descriptions.look &&
        this.descriptions.look.default
      ) {
        return this.descriptions.look.default;
      }
      return `${this.Articlename} is undescribed. `;
    }
    set description(look) {
      this.descriptions.look = look;
    }

    get collection() {
      return this.__collection;
    }
    set collection(arr) {
      if (false === Array.isArray(this.__collection)) {
        this.__collection = [];
      }
      this.__collection = A.validateAssetList(arr);
    }

    /**
     * <strong>validate()</strong> provides an opportunity to
     * check author-made Assets for errors before initializing them.
     * @method adventurejs.Asset#validate
     * @memberOf adventurejs.Asset
     */
    validate(game) {
      this.game.log("log", 3, ["Validating " + this.id], "Asset");

      // has it got an id?
      if ("undefined" === typeof this.name) {
        var msg = "This " + this.constructor.name + " has no id: ";
        //console.error(msg, this);
        this.game.log("warn", 0, msg, "Asset");
        return false;
      }

      this.setVerbSubscriptionsWithAssets();
      this.setVerbSubscriptionsWithConnection();

      return true;
    }

    /**
     * <strong>initialize()</strong> is the final step of
     * creating a new game world asset, following
     * construction and validation. The chief job of
     * initialization is to add all of
     * this asset's words to
     * {@link adventurejs.Game#world_lookup | MyGame.world_lookup}.
     * <br><br>
     * Because we're not doing natural language processing
     * and everything is indexed, we want to increase the chances
     * that the parser understands player input that is partial or
     * has words jumbled. We add a lookup entry for every
     * combination of an object's adjectives with its noun(s).
     * For example we have a "green colored pencil", and we want
     * the parser to understand "green pencil" or "colored pencil".
     * If there are other colored pencils, we want the parser to
     * understand "colored pencils". If there are colored pencils
     * in three shades of green, we want the parser to understand
     * "green pencils". We store all of these combinations to the lookup.
     * @method adventurejs.Asset#initialize
     * @memberOf adventurejs.Asset
     */
    initialize(game) {
      if (this.is.initialized) return this;
      this.game.log("log", 3, "Initializing " + this.id);
      var id;
      var name;
      var names = [];
      var pairs = [];
      var synonyms = [];
      var adjectives = [];
      var group = [];
      var serialized_group = [];

      for (var a = 0; a < this.adjectives.length; a++) {
        var adjective = this.adjectives[a].trim();
        for (var i = 0; i < this.singlePluralPairs.length; i++) {
          if ("" === adjective || " " === adjective) {
            continue;
          }
          pairs.push([
            // example: brass lantern
            A.deserialize(adjective + " " + this.singlePluralPairs[i][0]),
            // example: brass lanterns
            A.deserialize(adjective + " " + this.singlePluralPairs[i][1]),
          ]);

          // TODO SERIALIZED LOOKUP?
          // does world_lookup really need serialized entries?
          // pairs.push(
          //   [
          //     // example: brass_lantern
          //     A.serialize( adjective + "_" + this.singlePluralPairs[i][0] ),
          //     // example: brass_lanterns
          //     A.serialize( adjective + "_" + this.singlePluralPairs[i][1] )
          //   ]
          // );
        }
      }
      this.singlePluralPairs = this.singlePluralPairs.concat(pairs);

      // Most objects will be listed in world_lookup.
      // zones are excluded
      if (this.exclude_from_lookup) {
      } else {
        // There shouldn't be any spaces by this point, but just in case.
        id = this.id.toLowerCase().split(" ");
        name = [this.name].slice(0);

        /**
         * By default we add the name, each word of the name
         * and each pair of words in the name.
         * Possibly excessive, but helps catch
         * typos in long names for use with "oops".
         * Can be disabled per asset by setting
         * asset.split_name_for_world_lookup = false.
         */
        if (this.split_name_for_world_lookup) {
          // add each word of the name
          names = this.name.toLowerCase().split(" ");

          if (2 <= names.length) {
            for (let i = names.length - 1; i > 0; i--) {
              // add each pair of words in the name
              // ie for "tiny silver key" we add "tiny silver" and "silver key"
              let wordPair = `${names[i - 1]} ${names[i]}`;
              if (-1 === names.indexOf(wordPair)) {
                names.push(wordPair);
              }
            }
          }
        }

        /**
         * We're going to pass these properties through addWordsToLookup which
         * is destructive, so we use copies in order to retain the originals.
         */
        synonyms = this.synonyms.slice(0);
        adjectives = this.adjectives.slice(0);
        group = this.group.slice(0);

        // added this because non-serialized group words
        // were being omitted from lookup
        serialized_group = this.group.slice(0);
        serialized_group = A.serializeArray(serialized_group);

        this.addWordsToLookup(["all"], "plural");
        this.addWordsToLookup(id, "id");
        this.addWordsToLookup(name, "name");
        this.addWordsToLookup(names, "name");
        this.addWordsToLookup(synonyms, "synonym");
        this.addWordsToLookup(adjectives, "adjective");
        this.addWordsToLookup(group, "group");
        this.addWordsToLookup(serialized_group, "group");
        //this.addWordsToLookup( serialized_adjectives, "group" );

        if (this.singlePluralPairs.length > 0) {
          for (var i = 0; i < this.singlePluralPairs.length; i++) {
            var singular = this.singlePluralPairs[i][0];
            var plural = this.singlePluralPairs[i][1];

            // is this unneccessarily indirect?
            this.addWordsToLookup([singular], "singular");
            this.addWordsToLookup([plural], "plural");

            /*
             * Add lookup entry for "all [plural]"
             * which is really the same as just "[plural]"
             * Example:
             *  take keys
             *  take all keys
             * Are the same.
             * And don't add "all all".
             */
            if (false === this instanceof adventurejs.All) {
              this.addWordsToLookup([A.deserialize("all " + plural)], "plural");
              // TODO SERIALIZED LOOKUP?
              //this.addWordsToLookup( [ A.serialize( "all_" + plural ) ], "plural" );
            }

            // i'm not sure the singular needs a reference to the plural
            this.game.world_lookup[singular].plural = plural;

            // the plural word def needs a reference to the singular
            this.game.world_lookup[plural].singular = singular;

            if (false === this instanceof adventurejs.All) {
              // all plural
              this.game.world_lookup[A.deserialize("all " + plural)].singular =
                singular;
              // TODO SERIALIZED LOOKUP?
              //this.game.world_lookup[ A.serialize( "all_" + plural ) ].singular = singular;
            }
          }
        }
      }

      return this;
    }
  }

  adventurejs.Asset = Asset;
  var p = Asset.prototype;

  /**
   * <strong>aliases()</strong> is a collection of method
   * names that are meant for authors to use. Since they
   * don't exist on all classes, we set up these aliases
   * so that, if authors call them on classes they're not
   * applicable to, they will politely return null instead
   * of throwing a "not a function" error.
   * @method adventurejs.Asset#aliases
   * @memberOf adventurejs.Asset
   */
  p.aliases =
    p.$isIn =
    p.$is =
    p.$has =
    p.$put =
    p.$moveTo =
    p.$moveFrom =
    p.$get =
    p.$room =
    p.$exits =
    p.$directions =
    p.$player =
    p.$inventory =
    p.$nest =
    p.$nested =
    p.$getKeys =
    p.$getKey =
    p.$hasKey =
    p.$parent =
    p.$ =
      function Asset_aliases() {
        return null;
      };
})();

// $can.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;

  /**
   * <strong>$can()</strong> is a general method for
   * getting at asset properties stored in asset.can.
   * @method adventurejs.Asset#$can
   * @memberOf adventurejs.Asset
   */
  p.$can = function Asset_can(property, asset) {
    if (!property || !asset) return false;
    return asset.can[property] ? true : false;
  };
})();

// $has.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>has</strong> is an alias to asset.isIn()
   * that reverses the direct and indirect objects, to test 
   * whether that asset is in this asset.
   * <pre class="display"><code class="language-javascript">if( MyGame.$('crown').$has('jewel') ){ // do stuff }
   * </code></pre>
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#has
   */
  p.$has = function Asset_has( object ) 
  {
    return object.isIn( this );
  }
}());
// $is.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>$is()</strong> is a generalized method for 
   * getting various asset states, usually stored in the 
   * <code><a href="#property_is">asset.is</a></code> 
   * nested object. It can also test 
   * for more complex circumstances, such as in the case of 
   * Tangibles. For example, if your game has a sword in a stone,
   * you can test whether the sword is currently in the stone with
   * <code>MyGame.$("sword").is("in", "stone")</code>
   * @method adventurejs.Asset#$is
   * @memberOf adventurejs.Asset
   */
  p.$is = function Asset_is( property, asset )
  {
  }

}());
// $must.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;

  /**
   * <strong>$must()</strong> is a general method for
   * getting at asset properties stored in asset.must.
   * @method adventurejs.Asset#$must
   * @memberOf adventurejs.Asset
   */
  p.$must = function Asset_must(property, asset) {
    if (!property || !asset) return false;
    return asset.must[property] ? true : false;
  };
})();

// addWordsToLookup.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * <strong>addWordsToLookup()</strong> takes words associated with
   * this asset and adds them to the global lookup table.
   * @method adventurejs.Asset#addWordsToLookup
   * @memberOf adventurejs.Asset
   * @param {Array} words
   * @param {String} type
   */
  p.addWordsToLookup = function Asset_addWOrdsToLookup(words, type) {
    if (!words.length) return;
    while (words.length > 0) {
      if (!words[0] || "string" !== typeof words[0] || " " === words[0]) {
        words.shift();
        continue;
      }

      words[0] = words[0].trim();

      // is this word not in our lookup yet?
      if (false === words[0] in this.game.world_lookup) {
        this.game.world_lookup[words[0]] = {};
        this.game.world_lookup[words[0]].IDs = [];

        if (type) {
          this.game.world_lookup[words[0]].type = type;
        }
      }

      // is current object represented by this word yet?
      if (-1 === this.game.world_lookup[words[0]].IDs.indexOf(this.id)) {
        this.game.world_lookup[words[0]].IDs.push(this.id);
      }

      words.shift();
    }

    return;
  };
})();

// Asset_Can.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Can
   * @augments adventurejs.StateManager
   * @class adventurejs.Asset_Can
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <p>
   * <strong>Asset_Can</strong> is a state management class for all {@link adventurejs.Asset|Assets}.
   * used to store a variety of booleans.
   **/

  class Asset_Can extends adventurejs.StateManager {
    constructor(name = "can", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Asset_Can";

      return this;
    }
  }
  adventurejs.Asset_Can = Asset_Can;
})();

// Asset_Is.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Is
   * @augments adventurejs.StateManager
   * @class adventurejs.Asset_Is
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <p>
   * <strong>Asset_Is</strong> is a state management class for all {@link adventurejs.Asset|Assets}.
   * used to store general state variables.
   **/

  class Asset_Is extends adventurejs.StateManager {
    constructor(name = "is", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Asset_Is";

      /**
       * Used to track whether player knows about an asset.
       * @var {Boolean} adventurejs.Asset#is!known
       * @default false
       * @todo In games with multiple characters, any character the player takes
       * will share this knowledge. May want an option to set this per player character.
       */
      this._known = false;

      /**
       * Set to true when an object is removed from the game
       * by destruction.
       * @var {Boolean} adventurejs.Asset#is!destroyed
       * @default false
       */
      this.destroyed = false;

      /**
       * Set to true when an object is in the game.
       * @var {Boolean} adventurejs.Asset#is!extant
       * @default true
       */
      this.extant = true;

      /**
       * Set whether object is a collection of other object IDs.
       * @var {Boolean} adventurejs.Asset#is!collection
       * @default true
       */
      this.collection = false;

      /**
       * Used at runtime to keep track of asset's validation state.
       * @var {Boolean} adventurejs.Asset#is!validated
       * @default false
       */
      this.validated = false;

      /**
       * Used at runtime to keep track of asset's initialization state.
       * @var {Boolean} adventurejs.Asset#is!initialized
       * @default false
       */
      this.initialized = false;

      /**
       * Almost all assets are given a name which is then used to create
       * their id, with some exceptions.
       * For example, exit ids are generated by taking the name of the
       * exit's room + the exit's direction.
       * @var {Boolean} adventurejs.Asset#is!nameless
       * @default false
       */
      this.nameless = false;

      /**
       * Almost all tangible assets have a singular location.
       * Global assets are available in all locations
       * in order to catch player input.
       * @var {Boolean} adventurejs.Asset#is!global
       * @default false
       */
      this.global = false;

      /**
       * Abstractions are universally available and bypass reachability tests.
       * @var {Boolean} adventurejs.Asset#is!abstract
       * @default false
       */
      this.abstract = false;

      /**
       * Meant for use to distinguish some assets as being singular
       * in the game world.
       * @var {Boolean} adventurejs.Asset#is!singleton
       * @default false
       * @todo Have only applied this to several special global assets,
       * and have not implemented any code around it. Is it still useful?
       */
      this.singleton = false;

      return this;
    }

    get known() {
      return this._known;
    }
    set known(known) {
      this._known = known;
    }
  }
  adventurejs.Asset_Is = Asset_Is;
})();

// Asset_Must.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Must
   * @augments adventurejs.StateManager
   * @class adventurejs.Asset_Must
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <strong>Asset_Must</strong> is a state management class
   * used to store a variety of booleans for
   * {@link adventurejs.Asset|Assets}.
   **/

  class Asset_Must extends adventurejs.StateManager {
    constructor(name = "can", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Asset_Must";

      return this;
    }
  }
  adventurejs.Asset_Must = Asset_Must;
})();

// callAction.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * Check if this asset has a general verb action or reaction
   * for the specified event,
   * or if the asset has an action for the specific asset.
   * If either form
   * is found, pass it to getStringOrArrayOrFunction and
   * return the results. If the result returns false or null
   * it will terminate the calling verb's default behavior.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#callAction
   * @param {string} hook
   * @param {string} asset_name We use asset.name here instead of asset.id
   * in support of authors, because we're never asking them to deal in IDs,
   * only names. Hooks will only be defined by authors, so we let them use
   * asset.name as their identifier. We do however make an effort to see if
   * an id has been passed instead of a name, because Ivan.
   * @param {object} params Arbitrary parameter object.
   * @return {Boolean}
   */
  p.callAction = function Asset_callActions(
    hook_name,
    passed_asset_name,
    params = {}
  ) {
    params = params !== null && params !== undefined ? params : {};
    this.game.log(
      "log",
      "high",
      `${this.id}.callAction > ${hook_name}`,
      "Behavior"
    );
    if (!hook_name || !this[hook_name]) return;
    let input = this.game.getInput();
    let player, asset2, asset3;

    if (passed_asset_name) {
      // if an asset was passed, disregard assets retrieved from input
      asset2 = passed_asset_name.class
        ? passed_asset_name
        : this.game.getAsset(passed_asset_name);
    } else {
      asset2 = input.getAsset(2);
      asset3 = input.getAsset(3);
      if (!asset2) asset2 = this.game.getPlayer();
    }

    // look for a generic hook
    let hook = this[hook_name];
    if ("function" === typeof hook) {
      return hook.call(this, params);
    }

    // see if hook is an object containing other properties,
    // where we expect to find asset names
    if ("function" === typeof hook[asset2.name]) {
      return hook[asset2.name].call(this, params);
    }

    if (
      hook[asset2.name] &&
      asset3 &&
      "function" === typeof hook[asset2.name][asset3.name]
    ) {
      return hook[asset2.name][asset3.name].call(this, params);
    }
    return;
  };
})();

// canSetVerbState.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>canSetVerbState</strong> is a method to check whether 
   * the specified verb can set state on this asset. Assumes that 
   * asset.dov[verb].enabled is true
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#canSetVerbState
   * @param {String} verb
   * @returns {Boolean}
   */

  p.canSetVerbState = function Asset_canSetVerbState(verb)
  {
    if( !this.game.dictionary.verbs[verb] ) return false;
    if( !this.game.dictionary.verbs[verb].state 
      && !this.game.dictionary.verbs[verb].unstate ) return false;
    if( !this.dov[verb]?.enabled ) return false;

    verb = this.game.dictionary.verbs[verb];

    // ex: do verb close to this and this.is.closed
    if( verb.state && this.is[verb.state] ) return false;

    // ex: do verb open to this and !this.is.closed
    if( verb.unstate && !this.is[verb.unstate] ) return false;

    return true;
  }
}());
// destroy.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>destroy</strong> is called to remove an asset
   * from the game world.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#destroy
   * @todo What else needs to happen on destroy?
   */
  p.destroy = function Asset_destroy()
  {
    this.is.destroyed = true;
    this.is.extant = false;

    var results = this.callAction("doDestroyThis");
    if( "undefined" !== typeof results ) return results;            

    return;
  }
}());
// didDoVerbs.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>didDoVerbs</strong> check whether any of 
   * the specified verbs has ever been applied to the asset
   * as a direct object. This is a convenience method that 
   * relies on asset.DOVdidDo()
   * @method adventurejs.Asset#didDoVerbs
   * @memberOf adventurejs.Asset
   * @param {Array} verbs 
   * @returns {Boolean}
   */
  p.didDoVerbs = function Asset_didDoVerbs( verbs )
  {
    if( !Array.isArray(verbs) ) return false;
    for(var i = 0; i < verbs.length; i++ )
    {
      if( this.DOVdidDo(verbs[i]) ) return true;
    }
    return false;
  }
}());
// didIoVerbs.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
/**
 * <strong>didIoVerbs</strong> check whether any of 
 * the specified verbs has ever been applied to the asset
 * as an indirect object. This is a convenience method that 
 * relies on asset.IOVdidDo()
 * @method adventurejs.Asset#didIoVerbs
 * @memberOf adventurejs.Asset
 * @param {Array} verbs 
 * @returns {Boolean}
 */
p.didIoVerbs = function Asset_didIoVerbs( verbs )
{
  if( !Array.isArray(verbs) ) return false;
  for(var i = 0; i < verbs.length; i++ )
  {
    if( this.IOVdidDo(verbs[i]) ) return true;
  }
  return false;
}
}());
// DOVallowOnce.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVallowOnce</strong> is a method to check whether 
   * this asset is subscribed to allow the specified verb to act on it
   * as a direct object only once.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVallowOnce
   * @param {String} verb
   * @returns {Boolean}
   */
  p.DOVallowOnce = function Asset_DOVallowOnce(verb)
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !this.dov[verb]?.enabled ) return false;
    return this.dov[verb].once;
  }
}());
// DOVallowWithAnything.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVallowWithAnything</strong> is a method 
   * to check whether this asset is subscribed to act as a direct 
   * object with the specified verb without any direct object.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVallowWithAnything
   * @param {String} verb
   * @returns {Boolean}
   */
  p.DOVallowWithAnything = function Asset_DOVallowWithAnything(verb)
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !this.dov[verb] ) return false;
    return this.dov[verb].with_anything;
  }
}());
// DOVallowWithAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVallowWithAsset</strong> is a method 
   * to check whether this asset is subscribed to act
   * as a direct object with the specified verb and indirect object.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVallowWithAsset
   * @param {String} verb
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.DOVallowWithAsset = function Asset_DOVallowWithAsset(verb, asset)
  {
    if( "string" === typeof asset) asset = this.game.getAsset(asset);
    if( !asset || !asset.id ) return false;
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;

    if(!this.isDOV(verb)) return false;

    verb = this.game.dictionary.verbs[verb];

    if( -1 !== this.dov[verb.name].with_assets.indexOf( asset.id ) )
    {
      return true;
    }

    // is asset class in this.dov[verb].with_classes ?
    let classes = this.dov[verb.name].with_classes;
    for(let i = 0; i < classes.length; i++ ) {
      if( asset instanceof adventurejs[ classes[i] ] )
      {
        return true;
      }
    }
    
    return false;

  }
}());
// DOVallowWithNothing.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * <strong>DOVallowWithNothing</strong> is a method
   * to check whether this asset is subscribed to act as a direct
   * object with the specified verb without any indirect object.
   * For example, "plug in computer" where when an outlet is
   * implied but not defined.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVallowWithNothing
   * @param {String} verb
   * @returns {Boolean}
   */
  p.DOVallowWithNothing = function Asset_DOVallowWithNothing(verb) {
    if (!verb || !this.game.dictionary.verbs[verb]) return false;
    console.warn("verb", verb);
    console.warn("!this.dov[verb]", !this.dov[verb]);
    console.warn("this.dov[verb]", this.dov[verb]);
    console.warn("this.dov[verb].with_nothing", this.dov[verb].with_nothing);
    if (!this.dov[verb]) return false;
    return this.dov[verb].with_nothing;
  };
})();

// DOVdidDo.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVdidDo</strong> is a method to check whether 
   * this asset was already used as a direct objecb by the 
   * specified verb.
   * <br><br>
   * <strong>_didDo</strong> is an alias meant for authors.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVdidDo
   * @param {String} verb
   * @returns {Boolean}
   */
  p.DOVdidDo = p._didDo = function Asset_DOVDidDo(verb)
  { 
    if( !verb 
      || !this.game.dictionary.verbs[verb]
      || !this.dov[verb] ) 
      {
        return false;
      }
    return this.dov[verb].did_do;
  }
}());
// DOVdidDoCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVdidDoCount</strong> is a method to get 
   * a count of times this asset was used 
   * as a direct object by the specified verb.
   * <br><br>
   * <strong>_doCount</strong> is an alias meant for authors.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVdidDoCount
   * @param {String} verb
   * @returns {Int}
   */
  p.DOVdidDoCount = p._doCount = function Asset_DOVDidDoCount(verb)
  { 
    if( !verb || !this.game.dictionary.verbs[verb] ) return 0;
    if( !this.dov[verb] ) return 0;
    return this.dov[verb].do_count;
  }
}());
// DOVdidTry.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVdidTry</strong> is a method to check whether 
   * it was attempted to use this asset as a direct object by the specified verb.
   * <br><br>
   * <strong>_didTry</strong> is an alias meant for authors.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVdidTry
   * @param {String} verb
   * @returns {Boolean}
   */
  p.DOVdidTry = p._didTry = function Asset_DOVdidTry(verb)
  { 
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( this.dov[verb] ) 
    {
      return this.dov[verb].did_try;
    }
    else if( this.did_try_verb_count[verb] )
    {
      return this.did_try_verb_count[verb]?.noun1 > 0;
    }
    return false;
  }
}());
// DOVdidTryCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVdidTryCount</strong> is a method to get 
   * a count of times it was tried to use this asset 
   * as a direct object by the specified verb.
   * <br><br>
   * <strong>_tryCount</strong> is an alias meant for authors.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVdidTryCount
   * @param {String} verb
   * @returns {Boolean}
   */
  p.DOVdidTryCount = p._tryCount = function Asset_DOVDidTryCount(verb)
  { 
    if( !verb || !this.game.dictionary.verbs[verb] ) return 0;
    if( this.dov[verb] ) 
    {
      return this.dov[verb].try_count;
    }
    else if( this.did_try_verb_count[verb] )
    {
      return this.did_try_verb_count[verb].noun1; 
    }
    return 0;
  }
}());
// DOVgetConnectionCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Return 
   * this.dov[verb].with_params.connections.length
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#DOVgetConnectionCount
   * @param {String} verb The name of a verb.
   * @return {Int}
   */
  p.DOVgetConnectionCount = function Asset_DOVgetConnectionCount(verb) 
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return 0;
    if( this.dov[verb]?.with_params.connections )
    {
      return this.dov[verb].with_params.connections.length;
    }  
    return 0;
  }
}());
// DOVgetConnections.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Return 
   * this.dov[verb].with_params.connections
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#DOVgetConnections
   * @param {String} verb The name of a verb.
   * @return {Array}
   */
  p.DOVgetConnections = function Asset_DOVgetConnections(verb) 
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return [];
    return this.dov[verb]?.with_params.connections || [];
  }
}());
// DOVgetMaxConnections.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Return 
   * this.dov[verb].with_params.max_connections
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#DOVgetMaxConnections
   * @param {String} verb The name of a verb.
   * @return {Int}
   */
  p.DOVgetMaxConnections = function Asset_DOVgetMaxConnections(verb) 
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return 0;
    if( this.dov[verb]?.with_params.max_connections )
    {
      return this.dov[verb].with_params.max_connections;
    }  
    return 0;
  }
}());
// DOVhasIndirectObjects.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVhasIndirectObjects</strong> is a method to check 
   * whether this asset has any particular indirect objects specified 
   * by the author for use with the specified verb.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVhasIndirectObjects
   * @param {String} verb
   * @returns {Boolean}
   */

  p.DOVhasIndirectObjects = function Asset_DOVhasIndirectObjects(verb)
  {
    if(!this.isDOV(verb)) return false;

    // is this.dov[verb].with_assets !empty?
    if( this.dov[verb]?.with_assets.length )
    {
      return true;
    }

    // is this.dov[verb].with_classes !empty?
    if( this.dov[verb]?.with_classes.length )
    {
      return true;
    }
    
    return false;

  }
}());
// DOVhasMaxConnections.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Get whether the DOV has maximum connections.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#DOVhasMaxConnections
   * @param {String} verb The name of a verb.
   * @return {Boolean}
   */
  p.DOVhasMaxConnections = function Asset_DOVhasMaxConnections(verb) 
  {
    // no verb or not DOV, not max
    if( !verb || !this.game.dictionary.verbs[verb] ) return true;
    if( !this.dov[verb] ) return true;

    // no connections at all? is max
    if( !this.dov[verb].with_params.connections ) return true;

    // no max connections set? not max
    if( "undefined" === typeof this.dov[verb].with_params.max_connections ) return false;

    // max greater than actual? not max
    if( this.dov[verb].with_params.max_connections >= 
      this.dov[verb].with_params.connections.length )
    {
      return false;
    }

    // assume it's max
    return true;
  }
}());
// DOVincrementDoCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVincrementDoCount</strong> is a method to increment the number
   * of times the specified verb has acted on this asset as a direct object. 
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVincrementDoCount
   * @param {String} verb
   */

  p.DOVincrementDoCount = function Asset_DOVincrementDoCount(verb)
  {
    if( verb 
      && this.game.dictionary.verbs[verb]
      && this.dov[verb] ) 
      {
        this.dov[verb].incrementDoCount();
      }
  }
}());
// DOVincrementTryCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVincrementTryCount</strong> is a method to increment the number
   * of times the specified verb has been tried on this asset as a direct object. 
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVincrementTryCount
   * @param {String} verb
   */

  p.DOVincrementTryCount = function Asset_DOVincrementTryCount(verb)
  {
    if( verb 
      && this.game.dictionary.verbs[verb]
      && this.dov[verb] ) 
      {
        this.dov[verb].incrementTryCount();
      }
  }
}());
// DOVisConnectedToAnything.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Check whether this asset is currently connected to anything
   * directly by a verb such as <code class="property">plugIn</code>
   * or <code class="property">tie</code>. For example, if this asset 
   * is a computer plugged into an outlet, this method would return true.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#DOVisConnectedToAnything
   * @param {String} verb The name of a verb.
   * @return {Boolean}
   */
  p.DOVisConnectedToAnything = function Asset_DOVisConnectedToAnything(verb) 
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( this.dov[verb]?.with_params.connections?.length )
    {
      return true;
    }  
    return false;
  }
}());
// DOVisConnectedToAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Check whether this asset is currently connected as a direct
   * object to the specified indirect object by the specified verb.
   * For example, in the case of a computer plugged into an outlet, 
   * the computer would be the direct object, and calling this method 
   * on it would return true.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#DOVisConnectedToAsset
   * @param {String} verb The name of the verb to test.
   * @param {Object|String} asset A game asset or asset id to test.
   * @return {Boolean}
   */
  p.DOVisConnectedToAsset = function Asset_DOVisConnectedToAsset(verb,asset) 
  { 
    if( "string" === typeof asset) asset = this.game.getAsset(asset);
    if( !asset || !asset.id ) return false;
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( this.dov[verb]?.with_params.connections
      && -1 !== this.dov[verb].with_params.connections.indexOf(asset.id) )
      {
        return true;
      }    
    return false;
  }
}());
// DOVisConnectedToNothing.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Check whether this asset is currently connected as an indirect
   * object to nothing by the specified verb.
   * For example, in the case of a computer that can be plugged in, an
   * author might prefer not to create a specific outlet into which to 
   * plug the computer. For that case we allow 'plug in computer', and 
   * store a null value to 
   * <code class="property">asset.dov.plugIn.with_params.connections</code>
   * to represent the computer's plugged in state.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#DOVisConnectedToNothing
   * @param {String} verb The name of a verb.
   * @return {Boolean}
   */
  p.DOVisConnectedToNothing = function Asset_DOVisConnectedToNothing(verb)
  { 
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !this.dov[verb]?.with_params.connections
      || -1 === this.dov[verb].with_params.connections.indexOf(null) )
      {
        return false;
      }
    return true;
  }
}());
// DOVsetConnection.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Set asset's direct verb param connection to specified indirect object.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#DOVsetConnection
   * @param {String} verb
   * @param {Object} asset
   */
  p.DOVsetConnection = function Asset_DOVsetConnection( verb, asset )
  {
    if( "string" === typeof asset) asset = this.game.getAsset(asset);
    if( !asset || !asset.id ) return false;
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;

    this.game.dictionary.verbs[verb].setVerbSubscriptionConnection( this, asset );
  }
}());

// DOVsetWithAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVsetWithAsset</strong> is used to specify 
   * another asset that can be used as an indirect object with this 
   * asset as direct object. For example, if this asset is a locking
   * chest, chest.DOVsetWithAsset('unlock', 'gold key') would add 
   * the gold key as an indirect object of the chest.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVsetWithAsset
   * @param {String} verb
   * @param {Object} asset
   * @returns {Boolean}
   */

  p.DOVsetWithAsset = function Asset_DOVSetWithAsset(verb, asset)
  { 
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( "string" === typeof asset ) asset = this.game.getAsset(asset);
    if( !asset ) return false;

    // verify that this is set as a direct object of verb
    if(!this.isDOV(verb))
    {
      this.setDOV(verb);
    }

    // verify that indirect object isn't already set
    if( -1 === this.dov[verb].with_assets.indexOf( asset.id ) )
    {
      this.dov[verb].with_assets.push( asset.id );
    }
   
    // that it works with an asset means it doesn't work with nothing
    this.dov[verb].with_nothing = false;

    return true;
  }
}());
// DOVsetWithClass.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>DOVsetWithClass</strong> is a method to add an indirect object 
   * class to asset.dov[verb].with_classes.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#DOVsetWithClass
   * @param {String} verb
   * @param {String} clas
   * @returns {Boolean}
   */

  p.DOVsetWithClass = function Asset_DOVsetWithClass(verb, clas)
  { 
    var object_of = 'dov';
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !adventurejs[clas] ) return false;
    if(!this.isDOV(verb))
    {
      this.setDOV(verb);
    }
    if( -1 === this[object_of][verb].with_classes.indexOf( clas ) )
    {
      this[object_of][verb].with_classes.push( clas );
    }
    return true;
  }
}());
// DOVunsetConnection.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Unset asset's direct verb param connection to specified indirect object.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#DOVunsetConnection
   * @param {String} verb
   * @param {Object} asset
   */
  p.DOVunsetConnection = function Asset_DOVunsetConnection( verb, asset )
  {
    if( "string" === typeof asset) asset = this.game.getAsset(asset);
    if( !asset || !asset.id ) return false;
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;

    this.game.dictionary.verbs[verb].unsetVerbSubscriptionConnection( this, asset );
  }
}());

// getDescription.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * Get a description, such as "look in book", where
   * "in" has been defined as a key at
   * asset.descriptions.in.
   * "look" is always the default description.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#getDescription
   * @param {String} description
   * @return {String}
   */
  p.getDescription = function Asset_getDescription(description) {
    description = description || "look";
    if (!this.descriptions[description]) description = "look";
    if (this.descriptions[description]) {
      if (
        Array.isArray(this.descriptions[description]) ||
        "string" === typeof this.descriptions[description] ||
        "function" === typeof this.descriptions[description]
      ) {
        return A.getSAF.call(this.game, this.descriptions[description]);
      }

      if (
        "object" === typeof this.descriptions[description] &&
        this.descriptions[description].default
      ) {
        return A.getSAF.call(this.game, this.descriptions[description].default);
      }
    }

    return `${this.Articlename} is undescribed. `;
  };
})();

// getIndirectDescription.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * Get indirect description,
   * such as "look at this through magnifying glass", where
   * "through magnifying glass" is a key at
   * asset.descriptions["through magnifying glass"].description
   * "look" is always the default direct object description.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#getIndirectDescription
   * @param {String} indirect_aspect
   * @param {Object} indirect_asset
   * @param {String} direct_aspect
   * @return {String}
   */
  p.getIndirectDescription = function Asset_getIndirectDescription(
    direct_aspect,
    indirect_aspect,
    indirect_asset
  ) {
    if (direct_aspect === "at") direct_aspect = "look";
    direct_aspect = direct_aspect || "look";

    if (!indirect_aspect || !indirect_asset) {
      return this.getDescription(direct_aspect);
    }

    let target = `${indirect_aspect} ${indirect_asset.name}`;

    if (
      this.descriptions[direct_aspect] &&
      this.descriptions[direct_aspect][target]
    ) {
      return A.getSAF.call(this.game, this.descriptions[direct_aspect][target]);
    }

    return this.getDescription(direct_aspect);
  };
})();

// hasAction.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * Check if this asset has a general verb action or reaction
   * for the specified event,
   * or if the asset has an action for the specific asset.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#hasAction
   * @param {string} hook_name
   * @param {string} asset1_name We use asset.name here instead of asset.id
   * to make life slightly easier for authors. Asset IDs are formed from
   * asset names, but generally we don't expect authors to be aware of IDs.
   * Hooks will only be defined by authors, so let them use asset.name
   * as their identifier. We do however make an effort to see if an id has been
   * passed instead of a name.
   * @param {string} asset2_name
   * @return {Boolean}
   */
  p.hasAction = function Asset_hasAction(hook_name, asset1_name, asset2_name) {
    if (!hook_name || !this[hook_name]) return;
    var asset1, asset2;
    if (asset1_name) {
      asset1 = asset1_name.class
        ? asset1_name
        : this.game.getAsset(asset1_name);
      asset1_name = asset1?.name || asset1_name;
    }
    if (asset2_name) {
      asset2 = asset2_name.class
        ? asset2_name
        : this.game.getAsset(asset2_name);
      asset2_name = asset2?.name || asset2_name;
    }

    // look for a generic hook
    let hook = this[hook_name];
    if ("function" === typeof hook) {
      return true;
    }

    // look for a specific hook
    if ("function" === typeof hook[asset1_name]) {
      return true;
    }

    if (
      hook[asset1.name] &&
      "function" === typeof hook[asset1.name][asset2.name]
    ) {
      return true;
    }

    return false;
  };
})();

// hasDescription.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * See if asset has a description for an aspect, 
   * such as "look in book", where
   * "in" has been defined as a key at 
   * asset.descriptions.in.
   * "look" is always the default description.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#hasDescription
   * @param {String} description
   * @return {String|Boolean}
   */
  p.hasDescription = function Asset_hasDescription( description )
  {
    description = description || "look";    
    if( this.descriptions[ description ] )
    {
      return true; 
    }
    return false;
  }
}());
// hasIndirectDescription.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Determine whether asset has an indirect description, 
   * such as "look at this through magnifying glass", where
   * "through magnifying glass" becomes a key at 
   * asset.descriptions["through magnifying glass"].
   * "look" is always the default direct object description.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#hasIndirectDescription
   * @param {String} indirect_aspect
   * @param {Object} indirect_asset
   * @param {String} direct_aspect
   * @return {String|Boolean}
   */
  p.hasIndirectDescription = function Asset_hasIndirectDescription( direct_aspect, indirect_aspect, indirect_asset )
  {
    if( !indirect_aspect || !indirect_asset ) return false;
    if( direct_aspect === "at" ) direct_aspect = "look";
    direct_aspect = direct_aspect || "look";

    let target = `${indirect_aspect} ${indirect_asset.name}`;

    if( this.descriptions[ direct_aspect ]
    && this.descriptions[ direct_aspect ][ target ] )
    {
      return true;
    }

    return false;
  }
}());
// incrementDoVerbCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>incrementDoVerbCount</strong> takes a verb and an index and 
   * updates this asset's count of the number of times the verb has 
   * acted upon it. 
   * @method adventurejs.Asset#incrementDoVerbCount
   * @memberOf adventurejs.Asset
   * @param {String} verb 
   * @param {Int} index
   * 
   */
  p.incrementDoVerbCount = function Asset_incrementDoVerbCount( verb, index ) 
  {

  // this is questionable because it treats 
  // direct / indirect objects the same
  this.did_do_verb[verb] = true;

  /** @TODO replace linked_asset with a method to get any linked assets */
  var linked_asset;
  if( this.linked_asset ) 
  {
    linked_asset = this.game.getAsset( this.linked_asset );
    if(linked_asset) linked_asset.did_do_verb[verb] = true;
  }  

  if( !this.did_do_verb_count[ verb ] ) 
  {
    this.did_do_verb_count[ verb ] = { all:1, noun1:0, noun2:0, noun3:0 };
    if( linked_asset ) linked_asset.did_do_verb_count[ verb ] = { all:1, noun1:0, noun2:0, noun3:0 };
  } 
  else 
  {
    this.did_do_verb_count[ verb ].all++;
    if( linked_asset ) linked_asset.did_do_verb_count[ verb ].all++;
  }

  if( index ) 
  {
    // we have two verb counting systems
    // did_do_verb_count is the original
    // it counts verb attempts on all assets 
    // regardless of verb subscriptions
    this.did_do_verb_count[ verb ][ "noun" + index ]++;
    if( linked_asset ) linked_asset.did_do_verb_count[ verb ][ "noun" + index ]++;

    // DOVincrementDoCount came with verb subscriptions
    // it only counts verb attempts 
    // on assets with verb subscriptions
    switch(index){
      case 1: this.DOVincrementDoCount( verb ); break;
      case 2: 
        if(this.isIOV(verb) )
        {
          this.IOVincrementDoCount( verb ); 
        }
        // noun2 is usually indirect object but 
        // may be a direct object with some verbs
        else if(this.isDOV(verb) )
        {
          this.DOVincrementDoCount( verb ); 
        }
        break;
      case 3: this.IOVincrementDoCount( verb ); break;
    }
  }
}
}());
// incrementTryVerbCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
/**
* <strong>incrementTryVerbCount</strong> takes a verb and an index and 
* updates this asset's count of the number of times the verb has 
* attempted upon it. 
* @method adventurejs.Asset#incrementTryVerbCount
* @memberOf adventurejs.Asset
* @param {String} verb 
* @param {Int} index
*/
p.incrementTryVerbCount = function Asset_incrementTryVerbCount( verb, index ) 
{

  this.did_try_verb[verb] = true;

  var linked_asset;
  if( this.linked_asset ) 
  {
    linked_asset = this.game.getAsset( this.linked_asset );
    if(linked_asset) linked_asset.did_try_verb[verb] = true;
  }

  if( !this.did_try_verb_count[ verb ] ) 
  {
    this.did_try_verb_count[ verb ] = { all:1, noun1:0, noun2:0, noun3:0 };
    if( linked_asset ) linked_asset.did_try_verb_count[ verb ] = { all:1, noun1:0, noun2:0, noun3:0 };
  } 
  else 
  {
    this.did_try_verb_count[ verb ].all++;
    if( linked_asset ) linked_asset.did_try_verb_count[ verb ].all++;
  }

  if( index ) 
  {
    // we have two verb counting systems
    // did_try_verb_count is the original
    // it counts verb attempts on all assets 
    // regardless of verb subscriptions
    this.did_try_verb_count[ verb ][ "noun" + index ]++;
    if( linked_asset ) linked_asset.did_try_verb_count[ verb ][ "noun" + index ]++;

    // DOVincrementTryCount came with verb subscriptions
    // it only counts verb attempts 
    // on assets with verb subscriptions
    switch(index){
      case 1: this.DOVincrementTryCount( verb ); break;
      case 2: 
        if(this.isIOV(verb) )
        {
          this.IOVincrementTryCount( verb ); 
        }
        // noun2 is usually indirect object but 
        // may be a direct object with some verbs
        else if(this.isDOV(verb) )
        {
          this.DOVincrementTryCount( verb ); 
        }
        break;
      case 3: this.IOVincrementTryCount( verb ); break;
    }

  }
}
}());
// IOVallowOnce.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVallowOnce</strong> is a method to check whether 
   * this asset is subscribed to allow the specified verb to act on it
   * as an indirect object only once.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVallowOnce
   * @param {String} verb
   * @returns {Boolean}
   */
  p.IOVallowOnce = function Asset_IOVallowOnce(verb)
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !this.iov[verb]?.enabled ) return false;
    return this.iov[verb].once;
  }
}());
// IOVallowWithAnything.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVallowWithAnything</strong> is a method 
   * to check whether this asset is subscribed to act
   * as an indirect object with the specified verb and any direct object.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVallowWithAnything
   * @param {String} verb
   * @returns {Boolean}
   */
  p.IOVallowWithAnything = function Asset_isIOVWithAnything(verb)
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if(!this.isIOV(verb)) return false;
    if( !this.iov[verb].with_anything ) return false;
    return true;
  }
}());
// IOVallowWithAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVallowWithAsset</strong> is a method 
   * to check whether this asset is subscribed to act
   * as an indirect object with the specified verb and direct object.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVallowWithAsset
   * @param {String} verb
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.IOVallowWithAsset = function Asset_isIOVWithAsset(verb, asset)
  {
    if( "string" === typeof asset) asset = this.game.getAsset(asset);
    if( !asset || !asset.id ) return false;
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if(!this.isIOV(verb)) return false;

    verb = this.game.dictionary.verbs[verb];

    // ex: do verb close with this to direct_object 
    // and direct_object.is.closed
    if( verb.state && asset.is[verb.state] ) return false;

    // ex: do verb open with this to direct_object 
    // and !direct_object.is.closed
    if( verb.unstate && !asset.is[verb.unstate] ) return false;

    // is asset id inthis.iov[verb].with_assets ?
    if( -1 !== this.iov[verb.name].with_assets.indexOf( asset.id ) )
    {
      return true;
    }

    // is asset class in this.iov[verb].with_classes ?
    var classes = this.iov[verb.name].with_classes;
    for(var i = 0; i < classes.length; i++ ) {
      if( asset instanceof adventurejs[ classes[i] ] )
      {
        return true;
      }
    }
    
    return false;

  }
}());
// IOVallowWithNothing.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVallowWithNothing</strong> is a method 
   * to check whether this asset is subscribed to act as an indirect 
   * object with the specified verb without any direct object.
   * Unlikely to happen but provided for completionism.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVallowWithNothing
   * @param {String} verb
   * @returns {Boolean}
   */
  p.IOVallowWithNothing = function Asset_IOVallowWithNothing(verb)
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !this.iov[verb] ) return false;
    return this.iov[verb].with_nothing;
  }
}());
// IOVdidDo.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVdidDo</strong> is a method to check whether 
   * this asset was already used as an indirect objecb by the specified verb.
   * <br><br>
   * <strong>_iDidDo</strong> is an alias meant for authors.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVdidDo
   * @param {String} verb
   * @returns {Boolean}
   */
  p.IOVdidDo = p._iDidDo = function Asset_IOVDidDo(verb)
  {
    if( !verb 
      || !this.game.dictionary.verbs[verb]
      || !this.iov[verb] ) 
      {
        return false;
      }
    return this.iov[verb].did_do;
  }
}());
// IOVdidDoCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVdidDoCount</strong> is a method to get 
   * a count of times this asset was used 
   * as an indirect object by the specified verb.
   * <br><br>
   * <strong>_iDoCount</strong> is an alias meant for authors.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVdidDoCount
   * @param {String} verb
   * @returns {Int}
   */
  p.IOVdidDoCount = p._iDoCount = function Asset_IOVDidDoCount(verb)
  { 
    if( !verb || !this.game.dictionary.verbs[verb] ) return 0;
    if( !this.iov[verb] ) return 0;
    return this.iov[verb].do_count;
  }
}());
// IOVdidTry.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVdidTry</strong> is a method to check whether 
   * it was attempted to use this asset as an indirect object by the specified verb.
   * <br><br>
   * <strong>_iDidTry</strong> is an alias meant for authors.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVdidTry
   * @param {String} verb
   * @returns {Boolean}
   */
  p.IOVdidTry = p._iDidTry = function Asset_IOVDidTry(verb)
  { 
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( this.iov[verb] ) 
    {
      return this.iov[verb].did_try;
    }
    else if( this.did_try_verb_count[verb] )
    {
      return ( this.did_try_verb_count[verb]?.noun2 > 0 || this.did_try_verb_count[verb]?.noun3 > 0 );
    }
    return false;
  }
}());
// IOVdidTryCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVdidTryCount</strong> is a method 
   * to get a count of times it was attempted to use this asset 
   * as an indirect object by the specified verb.
   * <br><br>
   * <strong>_iTryCount</strong> is an alias meant for authors.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVdidTryCount
   * @param {String} verb
   * @returns {Boolean}
   */
  p.IOVdidTryCount = p._iTryCount = function Asset_IOVDidTryCount(verb)
  { 
    if( !verb || !this.game.dictionary.verbs[verb] ) return 0;
    if( this.iov[verb] ) 
    {
      return this.iov[verb].try_count;
    }
    else if( this.did_try_verb_count[verb] )
    {
      if( this.did_try_verb_count[verb].noun2 > 0 ) return this.did_try_verb_count[verb].noun2; 
      if( this.did_try_verb_count[verb].noun3 > 0 ) return this.did_try_verb_count[verb].noun3; 
    }
    return 0;
  }
}());
// IOVgetConnectionCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Return 
   * this.iov[verb].with_params.connections.length
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#IOVgetConnectionCount
   * @param {String} verb The name of a verb.
   * @return {Int}
   */
  p.IOVgetConnectionCount = function Asset_IOVgetConnectionCount(verb) 
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return 0;
    if( this.iov[verb]?.with_params.connections )
    {
      return this.iov[verb].with_params.connections.length;
    }  
    return 0;
  }
}());
// IOVgetConnections.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Return 
   * this.iov[verb].with_params.connections
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#IOVgetConnections
   * @param {String} verb The name of a verb.
   * @return {Array}
   */
  p.IOVgetConnections = function Asset_IOVgetConnections(verb) 
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return [];
    return this.iov[verb]?.with_params.connections || [];
  }
}());
// IOVgetMaxConnections.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Return 
   * this.iov[verb].with_params.max_connections
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#IOVgetMaxConnections
   * @param {String} verb The name of a verb.
   * @return {Int}
   */
  p.IOVgetMaxConnections = function Asset_IOVgetMaxConnections(verb) 
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return 0;
    if( this.iov[verb]?.with_params.max_connections )
    {
      return this.iov[verb].with_params.max_connections;
    }  
    return 0;
  }
}());
// IOVhasDirectObjects.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVhasDirectObjects</strong> is a method to check 
   * whether this asset has any particular direct objects specified 
   * by the author for use with the specified verb.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVhasDirectObjects
   * @param {String} verb
   * @returns {Boolean}
   */
  p.IOVhasDirectObjects = function Asset_IOVhasDirectObjects(verb)
  {
    if(!this.isIOV(verb)) return false;

    // is this.iov[verb].with_assets !empty?
    if( this.iov[verb]?.with_assets.length )
    {
      return true;
    }

    // is this.iov[verb].with_classes !empty?
    if( this.iov[verb]?.with_classes.length )
    {
      return true;
    }
    
    return false;

  }
}());
// IOVhasMaxConnections.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Get whether the IOV has maximum connections.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#IOVhasMaxConnections
   * @param {String} verb The name of a verb.
   * @return {Boolean}
   */
  p.IOVhasMaxConnections = function Asset_IOVhasMaxConnections(verb) 
  {
    // no verb or not DOV, not max
    if( !verb || !this.game.dictionary.verbs[verb] ) return true;
    if( !this.iov[verb] ) return true;

    // no connections at all? is max
    if( !this.iov[verb].with_params.connections ) return true;

    // no max connections set? not max
    if( "undefined" === typeof this.iov[verb].with_params.max_connections ) return false;

    // max greater than actual? not max
    if( this.iov[verb].with_params.max_connections >= 
    this.iov[verb].with_params.connections.length )
    {
      return false;
    }

    // assume it's max
    return true;
  }
}());
// IOVincrementDoCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVincrementDoCount</strong> is a method to increment the number
   * of times the specified verb has acted on this asset as an indirect object. 
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVincrementDoCount
   * @param {String} verb
   */
  p.IOVincrementDoCount = function Asset_IOVIncrementDoCount(verb)
  {
    if( verb 
      && this.game.dictionary.verbs[verb]
      && this.iov[verb] ) 
      {
        this.iov[verb].incrementDoCount();
      }
  }
}());
// IOVincrementTryCount.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVincrementTryCount</strong> is a method to increment the number
   * of times the specified verb has been tried on this asset as an indirect object. 
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVincrementTryCount
   * @param {String} verb
   */
  p.IOVincrementTryCount = function Asset_IOVIncrementTryCount(verb)
  {
    if( verb 
      && this.game.dictionary.verbs[verb]
      && this.iov[verb] ) 
      {
        this.iov[verb].incrementTryCount();
      }
  }
}());
// IOVisConnectedToAnything.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Check whether this asset is currently connected to anything
   * indirectly by a verb such as <code class="property">plugIn</code>
   * or <code class="property">tie</code>. For example, if this asset 
   * is an outlet with a computer plugged into it, this method would return true.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#IOVisConnectedToAnything
   * @param {String} verb The name of a verb.
   * @return {Boolean}
   */
  p.IOVisConnectedToAnything = function Asset_IOVisConnectedToAnything(verb) 
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( this.iov[verb]?.with_params.connections?.length )
    {
      return true;
    }  
    return false;
  }
}());
// IOVisConnectedToAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Check whether this asset is currently connected as an indirect
   * object to the specified direct object by the specified verb.
   * For example, in the case of a computer plugged into an outlet, 
   * the outlet would be the indirect object, and calling this method 
   * on it would return true.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#IOVisConnectedToAsset
   * @param {String} verb The name of the verb to test.
   * @param {Object|String} asset A game asset or asset id to test.
   * @return {Boolean}
   */
  p.IOVisConnectedToAsset = function Asset_IOVisConnectedToAsset(verb,asset) 
  { 
    if( "string" === typeof asset) asset = this.game.getAsset( asset );
    if( !asset || !asset.id ) return false;
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !this.iov[verb]?.with_params.connections
      || -1 === this.iov[verb].with_params.connections.indexOf( asset.id ) )
      {
        return false;
      }
    return true;
  }
}());
// IOVisConnectedToNothing.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Check whether this asset is currently connected as an indirect
   * object to nothing by the specified verb.
   * (This seems like an unlikely situation as of this writing,
   * but is offered for completion with DOVisConnectedToNothing
   * which does have at least one use case.)
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#IOVisConnectedToNothing
   * @param {String} verb The name of a verb.
   * @return {Boolean}
   */
  p.IOVisConnectedToNothing = function Asset_IOVisConnectedToNothing(verb)
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !this.iov[verb]?.with_params.connections
      || -1 === this.iov[verb].with_params.connections.indexOf(null) )
      {
        return false;
      }
    return true;
  }
}());
// IOVsetConnection.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Set asset's indirect verb param connection to specified direct object.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#IOVsetConnection
   * @param {String} verb
   * @param {Object} asset
   */
  p.IOVsetConnection = function Asset_IOVsetConnection( verb, asset )
  {
    if( "string" === typeof asset) asset = this.game.getAsset(asset);
    if( !asset || !asset.id ) return false;
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;

    this.game.dictionary.verbs[verb].setVerbSubscriptionConnection( asset, this );
  }
}());

// IOVsetWithAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVsetWithAsset</strong> is used to specify 
   * another asset that can be used as a direct object with this 
   * asset as indirect object. For example, if this asset is a gold key,
   * gold_key.IOVsetWithAsset('unlock', 'chest') would add 
   * the chest as a direct object of the gold key.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVsetWithAsset
   * @param {String} verb
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.IOVsetWithAsset = function Asset_IOVSetWithAsset(verb, asset)
  { 
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( "string" === typeof asset ) asset = this.game.getAsset(asset);
    if( !asset || !asset.id ) return false;

    // verify that this is set as an indirect object of verb
    if(!this.isIOV(verb))
    {
      this.setIOV(verb);
    }

    // verify that direct object isn't already set
    if( -1 === this.iov[verb].with_assets.indexOf( asset.id ) )
    {
      this.iov[verb].with_assets.push( asset.id );
    }
   
    // that it works with an asset means it doesn't work with nothing
    this.iov[verb].with_nothing = false;

    return true;
  }
}());
// IOVsetWithClass.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>IOVsetWithClass</strong> is a method to add a direct object 
   * class to asset.iov[verb].with_classes.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#IOVsetWithClass
   * @param {String} verb
   * @param {String} clas
   * @returns {Boolean}
   */
  p.IOVsetWithClass = function Asset_IOVSetWithClass(verb, clas)
  { 
    var object_of = 'iov';
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !adventurejs[clas] ) return false;
    if(!this.isIOV(verb))
    {
      this.setIOV(verb);
    }
    if( -1 === this[object_of][verb].with_classes.indexOf( clas ) )
    {
      this[object_of][verb].with_classes.push( clas );
    }
    return true;
  }
}());
// IOVunsetConnection.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Unset asset's indirect verb param connection to specified direct object.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#IOVunsetConnection
   * @param {String} verb
   * @param {Object} asset
   */
  p.IOVunsetConnection = function Asset_IOVUnsetConnection( verb, asset )
  {
    if( "string" === typeof asset) asset = this.game.getAsset(asset);
    if( !asset || !asset.id ) return false;
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;

    this.game.dictionary.verbs[verb].unsetVerbSubscriptionConnection( asset, this );
  }
}());

// isDOV.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>isDOV</strong> is a method to check whether 
   * this asset is subscribed to allow the specified verb to act on it
   * as a direct object.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#isDOV
   * @param {String} verb
   * @returns {Boolean}
   */
  p.isDOV = function Asset_isDOV(verb)
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !this.dov[verb]?.enabled ) return false;
    return true;
  }
}());
// isIOV.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * <strong>isIOV</strong> is a method to check whether 
   * this asset is subscribed to allow the specified verb to act on it
   * as an indirect object.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#isIOV
   * @param {String} verb
   * @returns {Boolean}
   */
  p.isIOV = function Asset_isIOV(verb)
  {
    if( !verb || !this.game.dictionary.verbs[verb] ) return false;
    if( !this.iov[verb]?.enabled ) return false;
    return true;
  }
}());
// isState.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * <strong>isState</strong> is a method to check whether
   * this asset already has state set by the specified verb.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#isState
   * @param {String} verb
   * @returns {Boolean}
   */
  p.isState = function Asset_isVerbState(verb) {
    if (!verb || !this.game.dictionary.verbs[verb]) return false;

    verb = this.game.dictionary.verbs[verb];

    // ex: do verb close to this and this.is.closed
    if (verb.state && this.is[verb.state]) return true;

    // ex: do verb open to this and !this.is.closed
    if (verb.unstate && !this.is[verb.unstate]) return true;

    return false;
  };
})();

// redirectVerb.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>redirectVerb</strong> is a method for setting 
   * a verb redirect on this asset, such that when one verb 
   * is called on the asset, another verb will be called instead.
   * Example: player enters "hit person", it is redirected to "slap person". 
   * @method adventurejs.Asset#redirectVerb
   * @memberOf adventurejs.Asset
   * @param {String} oldVerb
   * @param {String} newVerb
   */
  p.redirectVerb = function Asset_redirectVerb( oldVerb, newVerb )
  {
    this.redirected_verbs[oldVerb] = newVerb;
  }
}());
// setDOV.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;

  /**
   * <strong>setDOV</strong> is a passthrough to
   * <code><a href="#method_setObjectOfVerb">setVerbSubscription</a></code>
   * with direct object specified.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#setDOV
   * @param {String} verb
   * @param {Object} params
   */
  p.setDOV = function Asset_setDOV(verb) {
    this.setVerbSubscription("dov", verb);
  };
})();

// setDOVs.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;

  /**
   * <strong>setDOVs</strong> is a passthrough to send
   * multiple verbs to
   * <code><a href="#method_setVerbSubscription">setVerbSubscription</a></code>
   * with direct object specified.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#setDOVs
   * @param {String} verb
   * @param {Object} params
   */
  p.setDOVs = function Asset_setDOVs(verbs) {
    for (var i = 0; i < verbs.length; i++) {
      this.setVerbSubscription("dov", verbs[i]);
    }
  };
})();

// setIOV.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>setIOV</strong> is a passthrough to 
   * <code><a href="#method_setVerbSubscription">setVerbSubscription</a></code>
   * with indirect object specified.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#setIOV
   * @param {String} verb
   * @param {Object} params
   */
  p.setIOV = function Asset_setIOV( verb, params )
  {
    this.setVerbSubscription( 'iov', verb, params );
  }
}());
// setIOVs.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>setIOVs</strong> is a passthrough to send
   * multiple verbs to 
   * <code><a href="#method_setVerbSubscription">setVerbSubscription</a></code>
   * with indirect object specified.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#setIOVs
   * @param {String} verb
   * @param {Object} params
   */
  p.setIOVs = function Asset_setIOVs( verbs, params )
  {
    for( var i = 0; i < verbs.length; i++ )
    {
      this.setVerbSubscription( 'iov', verbs[i], params );
    }
  }
}());
// setKnown.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>setKnown</strong> sets an object known.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#setKnown
   * @param {Boolean} bool
   */
  p.setKnown = function Asset_setKnown( bool = true )
  {
    this.is.known = bool;
  }
}());
// setLinkedState.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>setLinkedState</strong> sets an asset and
   * its linked asset to the specified state.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#setLinkedState
   * @param {Boolean} bool
   */
  p.setLinkedState = function Asset_setLinkedState( property, value )
  {
    this.is[property] = value;
    if(this.linked_asset) {
      let asset = this.game.getAsset(this.linked_asset);
      if(asset) asset.is[property] = value;
    }
  }
}());
// setObjectOfVerbs.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;

  /**
   * <strong>setObjectOfVerbs</strong> is a convenience method that
   * passes a list of verb names through to
   * <code><a href="#method_setObjectOfVerb">setVerbSubscription</a></code>.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#setObjectOfVerbs
   * @param {String} object_of
   * @param {String} verb
   */
  p.setObjectOfVerbs = function Asset_setObjectOfVerbs(object_of, verbs) {
    for (var i = 0; i < verbs.length; i++) {
      this.setVerbSubscription(object_of, verbs[i]);
    }
  };
})();

// setState.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * Apply the specified state change to the asset.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#setState
   * @param {String} verb
   * @param {Boolean} bool
   */
  p.setState = function Asset_setState(state, bool) {
    this.is[state] = bool;
  };
})();

// setVerbSubscription.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * <strong>setVerbSubscription</strong> constructs verb subscriptions
   * at asset.dov / asset.iov. It's intended mostly
   * as a private function, though it is available to authors.
   * An early version takes a string with separate params object.
   * A later version takes an object that includes the verb name
   * as an object key and params as value.
   * // valid (for now) early version
   * this.setIOV('hold',{with_params:{max_connections:2}});
   * // valid later version with one verb
   * this.setIOV( { hold: { with_params: { max_connections:2 } } } );
   * // valid later version with multiple verbs
   * this.setIOVs([
   *   { hold: { with_params: { max_connections:3 } } },
   *   { smell: true },
   * ]);
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#setVerbSubscription
   * @param {String} object_of
   * @param {String|Object} verb An early version takes a string,
   * with separate params object. A later version takes an object
   * that includes the verb name as an object key and params as value.
   * @param {Object} params An optional param that works with the
   * earlier version.
   * @todo phase out earlier version
   */
  p.setVerbSubscription = function Asset_setObjectOfVerb(object_of, verb) {
    if (!object_of) return; // no object type
    let params;

    // does verb look like this: { verb: {} }
    if ("object" === typeof verb) {
      params = verb[Object.keys(verb)[0]];
      verb = Object.keys(verb)[0];
    }

    if (!verb || !this.game.dictionary.verbs[verb]) return; // no verb

    // we allow this shortcut {dov:{verb:true}}
    // did author use shortcut to enable verb subscription?

    if (params === true) {
      params = { enabled: true, with_nothing: true }; // we accept a bool
    }
    if (params === false) {
      params = { enabled: false };
    }
    // no other accepted form of params received?
    if ("object" !== typeof params) {
      params = { enabled: true, with_nothing: true };
    }
    if ("undefined" === typeof params.enabled) {
      params.enabled = true;
    }

    // if verb setting exists and params include nothing new, we're done
    if (this[object_of][verb] && !Object.keys(params).length) {
      return this[object_of][verb];
    }

    // is asset not already subscribed to verb?
    if (!this[object_of][verb]) {
      this[object_of][verb] = new adventurejs.VerbSubscription(
        verb,
        this.game_name,
        this.id
      );

      // set constructor name which gives us a way to find inheritance
      // @TODO this doesn't work the way I expected it to
      // need to loop through __proto__ to find which ancestor
      // this prop initiated from, but as verb subscriptions are set in
      // asset constructors, they're not available from here - rethink this
      this[object_of][verb].inherited_from = this.constructor.name;

      // save the verb name back to the verb subscription
      this[object_of][verb].name = verb;

      // copy verb.with_params
      // IMPORTANT: use JSON.parse(JSON.stringify(with_params))
      this[object_of][verb].with_params = JSON.parse(
        JSON.stringify(this.game.dictionary.verbs[verb].with_params)
      );
    }

    // if params include nothing new, we're done
    if (!Object.keys(params).length) {
      return this[object_of][verb];
    }

    // apply params from asset class or game file
    // which may include with_params and is therefore deep
    this[object_of][verb] = A.deepSet.call(
      this.game,
      params,
      this[object_of][verb]
    );

    // did author set a string for with_assets? we'll allow it
    if ("string" === typeof this[object_of][verb].with_assets) {
      this[object_of][verb].with_assets = [this[object_of][verb].with_assets];
    }

    if (this[object_of][verb].with_assets.length) {
      for (var i = 0; i < this[object_of][verb].with_assets.length; i++) {
        // author probably used names - set to ids
        this[object_of][verb].with_assets[i] = A.serialize(
          this[object_of][verb].with_assets[i]
        );
        // we want to validate these asset name/ids,
        // but at this point paired assets may not yet have been created
      }

      // was automatically setting with_nothing/anything
      // but maybe should leave that for author to explicitly set
      object_of === "dov"
        ? (this[object_of][verb].with_nothing = false)
        : (this[object_of][verb].with_anything = false);
    }

    // did author set a string for with_classes? we'll allow it
    if ("string" === typeof this[object_of][verb].with_classes) {
      this[object_of][verb].with_classes = [this[object_of][verb].with_classes];
    }

    if (this[object_of][verb].with_classes.length) {
      for (var i = this[object_of][verb].with_classes.length - 1; i >= 0; i--) {
        // validate classes
        var klass = this[object_of][verb].with_classes[i];
        if (!adventurejs[klass]) {
          var msg = `${this.id}.${object_of}.${verb}.with_classes.${klass}: ${klass} isn't recognized as an adventurejs class and was removed. `;
          this.game.log("warn", 0, msg, "Asset");
          this[object_of][verb].with_classes.splice(i);
        }
      }
      object_of === "dov"
        ? (this[object_of][verb].with_nothing = false)
        : (this[object_of][verb].with_anything = false);
    }

    // if no supporting assets, set anything/nothing to true?
    if (
      !this[object_of][verb].with_assets.length &&
      !this[object_of][verb].with_classes.length
    ) {
      //this[object_of][verb].with_anything = true;
      //this[object_of][verb].with_nothing = true;
    }

    return this[object_of][verb];
  };
})();

// setVerbSubscriptionsWithAssets.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Link assets that connect via verb subscriptions.
   * For example, imagine "hit target with sword", 
   * where we have 
   * target.dov.hit.with_assets:["sword"]
   * This pass will set 
   * sword.iov.hit.with_assets:["target"]
   * to ensure that both assets are in sync
   * and either can be queried.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#setVerbSubscriptionsWithAssets
   * @param {String} description
   * @return {String}
   */
  p.setVerbSubscriptionsWithAssets = function Asset_setVerbSubscriptionsWithAssets()
  {
    var object = ['dov','iov'];
    for(var of = 0; of < object.length; of++) {
      var oppo = object[of===0?1:0];
      for( var verb in this[object[of]] )
      {
        if(this[object[of]][verb]?.with_assets?.length)
        {
          var with_assets = this[object[of]][verb].with_assets;
          for(var v = 0; v < with_assets.length; v++ )
          {
            //if(!with_assets[v].length) continue; // empty string?
            var asset = this.game.getAsset( with_assets[v] );
            if(!asset) { 
              /*throw error*/ 
              this.game.log( "error", 0, `${this.id}.${object[of]}.${verb}.with_assets["${with_assets[v]}"] is an invalid asset name/id` );
              continue; 
            }
            if( !this.id ) continue; // not sure why we'd hit this, but must have done
            if( !asset[oppo][verb] ) 
            {
              // if opposing asset hasn't got a verb subscription, set that now
              asset.setVerbSubscription( oppo, verb, { with_assets: [ this.id ] } );
            }
            else if( -1 === asset[oppo][verb].with_assets.indexOf(this.id) ) 
            {
              // otherwise just make sure my id is in its with_assets
              asset[oppo][verb].with_assets.push(this.id);
            }
          }
        }
      }
    }
  }
}());
// setVerbSubscriptionsWithConnection.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
  /**
   * Make any connections specified in the game file. 
   * Assets can subscribe to verbs with 
   * <code class="property">dov[verb]</code>
   * and some verbs make connections between assets 
   * that they act upon, which are recorded in 
   * <code class="property">dov[verb].with_params.connections</code>.
   * Authors can preset connections in their game file, and 
   * in case they only set one of two connected assets, we want 
   * to ensure that both assets are marked as connected, 
   * so we check that here.
   * @memberOf adventurejs.Asset
	 * @method adventurejs.Asset#setVerbSubscriptionsWithConnection
   */
  p.setVerbSubscriptionsWithConnection = function Asset_setVerbSubscriptionsWithConnection()
  { 
    //console.warn(this.id,'setVerbSubscriptionsWithConnection');
    let objects = [ 
      ['dov','iov'],
      ['iov','dov'] 
    ];

    for(var pair = 0; pair < objects.length; pair++ ) {     
      let object = objects[pair];
      // check all this asset's direct/indirect verb subscriptions
      for(var verb in this[object[0]])
      {
        let averb = this[object[0]][verb];
        // does this verb make connections?
        if( averb?.with_params?.connections?.length )
        {        
          // does this asset have connections set from game file?
          for( var i = 0; i < averb.with_params.connections.length; i++ )
          {
            // author probably used names, not ids, so serialize
            averb.with_params.connections[i] = A.serialize(averb.with_params.connections[i]);
            // get connected asset
            let connection = this.game.getAsset(averb.with_params.connections[i]);
            if(connection)
            {
              // verify that connection is also subscribed to verb
              if(!connection[object[1]][verb])
              {
                // if not, subscribe it
                if( object[1] === 'dov' ) connection.setDOV(verb);
                else connection.setIOV(verb);
              }
              // is this id not found in connection?
              if(-1 === connection[object[1]][verb].with_params.connections.indexOf(this.id) )
              {
                // player would've set name, not id, so also check for that
                let namepos = connection[object[1]][verb].with_params.connections.indexOf(this.name);
                if(-1 !== namepos )
                {
                  // replace this name in connection with this id
                  connection[object[1]][verb].with_params.connections[namepos] = this.id;
                }
                else 
                {
                  // add this id to connection
                  connection[object[1]][verb].with_params.connections.push(this.id);
                }
              }
            }
          }
        }
      }
    }
  } // set connections

}());
// toggleState.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;
  /**
   * Apply the specified verb's state change to the asset.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#toggleState
   * @param {String} verb
   * @returns {Boolean}
   */
  p.toggleState = function Asset_toggleState(verb) {
    if (!this.canSetVerbState(verb)) return false;

    verb = this.game.dictionary.verbs[verb];

    if (verb.state && !this.is[verb.state]) {
      // ex: can do verb close if !is.closed
      this.is[verb.state] = true;
      return true;
    } else if (verb.unstate && this.is[verb.unstate]) {
      // ex: can do verb open if is.closed
      this.is[verb.unstate] = false;
      return true;
    }
    return false;
  };
})();

// tryDestroyAfterUsing.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Asset.prototype;

  /**
   * <strong>tryDestroyAfterUsing</strong> is the underlying
   * function for tryDestroyDirectObjectAfterUsing and
   * tryDestroyIndirectObjectAfterUsing.
   * @memberOf adventurejs.Verb
   * @method adventurejs.Verb#tryDestroyAfterUsing
   * @param {String} object_of
   * @param {Object} asset
   * @returns {Object}
   */
  p.tryDestroyAfterUsing = function Asset_tryDestroyAfterUsing(
    object_of,
    verb
  ) {
    var results = { destroy: false, msg: "" };
    if (
      !object_of ||
      !verb ||
      !this[object_of][verb] ||
      !this[object_of][verb].then_destroy
    )
      return results;

    results.destroy = true;
    if ("boolean" !== typeof this[object_of][verb].then_destroy) {
      results.msg = A.getSAF.call(
        this.game,
        this[object_of][verb].then_destroy,
        this
      );
    }
    this.destroy();
    return results;
  };
})();

// tryDestroyDirectObjectAfterUsing.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>tryDestroyDirectObjectAfterUsing</strong> 
   * checks to see if the specified asset can only be 
   * used directly once with this verb by checking for
   * <code>asset.dov[this.name].then_destroy</code>. 
   * This is intended to provide a hook for authors 
   * to easily destroy an object after a single use, such as a key 
   * that only works once and then breaks or disappears.
   * @memberOf adventurejs.Verb
   * @method adventurejs.Verb#tryDestroyDirectObjectAfterUsing
   * @param {Object} asset
   * @returns {Boolean|string}
   */
  p.tryDestroyDirectObjectAfterUsing = function Asset_tryDestroyDirectObjectAfterUsing(verb)
  {
    return this.tryDestroyAfterUsing('dov',verb);
  }
}());
// tryDestroyIndirectObjectAfterUsing.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>tryDestroyIndirectObjectAfterUsing</strong> 
   * checks to see if the specified asset can only be used 
   * indirectly once with this verb by checking for 
   * <code>asset.iov[this.name].then_destroy</code>.
   * This is intended to provide a hook for authors 
   * to easily destroy an object after a single use, such as a key 
   * that only works once and then breaks or disappears.
   * @memberOf adventurejs.Verb
   * @method adventurejs.Verb#tryDestroyIndirectObjectAfterUsing
   * @param {Object} asset
   * @returns {Boolean|string}
   */
  p.tryDestroyIndirectObjectAfterUsing = function Asset_tryDestroyIndirectObjectAfterUsing(verb)
  {
    return this.tryDestroyAfterUsing('iov',verb);
  }
}());
// undestroy.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>undestroy</strong> is called to return a destroyed asset
   * to the game world.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#undestroy
   */
  p.undestroy = function Asset_undestroy()
  {

    this.is.destroyed = false;
    this.is.extant = true;

    var results = this.callAction("doUndestroyThis");
    if( "undefined" !== typeof results ) return results;            
    
    return;
  }
}());
// unredirectVerb.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>unredirectVerb</strong> is a method for removing
   * previously set verb redirects. 
   * @method adventurejs.Asset#unredirectVerb
   * @memberOf adventurejs.Asset
   * @param {String} oldVerb
   */
  p.unredirectVerb = function Asset_unredirectVerb( oldVerb )
  {
    delete this.redirected_verbs[oldVerb];
  }
}());
// unsetDOV.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>unsetDOV</strong> is a passthrough to 
   * <code><a href="#method_unsetVerbSubscription">unsetVerbSubscription</a></code>.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#unsetDOV
   * @param {String} verb
   */
  p.unsetDOV = function Asset_unsetDOV( verb )
  {
    this.unsetVerbSubscription( 'dov', verb );
  }
}());
// unsetDOVs.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>unsetDOVs</strong> is a passthrough to 
   * <code><a href="#method_unsetVerbSubscription">unsetVerbSubscription</a></code>.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#unsetDOVs
   * @param {Array} verbs
   */
  p.unsetDOVs = function Asset_unsetDirectObjectOfVerbs( verbs )
  {
    for( var i = 0; i < verbs.length; i++ )
    {
      this.unsetVerbSubscription( 'dov', verbs[i] );
    }
  }
}());
// unsetIOV.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>unsetIOV</strong> is a passthrough to 
   * <code><a href="#method_unsetVerbSubscription">unsetVerbSubscription</a></code>.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#unsetIOV
   * @param {String} verb
   */
  p.unsetIOV = function Asset_unsetIOV( verb )
  {
    this.unsetVerbSubscription( 'iov', verb );
  }
}());
// unsetIOVs.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	

  /**
   * <strong>unsetIOVs</strong> is a passthrough to 
   * <code><a href="#method_unsetVerbSubscription">unsetVerbSubscription</a></code>.
   * @memberOf adventurejs.Asset
   * @method adventurejs.Asset#unsetIOVs
   * @param {Array} verbs
   */
  p.unsetIOVs = function Asset_unsetIOVs( verbs )
  {
    for( var i = 0; i < verbs.length; i++ )
    {
      this.unsetVerbSubscription( 'iov', verbs[i] );
    }
  }
}());
// unsetVerbSubscription.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Asset.prototype;	
/**
 * <strong>unsetVerbSubscription</strong> disables the use of the 
 * specified verb with this asset, if it has been previously set.
 * @memberOf adventurejs.Asset
 * @method adventurejs.Asset#unsetVerbSubscription
 * @param {String} object_of
 * @param {String} verb
 */
p.unsetVerbSubscription = function Asset_unsetObjectOfVerb( object_of, verb )
{
  if(!object_of) return;
  if(!verb) return;
  if( !this[object_of][verb] ) return;
  this[object_of][verb].enabled = false;
}
}());
// Zone.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Zone
   * @augments adventurejs.Asset
   * @class adventurejs.Zone
   * @ajsconstruct MyGame.createAsset({ "class":"Zone", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BaseClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Set UniversalScenery descriptions for groups of Rooms.
   * @tutorial NextSteps_GlobalScenery
   * @tutorial CreateSceneEvents
   * @classdesc
   * <p>
   * <strong>Zone</strong> is a low-level subclass of
   * {@link adventurejs.Asset|Asset} with just a couple
   * of properties: zone_events and zone_scenery. Use
   * Zone to define customized sets of global Assets that
   * can be shared by any number of
   * {@link adventurejs.Room|Rooms}. For instance, you might
   * create a desert Zone which describes a starry night sky,
   * a blood moon, and exits that are blocked by
   * sand dunes in every direction that hasn't got a defined
   * Exit, with random gusts of blown sand and shimmering heat haze.
   * </p>
   * <p>
   * There are three types of predefined global Assets:
   * {@link adventurejs.Scenery|Scenery},
   * {@link adventurejs.Wall|Walls}, and
   * {@link adventurejs.Exit|Exits} (aka NoExits).
   * Game comes with a number of predefined global Assets:
   * {@link global_air|air},
   * {@link global_moon|moon},
   * {@link global_sky|sky},
   * {@link global_sun|sun},
   * {@link global_stars|stars},
   * {@link global_ceiling|ceiling},
   * {@link global_sound|sound},
   * {@link global_rain|rain},
   * {@link global_trees|trees}, and
   * {@link global_wind|wind}; Walls for each of 12 directions; and
   * NoExits for each of 18 directions. (NoExits are only called
   * if the Room hasn't got an actual Exit in the given direction.)
   * Scenery and Walls are disabled by default and must be
   * enabled to use. NoExits are enabled by default,
   * and can be disabled or customized.
   * </p>
   * <p>
   * In addition to scenery, authors can create sets of
   * random (or sequential) events that will print at any
   * specified frequency. (<i>Events</i> here means in-game events,
   * such as a periodic car alarm or a twinkling light, as opposed
   * to JavaScript events.) A few random Room events can help to
   * spice up frequently visited locations. Look to the bottom
   * of the following example to see how events are set up.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * In this example, we've defined a room with its
   * <code class="property">zone</code> property set
   * to "Desert Zone", where we've set custom
   * descriptions for a couple of Game's predefined global
   * Assets, and given it some random events.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Eastern Sands",
   *   zone: "Desert Zone",
   *   description: "It's swelteringly hot here. ",
   *   exits: {
   *     west: "Western Sands",
   *     north: "Nothing but sand dunes that way. ",
   *   },
   * });
   *
   * MyGame.createAsset({
   *   class: "Zone",
   *   name: "Desert Zone",
   *   zone_scenery:
   *   {
   *     global_sky: {
   *       enabled: true,
   *       description: "Even the sky is burnt to a pale sandy color. ",
   *     },
   *     global_sun: {
   *       enabled: true,
   *       description: "The sun burns is punishingly bright. ",
   *     },
   *   },
   *
   *   zone_events: [
   *     {
   *       frequency: .1,
   *       randomize: true,
   *     },
   *     "You hear the distant shriek of a desert hawk. ",
   *     "A flurry of sand trickles down a nearby dune. ",
   *     "A shimmer of heat haze rises up from the sands. "
   *   ],
   * });
   * </code></pre>
   * <p>
   * To learn more about customizing global Assets, see
   * <a href="/doc/NextSteps_GlobalScenery.html">Global Scenery</a>.
   * </p>
   * <p>
   * This longer version below shows all of the available global Assets.
   * It's a pretty long list and it might look intimidating, but don't panic!
   * It's all optional.
   * In this example, we've expanded the
   * "Desert Zone" with all of the Game's predefined
   * global Assets. Note where the Room has
   * <code class="property">exits.west</code> set to
   * an actual Exit, which overrides the west NoExit
   * set in Desert Zone. Similarly, the Room has a
   * custom error message set for
   * <code class="property">exits.north</code>, and
   * this also overrides the north NoExit set in Desert Zone.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Eastern Sands",
   *   zone: "Desert Zone",
   *   description: "It's swelteringly hot here. ",
   *   exits: {
   *     west: "Western Sands",
   *     north: "Nothing but sand dunes that way. ",
   *   },
   * });
   *
   * MyGame.createAsset({
   *   class: "Zone",
   *   name: "Desert Zone",
   *   zone_scenery:
   *   {
   *     global_air: {
   *       enabled: true,
   *       description: "The air is hot and dry. ",
   *     },
   *     global_moon: { enabled: false,
   *       description: "The sun makes it impossible to see it. ",
   *     },
   *     global_sky: {
   *       enabled: true,
   *       description: "Even the sky is burnt to a pale sandy color. ",
   *     },
   *     global_sun: {
   *       enabled: true,
   *       description: "The sun burns is punishingly bright. ",
   *     },
   *     global_stars: {
   *       enabled: false,
   *       description: "Invisible under this brilliant sun. ",
   *     },
   *     global_floor: {
   *       enabled: true,
   *       description: "Endless sand. ",
   *     },
   *     global_ceiling: { enabled: false, description: "", },
   *     global_sound: {
   *       enabled: true,
   *       description: "You can hear a constant dry breeze. ",
   *     },
   *     global_east_wall: { enabled: false, description: "", },
   *     global_west_wall: { enabled: false, description: "", },
   *     global_north_wall: { enabled: false, description: "", },
   *     global_northeast_wall: { enabled: false, description: "", },
   *     global_northwest_wall: { enabled: false, description: "", },
   *     global_south_wall: {
   *       enabled: true,
   *       description: "A crumbling sandstone wall divides the entire region,
   *       blocking any passage to the south. ",
   *     },
   *     global_southeast_wall: {
   *       enabled: true,
   *       description: "The crumbling sandstone wall stretches away
   *       to the east, blocking any southeast passage. ",
   *     },
   *     global_southwest_wall: {
   *       enabled: true,
   *       descriptions: "The crumbling sandstone wall stretches away
   *       to the west, blocking any southwest passage. ",
   *     },
   *     global_aft_wall: { enabled: false, description: "", },
   *     global_port_wall: { enabled: false, description: "", },
   *     global_starboard_wall: { enabled: false, description: "", },
   *     global_fore_wall: { enabled: false, description: "", },
   *     global_east: {
   *       enabled: true,
   *       description: "Nothing but endless sand lies to the east. ",
   *     },
   *     global_west: {
   *       enabled: true,
   *       description: "Only trackless wastes lie to the west. ",
   *     },
   *     global_north: {
   *       enabled: true,
   *       description: "Tall dunes block passage to the north. ",
   *     },
   *     global_northeast: {
   *       enabled: true,
   *       description: "Towering dunes block any passage to the northeast. ",
   *     },
   *     global_northwest: {
   *       enabled: true,
   *       description: "Sand dunes prevent passage to the northwest. ",
   *     },
   *     global_south: {
   *       enabled: true,
   *       description: "The crumbling southern wall blocks all passage. ",
   *     },
   *     global_southeast: {
   *       enabled: true,
   *       description: "The endless sandstone wall lies southeast. ",
   *     },
   *     global_southwest: {
   *       enabled: true,
   *       description: "The sandstone wall prevents passage to the southwest. ",
   *     },
   *     global_aft: { enabled: false, description: "", },
   *     global_port: { enabled: false, description: "", },
   *     global_starboard: { enabled: false, description: "", },
   *     global_fore: { enabled: false, description: "", },
   *   },
   *
   *   zone_events: [
   *     {
   *       frequency: .1,
   *       randomize: true,
   *     },
   *     "You hear the distant shriek of a desert hawk. ",
   *     "A flurry of sand trickles down a nearby dune. ",
   *     "A shimmer of heat haze rises up from the sands. "
   *   ],
   * });
   * </code></pre>
   **/
  class Zone extends adventurejs.Asset {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Zone";

      this.exclude_from_lookup = true;

      this.zone_events = [];

      this.zone_scenery = {
        global_air: { enabled: false, description: "It smells like air. " },
        global_moon: { enabled: false, description: "It's the moon. " },
        global_sky: { enabled: false, description: "The sky. " },
        global_sun: { enabled: false, description: "The sun. " },
        global_stars: { enabled: false, description: "The stars. " },
        global_floor: { enabled: false, description: "The floor. " },
        global_ceiling: { enabled: false, description: "The ceiling. " },
        global_sound: { enabled: false, description: "No particular sound. " },
        global_rain: { enabled: false, description: "A light spring rain. " },
        global_wind: { enabled: false, description: "A mighty wind. " },
        global_trees: {
          enabled: false,
          description: "Can't see the forest for 'em. ",
        },
        global_clouds: { enabled: false, description: "Dark clouds. " },
        global_lightning: {
          enabled: false,
          description: "Distant lightning. ",
        },
        global_mountains: {
          enabled: false,
          description: "Snow capped mountains. ",
        },
        global_mountain: { enabled: false, description: "Mount Doom. " },

        global_east_wall: { enabled: false, description: "The east wall. " },
        global_west_wall: { enabled: false, description: "The west wall. " },
        global_north_wall: { enabled: false, description: "The north wall. " },
        global_northeast_wall: {
          enabled: false,
          description: "The northeast wall. ",
        },
        global_northwest_wall: {
          enabled: false,
          description: "The northwest wall. ",
        },
        global_south_wall: { enabled: false, description: "The south wall. " },
        global_southeast_wall: {
          enabled: false,
          description: "The southeast wall. ",
        },
        global_southwest_wall: {
          enabled: false,
          description: "The southwest wall. ",
        },
        global_aft_wall: { enabled: false, description: "The aft wall. " },
        global_port_wall: { enabled: false, description: "The port wall. " },
        global_starboard_wall: {
          enabled: false,
          description: "The starboard wall. ",
        },
        global_fore_wall: { enabled: false, description: "The fore wall. " },

        global_east: {
          enabled: true,
          description: "There's no exit to the east. ",
        },
        global_west: {
          enabled: true,
          description: "There's no exit to the west. ",
        },
        global_north: {
          enabled: true,
          description: "There's no exit to the north. ",
        },
        global_northeast: {
          enabled: true,
          description: "There's no exit to the northeast. ",
        },
        global_northwest: {
          enabled: true,
          description: "There's no exit to the northwest. ",
        },
        global_south: {
          enabled: true,
          description: "There's no exit to the south. ",
        },
        global_southeast: {
          enabled: true,
          description: "There's no exit to the southeast. ",
        },
        global_southwest: {
          enabled: true,
          description: "There's no exit to the southwest. ",
        },
        global_aft: {
          enabled: true,
          description: "There's no exit to the aft. ",
        },
        global_port: {
          enabled: true,
          description: "There's no exit to the port. ",
        },
        global_starboard: {
          enabled: true,
          description: "There's no exit to the starboard. ",
        },
        global_fore: {
          enabled: true,
          description: "There's no exit to the fore. ",
        },
      };
    }
  }
  adventurejs.Zone = Zone;
})();

// Matter.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter
   * @augments adventurejs.Asset
   * @class adventurejs.Matter
   * @ajsconstruct MyGame.createAsset({ "class":"Matter", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BaseClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Let's get physical! Physical!
   * @classdesc
   * <p>
   * <strong>Matter</strong> is a low-level subclass of
   * {@link adventurejs.Asset|Asset}, and the base class for
   * all physical matter in the
   * {@link adventurejs.Game|Game} world,
   * including
   * {@link adventurejs.Substance|Substances} and
   * {@link adventurejs.Tangible|Tangibles}. It exists chiefly
   * to provide a common base class for these two classes
   * for verb qualification with NounMustBe.matter.
   * </p>
   * <p>
   * Rather than subclassing Matter directly, authors should
   * use subclasses of Substance and Tangible.
   * </p>
   **/
  class Matter extends adventurejs.Asset {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Matter";

      // set up verbs that operate on all matter
      this.setDOVs(["examine", "look", "listen", "taste", "smell", "touch"]);
      this.setDOV({ hit: { with_anything: true, with_nothing: true } });
      this.setDOV({ flick: { with_nothing: true } });
    }

    validate(game) {
      super.validate(game);
      return true;
    }

    initialize(game) {
      super.initialize(game);
      return true;
    } // p.initialize

    destroy() {
      super.destroy();
      return true;
    } // p.destroy
  } // function Matter(id)

  adventurejs.Matter = Matter;
})();

// Substance_Is.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Is.Substance_Is
   * @augments adventurejs.Asset_Is
   * @class adventurejs.Substance_Is
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <p>
   * <strong>Substance_Is.js</strong> handles is.state management for
   * @TODO change is.substancetype to single constant?
   * {@link adventurejs.Substance|Substance Assets}.
   **/

  class Substance_Is extends adventurejs.Asset_Is {
    constructor(name = "is", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Substance_Is";

      /**
       * Set whether this asset is liquid.
       * @var {Boolean} adventurejs.Substance#is!liquid
       * @default false
       */
      this.liquid = false;

      /**
       * Set whether this asset is gas.
       * @var {Boolean} adventurejs.Substance#is!liquid
       * @default false
       */
      this.gas = false;

      /**
       * Set whether this asset is solid.
       * @var {Boolean} adventurejs.Substance#is!liquid
       * @default false
       */
      this.solid = false;

      /**
       * Set whether this asset is slurry.
       * @var {Boolean} adventurejs.Substance#is!liquid
       * @default false
       */
      this.slurry = false;

      this.known = true;

      // this.is.global = true; // should substances be global?
      // this.is.singleton = true; // should substances be singleton?
    }
  }
  adventurejs.Substance_Is = Substance_Is;
})();

// Substance.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Substance
   * @augments adventurejs.Matter
   * @class adventurejs.Substance
   * @ajsconstruct MyGame.createAsset({ "class":"Substance", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BaseClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Solids, Liquids, Slurries, and Gasses, baby.
   * @tutorial Substances_AboutSubstances
   * @todo How is gas volume measured? Is it something other than ml?
   * @todo State conversion
   * @todo Slurries
   * @todo is_edible / is_potable
   * @classdesc
   * <p>
   * <strong>Substance</strong> is a low-level subclass of
   * {@link adventurejs.Asset|Asset}, and the base class for
   * all
   * {@link adventurejs.Solid|Solids},
   * {@link adventurejs.Liquid|Liquids},
   * {@link adventurejs.Slurry|Slurries}, and
   * {@link adventurejs.Gas|Gasses}.
   * Substance is one of the pillars of the
   * {@link adventurejs.Game|Game} world,
   * along with
   * {@link adventurejs.Tangible|Tangibles} and
   * {@link adventurejs.Intangible|Intangibles}.
   * Substances fall somewhere between Tangibles and
   * Intangibles. Instances of Substances are quasi-global;
   * as with Intangibles,
   * player can refer to Substances regardless of their
   * physical availability, and be understood by the parser.
   * Yet, as with Tangibles, Substances exist in the physical
   * world. Substances have no physical aspect of their own,
   * but are defined by the Vessels that contain them.
   * A <strong>glass</strong> of water. A <strong>pile</strong>
   * of dirt. A <strong>cylinder</strong> of gas.
   * Technically, Substances are infinite. For example,
   * an instance of Water represents all Water,
   * everywhere in the Game, whether it's in a glass or a lake.
   * Substances can be added and divided;
   * Vessels can be emptied and filled.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * Rather than subclassing Substance directly, authors should
   * use Solid, Liquid, Gas, or Slurry.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Slurry",
   *   name: "frogurt",
   *   description: "The frogurt is full of vitamins and minerals.
   *   That's good. The frogurt is also cursed. That's bad. ",
   * });
   * </code></pre>
   **/
  class Substance extends adventurejs.Matter {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Substance";

      this.is = new adventurejs.Substance_Is("is", this.game_name, this.id).set(
        {
          parent_id: this.id,
        }
      );

      this.setIOV({ throw: { with_nothing: true } });
      this.setIOV({ flick: { with_nothing: true } });
      this.setDOV({ throw: { with_nothing: true } });
      this.setDOV({ flick: { with_anything: true } });

      this.can = this.can || {};
      this.can.be_poured_into = false;
      this.mixwith = {};

      this.melting_temperature = 0; // water // TODO lookup table
      this.boiling_temperature = 100; // water // TODO lookup table

      // Specific heat capacity is a measure of the amount of heat necessary
      // to raise the temperature of one gram of a pure substance by one degree K.
      this.specific_heat = 4.2; // water = 4186, commonly(?) rounded to 4.2Kj or 4200j
      // TODO lookup table
      // specific heats of common liquids and substances:
      // https://www.engineeringtoolbox.com/specific-heat-fluids-d_151.html
      // https://www.engineeringtoolbox.com/specific-heat-capacity-d_391.html

      // Heat Capacity is the amount of heat required to increase the temperature
      // of a mass of substance by one degree K.
      this.heat_capacity = 4.2;
      // TODO this should calculate specific_heat * mass
      // ( which is volume * grams-per-ml - water is roughly 1 gram per ml )

      this.state = this.game.settings.states.LIQUID; // liquid is default
      // but when we do state transitions we're just going to swap substances
      // 2023.05.18 I guess I toyed with changing states and then abandoned it
      // but leaving this in as it seems like it might be worth future exploration
      this.states_ids = {};

      // In reality density of liquids changes with temperature
      // but we're keeping it simple.
      this.density = 1; // water = 1(ish)
    } // function Substance(id)

    initialize(game) {
      super.initialize(game);

      /*
      mixwiths are object ids but as with most object id
      references we allow authors to enter them as
      non-serialized strings. In this case, both the key 
      and the value are ids, so we need to serialize both.
    */
      var keys = Object.keys(this.mixwith);
      for (var i = keys.length - 1; i > -1; i--) {
        var key = keys[i];
        var serialized_key = A.serialize(key);
        var serialized_with = A.serialize(this.mixwith[key]);
        this.mixwith[serialized_key] = serialized_with;
      }
      return true;
    } // p.initialize
  }
  adventurejs.Substance = Substance;
})();

/*

is global - sort of
- can always refer to it though it might not be present
is not a thing
all water is water

what if you color it?
then it becomes a different substance?

pour one substance into another
either they become a third substance
or one substance dissipates into the other
probably depending on viscosity?
water and oil don't mix
water and dirt becomes mud

sponges?
simulate leakage or evaporation - damp_level decrements over time

if you take a handful of a substance does the handful temporarily become an object?

fullness is a property of the object rather than an object in itself?

disambiguation from bodies of water

*/

// Gas.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Substance.Gas
   * @augments adventurejs.Substance
   * @class adventurejs.Gas
   * @ajsconstruct MyGame.createAsset({ "class":"Gas", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading SubstanceClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Base class for Gas Substances, like helium.
   * @tutorial Substances_AboutSubstances
   * @classdesc
   * <p>
   * <strong>Gas</strong> is a subclass of
   * {@link adventurejs.Substance|Substance} with gaseous
   * (as opposed to liquid or solid) properties.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * Substances are different from
   * {@link adventurejs.Tangible|Tangibles} in that they're
   * semi-global, rather than singular. The class represents
   * all of its kind in a {@link adventurejs.Game|Game},
   * meaning, if you create an instance called "helium", all
   * helium in the Game is the same helium, whether it's in a
   * cylinder or a balloon.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Gas",
   *   name: "helium",
   *   description: "It's invisible. ",
   * });
   * MyGame.createAsset({
   *   class: "Balloon",
   *   name: "balloon",
   *   place: { in: "Party" },
   *   description: "It's a balloon. ",
   *   in:
   *   {
   *     vessel: {
   *       volume: 2000,
   *       substance_id: "helium",
   *     },
   *   },
   * });
   * </code></pre>
   **/
  class Gas extends adventurejs.Substance {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Gas";

      this.noun = "Gas";
      this.is.gas = true;

      //this.freezing_temperature = 0; // water // TODO lookup table
      //this.boiling_temperature = 100; // water // TODO lookup table
      this.specific_heat = 5.2; // helium = 5.2Kj or 5200j // TODO lookup table
      this.state = this.game.settings.states.GAS;
    }
  }
  adventurejs.Gas = Gas;
})();

// Liquid.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Substance.Liquid
   * @augments adventurejs.Substance
   * @class adventurejs.Liquid
   * @ajsconstruct MyGame.createAsset({ "class":"Liquid", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading SubstanceClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Base class for liquids. Has properties of water.
   * @tutorial Substances_AboutSubstances
   * @classdesc
   * <p>
   * <strong>Liquid</strong> is a subclass of
   * {@link adventurejs.Substance|Substance} with liquid
   * (as opposed to solid or gaseous) properties. Liquid is
   * equivalent to water in its freezing temperature, boiling
   * temperature, and specific heat.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * Substances are different from
   * {@link adventurejs.Tangible|Tangibles} in that they're
   * semi-global, rather than singular. The class represents
   * all of its kind in a {@link adventurejs.Game|Game},
   * meaning, if you create an instance called "water", all
   * water in the Game is the same water, whether it's in a
   * lake or a drinking glass. As such, Liquid
   * has no temperature setting of its own. Instead, temperature
   * can be applied to a Liquid's container.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Liquid",
   *   name: "water",
   *   description: "It's water. ",
   * });
   * MyGame.createAsset({
   *   class: "Bowl",
   *   name: "bowl",
   *   place: { on: "counter" },
   *   description: "It's a bowl. ",
   *   in:
   *   {
   *     vessel: {
   *       volume: 350,
   *       substance_id: "water",
   *       temperature: 20,
   *     },
   *   },
   * });
   * </code></pre>
   * <p>
   * Liquids that you define can be mixed and turned into
   * other Liquids by setting the
   * <a class="code property" href="#mixwith">mixwith</a>
   * property, as shown in the example below.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Liquid",
   *   name: "water",
   *   description: "It's water. ",
   *   mixwith:
   *   {
   *     "milk": "watery milk",
   *     "ketchup": "ketchup water",
   *     "beer": "watered down beer",
   *   },
   * });
   * MyGame.createAsset({
   *   class: "Liquid",
   *   name: "milk",
   *   description: "It's milk. ",
   *   mixwith:
   *   {
   *     "water": "watery milk",
   *   },
   * });
   *
   * MyGame.createAsset({
   *   class: "Liquid",
   *   name: "watery milk",
   *   description: "It's watery milk. ",
   *   mixwith:
   *   {
   *     "milk": "watery milk",
   *     "water": "watery milk",
   *   },
   * });
   * </code></pre>
   **/
  class Liquid extends adventurejs.Substance {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Liquid";

      this.noun = "Liquid";

      this.is.known = true;
      this.is.liquid = true;

      this.setDOVs(["drink", "pour", "take", "put", "give"]);
      this.setIOVs(["fill"]);

      this.freezing_temperature = 0; // water // TODO lookup table
      this.boiling_temperature = 100; // water // TODO lookup table
      this.specific_heat = 4.2; // water = 4.2Kj or 4200j // TODO lookup table
      this.state = this.game.settings.states.LIQUID;
    }
  }

  adventurejs.Liquid = Liquid;
})();

// Slurry.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Substance.Slurry
   * @augments adventurejs.Substance
   * @class adventurejs.Slurry
   * @ajsconstruct MyGame.createAsset({ "class":"Slurry", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading SubstanceClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Base class for Slurry Substances, like mud.
   * @tutorial Substances_AboutSubstances
   * @classdesc
   * <p>
   * <strong>Slurry</strong> is a subclass of
   * {@link adventurejs.Substance|Substance} with mixed
   * =properties of Solid and Liquid.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * Substances are different from
   * {@link adventurejs.Tangible|Tangibles} in that they're
   * semi-global, rather than singular. The class represents
   * all of its kind in a {@link adventurejs.Game|Game},
   * meaning, if you create an instance called "mud", all
   * mud in the Game is the same mud, whether it's in a
   * puddle or a bowl.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Slurry",
   *   name: "mud",
   *   description: "It's mud. ",
   * });
   * MyGame.createAsset({
   *   class: "Bucket",
   *   name: "bucket",
   *   place: { in: "shed" },
   *   description: "It's a bucket. ",
   *   in:
   *   {
   *     vessel: {
   *       volume: 2000,
   *       substance_id: "mud",
   *     },
   *   },
   * });
   * </code></pre>
   **/
  class Slurry extends adventurejs.Substance {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Slurry";
      
      this.noun = "Slurry";
      this.setDOVs(["pour", "take", "put", "give"]);
      this.setIOVs(["fill"]);
      this.is.slurry = true;

      //this.freezing_temperature = 0; // water // TODO lookup table
      //this.boiling_temperature = 100; // water // TODO lookup table
      this.specific_heat = 0.8; // soil = 0.8Kj or 800j // TODO lookup table
      this.state = this.game.settings.states.SLURRY;
    }
  }

  adventurejs.Slurry = Slurry;
})();

// Solid.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Substance.Solid
   * @augments adventurejs.Substance
   * @class adventurejs.Solid
   * @ajsconstruct MyGame.createAsset({ "class":"Solid", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading SubstanceClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Base class for Solid Substances, like dirt.
   * @tutorial Substances_AboutSubstances
   * @classdesc
   * <p>
   * <strong>Solid</strong> is a subclass of
   * {@link adventurejs.Substance|Substance} with solid
   * (as opposed to liquid or gaseous) properties.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * Substances are different from
   * {@link adventurejs.Tangible|Tangibles} in that they're
   * semi-global, rather than singular. The class represents
   * all of its kind in a {@link adventurejs.Game|Game},
   * meaning, if you create an instance called "dirt", all
   * dirt in the Game is the same dirt, whether it's in a
   * grave or a bucket.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Solid",
   *   name: "dirt",
   *   description: "It's dirt. ",
   * });
   * MyGame.createAsset({
   *   class: "Bucket",
   *   name: "bucket",
   *   place: { in: "shed" },
   *   description: "It's a bucket. ",
   *   in:
   *   {
   *     vessel: {
   *       volume: 2000,
   *       substance_id: "dirt",
   *     },
   *   },
   * });
   * </code></pre>
   **/
  class Solid extends adventurejs.Substance {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Solid";
      
      this.noun = "Solid";

      this.setDOVs(["pour", "take", "put", "give"]);
      this.setIOVs(["fill"]);
      this.is.solid = true;

      //this.freezing_temperature = 0; // water // TODO lookup table
      //this.boiling_temperature = 100; // water // TODO lookup table
      this.specific_heat = 0.8; // soil = 0.8Kj or 800j // TODO lookup table
      this.state = this.game.settings.states.SOLID;
    }
  }

  adventurejs.Solid = Solid;
})();

// Vessel.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Vessel
   * @augments adventurejs.Atom
   * @class adventurejs.Vessel
   * @ajsinternal
   * @ajsnavheading BaseClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Class added to an Aspect (aka aspects) to allow it to hold substances.
   * @tutorial Substances_Vessels
   * @classdesc
   * <p>
   * <strong>Vessel</strong> is a special class that
   * adds the ability to contain substances to
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Assets}.
   * Vessels must exist within
   * {@link adventurejs.Aspect|Aspects},
   * which exist within
   * {@link adventurejs.Tangible|Tangibles}.
   * In other words,
   * <code class="property">Tangible.Aspect.Vessel</code>,
   * or as a practical example: <code class="property">sink.aspects.in.vessel</code>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Bowl",
   *   name: "stone bowl",
   *   place: { on: "blood stained shrine" },
   *   descriptions:{look:"It's a stained, chipped stone bowl. ",}
   *   in:
   *   {
   *     vessel: {
   *       maxvolume: 500,
   *       volume: 350,
   *       substance_id: "viscous fluid",
   *     },
   *   },
   * });
   * </code></pre>
   * <p>
   * To learn more, see how to use
   * <a href="/doc/Substances_AboutSubstances.html">Substances</a>.
   * </p>
   **/
  class Vessel extends adventurejs.Atom {
    constructor(name, game_name, parent_id) {
      super(name, game_name);
      this.class = "Vessel";
      if ("string" === typeof parent_id && parent_id) {
        this.parent_id = parent_id;
      }

      this.list_in_room = true; // <- to contents
      this.list_in_examine = true; // <- to contents

      this.with_classes = []; // defined

      this.substance_id = "";
      this.can_only_contain_these_substances = []; // defined
      this.maxvolume = 0;
      this.can_overflow = true;
      this.volume = 0;
      this.mix_volume = 0;
      this.vessel_is_known = false;
      this.drain_id = "";

      this.temperature = this.game.settings.room_temperature;
      this.temperature_equilibrates = false; // TODO equilibrium calculations
      this.density = 1; // water // TODO function of temp

      //this.state = this.game.settings.states.LIQUID; // liquid is default
      // when state change occurs, swap substances

      // for drains
      this.is_drain = false;
      this.max_volume_of_flow_per_turn = -1;
      this.rate_of_flow = -1; // 0 to 1

      // for emitters
      this.is_emitter = false;
      this.is_emitting = false;
      this.target_id = "";

      this.is_body_of_substance = false;
    }

    get temperature() {
      return this.__temperature;
    }
    set temperature(temperature) {
      temperature = Number(temperature);
      if (isNaN(temperature) || "number" !== typeof temperature) {
        var msg =
          "Vessel.js > instance " +
          this.id +
          " received invalid temperature " +
          String(temperature);
        this.game.log("error", "high", msg, "Vessel");
      } else {
        //this.game.log( "log", "high", "Vessel.js > instance " + this.id + " received valid temperature " + temperature, "Vessel" );
        this.__temperature = temperature;
      }
    }

    /**
     * @var {Getter} adventurejs.Vessel#can_drain
     * @default false
     */
    get can_drain() {
      // is this a drain?
      if (this.is_drain && this.game.getAsset(this.parent_id).is.plugged) {
        return true;
      }

      // or does it have a separate drain asset?
      else if (this.drain_id) {
        var drain = this.game.getAsset(this.drain_id);
        if (drain && drain.is.plugged) {
          return true;
        }
      }

      return false;
    }

    get parent_id() {
      return this.__parent_id;
    }
    set parent_id(id) {
      id = A.serialize(id);
      this.__parent_id = id;
    }

    get drain_id() {
      return this.__drain_id;
    }
    set drain_id(id) {
      id = A.serialize(id);
      this.__drain_id = id;
    }

    get substance_id() {
      if (0 < this.volume || this.is_emitter) {
        return this.__substance_id;
      } else return "";
    }
    set substance_id(substance_id) {
      this.__substance_id = A.serialize(substance_id);
    }

    get maxvolume() {
      if (isNaN(this.__maxvolume)) return 0;
      return this.__maxvolume;
    }
    set maxvolume(volume) {
      if (Infinity === volume) {
        this.__maxvolume = Infinity;
        //this.__volume = Infinity;
        return;
      }

      this.__maxvolume = A.convertVolume.call(this, volume, this.parent_id);
    }

    get volume() {
      if (isNaN(this.__volume)) return 0;
      return this.__volume;
    }
    set volume(volume) {
      //console.warn( "volume: " + volume );
      if (true === this.is_drain) {
        this.__volume = 0;
        return;
      }
      if (Infinity === volume) {
        // infinite
        this.__volume = Infinity;
        this.__maxvolume = Infinity;
        return;
      }

      this.__volume = A.convertVolume.call(this, volume, this.parent_id);
    }

    get percent_of_maxvolume() {
      if (isFinite(this.maxvolume)) {
        return this.volume / this.maxvolume;
      } else {
        return 1;
      }
    }
    set percent_of_maxvolume(percent) {
      if (isFinite(this.maxvolume)) {
        this.volume = this.maxvolume * percent;
      } else {
        this.volume = this.maxvolume;
      }
    }

    get game_name() {
      return this.__game_name;
    }
    set game_name(game_name) {
      this.__game_name = game_name;
    }

    get game() {
      return window[this.game_name] || false;
    }

    get with_classes() {
      return this.__with_classes;
    }
    set with_classes(arr) {
      if (false === Array.isArray(this.__with_classes)) {
        this.__with_classes = [];
      }
      this.__with_classes = A.validateClassList(arr);
    }

    get can_only_contain_these_substances() {
      return this.__can_only_contain_these_substances;
    }
    set can_only_contain_these_substances(arr) {
      if (false === Array.isArray(this.__can_only_contain_these_substances)) {
        this.__can_only_contain_these_substances = [];
      }
      this.__can_only_contain_these_substances = A.validateAssetList(arr);
    }

    get max_volume_of_flow_per_turn() {
      if (isNaN(this.__max_volume_of_flow_per_turn)) return 0;
      return this.__max_volume_of_flow_per_turn;
    }
    set max_volume_of_flow_per_turn(volume) {
      if (Infinity === volume) {
        this.__max_volume_of_flow_per_turn = Infinity;
        return;
      }

      this.__max_volume_of_flow_per_turn = A.convertVolume.call(
        this,
        volume,
        this.parent_id
      );
    }

    get volume_of_flow_per_turn() {
      return this.max_volume_of_flow_per_turn * this.rate_of_flow;
    }

    get mass() {
      if (!this.substance) return 0;
      return this.volume * this.vessel.density;
    }

    get mix_mass() {
      if (!this.substance) return 0;
      return this.mix_volume * this.vessel.density;
    }

    get substance() {
      return this.game.getAsset(this.__substance_id);
    }

    get heat_capacity() {
      if (!this.substance) return 0;
      return this.vessel.specific_heat * this.mass;
    }

    /**
     * <strong>empty</strong> sets the volume of this vessel to 0.
     * @memberOf adventurejs.Vessel
     * @method adventurejs.Vessel#getVolume
     * @returns {number}
     */
    empty() {
      if (!this.is_emitting && Infinity !== this.volume) {
        this.volume = 0;
      }
      return this.volume;
    }

    /**
     * <strong>getVolume</strong> is called to get the current volume of this vessel.
     * Takes into consideration whether vessel is emitting.
     * @memberOf adventurejs.Vessel
     * @method adventurejs.Vessel#getVolume
     * @returns {number}
     */
    getVolume() {
      if (this.is_emitting) {
        return this.volume_of_flow_per_turn * this.rate_of_flow;
      } else return this.volume;
    }

    /**
     * <strong>setVolume</strong> is called to set a
     * vessel to a specified volume.
     * @memberOf adventurejs.Vessel
     * @method adventurejs.Vessel#setVolume
     * @param {number} volume The volume to set the vessel to.
     */
    setVolume(volume) {
      this.volume = volume;
      return this.volume;
    }

    /**
     * <strong>addVolume</strong> is called to raise the
     * vessel's volume by a specified amount.
     * @memberOf adventurejs.Vessel
     * @method adventurejs.Vessel#addVolume
     * @param {number} volume The volume to add to the vessel.
     */
    addVolume(volume) {
      if (Infinity !== this.volume) {
        volume = this.volume + volume;
        if (volume > this.maxvolume) volume = this.maxvolume;
        this.volume = volume;
      }
      return this.volume;
    }

    /**
     * <strong>subtractVolume</strong> is called to reduce the
     * vessel's volume by a specified amount.
     * @memberOf adventurejs.Vessel
     * @method adventurejs.Vessel#subtractVolume
     * @param {number} volume The volume to subtract from the vessel.
     */
    subtractVolume(volume) {
      if (Infinity !== this.volume) {
        volume = this.volume - volume;
        if (0 > volume) volume = 0;
        this.volume = volume;
      }
      return this.volume;
    }
  }

  adventurejs.Vessel = Vessel;
})();

// Aspect.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Aspect
   * @augments adventurejs.Atom
   * @class adventurejs.Aspect
   * @ajsnavheading BaseClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Class that allows putting things in/on/under/behind/attached.
   * @tutorial Tangibles_Aspects
   * @classdesc
   * <p>
   * <strong>Aspect</strong> is a special class
   * that creates spaces within any
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset},
   * which can contain other Tangibles and/or
   * {@link adventurejs.Substance|Substances},
   * with the addition of a
   * {@link adventurejs.Vessel|Vessel}.
   * The five most commonly used aspects are behind,
   * in, on, under, and attached, and a lot of default logic is
   * predicated on using one of these. However it is possible to
   * create aspects at any preposition. Just note that it might
   * lead to unexpected results and require custom code.
   * </p>
   * <pre class="display"><code class="language-javascript">this.aspects.behind = {};
   * </code></pre>
   * <p>
   * Here is an example of how to set the properties of a
   * Aspect of an existing class using createAsset.
   * If you use a preposition that hasn't been defined for the class
   * you're using, a new Aspect will be constructed
   * automatically during construction.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Desk",
   *   name: "desk",
   *   place: { in: "Office" },
   *   behind: {
   *     list_in_room: false,
   *     list_in_examine: true,
   *     maxheight: 1,
   *     maxwidth: 6,
   *     maxdepth: 4,
   *   }
   * });
   * </code></pre>
   * <p>
   * To define a new class with an Aspect, use the Aspect
   * constructor within the class constructor. Here is a very simple
   * example of a new class with a behind Aspect.
   * </p>
   * <pre class="display"><code class="language-javascript">class NewClass {
   *   constructor( name, game_name ) {
   *     super( name, game_name );
   *     this.aspects.newaspect = new adventurejs.Aspect( "newaspect", this.game_name )
   *     .set({
   *       "parent_id": this.id,
   *     });
   *    }
   *   }
   *   adventurejs.NewClass = NewClass;
   * };
   * </code></pre>
   **/
  class Aspect extends adventurejs.Atom {
    constructor(name, game_name, parent_id) {
      super(name, game_name);
      this.class = "Aspect";
      if ("string" === typeof parent_id && parent_id) {
        this.parent_id = parent_id;
      } else this.parent_id = "";
      this.maxheight = -1;
      this.maxwidth = -1;
      this.maxdepth = -1;
      this.maxcount = -1;
      this.maxsize = -1;
      this.maxweight = -1;
      this.maxvolume = -1; // in ml, -1 = infinite

      this.list_in_room = true; // <- to contents
      this.list_in_examine = true; // <- to contents
      this.know_with_parent = false;

      this.contents = []; // defined // <- to contents
      this.with_assets = []; // defined
      this.with_classes = []; // defined
      this.player_can_add_assets_to_contents = true;
      this.player_can_remove_assets_from_contents = true;

      this.vessel = {};
      this.plug_id = "";
      //this.plugs = [];

      /**
       * A collection of properties that defines whether a player may
       * enter this aspect, what actions they are allowed to perform
       * in it, and the default posture they will take upon entering.
       * Aspects and Rooms both share these properties.
       * @var {boolean} adventurejs.Aspect#player
       * @default {}
       * Aspect_Player
       */
      this.player = new adventurejs.Aspect_Player(
        "player",
        this.game_name,
        this.parent_id,
        this.name
      ).set({
        parent_id: this.parent_id,
        preposition: this.name,
      });

      /**
       * <strong>orientation</strong> determines whether an Aspect
       * is horizontal or vertical. Chiefly meant to distinguish
       * between player being on a flat surface such as a table,
       * vs player being on a vertical face such as a tree.
       * @var {String} adventurejs.Aspect#orientation
       * @default "horizontal"
       */
      this.orientation = "horizontal";

      /**
       * @var {boolean} adventurejs.Aspect#is_false_nest
       * @default false
       */
      this.is_false_nest = false;

      /**
       * @var {boolean} adventurejs.Aspect#player_can_reach
       * @default true
       */
      this.player_can_reach = true;

      // these are equivalent
      //this.things_player_can_reach_from_this_aspect = [ "id", {"id":['preposition']} ];
      //this.things_player_can_reach_from_this_aspect = { any: [ "id", {"id":['preposition']} ] }
      this.things_player_can_reach_from_this_aspect = [];

      /**
       *
       * @var {Object|Array} adventurejs.Aspect#things_player_can_reach_from_positions_of_this_aspect
       * @todo for this to work properly each aspect needs its own local coordinates
       */
      this.things_player_can_reach_from_positions_of_this_aspect = {
        // Specify assets that player can reach when nested anywhere
        // within this aspect.
        // array can take "id" or {"id":['preposition']}
        any: [],

        // Specify assets that player can reach when nested within this aspect,
        // at the bottom-most y position of the parent asset's height.
        bottom: [], // min y

        // Specify assets that player can reach when nested within this aspect,
        // at the top-most y position of the parent asset's height.
        // Useful for example when climbing a ladder to reach a skylight.
        top: [], // max y

        // Specify assets that player can reach when nested within this aspect,
        // at the farthest left, or min x position, of the parent asset's width.
        left: [], // min x

        // Specify assets that player can reach when nested within this aspect,
        // at the farthest right, or max x position, of the parent asset's width.
        right: [], // max x

        // Specify assets that player can reach when nested within this aspect,
        // at the farthest front, or min z position, of the parent asset's depth.
        front: [], // min z

        // Specify assets that player can reach when nested within this aspect,
        // at the farthest back, or max z position, of the parent asset's depth.
        back: [], // max z
      };

      return this;
    }

    get parent_id() {
      return this.__parent_id;
    }
    set parent_id(id) {
      id = A.serialize(id);
      this.__parent_id = id;
    }

    get plug_id() {
      return this.__plug_id;
    }
    set plug_id(id) {
      id = A.serialize(id);
      this.__plug_id = id;
      if (!Array.isArray(this.plugs)) {
        this.plugs = [];
      }
      if (this.plugs.indexOf(id) === -1) {
        this.plugs.push(id);
      }
    }

    get contents() {
      return this.__contents;
    }
    set contents(arr) {
      if (!Array.isArray(this.__contents)) {
        this.__contents = [];
      }
      this.__contents = A.validateAssetList(arr);
    }

    get with_assets() {
      return this.__with_assets;
    }
    set with_assets(arr) {
      if (!Array.isArray(this.__with_assets)) {
        this.__with_assets = [];
      }
      this.__with_assets = A.validateAssetList(arr);
    }

    get with_classes() {
      return this.__with_classes;
    }
    set with_classes(arr) {
      if (!Array.isArray(this.__with_classes)) {
        this.__with_classes = [];
      }
      this.__with_classes = A.validateClassList(arr);
    }

    get number_of_listable_things() {
      var num = this.contents.length;
      for (var i = num - 1; i > -1; i--) {
        if (!this.game.getAsset(this.contents[i]).is.listed_in_parent) {
          num--;
        }
      }
      return num;
    }

    /*doc@this*/
    get things_player_can_reach_from_this_aspect() {
      return this.__things_player_can_reach_from_this_aspect;
    }
    set things_player_can_reach_from_this_aspect(arr) {
      if (!Array.isArray(this.__things_player_can_reach_from_this_aspect)) {
        this.__things_player_can_reach_from_this_aspect = [];
      }
      this.__things_player_can_reach_from_this_aspect =
        A.validateAssetList(arr);
    }

    /*doc@this*/
    get things_player_can_reach_from_positions_of_this_aspect() {
      return this.__things_player_can_reach_from_this_aspect_positions;
    }
    set things_player_can_reach_from_positions_of_this_aspect(object) {
      if (
        Object(this.__things_player_can_reach_from_this_aspect_positions) !==
        this.__things_player_can_reach_from_this_aspect_positions
      )
        this.__things_player_can_reach_from_this_aspect_positions = {};
      this.__things_player_can_reach_from_this_aspect_positions =
        A.validateAssetList(object);
    }

    /**
     * This broadly asks whether another asset is reachable from anywhere in this aspect.
     * @param {*} thatobject
     * @param {*} thatprep
     * @returns {Boolean}
     */
    canPlayerReachThatFromThisAspect(thatobject, thatprep) {
      var bool = false;
      bool = A.isIdInMixedArray(
        thatobject.id,
        this.things_player_can_reach_from_this_aspect
      );
      if (bool) return bool;
      bool = this.canPlayerReachThatFromThisAspectPositions(
        thatobject,
        thatprep
      );
      return bool;
    }

    /**
     * This only asks if an object id appears in any position.
     * @param {*} thatobject
     * @param {*} thatprep
     * @returns {Boolean}
     */
    canPlayerReachThatFromThisAspectPositions(thatobject, thatprep) {
      var bool = false;
      var position_keys = Object.keys(
        this.things_player_can_reach_from_positions_of_this_aspect
      );
      console.warn("position_keys", position_keys);
      for (var num in position_keys) {
        var position = position_keys[num];
        console.warn("position", position);

        // @todo additional logic required here to compare positions
        bool = A.isIdInMixedArray(
          thatobject.id,
          this.things_player_can_reach_from_positions_of_this_aspect[position]
        );
        if (bool) return bool;
      }
      return bool;
    }

    /**
     * For the most part the answer is yes. It might not be for <code>in</code>.
     * @todo reachability
     */
    canPlayerReachThisContents() {
      //
    }

    /**
     * For the most part the answer is yes. It might not be for <code>in</code>.
     * @todo visibility
     */
    canPlayerSeeThisContents() {
      //
    }
  }
  adventurejs.Aspect = Aspect;
})();

/*
      // switch( position_key ) 
      // {
      //   case 'any':
      //     break;
      //   case 'bottom':
      //     break;
      //   case 'top':
      //     break;
      //   case 'left':
      //     break;
      //   case 'right':
      //     break;
      //   case 'front':
      //     break;
      //   case 'back':
      //     break;
      // }
*/

// Tangible_Is.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Is.Tangible_Is
   * @augments adventurejs.Asset_Is
   * @class adventurejs.Tangible_Is
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <strong>Tangible_Is.js</strong> is a state management class
   * used to handle a variety of properties for
   * {@link adventurejs.Tangible|Tangible Assets}.
   **/

  class Tangible_Is extends adventurejs.Asset_Is {
    constructor(name = "is", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Tangible_Is";
      this._seen = false;
      //this._known = false;

      /**
       * Set whether this asset is plugged, like a drain.
       * @var {Boolean} adventurejs.Asset#is!plugged
       * @default false
       */
      this._plugged = false;

      /**
       * Set whether this asset is plugged in, like an appliance.
       * @var {Boolean} adventurejs.Asset#is!pluggedIn
       * @default false
       */
      this._pluggedIn = false;

      /**
       * Set whether this asset is hidden.
       * @var {Getter|Boolean} adventurejs.Tangible#is!hidden
       * @default false
       * @todo add logic to test conditions?
       */
      this.hidden = false;

      /**
       * Set whether this asset is a typing target, as in a screen for a keyboard.
       * @var {Boolean} adventurejs.Tangible#is!typing_target
       * @default false
       */
      this.typing_target = false;

      /**
       * Set whether this asset is supported. Used in conjuction with
       * can.swing_on_if_holding_and_supported to determine whether player can swing
       * on the asset in its current state. Meant for assets like two-ended ropes
       * which must be tied to a supporting structure.
       * @var {Boolean} adventurejs.Tangible#is!supported
       * @default false
       */
      this.supported = false;

      /**
       * Set whether this asset is hollow. Used to determine whether player can look in asset.
       * @var {Boolean} adventurejs.Tangible#is!hollow
       * @default false
       */
      this.hollow = false; // determines whether you can look in

      /**
       * Set whether this asset is listed in the current room description.
       * @var {Boolean} adventurejs.Tangible#is!listed_in_room
       * @default true
       */
      this.listed_in_room = true;

      /**
       * Set whether this asset's children are listed in the current room description.
       * Meant for situations where a parent asset is part of the room description,
       * to avoid listing the parent asset twice.
       * @var {Boolean} adventurejs.Tangible#is!unlisted_but_list_children
       * @default false
       */
      this.unlisted_but_list_children = false;

      /**
       * Set whether this asset is listed in its parent's description.
       * @var {Boolean} adventurejs.Tangible#is!listed_in_parent
       * @default true
       */
      this.listed_in_parent = true;

      /**
       * Set whether this asset is distant. Originally meant to help define scenery assets,
       * but mostly superseded by other scenery handling and no logic has been written for it.
       * @var {Boolean} adventurejs.Tangible#is!distant
       * @default false
       */
      this.distant = false;

      /**
       * Set whether this asset is watertight.
       * No logic has been written for this.
       * @var {Boolean} adventurejs.Tangible#is!watertight
       * @default false
       * @todo Write logic for this. Is this the same as airtight?
       */
      this.watertight = false;

      /**
       * Set whether this asset is being worn by player or other characters.
       * @var {Boolean} adventurejs.Tangible#is!worn
       * @default false
       */
      this.worn = false;

      /**
       * Set whether this asset is screwed.
       * @var {Boolean} adventurejs.Tangible#is!screwed
       * @default false
       */
      this.screwed = false;

      /**
       * Set whether this asset is zipped.
       * @var {Boolean} adventurejs.Tangible#is!zipped
       * @default false
       */
      this.zipped = false;

      /**
       * Set whether this asset is buttoned.
       * @var {Boolean} adventurejs.Tangible#is!buttoned
       * @default false
       */
      this.buttoned = false;

      /**
       * Set whether this asset is fixed in its place, such as drawers in a desk.
       * (This may be redundant to can_be_taken.)
       * @var {Boolean} adventurejs.Tangible#is!fixed
       * @default false
       */
      this.fixed = false;

      /**
       * Set whether this asset is locked.
       * @var {Boolean} adventurejs.Tangible#is!locked
       * @default false
       */
      this._locked = false;

      /**
       * Set whether this asset is closed.
       * @var {Boolean} adventurejs.Tangible#is!closed
       * @default false
       */
      this._closed = false;

      /**
       * Set whether this asset is sealed.
       * @var {Boolean} adventurejs.Tangible#is!sealed
       * @default false
       */
      this._sealed = false;

      /**
       * Set whether player can leave this asset. Useful for keeping player from leaving,
       * such as if they're on a carousel horse while the carousel is in motion.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#is!unleavable
       * @default false
       */
      this.unleavable = false;

      /**
       * Set whether this asset can be climbed.
       * @var {Boolean} adventurejs.Tangible#is!climbable
       * @default false
       */
      this.climbable = false;

      /**
       * Set whether this asset can be peddled, like a bicycle.
       * @var {Boolean} adventurejs.Tangible#is!peddleable
       * @default false
       */
      this.peddleable = false;

      /**
       * Set whether this asset can be skated on, like a skateboard.
       * @var {Boolean} adventurejs.Tangible#is!skateable
       * @default false
       */
      this.skateable = false;

      /**
       * Set whether this asset can be looked through,
       * like a window or a telescope.
       * @var {Boolean} adventurejs.Tangible#is!lookthroughable
       * @default false
       */
      this.lookthroughable = false;

      /**
       * Set whether player can nest inside this asset when this asset is in an
       * aspect of another asset (as opposed to being a direct child of a room).
       * For example, a carousel horse might be on a carousel platform.
       * @var {Boolean} adventurejs.Tangible#is!deep_nest
       * @default false
       */
      this.deep_nest = false;

      /**
       *
       * @var {Boolean} adventurejs.Tangible#is!false_nest
       * @default false
       */
      this.false_nest = false;

      return this;
    }

    get seen() {
      return this._seen;
    }
    set seen(value) {
      this._seen = value;
      //this.setLinkedAssetState("_seen", value);
      let parent = this.parent;
      if (parent && parent.setAllAspectsContentsSeen)
        parent.setAllAspectsContentsSeen.call(parent, value);
    }

    get known() {
      return this._known;
    }
    set known(value) {
      this._known = value;
      //this.setLinkedAssetState("_known", value);
      let parent = this.parent;
      if (parent && parent.setAllAspectsContentsKnown)
        parent.setAllAspectsContentsKnown.call(parent, value);
    }

    get plugged() {
      return this._plugged;
    }
    set plugged(value) {
      this._plugged = value;
    }

    get pluggedIn() {
      return this._pluggedIn;
    }
    set pluggedIn(value) {
      this._pluggedIn = value;
    }

    get sealed() {
      return this._sealed;
    }
    set sealed(value) {
      this._sealed = value;
    }

    get closed() {
      return this._closed;
    }
    set closed(value) {
      this._closed = value;
    }

    get locked() {
      return this._locked;
    }
    set locked(value) {
      this._locked = value;
    }
  }
  adventurejs.Tangible_Is = Tangible_Is;
})();

// Tangible_Can.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Can.Tangible_Can
   * @augments adventurejs.Tangible_Can
   * @class adventurejs.Tangible_Can
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <strong>Tangible_Can</strong> is a state management class
   * used to store a variety of booleans for
   * {@link adventurejs.Tangible|Tangible Assets}.
   **/

  class Tangible_Can extends adventurejs.Asset_Can {
    constructor(name = "can", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Tangible_Can";

      return this;
    }
  }
  adventurejs.Tangible_Can = Tangible_Can;
})();

// Tangible_Must.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Can.Tangible_Must
   * @augments adventurejs.Tangible_Must
   * @class adventurejs.Tangible_Must
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <strong>Tangible_Must</strong> is a state management class
   * used to store a variety of booleans for
   * {@link adventurejs.Tangible|Tangible Assets}.
   **/

  class Tangible_Must extends adventurejs.Asset_Can {
    constructor(name = "can", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Tangible_Must";

      /**
       * Set whether this asset must be held to look with, as with a binocular.
       * @var {Boolean} adventurejs.Tangible#must!be_in_hands_to_look_with
       * @default false
       */
      this.be_in_hands_to_look_with = false;

      /**
       * Set whether this asset must be held to look through, as with a telescope.
       * @var {Boolean} adventurejs.Tangible#must!be_in_hands_to_look_through
       * @default false
       */
      this.be_in_hands_to_look_through = false;

      /**
       * Set whether this asset must be worn to look with, as with glasses.
       * @var {Boolean} adventurejs.Tangible#must!be_worn_to_look_with
       * @default false
       */
      this.be_worn_to_look_with = false;

      /**
       * Set whether this asset must be held to be read, as with a small book.
       * @var {Boolean} adventurejs.Tangible#must!be_in_hands_to_read
       * @default false
       */
      this.be_in_hands_to_read = false;

      /**
       * Set whether player will let go of this asset after swinging on it. Meant
       * for situations such as when player swings from a vine and lets go upon landing.
       * @var {Boolean} adventurejs.Tangible#must!let_go_after_swing
       * @default false
       */
      this.let_go_after_swing = false;

      return this;
    }
  }
  adventurejs.Tangible_Must = Tangible_Must;
})();

// Tangible.js
(function () {
  /*global adventurejs A*/
  "use strict";
  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible
   * @augments adventurejs.Matter
   * @class adventurejs.Tangible
   * @ajsconstruct MyGame.createAsset({ "class":"Tangible", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BaseClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Base class for all game objects with physical properties.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Tangible</strong> is the base class for all
   * {@link adventurejs.Asset|Assets} with physical properties
   * in the game world, with the exception of Substances.
   * All of the properties of Tangible are inherited by all of
   * its subclasses, and most subclasses don't define new properties.
   * Most subclasses are essentially convenience methods that set
   * a group of properties particular to a type of object.
   * In theory, an instance of almost any subclass could be made to
   * behave like an instance of almost any other subclass,
   * simply by setting the right properties. This provides the
   * flexibility to mix and match properties to construct game
   * assets with customized behaviors.
   * </p>
   * <p>
   * For example, {@link adventurejs.Chair|Chair} defines
   * something you can sit on, and
   * {@link adventurejs.Bed|Bed} defines something
   * you can lie on, but perhaps you want to make something
   * like a divan, that you can sit on and lie on. You could
   * create a Chair and set asset.aspects.on.player.can.lie
   * property to true.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Chair",
   *   name: "divan",
   *   descriptions: {look:"A comfortable looking fainting couch. ",),
   *   aspects:
   *   {
   *     on: { player: { can: { lie: true } } }
   *   }
   * });
   * </code></pre>
   * This is a simple example of customizing an object, but hopefully
   * it gives you an idea of how flexible the Tangible class is.
   * Alternatively if you wanted to extensively customize your divan,
   * you could define your own Divan class to extend
   * {@link adventurejs.Furniture|Furniture}.
   **/
  class Tangible extends adventurejs.Matter {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Tangible";

      this.is = new adventurejs.Tangible_Is("is", this.game_name, this.id).set({
        parent_id: this.id,
      });

      this.can = new adventurejs.Tangible_Can(
        "can",
        this.game_name,
        this.id
      ).set({
        parent_id: this.id,
      });

      this.must = new adventurejs.Tangible_Must(
        "must",
        this.game_name,
        this.id
      ).set({
        parent_id: this.id,
      });

      /**
       * Containing object for Aspects, aka "in", "out", "under", "behind"
       * etc.
       * @var {Object} adventurejs.Tangible#aspects
       * @default {}
       */
      this.aspects = {};

      // set direct verb subscriptions
      this.setDOVs([
        "attach",
        "detach",
        "go",
        "hit",
        "kick",
        "move",
        "poke",
        "pull",
        "push",
        "shake",
        //"throw",
      ]);

      // set indirect verb subscriptions
      this.setIOVs(["hit", "throw", "flick"]);

      //this.player_has_used = false;

      /**
       * It's possible for player to become nested to an asset without a
       * specified preposition. In such cases, this default aspect is used.
       * @var {String} adventurejs.Tangible#default_aspect
       * @default "on"
       */
      this.default_aspect = "on";

      /**
       * When player is nested, some verbs can only be applied to assets that
       * have been specified as being within reach.
       * @var {Array} adventurejs.Tangible#things_player_can_do_all_verbs_to_from_this
       * @default []
       * @todo Revisit this. Use things_within_reach for all reach settings?
       */
      this.things_player_can_do_all_verbs_to_from_this = [];

      /**
       * When player climbs asset, set their preposition to this default.
       * @var {String} adventurejs.Tangible#default_aspect_for_climb
       * @default "on"
       * @todo Move string to const
       */
      this.default_aspect_for_climb = "on";

      /**
       * Set whether 'climb' means 'go on', which might apply to assets
       * such as stairs and ladders.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!climb_means_go_on
       * @default false
       */
      this.quirks.climb_means_go_on = false;

      /**
       * Set whether 'climb' means 'stand on', which might apply to
       * furniture and things like boulders which players can stand on.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!climb_means_stand_on
       * @default false
       */
      this.quirks.climb_means_stand_on = false;

      /**
       * Set list of other assets that player can climb to from this.
       * @var {Array} adventurejs.Tangible#things_player_can_climb_to_from_this
       * @default []
       */
      this.things_player_can_climb_to_from_this = [];

      /**
       * Set whether 'crawl' means 'go on', which might apply to
       * furniture and things like boulders which players can stand on.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!crawl_means_go
       * @default false
       */
      this.quirks.crawl_means_go = true;

      /**
       * Set whether player can go off (aka get off) this asset. Used for Rooms.
       * @var {Boolean} adventurejs.Tangible#player_can_exit
       * @default false
       */
      this.player_can_exit = false;

      /**
       * Set whether 'stand' means 'go off' (aka 'get off'), which might apply
       * to furniture such as chairs.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!stand_means_get_off
       * @default false
       */
      this.quirks.stand_means_get_off = false;

      /**
       * Set whether 'get up' means 'go off' (aka 'get off'), which might apply
       * to furniture such as chairs or beds.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!get_up_means_get_off
       * @default false
       */
      this.quirks.get_up_means_get_off = false;

      /**
       * Set whether 'get on' means 'climb', which might apply
       * to things such as trees.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!go_on_means_climb
       * @default false
       */
      this.quirks.go_on_means_climb = false;

      /**
       * If set to true, "in" and "on" become interchangeable for some verbs.
       * Intended chiefly for things like chairs where "sit in chair"
       * and "sit on chair" can be interpreted to mean the same thing.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!in_means_on
       * @default false
       */
      this.quirks.in_means_on = false;

      /**
       * If set to true, "put" means "pour" for some verbs.
       * Intended chiefly for things like "put syrup on pancakes" which is
       * a common phrasing where clearly the speaker means to pour.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!put_means_pour
       * @default false
       */
      this.quirks.put_means_pour = false;

      /**
       * Set whether 'jump' means 'jump on' as in jumping up and down on a bed.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!jump_means_jump_on
       * @default true
       */
      this.quirks.jump_means_jump_on = true;

      /**
       * Set whether 'jump' means 'jump off' as in jumping off a tree.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!jump_means_jump_off
       * @default false
       */
      this.quirks.jump_means_jump_off = false;

      /**
       * List of other assets player can jump to while nested within this asset.
       * @var {Array} adventurejs.Tangible#things_player_can_jump_to_from_this
       * @default []
       */
      this.things_player_can_jump_to_from_this = [];

      /**
       * Set whether player can step on this asset.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!step_on_means_stamp_on
       * @default false
       */
      this.quirks.step_on_means_stamp_on = false;

      /**
       * Set whether ver 'step on' means 'stand on', as with a skateboard or some
       * types of furniture.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!step_on_means_stand_on
       * @default false
       */
      this.quirks.step_on_means_stand_on = false;

      /**
       * If player becomes nested within this asset via 'swing to', set the player's
       * posture to this default.
       * @var {Boolean} adventurejs.Tangible#default_posture_for_swing_to
       * @default false
       */
      this.default_posture_for_swing_to = "stand";

      /**
       * If player becomes nested within this asset via 'swing to', set the player's
       * preposition to this default.
       * @var {Boolean} adventurejs.Tangible#default_aspect_for_swing_to
       * @default false
       */
      this.default_aspect_for_swing_to = "on";

      /**
       * List of other assets that player can swing to while nested within this asset.
       * @var {Array} adventurejs.Tangible#things_player_can_swing_to_from_this
       * @default []
       */
      this.things_player_can_swing_to_from_this = [];

      /**
       * Set whether player can hang on this asset.
       * @var {Boolean} adventurejs.Tangible#player_can_hang_on_this
       * @default false
       */
      this.player_can_hang_on_this = false;

      /**
       * A string that describes the position the
       * {@link adventurejs.Asset|Asset}
       * is in, ex "resting" for most non-Character Assets,
       * or "lying", "sitting", "standing" etc for
       * {@link adventurejs.Characters|Characters}.
       * <code class="property">this.game.dictionary.getStringLookup( type, value )</code>.
       * Can be referenced in custom code through
       * <code class="property">MyGame.dictionary.getStringLookup( type, value )</code>.
       * @var {Boolean} adventurejs.Tangible#posture_position
       * @default "default"
       */
      this.posture_position = this.game.dictionary.getStringLookup(
        "posture_positions",
        "default"
      );

      /**
       * Set whether player knows a thing is hidden. Useful if player is the one doing
       * the hiding, or if player has found an object but not picked it up.
       * @var {Boolean} adventurejs.Tangible#player_knows_its_hidden
       * @default false
       */
      this.player_knows_its_hidden = false;

      /**
       * Set an asset's percent of buoyancy. No logic has been implemented around this.
       * @var {float} adventurejs.Tangible#buoyancy
       * @default 0
       * @todo Implement.
       */
      this.buoyancy = 0; // range 0 to 1

      /**
       * Set the amount of liquid an asset has absorbed.
       * No particular logic has been implemented around absorption.
       * @var {Boolean} adventurejs.Tangible#absorption_quantity
       * @default 0
       */
      this.absorption_quantity = 0;

      /**
       * Set whether a closed thing can be auto-opened. This is used chiefly for 'go to',
       * which tries to auto-open doors, something which authors might want to prevent
       * depending on other logic.
       * @var {Boolean} adventurejs.Tangible#can!auto_open
       * @default false
       */
      this.can.auto_open = false;

      /**
       * Set whether a locked thing can be auto-unlocked. This is used chiefly for 'go to',
       * which tries to auto-unlock doors, something which authors might want to prevent
       * depending on other logic.
       * @var {Boolean} adventurejs.Tangible#can!auto_unlock
       * @default false
       */
      this.can.auto_unlock = false;

      /**
       * Set whether a sealed thing can be auto-unsealed. This is used chiefly for 'go to',
       * which tries to auto-unseal apertures, something which authors might want to prevent
       * depending on other logic.
       * @var {Boolean} adventurejs.Tangible#can!auto_unseal
       * @default false
       */
      this.can.auto_unseal = false;

      /**
       * Set whether 'pick' means 'unlock'. This is provided to give authors the option
       * to choose whether pick and unlock are treated as distinct verbs.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!pick_means_unlock
       * @default false
       */
      this.quirks.pick_means_unlock = false;

      /**
       * Set a message to print for asset's single use.
       * @var {Boolean} adventurejs.Tangible#use_once_message
       * @default false
       */
      this.use_once_message = "";

      /* *
       * Tangible Assets may have numerous descriptions, though all but
       * default are optional.
       * @var {Object} adventurejs.Tangible#descriptions
       * @default { look: "", careful: "", long: "", short: "", brief: "", verbose: "", closed: "", open: "", taste: "", smell:"", listen:"", in:"", through:"", }
       */
      this.descriptions = {
        look: "",
        brief: "",
        verbose: "",
        careful: "",
        closed: "",
        open: "",
        taste: "",
        touch: "",
        smell: "",
        sound: "",
        exits: "",
        for_exits_list: "",
        behind: "",
        in: "",
        on: "",
        over: "",
        through: "",
        under: "",
      };

      /* *
       * @var {String} adventurejs.Tangible#description
       * @default ""
       */
      //this.description = "";//"$(We) see nothing worth mentioning.";

      /**
       * Set whether this asset should be destroyed when drunk.
       * @var {Boolean} adventurejs.Tangible#on_drink_destroy
       * @default false
       */
      this.on_drink_destroy = false;

      /**
       * Set whether this asset should be emptied when drunk,
       * versus only subtracting a mouthful as set in Settings.
       * @var {Boolean} adventurejs.Tangible#on_drink_empty
       * @default false
       */
      this.on_drink_empty = false;

      /**
       * Set whether this asset should be destroyed when eaten.
       * @var {Boolean} adventurejs.Tangible#on_eat_destroy
       * @default false
       */
      this.on_eat_destroy = false;

      /**
       * Set whether "look with" is equivalent to "look through". For example,
       * in the case of a telescope, "look with telescope" is equivalent to
       * "look through telescope". In the case of a window, you can look through
       * it, but not look with it. In the case of a candle, you can look with it,
       * but not look through it.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!look_with_means_look_through
       * @default false
       */
      this.quirks.look_with_means_look_through = false;

      /**
       * This property was superseded by the GraduatedController class. It may still be useful
       * for simpler interactions. Use in conjunction with turn_rotation to save current position.
       * @var {int} adventurejs.Tangible#turn_positions
       * @default 1
       */
      this.turn_positions = 1;

      /**
       * This property was superseded by the GraduatedController class. It may still be useful
       * for simpler interactions. Use in conjunction with turn_positions to set number of positions.
       * @var {float} adventurejs.Tangible#turn_rotation
       * @default 0
       */
      this.turn_rotation = 0;

      /**
       * @var {String} adventurejs.Tangible#turn_target_id
       * @default ""
       */
      this.turn_target_id = "";

      /**
       * Used by GraduatedController class to set target for the controller.
       * @var {String} adventurejs.Tangible#control_target_id
       * @default ""
       */
      this.control_target_id = "";

      /**
       * Used by GraduatedController class to set number of control positions for a
       * controller, where 2 is a toggle and anything more than 2 is a dial.
       * @var {int} adventurejs.Tangible#control_positions
       * @default 1
       */
      this.control_positions = 1;

      /**
       * Used by GraduatedController class to set current position of controller.
       * 0 means off. If 2 positions are available, 1 means on. If more than
       * 2 positions, each position above 0 is treated as a percent of total capacity.
       * For example in a 3 position controller, 1 = 50% and 2 = 100%;
       * @var {int} adventurejs.Tangible#current_position
       * @default 0
       */
      this.current_position = 0;

      /**
       * Set whether this asset can be swung at another asset, as in swinging a bat at a ball.
       * @var {Boolean} adventurejs.Tangible#can!be_swung_at
       * @default true
       */
      this.can.be_swung_at = true;

      // readin'n'writin'

      /**
       * Set whether this asset can be written in
       * like a book.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!write_on_means_write_in
       * @default false
       */
      this.quirks.write_on_means_write_in = false;

      /**
       * List of strings that have been written on this asset.
       * @var {Array} adventurejs.Tangible#written_strings
       * @default []
       */
      this.written_strings = [];

      /**
       * Set whether strings written on this asset are appended to its description.
       * @var {Boolean} adventurejs.Tangible#append_written_strings_to_description
       * @default false
       */
      this.append_written_strings_to_description = false;

      /**
       * Set the ID of a target asset for this asset to type on, as in a screen for a keyboard.
       * @var {String} adventurejs.Tangible#typing_target_id
       * @default ""
       */
      this.typing_target_id = "";

      // ROPES

      /**
       * Set whether this is taken into player inventory when another asset is tied
       * to it. For example, on tying a string that is in inventory to a tin can that
       * is not in inventory, it's assumed that player would then pick up the can.
       * @var {Boolean} adventurejs.Tangible#on_tie_to_this_take_this
       * @default false
       */
      this.on_tie_to_this_take_this = false;

      /**
       * If player uses a rope in inventory to tie to an object that is not in inventory,
       * this sets whether the object gets dragged behind when player leaves the current room.
       * @var {Boolean} adventurejs.Tangible#on_tie_to_drag_behind_rope
       * @default false
       */
      this.on_tie_to_drag_behind_rope = false;

      /**
       * Set whether this asset's description includes things that it is tied to.
       * @var {Boolean} adventurejs.Tangible#show_things_this_is_tied_to_in_description
       * @default true
       */
      this.show_things_this_is_tied_to_in_description = true;

      /**
       * Set whether 'take' means 'hold', as in the case of hanging ropes.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!take_means_hold
       * @default false
       */
      this.quirks.take_means_hold = false; // used for swingable things

      /**
       * Set whether 'let go of' means 'get off', as in the case of assets that
       * the player is suspended from, such as hanging from a rope.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!let_go_of_means_go_off
       * @default false
       */
      this.quirks.let_go_of_means_go_off = false;

      /**
       * Set whether 'let go of' means 'go down', as in the case of player being
       * suspended by a rope above a pit, where letting go means moving to a new Room.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!let_go_of_means_go_down
       * @default false
       */
      this.quirks.let_go_of_means_go_down = false;

      /**
       * Set properties for a variety of things a tangible asset can emit.
       * @var {Boolean} adventurejs.Tangible#emits
       * @default false
       * @todo Write logic for this.
       */
      this.emits = {
        gravity: { enabled: false, level: 0, description: "", results: null },
        light: { enabled: false, level: 0, description: "", results: null },
        heat: { enabled: false, level: 0, description: "", results: null },
        sound: { enabled: false, level: 0, description: "", results: null },
        smell: { enabled: false, level: 0, description: "", results: null },

        // liquid: { enabled: false, level: 0, description: '', results: null, id:'' },
        // gas: { enabled: false, level: 0, description: '', results: null, id:'' },
        // slurry: { enabled: false, level: 0, description: '', results: null, id:'' },
        // solid: { enabled: false, level: 0, description: '', results: null, id:'' },
        substance: {
          enabled: false,
          level: 0,
          description: "",
          results: null,
          id: "",
        },
      };

      /**
       * Set whether this asset must have a location. Chiefly for use with Aperture class.
       * Apertures must have a location because they're tied to Exits. Other assets can
       * exist without a location, though unlocated tangible assets won't be available to player.
       * @var {Boolean} adventurejs.Tangible#location_required
       * @default false
       */
      this.location_required = false; // some classes must have a location

      /**
       * Explicitly set whether this asset can exist without a location. Chiefly for use
       * with Room class. Rooms will not have a location.
       * @var {Boolean} adventurejs.Tangible#location_unneccessary
       * @default false
       */
      this.location_unneccessary = false; // some classes don't need a location

      /**
       * Set the minimum light required to see this asset. Meant for situations with
       * variable lighting where some objects might be hidden in shadow.
       * @var {float} adventurejs.Tangible#min_light_required_to_see
       * @default 0.5
       * @todo Write logic for this in selectVisible.js
       */
      this.min_light_required_to_see = 0.5; // TODO amount of ambient light required to be visible

      /**
       * @var {Object} adventurejs.Tangible#dimensions
       * @default {}
       */
      this.dimensions = {
        depth: -1,

        /**
         * Set a height for this asset. Used to calculate whether some assets can fit in other assets.
         * Also used for climbing and reachability.
         * Currently, 1 is considered to be human height, or about six feet.
         * @var {float} adventurejs.Tangible#dimensions.height
         * @default 1
         */
        height: 0,

        /**
         * Set the opacity for this asset. Used for assets made of transparent materials
         * such as glass, and helps determine whether player can look in or through assets.
         * @var {float} adventurejs.Tangible#opacity
         * @default 1
         */
        opacity: 1,

        /**
         * Set a size for this asset. Meant for figuring whether some assets can fit in other assets.
         * Logic for this is incomplete and may be duplicative of width / height / depth.
         * @var {float} adventurejs.Tangible#dimensions.size
         * @default -1
         * @todo Revisit this. Does it conflict with width / height / depth?
         */
        size: -1,

        /**
         * Set a weight for this asset. Used to calculate whether some assets can fit in other assets.
         * May also be used for buoyancy though no logic has been written for that.
         * @var {float} adventurejs.Tangible#dimensions.weight
         * @default -1
         * @todo Figure weight into buoyancy?
         */
        weight: -1,

        /**
         * Set a width for this asset. Used to calculate whether some assets can fit in other assets.
         * @var {float} adventurejs.Tangible#dimensions.width
         * @default 1
         */
        width: -1,
      };

      /**
       * XYZ coordinates. Defaults to 0,0,0.
       * It's safe to ignore these if you don't want to use them.
       * They can be used for things like:
       * <ul>
       * <li>managing reachability of objects that are on top of other things</li>
       * <li>managing reachability of objects in the room while player is climbing or standing atop a thing</li>
       * <li>dividing a room up into reachable/unreachable spaces</li>
       * <li>managing player depth in an underwater location</li>
       * <li>managing player position while flying/floating/levitating</li>
       * </ul>
       * Here's an example of how to set an object's position.
       * <pre class="display"><code class="language-javascript">MyGame.createAsset({
       *   class: "Stalactite",
       *   name: "stalactite",
       *   place: { on: "Colossal Cave" },
       *   descriptions: {look: "It clings tight to the ceiling. ",},
       *   height: -2,
       *   position: { x:0, y:5, z:0 },
       * });
       * </code></pre>
       * Also see related <a href="#height">height</a>.
       * @var {Object} adventurejs.Tangible#position
       * @default {x:0,y:0,z:0}
       *
       * @related height
       */
      this.position = {
        x: 0,
        y: 0,
        z: 0,
      };

      /**
       * Meant for handling screen output, by breaking listed items into subgroups
       * to be divided into paragraphs, but not implemented.
       * @var {int} adventurejs.Tangible#list_group
       * @default 0
       *
       * @todo Implement this or remove it.
       */
      this.list_group = 0; // @TODO list visible items in separate paragraphs

      /**
       * Set whether verb point means aim for this asset.
       * If so, point verb will redirect to aim.
       * @nestedproprty
       * @var {Boolean} adventurejs.Tangible#quirks!point_means_aim
       * @default false
       *
       */
      this.quirks.point_means_aim = false;

      /**
       * When player is nested within an aspect of an asset, other assets may not be reachable.
       * <strong>things_player_can_reach_from_this</strong> helps manage reachability.
       * For example, if player is on a ladder, things on the ground might not be reachable.
       * But, a player seated on a chair at a desk should be able to reach the desk and anything on it.
       * Use this property to explicitly make some things reachable from other things.
       * <br/><br/>
       * <em>things_player_can_reach_from_this is a broad catchall that covers all
       * nesting options.</em> What this means is that players can reach assets in this
       * list no matter how they are nested within this asset.
       * Going back to the example of the chair and desk, if the chair has this property set thusly...
       * <pre class="display"><code class="language-javascript">this.things_player_can_reach_from_this = [ 'desk' ];
       * </code></pre>
       * ...it means that the player, seated in the chair,
       * can reach any part of the desk: not just stuff that's on it, but also stuff
       * under it or behind it. That might be fine for your purposes.
       * Or, you might want more granular control. Let's say there's an electrical outlet under the desk,
       * and you want that players shouldn't be able to reach it without actually crawling under the desk.
       * If you need that kind of precision, you can manage reachability for each aspect of an asset.
       * For more information about that, see
       * {@link adventurejs.Aspect#things_player_can_reach_from_this_aspect|Aspect.things_player_can_reach_from_this_aspect}
       * and
       * {@link adventurejs.Aspect#things_player_can_reach_from_positions_of_this_aspect|Aspect.things_player_can_reach_from_positions_of_this_aspect}.
       * @var {Array} adventurejs.Tangible#things_player_can_reach_from_this
       * @default []
       *
       */
      this.things_player_can_reach_from_this = []; // defined

      /**
       * When player is nested within an asset, other assets may not be reachable.
       * For example, if player is on a ladder, things on the ground won't be reachable.
       * Use this property to explicitly list things that player can reach while nested
       * at the top of asset. For example, perhaps there is a window that player should
       * only be able to reach from the top of a ladder.
       * <strong>things_player_can_reach_from_top_of_this</strong> allows that to be set.
       * For example:
       * <pre class="display"><code class="language-javascript">this.things_player_can_reach_from_top_of_this = [ 'window' ];
       * </code></pre>
       * <em>things_player_can_reach_from_this is a convenience method for a common situation.</em>
       * If you need more control over reachability from specific positions within an aspect,
       * like left/right/front/back, you can manage that at the aspect level.
       * For more information about that, see
       * {@link adventurejs.Aspect#things_player_can_reach_from_this_aspect|Aspect.things_player_can_reach_from_this_aspect}
       * and
       * {@link adventurejs.Aspect#things_player_can_reach_from_positions_of_this_aspect|Aspect.things_player_can_reach_from_positions_of_this_aspect}.
       * @var {Array} adventurejs.Tangible#things_player_can_reach_from_top_of_this
       * @default []
       *
       */
      this.things_player_can_reach_from_top_of_this = []; // defined

      /**
       * When player is nested within an asset, other assets may not be reachable.
       * For example, if player is on a ladder, things on the ground won't be reachable.
       * Use this property to explicitly list things that player can reach while nested
       * at the bottom of asset. For example, perhaps there is an alcove at the bottom
       * of a pit, with a ladder leading down, where player should
       * only be able to reach the alcove from the bottom of the ladder.
       * <strong>things_player_can_reach_from_bottom_of_this</strong> allows that to be set.
       * For example:
       * <pre class="display"><code class="language-javascript">this.things_player_can_reach_from_bottom_of_this = [ 'alcove' ];
       * </code></pre>
       * <em>things_player_can_reach_from_bottom_of_this is a convenience method for a common situation.</em>
       * If you need more control over reachability from specific positions within an aspect,
       * like left/right/front/back, you can manage that at the aspect level.
       * For more information about that, see
       * {@link adventurejs.Aspect#things_player_can_reach_from_this_aspect|Aspect.things_player_can_reach_from_this_aspect}
       * and
       * {@link adventurejs.Aspect#things_player_can_reach_from_positions_of_this_aspect|Aspect.things_player_can_reach_from_positions_of_this_aspect}.
       * @var {Array} adventurejs.Tangible#things_player_can_reach_from_top_of_this
       * @default []
       *
       */
      this.things_player_can_reach_from_bottom_of_this = []; // defined

      /**
       * Some Tangible subclasses come pre-coded to handle certain
       * "parts", classes which can automatically be registered with
       * each other to form complex associations.
       * For example, a
       * {@link adventurejs.Sink|Sink}
       * can have matching
       * {@link adventurejs.Faucet|Faucet},
       * {@link adventurejs.FaucetHandle|FaucetHandles},
       * {@link adventurejs.Drain|Drain} and
       * {@link adventurejs.Plug|Plug}.
       * Not all classes have parts. See each class's documentation
       * header for "Can have parts:" and "Can be part of:".
       * The registerParts() method is called during initialization.
       * Set up parts like so:
       * <pre class="display"><code class="language-javascript">MyGame.createAsset({
       *   class: "Sink",
       *   name: "sink",
       *   place: { in: "Bathroom" },
       *   descriptions:{
       *     look: function()
       *     {
       *       return "A pedestal sink with porcelain handles and
       *       a stainless steel faucet. Its drain appears to be
       *       $( sink drain is| open or| closed ). ";
       *     }
       *   },
       *   parts: [
       *     // each of these is a name of another Asset
       *     "hot water handle",
       *     "cold water handle",
       *     "faucet",
       *     "drain",
       *     "plug"
       *   ],
       * });
       * </code></pre>
       * @var {Array} adventurejs.Tangible#parts
       * @default []
       *
       */
      this.parts = [];

      /**
       *
       * @var {Object} adventurejs.Tangible#registered_parts
       * @default {}
       *
       */
      this.registered_parts = {};

      /**
       *
       * @var {Object} adventurejs.Tangible#registerableClasses
       * @default {}
       *
       */
      this.registerableClasses = {};

      this.place = {};
    } // function Tangible(id)

    // PROTOTYPE DEFINED PROPERTIES

    /*doc@this*/
    get parts() {
      return this.__parts;
    }
    set parts(arr) {
      this.__parts = A.validateAssetList(arr);
    }

    /*doc@this*/
    get things_player_can_do_all_verbs_to_from_this() {
      return this.__things_player_can_do_all_verbs_to_from_this;
    }
    set things_player_can_do_all_verbs_to_from_this(arr) {
      this.__things_player_can_do_all_verbs_to_from_this =
        A.validateAssetList(arr);
    }

    /*doc@this*/
    get things_player_can_climb_to_from_this() {
      return this.__things_player_can_climb_to_from_this;
    }
    set things_player_can_climb_to_from_this(arr) {
      this.__things_player_can_climb_to_from_this = A.validateAssetList(arr);
    }

    /*doc@this*/
    get things_player_can_jump_to_from_this() {
      return this.__things_player_can_jump_to_from_this;
    }
    set things_player_can_jump_to_from_this(arr) {
      this.__things_player_can_jump_to_from_this = A.validateAssetList(arr);
    }

    /**
     * @var {Getter/Setter} adventurejs.Tangible#things_player_can_swing_to_across_this
     * @default false
     */
    get things_player_can_swing_to_across_this() {
      return this.__things_player_can_swing_to_across_this;
    }
    set things_player_can_swing_to_across_this(arr) {
      this.__things_player_can_swing_to_across_this = A.validateAssetList(arr);
    }

    /*doc@this*/
    get things_player_can_swing_to_from_this() {
      return this.__things_player_can_swing_to_from_this;
    }
    set things_player_can_swing_to_from_this(arr) {
      this.__things_player_can_swing_to_from_this = A.validateAssetList(arr);
    }

    /**
     * Get a string representing open / closed state of this asset.
     * @var {Boolean} adventurejs.Tangible#print_open_or_closed
     * @default false
     */
    get print_open_or_closed() {
      var state = "neither open nor closed";
      if (this.is.closed) state = "closed";
      if (false === this.is.closed) state = "open";
      return state;
    }

    /**
     * Get / set place. The private var __place is an
     * object with two properties: aspect and asset.
     * For example: { aspect:"in", asset:"room" }
     * However, the public var place appears in the form
     * { in: "room" }. This is to make it easier and more
     * intuitive for authors to set asset places.
     * @var {Object} adventurejs.Tangible#place
     */
    get place() {
      return { [this.__place.aspect]: this.__place.asset };
    }
    set place(value) {
      var newplace = { asset: "", aspect: "" };
      if (Object(value) !== value) {
        var msg = this.id + ".place received no value. Setting no place. ";
        this.game.log("warn", "critical", msg, "Tangible");
      } else {
        // for some reason world.copy was returning {"":"","key":"value"}
        // so we need to delete the empty string key
        delete value[""];

        var keys = Object.keys(value);
        if (value.asset && value.aspect) {
          // received for example: { aspect:"in", asset:"room" }
          // serialize asset name
          newplace.aspect = value.aspect;
          newplace.asset = A.serialize(value.asset);
        } else if (keys.length === 0) {
        } else if (keys.length === 1) {
          // received for example: { in: "room" }
          // verify asset
          if ("string" !== typeof value[keys[0]]) {
            var msg = this.id + ".place set to an invalid asset ";
            this.game.log("error", "critical", msg, "Tangible");
          }
          // serialize asset name
          newplace.asset = A.serialize(value[keys[0]]);
          newplace.aspect = keys[0];
        } else if (keys.length > 1) {
          newplace.asset = value[keys[0]];
          newplace.aspect = keys[0];
          var msg =
            this.id +
            ".place received more than one location. Using the first. ";
          for (var i = 0; i < keys.length; i++) {
            msg += keys[i] + ": " + value[keys[i]] + ", ";
          }
          this.game.log("error", "critical", msg, "Tangible");
        }
      }

      if (
        this.__place &&
        this.__place.asset &&
        this.__place.aspect &&
        (this.__place.asset !== newplace.asset ||
          this.__place.aspect !== newplace.aspect)
      ) {
        this.game
          .getAsset(this.__place.asset)
          .removeAssetAt(this.id, this.__place.aspect);
      }
      if (
        newplace.asset &&
        newplace.aspect &&
        this.game.getAsset(newplace.asset)
      ) {
        this.game.getAsset(newplace.asset).addAssetAt(this.id, newplace.aspect);
      }
      this.__place = newplace;
    }

    /*doc@this*/
    get things_player_can_reach_from_this() {
      return this.__things_player_can_reach_from_this;
    }
    set things_player_can_reach_from_this(arr) {
      this.__things_player_can_reach_from_this = A.validateAssetList(arr);
    }

    /*doc@this*/
    get things_player_can_reach_from_top_of_this() {
      return this.__things_player_can_reach_from_top_of_this;
    }
    set things_player_can_reach_from_top_of_this(arr) {
      this.__things_player_can_reach_from_top_of_this =
        A.validateAssetList(arr);
    }

    /*doc@this*/
    get things_player_can_reach_from_bottom_of_this() {
      return this.__things_player_can_reach_from_bottom_of_this;
    }
    set things_player_can_reach_from_bottom_of_this(arr) {
      this.__things_player_can_reach_from_bottom_of_this =
        A.validateAssetList(arr);
    }

    /**
     * <strong>Contains</strong> is a shortcut for creating
     * a substance container and filling it with an infinite
     * amount of a specified substance.
     * It is the equivalent of this code:
     * <pre class="display"><code class="language-javascript">this.aspects.in = new adventurejs.Aspect( "in", this.game_name )
     *   .set({
     *     "parent_id": this.id,
     *   });
     * this.aspects.in.vessel = new adventurejs.Vessel( "in", game_name )
     *   .set({
     *     "volume": Infinity,
     *     "maxvolume": Infinity,
     *     "substance_id": substance_id,
     *   });
     * </code></pre>
     * <br><br>
     * This is to make it easier and more
     * intuitive for authors to set things like sand
     * in a desert room or water in a swamp room, so that
     * if player inputs "fill bowl with water", it can be
     * assumed that the room is the source of the substance.
     * When multiple substance containers are available,
     * usually disambiguation occurs, but in the case of a
     * room containing a substance, the room is assumed to
     * be the source.
     * @var {Object} adventurejs.Tangible#place
     */
    get contains() {
      if (this.hasVesselAtAspect("in")) {
        return this.aspects.in.vessel.substance_id;
      }
      return "";
    }
    set contains(params) {
      if ("string" === typeof params) {
        params = { substance_id: params };
      }
      if (!params) params = {};
      if (!params.substance_id) {
        params.substance_id = "";
      }
      if (!params.maxvolume) params.maxvolume = Infinity;
      if (!params.volume) params.volume = Infinity;
      params.vessel_is_known = true;
      this.setVesselAt("in", params);
    }

    // METHODS

    /**
     * Inherited from superclass {@link adventurejs.Asset|Asset}.
     * Tangible adds validation methods that are used for all Tangible assets,
     * including:
     * <ul>
     * <li>check for implied dependencies and make them explicit</li>
     * <li>check for proper asset location</li>
     * <li>set parent associations</li>
     * </ul>
     *
     * @memberOf adventurejs.Tangible
     * @method adventurejs.Tangible#validate
     * @param {Object} game
     * @returns {Boolean}
     */
    validate(game) {
      super.validate(game);

      // Validate place. Many tangibles, generally globals, have no place,
      // and that's valid, but if it does have a place, ensure that it refers
      // to a valid asset.
      if (this.__place.asset) {
        var place_asset, place_aspect;
        place_aspect = Object.keys(this.place)[0];
        place_asset = this.game.getAsset(A.serialize(this.__place.asset));

        // is place_object a tangible game asset?
        if (!place_asset || !(place_asset instanceof adventurejs.Tangible)) {
          var msg = `${this.constructor.name} ${this.name}'s place ${this.__place.asset} is unset or invalid. `;
          this.game.log("error", "critical", msg, "Tangible");
          return false;
        }

        // has place had an Aspect instantiated?
        if (
          !place_asset.hasAspectAt(place_aspect) ||
          !place_asset.getAspectAt(place_aspect).class
        ) {
          place_asset.aspects[place_aspect] = new adventurejs.Aspect(
            place_aspect,
            this.game_name
          ).set({
            parent_id: place_asset.id,
          });
          this.game.debug(
            `F1568 | Tangible.js | ${this.constructor.name} ${this.name}'s container, ${place_asset.name}.${place_aspect}, was not set. A new Aspect has been constructed for ${place_asset.name}.${place_aspect}. `
          );
          this.game.print(msg);
        }
      }

      // has it got no location but requires a location?
      if (this.location_required && !this.hasPlace()) {
        msg += this.constructor.name + " " + this.name + " hasn't got a place.";
        console.error(msg);
        return false;
      }

      return true;
    } // validate

    /**
     * Inherited from superclass {@link adventurejs.Asset|Asset}.
     * Tangible adds initialization methods that are used for all
     * Tangible assets, including:
     * <ul>
     * <li>link related objects</li>
     * <li>register parts</li>
     * </ul>
     * @memberOf adventurejs.Tangible
     * @method adventurejs.Tangible#initialize
     * @param {Object} game
     * @returns {Boolean}
     */
    initialize(game) {
      super.initialize(game);
      if (this.getPlaceAsset()) {
        this.getPlaceAsset().addAssetAt(this.id, this.getPlacePreposition());
      }
      this.registerParts.call(this);
      this.linkRegisteredParts.call(this);
      return true;
    } // p.initialize

    /**
     * Remove this asset from the world before calling superclass.destroy.
     * @memberOf adventurejs.Tangible
     * @method adventurejs.Tangible#destroy
     */
    destroy() {
      this.setPlace(); // calling without param removes from parent

      // in most cases we call the super method first
      // in the case of destroy the last thing to happen
      // is removing from lookups
      super.destroy();
    }
  }
  adventurejs.Tangible = Tangible;
})();

// get.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Utility function that provides an easy way for
   * authors to test for various conditions.
   * <ul>
   * <li>all - list things anywhere in this</li>
   * <li>behind - list things behind this</li>
   * <li>in - list things in this</li>
   * <li>on - list things on this</li>
   * <li>under - list things under this</li>
   * <li>attached - list things attached to this</li>
   * </ul>
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#get
   * @param {String} property
   * @param {String} qualifier
   */
  p.get = p.$get = function Tangible_$get(property, qualifier) {
    if (
      this.game.dictionary.isPreposition(property) &&
      this.hasAspectAt(property)
    ) {
      // this returns a list of ids
      // what if author wants a nice formatted list?
      return this.aspects[property].contents;
    }

    switch (property) {
      // TODO
      // case "everythingInsideMeRecursively":
      // return;
      //break;

      case "all":
        var things = [];

        for (var aspect in this.aspects) {
          things.concat(this.aspects[aspect].contents);
        }

        return things;

      default:
        if ("undefined" === typeof this[property]) {
          console.warn(
            "Tangible.get() couldn't find a property called " +
              property +
              " on " +
              this.name +
              "."
          );
          return false;
        }

        return this[property];
    } // switch
  }; // adventurejs.Tangible.prototype.get
})();

// Tangible_Is.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * <strong>$is()</strong> is a convenience method for authors that
   * provides an easy way to test for various conditions.
   * <ul>
   * <li><dt>assetA.$is("body")</dt> <dd>asking, is this asset a body of substance such as a lake or sandy desert?</li>
   * <li><dt>assetA.$is("closed")</dt> <dd>asking, is this asset closed?</li>
   * <li><dt>assetA.$is("held", assetB)</dt> <dd>asking, is this asset held by that asset, as in a bannister held by player?</dd></li>
   * <li><dt>assetA.$is("holding", assetB)</dt> <dd>asking, is this asset holding that asset, as in player holding a rope?</dd></li>
   * <li><dt>assetA.$is("in", assetB)</dt> <dd>accepts any preposition, asking, is this asset in that aspect of that asset?</dd> </li>
   * <li><dt>assetA.$is("locked")</dt> <dd>asking, is this asset locked?</li>
   * <li><dt>assetA.$is("nested in", assetB)</dt> <dd>nested in, specific to character classes, asking, is this asset nested in that asset?</dd></li>
   * <li><dt>assetA.$is("open")</dt> <dd>asking, is this asset open?</li>
   * <li><dt>assetA.$is("plugged")</dt> <dd>asking, is this asset plugged?</li>
   * <li><dt>assetA.$is("sealed")</dt> <dd>asking, is this asset sealed?</li>
   * <li><dt>assetA.$is("takeable")</dt> <dd>asking, can this asset be taken?</li>
   * <li><dt>assetA.$is("unlocked")</dt> <dd>asking, is this asset unlocked?</li>
   * <li><dt>assetA.$is("unplugged")</dt> <dd>asking, is this asset unplugged?</li>
   * <li><dt>assetA.$is("unsealed")</dt> <dd>asking, is this asset unsealed?</li>
   * <li><dt>assetA.$is("worn")</dt> <dd>asking, is this asset being worn?</li>
   * <li><dt>assetA.$is("zipped")</dt> <dd>asking, is this asset zipped?</li>
   * </ul>
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#$is
   * @param {String} property
   * @param {Object} asset
   * @todo Leaving open the possibility for other params.
   */
  p.$is = function Tangible_$is(property, asset) {
    var msg = "";
    // property is required, asset is optional

    let shadow_props = {
      open: "closed",
      unlocked: "locked",
      unplugged: "plugged",
      unsealed: "sealed",
    };

    if ("string" !== typeof property) {
      msg = "Tangible_is received a value for property that is not a string. ";
      this.game.log("warn", "high", msg, "Tangible");
      return false;
    }

    if ("string" === typeof asset) {
      asset = this.game.getAsset(asset);
    }

    // shadow props are properties we don't actually track
    // but which are opposites of props we do track
    // ie we track asset.is.sealed and using this we allow
    // authors to ask if asset.is.unsealed
    if (!asset && shadow_props[property]) {
      // only return true if opposite property is explicitly
      // set to false, vs null or undefined,
      // so we don't get false positives, ie returning
      // open === true for a thing that doesn't actually open
      return false === asset.is[shadow_props[property]];
    }

    if (!asset && "undefined" !== typeof this.is[property]) {
      // we understand this to mean that author is asking for
      // something like asset.$is('closed') where we can return
      // asset.is.closed
      return this.is[property];
    }

    // check for preposition aka aspect
    if (this.game.dictionary.isPreposition(property)) {
      // property is a preposition
      // we take this to mean that author is asking
      // something like MyGame.$('comb').is('on','dresser')

      if (!asset) return false;

      // characters are special because they have two ways to be children
      // we have to check place and nest
      if (asset instanceof adventurejs.Character) {
        if (property !== this.getNestOrPlacePreposition()) return false;
        if (asset.id !== this.getNestOrPlaceAsset().id) return false;
        return true;
      }

      // for anything other than character, just check place
      if (property !== this.getPlacePreposition()) return false;
      if (asset.id !== this.getPlaceAssetId()) return false;
      return true;
    }

    // otherwise we got some random property that we may or may not support
    switch (property) {
      case "body":
        if (
          this.hasVessel() &&
          this.getVesselAt(this.getAspectWithVessel()).is_body_of_substance
        ) {
          return true;
        }
        return false;

      case "takeable":
        return asset.isDOV("take");

      case "holding":
        msg = `Is ${this.id} holding ${asset.id}? `;
        this.game.log("log", "high", msg, "Tangible");
        return this.IOVisConnectedToAsset("hold", asset);

      case "held":
        msg = `Is ${this.id} held by ${asset.id}? `;
        this.game.log("log", "high", msg, "Tangible");
        return this.DOVisConnectedToAsset("hold", asset);

      case "nested in":
        msg = `Is ${this.id} nested in ${asset.id}? `;
        this.game.log("log", "high", msg, "Tangible");
        if (this.getNestId) {
          return this.getNestId() === asset.id;
        }
        return false;

      default:
        // no property
        if ("undefined" === typeof this[property]) {
          msg = `Tangible.$is() couldn't find a property ${property} on ${this.name}. `;
          this.game.log("warn", "high", msg, "Tangible");
          return false;
        }

        // property is object
        if ("object" === typeof this[property]) {
          msg = `Tangible.$is() is meant to return a boolean. ${this.name}'s ${property} is an object, which isn't handled by asset.$is(). `;
          this.game.log("warn", "high", msg, "Tangible");
          return false;
        }

        // property is something else
        if ("boolean" !== typeof this[property]) {
          // we'll return a string or a number with a warning
          msg = `Tangible.$is() is meant to return a boolean. ${
            this.name
          }'s ${property} is ${typeof this[
            property
          ]}, which isn't handled by asset.$is(). `;
          this.game.log("warn", "high", msg, "Tangible");
          return false;
        }

        return this[property];
    } // switch
  }; // adventurejs.Tangible.prototype.is
})();

// isIn.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	

  /**
   * <strong>isIn</strong> tests whether 
   * one asset is in (any aspect of) another asset.
   * <pre class="display"><code class="language-javascript">if( MyGame.$('jewel').$isIn('crown') ){ // do stuff }
   * </code></pre>
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#isIn
   * @param {Object|String} asset Can be string or object.
   */
  p.isIn = p.$isIn = function Tangible_isIn( asset ) 
  {
		if("string" === typeof asset) asset = this.game.getAsset(asset);
    if(!asset) return false;
    var parent_id;
    var nextlevel;

		// get parent of this
    if( this.place ) nextlevel = this.getPlaceAsset();

		// this has no parent
		if( !nextlevel ) return false;

		while ( nextlevel ) 
    {
			if( nextlevel.id === asset.id ) 
      { 
				return true;
			} 
      else 
      {
        if( !nextlevel.place ) return false;
        nextlevel = nextlevel.getPlaceAsset();
        if( !nextlevel ) return false;
			}
		}

		return false;

  }
}());
// $moveFrom.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * $moveFrom is an author shortcut that is similar 
   * to moveFrom but which bypasses onRemoveThatFromThis, 
   * avoiding the consequences of any verb actions.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#moveFrom
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.$moveFrom = function Tangible_$moveFrom( asset ) 
  {
    if("string" === typeof asset) asset = this.game.getAsset(asset);
    if(!asset) return false;
    this.setPlace();
    return true;
  }
 }());
// $moveTo.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * $moveTo is an author shortcut that is similar 
   * to moveTo but which bypasses onMoveThatToThis, 
   * avoiding the consequences of any verb actions.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#$moveTo
   * @param {String} aspect
   * @param {Object} asset
   */
  p.$moveTo = function Tangible_$moveTo( aspect, asset )
  {
    if("string" === typeof asset) asset = this.game.getAsset(asset);
    if(!aspect||!asset) return false;
    if(!asset.hasAspectAt(aspect)) return false;
    this.setPlace( aspect, asset.id );
    return true;
  }
 }());
// put.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Tangible.prototype;

  /**
   * <strong>put</strong> places one asset inside another,
   * bypassing onMoveThatToThis and subsequent
   * doMoveThatToThis/doMoveThisToThat.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#put
   * @param {String} preposition
   * @param {Object|String} indirect_object asset object or name/id
   */
  p.put = p.$put = function Game_put(preposition, indirect_object) {
    this.game.log(
      "log",
      "high",
      "put.js > " + this.id + " " + preposition + " " + indirect_object.id,
      "Game"
    );
    if ("string" === typeof indirect_object)
      indirect_object = this.game.getAsset(indirect_object);
    if (
      !preposition ||
      !indirect_object ||
      !indirect_object.aspects[preposition]
    )
      return false;
    this.setPlace(preposition, indirect_object.id);
    return true;
  };
})();

// addAssetAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Add specified asset id to the contents of
   * specified aspect on this asset.
   * Returns contents if aspect exists, or null.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#addAssetAt
   * @return {Array}
   */
  p.addAssetAt = function Tangible_addAssetAt(id, aspect) {
    this.game.log(
      "log",
      "medium",
      "addAssetAt " + id + " " + aspect + " " + this.id,
      "Tangible"
    );
    if (this.hasAspectAt(aspect)) {
      if (-1 === this.aspects[aspect].contents.indexOf(id)) {
        this.aspects[aspect].contents.push(id);
      }
      return this.aspects[aspect].contents;
    }
    return null;
  };
})();

// areAnscestorsClosed.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Checks to see if this asset's containing parent(s) is closed. 
   * Takes into account nesting doll 
   * situations and looks all the way up the chain.
   * Useful for determining whether a player can interact
   * with a nested object.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#areAnscestorsClosed
   * @returns {Boolean}
   */
   p.areAnscestorsClosed = function Tangible_areAnscestorsClosed() 
   {
     //console.warn( 'areAnscestorsClosed this',this.id);
     var parent = this.getPlaceAsset();
     //console.warn( '- areAnscestorsClosed parent',parent.id);
     var parentClosed = false;
     var anscestorsClosed = false;
     if( parent
     && "undefined" !== typeof parent.is.closed
     && "undefined" !== typeof parent.areAnscestorsClosed ) 
     {
       parentClosed = ( parent.isDOV('close') && parent.is.closed );
       //console.warn('--',parent.id,'.parentClosed',parentClosed );
       anscestorsClosed = parent.areAnscestorsClosed();
       //console.warn('--',parent.id,'.anscestorsClosed',anscestorsClosed );
     }
     //console.warn('-',parent.id,'says parentClosed',parentClosed,'anscestorsClosed',anscestorsClosed);
     if (parentClosed || anscestorsClosed) 
     {
       return true;
     }
     return false;
    } 
}());
// areAnscestorsKnown.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Checks to see if this asset and its containing parent(s)
   * are known to player. Takes into account nesting doll 
   * situations and looks all the way up the chain.
   * Useful for determining whether a player can "see"
   * a nested object.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#areAnscestorsKnown
   * @returns {Boolean}
   */
   p.areAnscestorsKnown = function Tangible_AreThisAndAnscestorsKnown() 
   {
     var player_knows_parent = true;
     var parent = this.getPlaceAsset();

     if( parent
     && "undefined" !== typeof parent.is.known
     && "undefined" !== typeof parent.areAnscestorsKnown ) 
     {
      player_knows_parent = parent.areAnscestorsKnown();
     }
     if (this.is.known && player_knows_parent) 
     {
       return true;
     }
     else 
     {
       return false;
     }
   }
 }());
// areAnscestorsOpen.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Checks to see if this asset's containing parent(s) 
   * is open. Takes into account nesting doll 
   * situations and looks all the way up the chain.
   * Useful for determining whether a player can interact
   * with a nested object.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#areAnscestorsOpen
   * @returns {Boolean}
   */
   p.areAnscestorsOpen = function Tangible_areAnscestorsOpen() 
   {
     var parent = this.getPlaceAsset();
     var parentOpen = true;
     var anscestorsOpen = true;
 
     if( parent
     && "undefined" !== typeof parent.is.closed
     && "undefined" !== typeof parent.areAnscestorsOpen ) 
     {
       parentOpen = ( false === parent.is.closed );
       anscestorsOpen = parent.areAnscestorsOpen();
     }
     if (parentOpen && anscestorsOpen) 
     {
       return true;
     }
     else 
     {
       return false;
     }
     //return parentOpen
   } 
}());
// areAnscestorsUnknown.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Checks to see if this asset or its containing parent(s)
   * are unknown to player. Takes into account nesting doll 
   * situations and looks all the way up the chain.
   * Useful for determining whether a player can "see"
   * a nested object.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#areAnscestorsUnknown
   * @param {int} nestlevel
   * @returns {Boolean}
   */
  p.areAnscestorsUnknown = function Tangible_areAnscestorsUnknown(nestlevel) 
  {
    if("undefined" === typeof nestlevel) 
    {
      nestlevel = 0;
    } 
    else 
    {
      nestlevel++;
    }
    var player_knows_parent = true;
    var parent = this.getPlaceAsset();

    if( parent
    && "undefined" !== typeof parent.is.known
    && "undefined" !== typeof parent.areAnscestorsUnknown ) 
    {
      player_knows_parent = parent.areAnscestorsUnknown(nestlevel);
    }
    // We pass this call up and then back down the anscestor
    // chain, using nestlevel to keep track of our place in
    // the chain â but descendants need the opposite of the response
    // that we're going to send back to the original caller.
    nestlevel--;
    if ( !this.is.known || !player_knows_parent ) 
    {
      return ( -1 < nestlevel ? false : true );
    } 
    else 
    {
      return ( -1 < nestlevel ? true : false );
    }
  }  
}());
// canBePut.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset can be placed within
   * the specified aspect of the specified asset.
   * This takes into account the
   * <code>with_assets</code> and
   * <code>with_classes</code> properties.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#canBePut
   * @param {String} aspect
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.canBePut = function Tangible_canBePut(aspect, asset) {
    if (!asset.hasAspectAt(aspect)) return false;
    if (!asset.getAspectAt(aspect).player_can_add_assets_to_contents)
      return false;

    var can = true;

    var with_classes = asset.aspects[aspect].with_classes;
    if (with_classes.length > 0) {
      can = false;
      for (var i = 0; i < with_classes.length; i++) {
        var clas = with_classes[i];
        if (this instanceof adventurejs[clas]) {
          can = true;
          break;
        }
      }
    }

    var with_assets = asset.aspects[aspect].with_assets;
    if (with_assets.length > 0) {
      can = false;
      for (var i = 0; i < with_assets.length; i++) {
        if (this.id === with_assets[i]) {
          can = true;
          break;
        }
      }
    }

    return can;
  };
})();

// canContainAnySubstance.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Determine whether asset can contain any substance.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#canContainAnySubstance
   * @return {Boolean}
   */
  p.canContainAnySubstance = function Tangible_canContainAnySubstance()
  {
    if( this.getAspectWithVessel() ) return true;
    return false;
  }
 }());
// canContainAssetAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset can be attached to specified
   * other asset.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#canContainAssetAt
   * @param {Object} object
   * @returns {Boolean}
   */
  p.canContainAssetAt = function Tangible_canContainAssetAt(
    asset,
    preposition
  ) {
    var aspect = this.aspects[preposition];
    if (!aspect || !aspect.class) return false;

    if (aspect.maxsize > -1 && asset.dimensions.size > aspect.maxsize) {
      return false;
    }

    if (aspect.maxweight > -1 && asset.dimensions.weight > aspect.maxweight) {
      return false;
    }

    if (aspect.maxcount > -1 && aspect.contents.length >= aspect.maxcount) {
      return false;
    }

    return true;
  };
})();

// canPlayerNest.js

(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Tangible.prototype;

  /**
   * Ask if player can nest in an aspect of this asset.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#canPlayerNest
   * @param {String} aspect A Tangible Aspect ID.
   * @returns {Boolean}
   */
  p.canPlayerNest = function Tangible_canPlayerNest(aspect) {
    this.game.log(
      "log",
      "high",
      "canPlayerNest.js > " + aspect + " " + this.name + "?",
      "Tangible"
    );

    return this.hasAspectAt(aspect) && this.aspects[aspect].player.can.enter;
  };
})();

// canPlayerReachThatFromThis.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether that asset can be reached
   * by player when nested in this asset.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#canPlayerReachThatFromThis
   * @param {Object} object
   * @returns {Boolean}
   */
  p.canPlayerReachThatFromThis = function Tangible_canPlayerReachThatFromThis(
    thatobject,
    thatprep
  ) {
    // was question asked without a valid object?
    if ("undefined" === typeof thatobject || !thatobject) {
      return false;
    }

    var player = this.game.getPlayer();

    // question is only relevant if player is nested within this asset
    if (this !== player.getNestAsset()) {
      return false;
    }

    var bool = false;
    var this_aspect = player.getNestPreposition();

    // Arrays can contain ID strings or objects which
    // ["uncomfortable_looking_bed", "table"]
    // [{desk: ["on"]}, {uncomfortable_looking_bed: ["on"]}]

    // this.things_player_can_reach_from_this is the simple version
    // of setting reachability.
    bool = A.isIdInMixedArray(
      thatobject.id,
      this.things_player_can_reach_from_this
    );
    if (bool) return bool; // don't need to look any deeper

    // the simple version of setting reachability from top of thing
    if (player.isNestedOnTop()) {
      bool = A.isIdInMixedArray(
        thatobject.id,
        this.things_player_can_reach_from_top_of_this
      );
      if (bool) return bool;
    }

    // the simple version of setting reachability from bottom of thing
    if (player.isNestedOnBottom()) {
      bool = A.isIdInMixedArray(
        thatobject.id,
        this.things_player_can_reach_from_bottom_of_this
      );
      if (bool) return bool;
    }

    // else we need to look deeper into the aspect player is nested in
    bool = this.aspects[this_aspect].canPlayerReachThatFromThisAspect(
      thatobject,
      thatprep
    );

    return bool;
  };
})();

// doesContainAnyAsset.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset contains any assets.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#doesContainAnyAsset
   * @returns {Boolean}
   */
  p.doesContainAnyAsset = function Tangible_doesContainAnyAsset() {
    for (var prop in this.aspects) {
      if (this.aspects[prop].contents.length > 0) {
        return true;
      }
    }
    return false;
  }; // doesContainAnyAsset.js
})();

// doesContainAnyAssetAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset contains any assets.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#doesContainAnyAssetAt
   * @param {String} aspect
   * @returns {Boolean}
   */
  p.doesContainAnyAssetAt = function Tangible_doesContainAnyAssetAt(aspect) {
    if (!aspect) return false;
    if (!this.aspects[aspect]) return false;
    if (this.aspects[aspect].contents.length > 0) return true;
    return false;
  }; // doesContainAnyAssetAt.js
})();

// doesContainAnySubstance.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset contains any substance.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#doesContainAnySubstance
   * @returns {Boolean}
   */
  p.doesContainAnySubstance = function Tangible_doesContainAnySubstance() {
    var aspect = this.getAspectWithVessel();
    if (aspect && this.aspects[aspect].vessel.getVolume() > 0) {
      return true;
    }
    return false;
  }; // doesContainAnySubstance.js
})();

// doesContainAnySubstanceAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset contains any substance at specified aspect.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#doesContainAnySubstanceAt
   * @param {String} aspect
   * @returns {Boolean}
   */
  p.doesContainAnySubstanceAt = function Tangible_doesContainAnySubstanceAt(
    aspect
  ) {
    if (!aspect) return false;
    if (!this.aspects[aspect]) return false;
    if (!this.aspects[aspect].vessel) return false;
    if (!this.aspects[aspect].vessel.getVolume() > 0) return true;
    return false;
  }; // doesContainAnySubstanceAt.js
})();

// doesContainAsset.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset contains the specified asset.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#doesContainAsset
   * @param {String} id
   * @returns {String}
   */
  p.doesContainAsset = function Tangible_doesContainAsset(id) {
    if (!id) return false;

    for (var prop in this.aspects) {
      var contents = this.aspects[prop].contents;
      for (var i = 0; i < contents.length; i++) {
        if (id === contents[i]) return true;
      }
    }
    return false;
  }; // doesContainAsset.js
})();

// doesContainAssetAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset contains the specified asset
   * at the specified aspect.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#doesContainAssetAt
   * @param {String} id
   * @param {String} aspect
   * @returns {Boolean}
   */
  p.doesContainAssetAt = function Tangible_doesContainAssetAt(id, aspect) {
    if (!id) return false;
    if (!aspect) return false;
    if (!this.aspects[aspect]) return false;
    if (-1 < this.aspects[aspect].contents.indexOf(id)) return true;
    return false;
  }; // doesContainAssetAt.js
})();

// doesContainSubstance.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset contains the specified substance.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#doesContainSubstance
   * @param {String} id
   * @returns {String}
   */
  p.doesContainSubstance = function Tangible_doesContainSubstance(id) {
    if (!id) return false;
    var aspect = this.getAspectWithVessel();
    if (aspect && id === this.aspects[aspect].vessel.substance_id) {
      return aspect;
    }
    return "";
  }; // doesContainSubstance.js
})();

// doesContainSubstanceAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset contains the specified substance.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#doesContainSubstanceAt
   * @param {String} id
   * @param {String} aspect
   * @returns {Boolean}
   */
  p.doesContainSubstanceAt = function Tangible_doesContainSubstanceAt(
    id,
    aspect
  ) {
    if (!id) return false;
    if (!aspect) return false;
    if (!this.aspects[aspect]) return false;
    if (!this.aspects[aspect].vessel) return false;
    if (id === this.aspects[aspect].vessel.substance_id) return true;
    return false;
  }; // doesContainSubstanceAt.js
})();

// findClassInThis.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Find instances of specified class within this asset, for example
   * find all coins within a purse. Returns an array of asset IDs.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#findClassInThis
   * @param {String} instanceClass
   * @returns {Array}
   */
  p.findClassInThis = function Tangible_findClassInThis(
    instanceClass,
    params = {}
  ) {
    if ("string" !== typeof instanceClass) return [];

    // did we receive a valid class name?
    if (!adventurejs[instanceClass]) {
      // if not, since class names are propercased,
      // make an effort to propercase
      instanceClass = A.propercase(instanceClass);
    }
    if (!adventurejs[instanceClass]) return [];

    var contents = this.getAllNestedContents();
    var foundInstances = [];
    for (var i = 0; i < contents.length; i++) {
      var asset_id = contents[i];
      if (params.exclude?.includes(asset_id)) continue;
      var asset = this.game.getAsset(asset_id);
      if (asset && asset instanceof adventurejs[instanceClass]) {
        foundInstances.push(asset_id);
      }
    }
    return foundInstances;
  };
})();

// getAllContents.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Returns an array of all content in any location
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getAllContents
   * @return {Array}
   */
  p.getAllContents = function Tangible_getAllContents() {
    var contents = [];
    for (var aspect in this.aspects) {
      if (!this.hasAspectAt(aspect)) {
        continue;
      }
      if (Array.isArray(this.aspects[aspect].contents)) {
        contents = contents.concat(this.aspects[aspect].contents);
      }
    }
    return contents;
  };
})();

// getAllNestedContents.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Get list of other assets nested within this one. 
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getAllNestedContents
   * @return {Array}
   */
   p.getAllNestedContents = p.$inventory = function Tangible_getAllNestedContents() {
    var contents = [];
    contents = contents.concat( this.getAllContents() );

    for( var i = 0; i < contents.length; i++ ) 
    {
      var child = this.game.getAsset( contents[ i ] );
      var nestedContents = child.getAllNestedContents( contents );

      for( var n = 0; n < nestedContents.length; n++ ) 
      {
        if( -1 === contents.indexOf( nestedContents[ n ] )) 
        {
          contents.push( nestedContents[ n ] );
        }
      }
    }

    return contents;
  }
}());
// getAncestorId.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Get the ID of this asset's topmost parent, excluding {@link adventurejs.Room|Room}.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getAncestorId
   * @returns {String}
   */
  p.getAncestorId = function Tangible_getAncestorId() 
  {
    var child = this;
    var parent_asset = this.getPlaceAsset();

    // child has no parent, so it's not accessible
    if( !parent_asset ) 
    {
      return "";
    }

    // child parent is room
    if( parent_asset instanceof adventurejs.Room ) 
    {
      return "";
    }

    while ( parent_asset ) 
    {
      child = parent_asset;
      if( !parent_asset.getPlaceAsset() ) 
      {
        return "";
      }
      parent_asset = parent_asset.getPlaceAsset();
      if( parent_asset instanceof adventurejs.Room ) 
      {
        return child.id;
      }
    }
    return "";
  }
}());
// getAnySubstanceThisContains.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get the substance, if any, contained in this asset.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getAnySubstanceThisContains
   * @returns {String}
   */
  p.getAnySubstanceThisContains =
    function Tangible_getAnySubstanceThisContains() {
      var aspect = this.getAspectWithVessel();
      if (aspect && this.aspects[aspect].vessel.getVolume() > 0) {
        return this.aspects[aspect].vessel.substance_id;
      }
      return "";
    }; // getAnySubstanceThisContains.js
})();

// getAspectAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get aspect at specified preposition.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getAspectAt
   * @param {string} aspect - The aspect to get.
   * @return {Object|Null}
   */
  p.getAspectAt = function Tangible_getAspectAt(aspect) {
    if (!aspect || !this.aspects || !this.aspects[aspect]) {
      return null;
    }
    return this.aspects[aspect];
  };
})();

// getAspectWithVessel.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get this asset's substance location. This is somewhat
   * ambiguous because in theory an asset can have multiple
   * substance locations but in practice we clearly prefer 'in'.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getAspectWithVessel
   * @returns {String}
   */
  p.getAspectWithVessel = function Tangible_getAspectWithVessel() {
    var keys = Object.keys(this.aspects);
    var vessels = [];
    for (var i = 0; i < keys.length; i++) {
      var aspect = keys[i];
      if (!this.aspects[aspect].vessel.class) continue;
      vessels.push(aspect);
    }
    switch (vessels.length) {
      case 0:
        return "";
      case 1:
        return vessels[0];
      default:
        // if more than one vessels are found and 'in' is one return 'in'
        // otherwise just return the first one found
        if (vessels.indexOf("in") !== -1) return "in";
        else return vessels[0];
    }
  };
})();

// getClosedAnscestors.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Get a list of this asset's containing parent(s) that are closed. 
   * Takes into account nesting doll 
   * situations and looks all the way up the chain.
   * Useful for determining whether a player can interact
   * with a nested object.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getClosedAnscestors
   * @returns {Array}
   */
   p.getClosedAnscestors = function Tangible_getClosedAnscestors() 
   {
     var parent = this.getPlaceAsset();
     var anscestorsToOpen = [];
 
     if( parent
     && parent.isDOV('close')
     && "undefined" !== typeof parent.getClosedAnscestors ) 
     {
       anscestorsToOpen = anscestorsToOpen.concat( parent.getClosedAnscestors() );
     }
     if( this.isDOV('close') && this.is.closed ) 
     {
       anscestorsToOpen = anscestorsToOpen.concat( this.id );
     }
     return anscestorsToOpen;
   } 
}());
// getContentsAt.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Returns an array of all content in the specified aspect.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getContentsAt
   * @return {Array}
   */
   p.getContentsAt = function Tangible_getContentsAt(aspect) 
   {
    if(!this.hasAspectAt(aspect) ) return [];
    return this.getAspectAt(aspect).contents;
   }
 }());
// getCountOfListableContentsAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get a count of assets within this asset that are listable in
   * this asset's description, for example when player examines this.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getCountOfListableContentsAt
   * @param {String} where
   * @returns {int}
   */
  p.getCountOfListableContentsAt = function Tangible_getCountOfListableContents(
    where
  ) {
    if ("" === this.game.dictionary.getStringLookup("prepositions", where)) {
      console.warn("Bad request to count_listable_contents", where);
      return 0;
    }
    var list = this.aspects[where].contents;
    var num = list.length;
    for (var i = num - 1; i > -1; i--) {
      if (!this.game.getAsset(list[i]).is.listed_in_parent) {
        num--;
      }
    }
    return num;
  };
})();

// getListableContents.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get an array of assets within this asset that are listable in
   * this asset's description, for example when player examines this.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getListableContents
   * @returns {Array}
   */
  p.getListableContents = function Tangible_getListableContents() {
    var masterlist = [];
    for (var aspect in this.aspects) {
      if (!this.hasAspectAt(aspect)) {
        continue;
      }
      if (
        this.aspects[aspect].list_in_room &&
        this.aspects[aspect].contents.length > 0
      ) {
        if ("in" === aspect && this.is.closed) {
          continue;
        }
        // TODO transparent containers

        var list = this.aspects[aspect].contents;
        for (var i = 0; i < list.length; i++) {
          if (this.game.getAsset(list[i]).is.listed_in_parent) {
            masterlist.push(list[i]);
            // recurse
            masterlist = masterlist.concat(
              this.game.getAsset(list[i]).getListableContents()
            );
          }
        }
      }
    }
    return masterlist;
  };
})();

// getNestOrPlacePreposition.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get preposition of character's parent aspect. If character is nested,
   * returns nest asset preposition, otherwise returns room asset preposition.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getNestOrPlacePreposition
   * @return {Boolean}
   */
  p.getNestOrPlacePreposition = function Tangible_getNestOrPlacePreposition() {
    if (this.isNested()) {
      return this.getNestPreposition();
    } else {
      return this.getPlacePreposition();
    }
  };
})();

// getOpenOrClosed.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Print a string representing open / closed 
   * state of this asset.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getOpenOrClosed
   * @return {Array}
   */
  p.getOpenOrClosed = function Tangible_getOpenOrClosed()
  {
    return this.print_open_or_closed;
  }
 }());
// getPlaceAspect.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Returns the aspect object of this asset's parent
   * asset or null.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getPlaceAspect
   * @return {Object|null}
   */
  p.getPlaceAspect = function Tangible_getPlaceAspect() {
    if (!this.__place) return null;
    if (!this.__place.asset) return null;
    if (!this.__place.aspect) return null;
    var asset = this.game.getAsset(this.__place.asset);
    if (!asset) return null;
    if (!asset.aspects[this.__place.aspect]) return null;
    return asset.aspects[this.__place.aspect];
  };
})();

// getPlaceAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Get the object of this asset's parent asset.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getPlaceAsset
   * @returns {Object|Boolean}
   */
  p.getPlaceAsset = p.$parent = function Tangible_getPlaceAsset() 
  {
    return this.game.getAsset( this.getPlaceAssetId() );
  }
}());
// getPlaceAssetId.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Returns the ID of asset's parent or a blank string.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getPlaceAssetId
   * @return {String}
   */
   p.getPlaceAssetId = function Tangible_getPlaceAssetId()
   {
    if(!this.__place) return "";
    if(!this.__place.asset) return "";
    return this.__place.asset;
  }
}());
// getPlacePreposition.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Returns the aspect id of this asset's parent
   * asset, or a blank string.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getPlacePreposition
   * @return {String}
   */
  p.getPlacePreposition = function Tangible_getPlacePreposition() {
    if (!this.__place) return "";
    if (!this.__place.aspect) return "";
    return this.__place.aspect;
  };
})();

// getPrintableListOfContents.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get a printable list of assets within all
   * Aspects of this asset, for example
   * to append to asset description when player inputs
   * "examine this". Returns a string.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getPrintableListOfContents
   * @param {Object} params
   * @returns {String}
   */
  p.getPrintableListOfContents =
    function Tangible_getPrintableListOfFullContents(params) {
      this.game.log(
        "log",
        "high",
        "Tangible.js > " + this.id + " getPrintableListOfContents",
        "Tangible"
      );
      if (!params) {
        params = {};
      }
      if (!params.caller) {
        params.caller = "examine";
      }
      var output = "";

      for (var aspect in this.aspects) {
        if (!this.hasAspectAt(aspect)) {
          continue;
        }
        if (!this.aspects[aspect].list_in_room) {
          if (this.aspects[aspect].know_with_parent) {
            this.setAspectContentsKnown(aspect);
          }
        } else if (
          this.aspects[aspect].contents.length > 0 ||
          this.aspects[aspect].vessel.class
        ) {
          output += this.getPrintableListOfContentsAt(aspect, params);
        }
      }
      return output;
    };
})();

// getPrintableListOfContentsAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get a printable list of assets within a specified
   * Aspect of this asset, for example
   * to append to asset description when player inputs
   * "look in this". Returns a string.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#
   * @param {String} where
   * @param {Object} params
   * @return {String}
   * @todo reconsider this logic because it assumes that aspect can be
   * not enabled while substance within it can be enabled
   * and that is not how I see it right now
   * @todo replace the aspect checks with this.hasAspectAt(where)
   */
  p.getPrintableListOfContentsAt = function Tangible_getPrintableListOfContents(
    where,
    params
  ) {
    this.game.log(
      "log",
      "high",
      "Tangible.js > " + this.id + " getPrintableListOfContentsAt " + where,
      "Tangible"
    );

    // Aspect not defined
    if (!this.aspects[where]) {
      return "";
    }

    // neither things nor substances enabled
    // @todo reconsider this logic
    if (!this.hasAspectAt(where) && !this.hasVesselAtAspect(where)) {
      return "";
    }

    // only things enabled but no things to list
    if (
      this.hasAspectAt(where) &&
      !this.hasVesselAtAspect(where) &&
      0 === this.getCountOfListableContentsAt(where)
    ) {
      return "";
    }

    // only substances enabled but empty
    if (this.hasAspectAt(where)) {
      if (
        !this.hasAspectAt(where) &&
        this.hasVesselAtAspect(where) &&
        0 >= this.aspects[where].vessel.getVolume()
      ) {
        return "";
      }
    }

    // some valid contexts call without params
    params = params || {};
    params.caller = params.caller || "examine";

    var output = "";
    var listableObjects = [];
    var contents = A.clone.call(this.game, this.aspects[where].contents);
    var empty = true;

    //output += "water "

    if (
      this.hasVesselAtAspect(where) &&
      0 < this.aspects[where].vessel.getVolume() &&
      this.aspects[where].vessel.substance_id
    ) {
      // shouldn't be necessary
      empty = false;
      this.aspects[where].vessel.vessel_is_known = true;
      output +=
        this.Articlename +
        " is " +
        this.game.dictionary.getStringLookup(
          "substance_percents",
          this.aspects[where].vessel.percent_of_maxvolume.toFixed(1)
        ) +
        " of " +
        this.game.world[this.aspects[where].vessel.substance_id].name +
        ". ";
    }

    for (var i = 0; i < contents.length; i++) {
      var object = this.game.getAsset(contents[i]);

      if (object.is.hidden) {
        continue;
      }

      object.setKnown();
      object.setSeen();

      if ("room" === params.caller && !object.is.listed_in_room) {
        continue;
      }

      if ("examine" === params.caller && !object.is.listed_in_parent) {
        continue;
      }

      listableObjects.push(object);
    }

    // if( 0 === listableObjects.length
    // && empty
    // && "examine" === params.caller )
    // {
    //   output += " There isn't anything "
    //   + this.game.dictionary.getStringLookup( "prepositions", where )
    //   + " "
    //   + this.definite_article
    //   + " "
    //   + this.name
    //   + ". ";
    // }

    if (listableObjects.length > 0) {
      // TODO language string for behind/in/on/under
      var str_where = this.game.dictionary.getStringLookup(
        "prepositions",
        where
      );
      output += " ";
      output +=
        A.propercase(str_where) + " " + this.articlename + " $(we) see ";

      output += this.game.getPrintableObjectList({ objects: listableObjects });
      output += ". ";
    }
    return output;
  };
})();

// getRoomAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Get the asset of the room this asset is in.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getRoomAsset
   * @returns {String}
   */
  p.getRoomAsset = p.$room = function Tangible_getRoomAsset() 
  {
    return this.game.getAsset( this.getRoomId() );
  }
}());
// getRoomId.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Get the ID of the room this asset is in.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getRoomId
   * @returns {String}
   */
  p.getRoomId = function Tangible_getRoomId() 
  {
    var room = null;
    var child = this;
    while ( null === room ) 
    {
      if( "undefined" === typeof child.place ) 
      {
        // if it doesn't have a place property, it's not Tangible
        break;
      }
      var parent = child.getPlaceAsset();
      if( !parent ) 
      {
        break;
      }
      if( parent instanceof adventurejs.Room ) 
      {
        room = parent.id;
      } 
      else 
      {
        child = parent;
      }
    }
    return room;
  }
}());
// getRopesThatBlockTravel.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check if player is holding a rope, or tied by a rope, that
   * is tied at the other end, preventing player from leaving room.
   * Return a list of assets that meet this qualification.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getRopesThatBlockTravel
   * @return {Array}
   */
  p.getRopesThatBlockTravel = function Tangible_getRopesThatBlockTravel() {
    var carried_ropes = this.findClassInThis("Rope");
    var tied_ropes = this.iov.tie?.with_params.connections;
    var all_ropes = carried_ropes.concat(
      Array.isArray(tied_ropes) && tied_ropes.length ? tied_ropes : []
    );
    var travel_blocking_ropes = [];

    // look for ropes which are children
    for (var i = 0; i < all_ropes.length; i++) {
      var rope = this.game.getAsset(all_ropes[i]);
      if (rope && 0 < rope.dov.tie?.with_params.connections.length) {
        for (var r = 0; r < rope.dov.tie.with_params.connections.length; r++) {
          var tiedThing = this.game.getAsset(
            rope.dov.tie.with_params.connections[r]
          );
          console.warn("tiedThing", tiedThing);

          // it's in this and tied to this, don't care
          if (tiedThing.id === this.id) continue;

          // tied to something external
          if (
            !tiedThing.isIn(this) &&
            /* and can't stretch outside the room */
            !rope.can.be_in_multiple_rooms &&
            /* and can't be dragged behind */
            !tiedThing.on_tie_to_drag_behind_rope
          ) {
            if (-1 === travel_blocking_ropes.indexOf(rope.id)) {
              travel_blocking_ropes.push(rope.id);
            }
          }
        }
      }
    }
    return travel_blocking_ropes;
  };
})();

// getSubstanceAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get the substance, if any, contained in this asset.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getSubstanceAt
   * @returns {String}
   */
  p.getSubstanceAt = function Tangible_getSubstanceAt(aspect) {
    if (
      this.hasAspectAt(aspect) &&
      this.aspects[aspect].vessel.getVolume() > 0
    ) {
      return this.aspects[aspect].vessel.substance_id;
    }
    return "";
  }; // getSubstanceAt.js
})();

// getThingThisIsTiedToPlayerBy.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Assuming this asset is tied to the player asset by means of a third 
   * thing, get that third thing. 
   * Returns an asset object.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#getThingThisIsTiedToPlayerBy
   * @return {Object}
   */
  p.getThingThisIsTiedToPlayerBy = function Tangible_getThingThisIsTiedToPlayerBy()
  {
    var player = this.game.getPlayer();
    var ropeTiedToPlayer;
    for( var i = 0; i < this.iov.tie.with_params.connections.length; i++ ) 
    {
      var rope = this.game.getAsset( this.iov.tie.with_params.connections[i] );
      if( rope.isIn( player )
      || -1 < rope.dov.tie.with_params.connections.indexOf( player.id ) )
      {
        ropeTiedToPlayer = rope;
      }
    }
    return ropeTiedToPlayer;
}
}());
// getTiedThingsThatDragOnTravel.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check if player is holding a rope, or tied by a rope, that
   * is tied at the other end to an asset that can travel with player.
   * Return a list of assets that meet this qualification.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getTiedThingsThatDragOnTravel
   * @return {Array}
   */
  p.getTiedThingsThatDragOnTravel =
    function Tangible_getTiedThingsThatDragOnTravel() {
      var carried_ropes = this.findClassInThis("Rope");
      var tied_ropes = this.iov.tie.with_params.connections;
      var all_ropes = carried_ropes.concat(tied_ropes);
      var draggedThings = [];

      // look for ropes which are children
      for (var i = 0; i < all_ropes.length; i++) {
        var rope = this.game.getAsset(all_ropes[i]);
        if (0 < rope.dov.tie.with_params.connections.length) {
          for (
            var r = 0;
            r < rope.dov.tie.with_params.connections.length;
            r++
          ) {
            var tiedThing = this.game.getAsset(
              rope.dov.tie.with_params.connections[r]
            );
            console.warn("tiedThing", tiedThing);

            // it's in this and tied to this, don't care
            if (tiedThing.id === this.id) continue;

            // tied to something external
            if (
              !tiedThing.isIn(this) &&
              /* and can't stretch outside the room */
              !rope.can.be_in_multiple_rooms &&
              /* and can't be dragged behind */
              tiedThing.on_tie_to_drag_behind_rope
            ) {
              if (-1 === draggedThings.indexOf(tiedThing.id)) {
                draggedThings.push(tiedThing.id);
              }
            }
          }
        }
      }

      return draggedThings;
    };
})();

// getVesselAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get substance container at specified preposition.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getVesselAt
   * @param {string} aspect - The aspect to check.
   * @return {Object|Null}
   */
  p.getVesselAt = function Tangible_getVesselAt(aspect) {
    if (
      !this.getAspectAt(aspect) ||
      !this.aspects[aspect].vessel ||
      !this.aspects[aspect].vessel.class
    ) {
      return null;
    }
    return this.aspects[aspect].vessel;
  };
})();

// getY.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get this asset's global y.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getY
   * @returns {Float}
   */
  p.getY = function Tangible_getY() {
    return this.position.y;
  };
})();

// getYBottom.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get this asset's global bottom y based on its y and height,
   * which may be negative.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getYBottom
   * @returns {Float}
   */
  p.getYBottom = function Tangible_getYBottom() {
    return this.position.y;
  };
})();

// getYRange.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get this asset's bottom y and top y based on its y and height,
   * which may be negative.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getYRange
   * @returns {Object}
   */
  p.getYRange = function Tangible_getYRange() {
    return { min: this.getYBottom, max: this.getYTop };
  };
})();

// getYTop.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Get this asset's global top y based on its y and height.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#getYTop
   * @returns {Float}
   */
  p.getYTop = function Tangible_getYTop() {
    return this.position.y + this.dimensions.height;
  };
})();

// hasAspectAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Determine whether asset has an aspect at specified preposition.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#hasAspectAt
   * @param {String} aspect
   * @return {Boolean}
   */
  p.hasAspectAt = function Tangible_hasAspectAt(aspect) {
    if (
      !aspect ||
      !this.aspects ||
      !this.aspects[aspect] ||
      !this.aspects[aspect].class
    ) {
      return false;
    }
    return true;
  };
})();

// hasContentsAtAspect.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Determine whether asset has contents at the specified aspect.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#hasContentsAtAspect
   * @param {String} aspect
   * @return {Boolean}
   */
  p.hasContentsAtAspect = function Tangible_hasContentsAtAspect(aspect) {
    if (
      !this.hasAspectAt(aspect) ||
      !this.aspects[aspect].contents ||
      this.aspects[aspect].contents.length === 0
    ) {
      return false;
    }
    return true;
  };
})();

// hasListableContents.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Check whether this asset has any listable contents.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#hasListableContents
   * @returns {Boolean}
   * @TODO transparent containers
   */
  p.hasListableContents = function Tangible_hasListableContents() {
    for (var i = 0; i < this.game.dictionary.prepositions.length; i++) {
      var aspect = this.game.dictionary.prepositions[i];
      if (!this.hasAspectAt(aspect)) {
        continue;
      }
      if (
        this.aspects[aspect].list_in_room &&
        this.aspects[aspect].contents.length > 0
      ) {
        if (aspect === "in" && true === this.is.closed) continue;
        // @TODO transparent containers
        return true;
      }
    }

    return false;
  };
})();

// hasPlace.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Determine whether asset has a place.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#hasPlace
   * @return {Boolean}
   */
  p.hasPlace = function Tangible_hasPlace()
  {
    if(!this.place) return false;
    if(!Object.keys(this.place)[0]) return false;
    return true;
  }
 }());
// hasPropertyOnAspectAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Determine whether asset has specified property on
   * specified aspect. Useful for testing whether properties
   * exist before trying to assign to them.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#hasPropertyOnAspectAt
   * @return {Boolean}
   * @deprecated this will likely go away
   */
  p.hasPropertyOnAspectAt = function Tangible_hasPropertyOnAspectAt(
    property,
    aspect
  ) {
    if (
      !aspect ||
      !property ||
      !this.aspects[aspect] ||
      !this.aspects[aspect][property]
    ) {
      return false;
    }
    return true;
  };
})();

// hasRopesThatBlockTravel.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Determine if player is holding or tied by any ropes 
   * that block travel to other rooms.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#hasRopesThatBlockTravel
   * @return {Boolean}
   */
  p.hasRopesThatBlockTravel = function Tangible_hasRopesThatBlockTravel()
  {
    return this.getRopesThatBlockTravel().length > 0 ? true : false;
  }
}());
// hasTiedThingsThatDragOnTravel.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Check if player is holding a rope, or tied by a rope, that 
   * is tied at the other end to an asset that can travel with player. 
   * Returns a boolean indicating whether any asset meets this qualification.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#hasTiedThingsThatDragOnTravel
   * @return {Boolean}
   */
  p.hasTiedThingsThatDragOnTravel = function Tangible_hasTiedThingsThatDragOnTravel()
  {
    return this.getTiedThingsThatDragOnTravel().length > 0 ? true : false;
  }
}());
// hasVessel.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Determine whether asset has any aspect with a vessel.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#hasVessel
   * @return {Boolean}
   */
  p.hasVessel = function Tangible_hasVessel()
  {
    if( this.getAspectWithVessel() ) return true;
    return false;
  }
 }());
// hasVesselAtAspect.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Determine whether asset has substance at an aspect
   * at specified preposition.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#hasVesselAtAspect
   * @param {String} aspect
   * @return {Boolean}
   */
  p.hasVesselAtAspect = function Tangible_hasVesselAtAspect(aspect) {
    if (
      !aspect ||
      !this.aspects ||
      !this.aspects[aspect] ||
      !this.aspects[aspect].class ||
      !this.aspects[aspect].vessel ||
      !this.aspects[aspect].vessel.class
    ) {
      return false;
    }
    return true;
  };
})();

// isPlacedAtAspect.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Verify that asset is in the specified aspect.
   * For example, cap.isPlacedAtAspect( 'attached' )
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#isPlacedAtAspect
   * @return {Boolean}
   */
  p.isPlacedAtAspect = function Tangible_isPlacedAtAspect( aspect )
  {
    if(!this.__place) return false;
    if(!this.__place.aspect) return false;
    if(aspect && aspect !== this.__place.aspect) return false;
    return true;
  }
}());
// isPlacedAtAspectAndAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Determine whether asset has a place. Can be used 
   * to test against specific aspects and parent assets.
   * For example, cap.isPlacedAtAspectAndAsset( 'attached', 'pen' )
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#isPlacedAtAspectAndAsset
   * @param {String} aspect
   * @param {String} asset
   * @return {Boolean}
   */
  p.isPlacedAtAspectAndAsset = function Tangible_isPlacedAtAspectAndAsset( aspect, asset )
  {
    if( !this.__place ) return false;
    if( !this.__place.aspect ) return false;
    if( !this.__place.asset ) return false;

    if( aspect && aspect !== this.__place.aspect ) return false;
    if( asset && asset !== this.__place.asset ) return false;

    return true;
  }
}());
// isWithinYRange.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Determine whether this asset's y position is within another asset's 
   * y range, aka its height from its y position.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#isWithinYRange
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.isWithinYRange = function Tangible_isWithinPositionYRange(asset) 
  {
    if(!asset) return false;
    var range = asset.getYRange();
    return ( this.position.y >= range.min && this.position.y <= range.max );
  }
}());
// linkRegisteredParts.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * linkRegisteredParts does the bulk of the work for 
   * <a href="#registerParts">registerParts</a>. The base
   * method defined in Tangible is blank. Subclasses that 
   * can make use of it will override the method as needed.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#linkRegisteredParts
   */
   p.linkRegisteredParts = function Tangible_linkRegisteredParts()
  {
    // customize per class
  }  
}());
// moveFrom.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * moveFrom is an alias to onRemoveThatFromThis 
   * but with asset and this reversed
   * purely for syntactic convenience.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#moveFrom
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.moveFrom = function Tangible_moveFrom( asset ) 
  {
    if("string" === typeof asset) asset = this.game.getAsset(asset);
    if(!asset) return false;
    return asset.onRemoveThatFromThis( this );
  }
 }());
// moveTo.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * moveFrom is an alias to onMoveThatToThis 
   * but with asset and this reversed
   * purely for syntactic convenience.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#moveTo
   * @param {String} aspect
   * @param {Object} asset
   */
  p.moveTo = function Tangible_moveTo( aspect, asset )
  {
    if("string" === typeof asset) asset = this.game.getAsset(asset);
    if(!aspect||!asset) return false;
    if(!asset.hasAspectAt(aspect)) return false;
    return asset.onMoveThatToThis( this, aspect );
  }
 }());
// onAddSubstanceToThis.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Called when a substance asset is added to this, 
   * providing an opportunity to override default behavior 
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb effect hook</a> 
   * doAddSubstanceToThis.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#
	 * @method adventurejs.Tangible#onAddSubstanceToThis
   * @param {Object} asset
   */
   p.onAddSubstanceToThis = function Tangible_onAddSubstanceToThis(asset) 
   {
      this.game.log( "log", "medium", this.name + " onAddSubstanceToThis " + asset.name + "." , 'Behavior' );
      var results = this.callAction('doAddSubstanceToThis', asset.name, {} );
      if( "undefined" !== typeof results ) return results;            
      return;
   }
 }());
// onChangeGravity.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
  * Called when there is a change in gravity, 
  * providing an opportunity to override default behavior 
  * through the use of
  * <a href="/doc/Scripting_VerbReactions.html">verb effect hook</a> 
  * doChangeGravity.
  * @memberOf adventurejs.Tangible
	* @method adventurejs.Tangible#onChangeGravity
  */
  p.onChangeGravity = function Tangible_onChangeGravity(oldval, newval)
  {
    this.game.log( "log", "medium", this.name + " onChangeGravity " + oldval + ", " + newval + "." , "Behavior" );
    var results = this.callAction("doChangeGravity", null, {"oldval":oldval,"newval":newval} );
    if( "undefined" !== typeof results ) return results;            
    return;
  }
}());
// onChangeMoisture.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
  * Called when there is a change in moisture level, 
  * providing an opportunity to override default behavior 
  * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb effect hook</a> 
   * doChangeMoisture.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#onChangeMoisture
   * @param {Object} asset
   * @todo This should probably take a moisture value rather than an asset.
   */
   p.onChangeMoisture = function Tangible_onChangeMoisture(asset) 
   {
      this.game.log( "log", "medium", this.name + " onChangeMoisture " + "." , "Behavior" );
      var results = this.callAction('doChangeMoisture', asset.name, {} );
      if( "undefined" !== typeof results ) return results;            
      return;
   }
 }());
// onChangeTemperature.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Called when there is a change in temperature, 
   * providing an opportunity to override default behavior 
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb effect hook</a> 
   * doChangeTemperature.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#onChangeTemperature
   */
    p.onChangeTemperature = function Tangible_onChangeTemperature(oldval, newval)
    {
      this.game.log( "log", "medium", this.name + " onChangeTemperature " + oldval + ", " + newval + "." , "Behavior" );
      var results = this.callAction("doChangeTemperature", null, {"oldval":oldval,"newval":newval} );
      if( "undefined" !== typeof results ) return results;            
      return;
    }
  }());
// onMoveThatToThis.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Called when another asset is added to this.
   * Provides opportunities to override default behavior
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb reactions</a>
   * doMoveThisToThat and doMoveThatToThis.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#onMoveThatToThis
   * @param {Object} asset
   * @param {String} where
   * @returns {Boolean}
   */
  p.onMoveThatToThis = function Tangible_onMoveThatToThis(asset, aspect) {
    //console.warn('onMoveThatToThis');
    this.game.log(
      "log",
      "high",
      this.name + " onMoveThatToThis " + asset.name + ".",
      "Behavior"
    );
    var results;

    //
    if ("string" !== typeof aspect) {
      aspect = this.default_aspect;
    }

    this.game.debug(
      `F1930 | onMoveThatToThis.js | move ${asset.id} ${aspect} ${this.id} `
    );

    // check receiving asset for verb hook
    results = this.callAction("doMoveThatToThis", asset.name, {
      preposition: aspect,
    });
    if ("undefined" !== typeof results) return results;

    // check asset to be placed for verb hook
    //console.warn(asset);
    results = asset.callAction("doMoveThisToThat", this.name, null);
    if ("undefined" !== typeof results) return results;

    // set asset's new location to this
    asset.setPlace(aspect, this.id);

    return results;
  }; // onMoveThatToThis.js
})();

// onNestThatToThis.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Called when a player asset is nested to this.
   * Provides an opportunity to override default behavior
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb reactions</a>
   * doNestThatToThis.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#onNestThatToThis
   * @param {Object} player
   * @returns {Boolean}
   */
  p.onNestThatToThis = function Tangible_onNestThatToThis(player) {
    this.game.log(
      "log",
      "high",
      this.name + " onNestThatToThis " + player.name + ".",
      "Behavior"
    );
    if (!player) return;
    var results;
    var msg = "";

    // Unless explicitly set otherwise,
    // typically can't nest player into objects
    // that are themselves contained.

    if (
      !this.is.deep_nest &&
      this.getPlaceAssetId() !== this.game.getPlayer().id &&
      !(this.getPlaceAsset() instanceof adventurejs.Room)
    ) {
      this.game.debug(
        `F1524 | onNestThatToThis.js | ${this.id}.can_deep_nest is false `
      );
      msg += `$(We) can't do that while ${this.articlename} is 
        ${this.game.dictionary.getStringLookup(
          "prepositions",
          this.getPlacePreposition()
        )}
        ${this.getPlaceAsset().articlename}. `;
      this.game.print(msg);
      return null;
    }

    // Simple vehicles go into player inventory.

    if (this.is.rideable && !this.isIn(player)) {
      // move this from its parent
      results = this.moveFrom(this.getPlaceAsset());
      if ("undefined" !== typeof results) return results;

      // move this into player inventory
      results = this.moveTo("in", player);
      if ("undefined" !== typeof results) return results;
    }

    // allow for author to add custom interactions per-object
    results = this.callAction("doNestThatToThis", player.name, {});
    if ("undefined" !== typeof results) return results;

    return;
  };
})();

// onRemoveThatFromThis.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Called when another asset is removed from this.
   * Provides opportunities to override default behavior
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb reactions</a>
   * doRemoveThisFromThat and doRemoveThatFromThis.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#onRemoveThatFromThis
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.onRemoveThatFromThis = function Tangible_onRemoveThatFromThis(asset) {
    this.game.log(
      "log",
      "high",
      this.name + " onRemoveThatFromThis " + asset.name + ".",
      "Behavior"
    );
    var results;

    this.game.debug(
      `F1149 | onRemoveThatFromThis.js | remove ${asset.id} from ${this.id} `
    );

    // this may have an override when asset is removed
    results = this.callAction("doRemoveThatFromThis", asset.name, {});
    if (A.isFalseOrNull(results)) return results;

    // asset may also have an ovveride when removed from this
    results = asset.callAction("doRemoveThisFromThat", this.name, {});
    if (A.isFalseOrNull(results)) return results;

    // bedrock - perform the removal - no overrides or qualifiers
    this.removeThatFromThis(asset);
    asset.setPlace();

    return; // results;
  };
})(); // onRemoveThatFromThis.js

// onSubtractSubstanceFromThis.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Called when a substance is subtracted from this, 
   * providing an opportunity to override default behavior 
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb reactions</a> 
   * doSubtractSubstanceFromThis.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#
	 * @method adventurejs.Tangible#onSubtractSubstanceFromThis
   * @param {Object} asset
   */
   p.onSubtractSubstanceFromThis = function Tangible_onSubtractSubstanceFromThis(asset) 
   {
      this.game.log( "log", "medium", this.name + " onSubtractSubstanceFromThis " + asset.name + "." , 'Behavior' );
      var results = this.callAction('doRemoveThatFromThis', asset.name, {} );
      if( "undefined" !== typeof results ) return results;            
      return;
    }
 }());
// onTieThisToThat.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Called when this asset is tied to another asset.
   * Provides opportunities to override default behavior 
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb reactions</a> 
   * doTieThisToThat and doTieThatToThis.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#onTieThisToThat
   * @param {Object} asset
   * @returns {Boolean}
   */
   p.onTieThisToThat = function Tangible_onTieThisToThat( asset )
   {
    this.game.log( "log", "medium", this.name + " onTieThisToThat " + asset.name + "." , 'Behavior' );
    var results;
  
    // check rope for custom response
    results = this.callAction('doTieThisToThat', asset.name, {} );
    if( A.isFalseOrNull(results) ) return results;

    // check asset to be tied to for custom response
    results = asset.callAction('doTieThatToThis', this.name, {} );
    if( A.isFalseOrNull(results) ) return results;

    // add asset to rope's list of things its tied to
    if(-1 === this.dov.tie.with_params.connections.indexOf( asset.id )) 
    {
      this.dov.tie.with_params.connections.push( asset.id );
    }

    // add rope to asset's list of things tied to it
    if(-1 === asset.iov.tie.with_params.connections.indexOf( this.id ) )
    {
      asset.iov.tie.with_params.connections.push( this.id );
    }

    return;// results;
   }
 }());
// onUnnestThatFromThis.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Called when player is unnested from this asset.
   * Provides an opportunity to override default behavior 
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb reactions</a> 
   * doUnnestThatFromThis.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#onUnnestThatFromThis
   * @param {Object} player
   * @returns {Boolean}
   */
  p.onUnnestThatFromThis = function Tangible_onUnnestThatFromThis( player ) 
  {
    this.game.log( "log", "high", this.name + " onUnnestThatFromThis " + player.name + "." , 'Behavior' );
    var results;
    
    if( this.is.rideable
    && this.isIn( player ) ) 
    {
      results = player.onRemoveThatFromThis( this );
      if( "undefined" !== typeof results ) return results;            
    }

    results = this.callAction('doUnnestThatFromThis', player.name, {} );
    if( "undefined" !== typeof results ) return results;            

    return;
  }
}());
// onUntieThisFromThat.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Called when this asset is untied from another asset.
   * Provides opportunities to override default behavior 
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb reactions</a> 
   * doUntieThisFromThat and doUntieThatFromThis.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#onUntieThisFromThat
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.onUntieThisFromThat = function Tangible_onUntieThisFromThat( asset )
  {
    this.game.log( "log", "medium", this.name + " onUntieThisFromThat " + asset.name + "." , 'Behavior' );
    var results;

    // check rope for override
    results = this.callAction('doUntieThisFromThat', asset.name, {} );
    if( "undefined" !== typeof results ) return results;            

    // call actions
    results = asset.callAction('doUntieThatFromThis', this.name, {} );
    if( "undefined" !== typeof results ) return results;            

    // remove asset from rope's list of things its tied to
    var i = this.dov.tie.with_params.connections.indexOf( asset.id );
    this.dov.tie.with_params.connections.splice( i, 1 );

    // remove rope from asset's list of things tied to it
    i = asset.iov.tie.with_params.connections.indexOf( this.id );
    asset.iov.tie.with_params.connections.splice( i, 1 );

    return;
  }   
}());
// registerParts.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * registerParts is a shortcut method for use with complex objects 
   * that have interlinked parts. For example, a sink of class Drainable 
   * can have a faucet, a drain, and multiple handles, each of which 
   * interact with the base object or other objects in the collection 
   * in different ways. Registering parts with the base object offers 
   * an opportunity to create object references and share variables.
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#registerParts
   */
   p.registerParts = function Tangible_registerParts()
  {
    if(this.parts.length>0)
    {
      //var msg = this.class + " " + this.id + " registerParts found parts";
      var msg = this.id + ".registerParts)() found parts:";
      this.game.log( "log", "high", msg , 'Tangible' );
    }
    for( var i = this.parts.length-1; i > -1; i-- )
    {
      var part_id = this.parts[i];
      var part = this.game.getAsset( this.parts[i] );
      this.parts.splice( i, 1 );
      if( "undefined" === typeof part )
      {
        //var msg = this.class + " " + this.name + " parts contains an invalid id: " + id;
        var msg = this.name + " parts contains an invalid id: " + part_id;
        this.game.log( "warn", "critical", msg , 'Tangible' );
        continue;
      }
      var registerableClassKeys = Object.keys( this.registerableClasses );
      for( var r = 0; r < registerableClassKeys.length; r++ )
      {
        var registerableClass = registerableClassKeys[r];
        if( true === part instanceof adventurejs[registerableClass] )
        {
          // pass in a reference to 'this' as well as the part to be registered
          // because we're going into anonymous functions that don't have scope
          //this.registerableClasses[ registerableClass ]( this, part );
          this.registerableClasses[ registerableClass ].call( this, part );
          //var msg = "-- " + this.class + " " + this.id + " register " + part.class + " " + part.id;
          var msg = "-- " + this.id + " register " + part.id;
          this.game.log( "log", "high", msg , 'Tangible' );
          continue;
        }
      }
    }
  }
}());
// removeAssetAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Remove specified asset id from the contents of
   * specified aspect on this asset.
   * Returns contents if aspect exists, or null.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#removeAssetAt
   * @return {Array}
   */
  p.removeAssetAt = function Tangible_removeAssetAt(id, aspect) {
    if (this.hasAspectAt(aspect)) {
      if (-1 < this.aspects[aspect].contents.indexOf(id)) {
        this.aspects[aspect].contents.splice(
          this.aspects[aspect].contents.indexOf(id),
          1
        );
      }
      return this.aspects[aspect].contents;
    }
    return null;
  };
})();

// removeThatFromThis.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Removes an asset from another asset. It's not meant to be
   * called directly, but is the last piece, or bedrock, of the
   * removal process after checking for custom logic.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#removeThatFromThis
   * @param {Object} asset
   */
  p.removeThatFromThis = function Tangible_removeThatFromThis(asset) {
    this.game.log(
      "log",
      "high",
      this.name + " removeThatFromThis " + asset.name + ".",
      "Behavior"
    );
    for (var aspect in this.aspects) {
      if (!this.hasAspectAt(aspect)) {
        continue;
      }
      if (-1 < this.aspects[aspect].contents.indexOf(asset.id)) {
        this.aspects[aspect].contents.splice(
          this.aspects[aspect].contents.indexOf(asset.id),
          1
        );
      }
    }
    return;
  };
})();

// setAllAspectsContentsKnown.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * This function will try to set all aspect contents
   * of this asset known.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setAllAspectsContentsKnown
   */
  p.setAllAspectsContentsKnown = function Tangible_setAllAspectsContentsKnown(
    value
  ) {
    //console.warn(this.id,'setAllAspectsContentsKnown');

    // @TODO this should work with on and attached,
    // in if thing is open, maybe behind / under

    for (var aspect in this.aspects) {
      if (this.aspects[aspect].know_with_parent) {
        this.setAspectContentsKnown(aspect, value);
      }
    }
  };
})();

// setAllAspectsContentsSeen.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * This function will try to set all aspect contents
   * of this asset seen.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setAllAspectsContentsSeen
   */
  p.setAllAspectsContentsSeen = function Tangible_setAllAspectsContentsSeen(
    value
  ) {
    //console.warn(this.id,'setAllAspectsContentsKnown');

    // @TODO this should work with on and attached,
    // in if thing is open, maybe behind / under

    for (var aspect in this.aspects) {
      if (this.aspects[aspect].know_with_parent) {
        this.setAspectContentsSeen(aspect, value);
      }
    }
  };
})();

// setAspectAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Add an aspect at the specified aspect on this asset.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setAspectAt
   * @param {string} aspect - The aspect to add.
   * @return {Array}
   */
  p.setAspectAt = function Tangible_setAspectAt(aspect, params) {
    if (this.hasAspectAt(aspect)) {
      if (params) this.aspects[aspect].set(params);
    } else {
      if (!params) params = {};
      if (!params.parent_id) params.parent_id = this.id;
      this.aspects[aspect] = new adventurejs.Aspect(aspect, this.game_name).set(
        params
      );
    }
    return this.getAspectAt(aspect);
  };
})();

// setAspectContentsKnown.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * When player knows an asset, call this function to
   * make its contents known. Generally, contents of
   * behind/in/on/under are listed automatically and known,
   * whereas attachments may go unlisted in room descriptions.
   * This function is chiefly for setting is.known
   * for attachments, but can be applied to any aspects.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setAspectContentsKnown
   */
  p.setAspectContentsKnown = function Tangible_setAspectContentsKnown(
    aspect,
    value
  ) {
    //console.warn(this.id, "setAspectContentsKnown", aspect, value);
    if ("undefined" === typeof value) return false;
    if (!this.hasAspectAt(aspect)) {
      this.game.log(
        "warn",
        "high",
        "setAspectContentsKnown.js > Bad request",
        "Tangible"
      );
      return false;
    }
    var contents = this.aspects[aspect].contents;
    for (var i = 0; i < contents.length; i++) {
      var object = this.game.getAsset(contents[i]);

      // we don't want this to be recursive
      object.is._known = value;
      // object.is._seen = value;
    }
    return;
  };
})();

// setAspectContentsSeen.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * When player sees an asset, call this function to
   * make its contents known. Generally, contents of
   * behind/in/on/under are listed automatically and seen,
   * whereas attachments may go unlisted in room descriptions.
   * This function is chiefly for setting is.seen
   * for attachments, but can be applied to any aspects.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setAspectContentsSeen
   */
  p.setAspectContentsSeen = function Tangible_setAspectContentsSeen(
    aspect,
    value
  ) {
    //console.warn(this.id, "setAspectContentsSeen", aspect, value);
    if ("undefined" === typeof value) return false;
    if (!this.hasAspectAt(aspect)) {
      this.game.log(
        "warn",
        "high",
        "setAspectContentsSeen.js > Bad request",
        "Tangible"
      );
      return false;
    }
    var contents = this.aspects[aspect].contents;
    for (var i = 0; i < contents.length; i++) {
      var object = this.game.getAsset(contents[i]);

      // we don't want this to be recursive
      // object.is._known = value;
      object.is._seen = value;
    }
    return;
  };
})();

// setAttachmentsKnown.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Attachments may go unlisted in room descriptions unlike other assets.
   * It's assumed that the author will include them in their
   * parent's description.
   * For example "The desk has a drawer" where drawer is an attachment.
   * When these assets go unlisted,
   * they miss being marked as seen / known like other assets.
   * This function explicitly sets
   * is.known / is.seen properties for attachments.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setAttachmentsKnown
   */
  p.setAttachmentsKnown = function Tangible_setAttachmentsKnown() {
    //console.warn( this.name + " recognize attachments" );

    if (!this.hasAspectAt("attached")) {
      this.game.log(
        "warn",
        "high",
        "setAttachmentsKnown.js > Bad request",
        "Tangible"
      );
      return false;
    }
    var contents = this.aspects.attached.contents;
    for (var i = 0; i < contents.length; i++) {
      var object = this.game.getAsset(contents[i]);
      object.setKnown();
      object.setSeen();
    }
    return;
  };
})();

// setClosed.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;

  /**
   * <strong>setClosed</strong> sets an object closed,
   * also setting any linked assets closed.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setClosed
   * @param {Boolean} bool
   */
  p.setClosed = p.$close = function Tangible_setClosed(bool = true) {
    this.is.closed = bool;
  };
})();

// setKnown.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;

  /**
   * <strong>setKnown</strong> sets an object known,
   * also setting any linked assets known.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setKnown
   * @param {Boolean} bool
   */
  p.setKnown = p.$known = function Tangible_setKnown(bool = true) {
    this.is.known = bool;
    if (this.setAllAspectsContentsKnown) this.setAllAspectsContentsKnown(bool);
  };
})();

// setLocked.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;

  /**
   * <strong>setLocked</strong> sets an asset locked,
   * also setting any linked assets locked.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setLocked
   * @param {Boolean} bool
   */
  p.setLocked = p.$lock = function Tangible_setLocked(bool = true) {
    this.is.locked = bool;
  };
})();

// setPlace.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Tangible.prototype;	
  /**
   * Set an asset's place, aka parent asset and aspect. 
   * This is how one thing is put inside another.
   * cap.setPlace( 'attached', 'pen' );
   * @memberOf adventurejs.Tangible
	 * @method adventurejs.Tangible#setPlace
   * @param {String} aspect
   * @param {String} asset_id
   * @return {Object}
   */
  p.setPlace = function Tangible_setPlace( aspect, asset_id )
  {
    if( asset_id && !aspect )
    {
      var asset = this.game.getAsset( asset_id );
      if( asset )
      {
        aspect = asset.default_aspect;
      }
    }
    if( asset_id && aspect )
    {
      this.place = { [aspect]: asset_id };
    }
    else this.place = {};
    return this.place;
  }
}());
// setPosition.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Set this asset's global position.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setPosition
   * @param {Object} params
   * @returns {Object}
   */
  p.setPosition = function Tangible_setPosition(params) {
    this.position.x = params.x || this.position.x;
    this.position.y = params.y || this.position.y;
    this.position.z = params.z || this.position.z;
    return this.position;
  };
})();

// setSealed.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;

  /**
   * <strong>setSealed</strong> sets an asset sealed,
   * also setting any linked assets sealed.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setSealed
   * @param {Boolean} bool
   */
  p.setSealed = p.$seal = function Tangible_setSealed(bool = true) {
    this.is.sealed = bool;
  };
})();

// setSeen.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;

  /**
   * Used to track whether player has seen this asset.
   * 'seen' and 'known' are distinct because a player
   * may learn about a thing without seeing it.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setSeen
   * @param {Boolean} bool
   */
  p.setSeen = p.$seen = function Tangible_setSeen(bool = true) {
    this.is.seen = bool;
  };
})();

// setUsed.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;

  /**
   * Set whether player has used this asset. Used chiefly for Exit class to say
   * whether player has used an exit before. This figures into 'go to', which
   * excludes exits a player has never used from its pathfinding algorithm.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setUsed
   * @param {Boolean} bool
   */
  p.setUsed = p.$used = function Tangible_setUsed(bool = true) {
    this.is.used = bool;
  };
})();

// setVesselAt.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Add a substance container at the specified aspect on this asset.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setVesselAt
   * @param {string} aspect - The aspect to add.
   * @return {Array}
   */
  p.setVesselAt = function Tangible_addVesselAt(aspect, params) {
    if (!this.hasAspectAt(aspect)) {
      this.setAspectAt(aspect, { parent_id: this.id });
    }
    if (!this.hasVesselAtAspect(aspect)) {
      if (!params) params = {};
      if (!params.parent_id) params.parent_id = this.id;
      this.aspects[aspect] = new adventurejs.Aspect(aspect, this.game_name).set(
        params
      );
    } else {
      if (params) this.getVesselAt(aspect).set(params);
    }

    return this.getVesselAt(aspect);
  };
})();

// setX.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Set this asset's global x position.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setX
   * @param {Float} value
   * @returns {Float}
   */
  p.setX = function Tangible_setX(value) {
    return (this.position.x = value);
  };
})();

// setY.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Set this asset's global y position.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setY
   * @param {Float} value
   * @returns {Float}
   */
  p.setY = function Tangible_setY(value) {
    return (this.position.y = value);
  };
})();

// setZ.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;
  /**
   * Set this asset's global x position.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#setZ
   * @param {Float} value
   * @returns {Float}
   */
  p.setZ = function Tangible_setZ(value) {
    return (this.position.z = value);
  };
})();

// unfasten.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Tangible.prototype;

  /**
   * <strong>unfasten</strong> tries several methods for
   * unfastening.
   * @memberOf adventurejs.Tangible
   * @method adventurejs.Tangible#unfasten
   * @returns {string}
   */
  p.unfasten = function Tangible_unfasten() {
    let unfasten = "";
    if (this.is.zipped) {
      unfasten = "unzip";
      this.is.zipped = false;
      this.incrementDoVerbCount("unzip", 1);
    } else if (this.is.buttoned) {
      unfasten = "unbutton";
      this.is.buttoned = false;
      this.incrementDoVerbCount("unbutton", 1);
    }
    return unfasten;
  };
})();

// All.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments adventurejs.Tangible
   * @class adventurejs.All
   * @ajsconstruct MyGame.createAsset({ "class":"All", "name":"all" })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsinternal
   * @ajsnavheading LibraryAssets
   * @ajsnode game.world.all
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Internal class used to help parse when player inputs "all".
   * @classdesc <strong>All</strong> is an internal asset class used
   * to help parse input that tries to perform a verb on "all".
   * Created automatically at runtime. Authors should not need to create
   * instance of this.
   **/
  class All extends adventurejs.Tangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "All";
      this.descriptions.look = "That's all.";
      this.noun = "all";
      this.plural = "all";
      this.singlePluralPairs = [["all", "all"]];
      this.is.global = true;
      this.is._known = true;
      this.is._seen = true;
    }
  }

  adventurejs.All = All;
})();

// Character_Is.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Is.Tangible_Is.Character_Is
   * @augments adventurejs.Tangible_Is
   * @class adventurejs.Character_Is
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <strong>Character_Is.js</strong> is a state management class
   * used to handle a variety of properties for
   * {@link adventurejs.Character|Character Assets}.
   **/

  class Character_Is extends adventurejs.Tangible_Is {
    constructor(name = "is", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);
      this.class = "Character_Is";

      //this.alive = true;
      this.blind = false;
      this.dead = false;
      this.deaf = false;
      this.mute = false;
      this.asleep = false;
      this.unconscious = false;
      this.constrained = false;

      return this;
    }

    get climbing() {
      return this.parent.posture === "climb";
    }
    get crawling() {
      return this.parent.posture === "crawl";
    }
    get floating() {
      return this.parent.posture === "float";
    }
    get flying() {
      return this.parent.posture === "fly";
    }
    get hovering() {
      return this.parent.posture === "hover";
    }
    get kneeling() {
      return this.parent.posture === "kneel";
    }
    get slithering() {
      return this.parent.posture === "slither";
    }
    get swimming() {
      return this.parent.posture === "swim";
    }
    get hopping() {
      return this.parent.posture === "hop";
    }

    get clinging() {
      return this.parent.posture === "cling";
    }
    get hanging() {
      return this.parent.posture === "hang";
    }
    get lying() {
      return this.parent.posture === "lie";
    }
    get sitting() {
      return this.parent.posture === "sit";
    }
    get standing() {
      return this.parent.posture === "stand";
    }
  }
  adventurejs.Character_Is = Character_Is;
})();

// Character_Can.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Can.Tangible_Can.Character_Can
   * @augments adventurejs.Character_Can
   * @class adventurejs.Character_Can
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <strong>Character_Can</strong> is a state management class
   * used to store a variety of booleans for
   * {@link adventurejs.Character|Character Assets}.
   **/

  class Character_Can extends adventurejs.Asset_Can {
    constructor(name = "can", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Character_Can";

      this.climb = true;
      this.crawl = true;
      this.float = false;
      this.fly = false;
      this.hover = false;
      this.slither = true;
      this.swim = true;
      this.hop = true;

      this.cling = true;
      this.hang = true;
      this.kneel = true;
      this.lie = true;
      this.sit = true;
      this.stand = true;

      return this;
    }
  }
  adventurejs.Character_Can = Character_Can;
})();

// Character_Must.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Must.Tangible_Must.Character_Must
   * @augments adventurejs.Character_Must
   * @class adventurejs.Character_Must
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <strong>Character_Must</strong> is a state management class
   * used to store a variety of booleans for
   * {@link adventurejs.Character|Character Assets}.
   **/

  class Character_Must extends adventurejs.Tangible_Must {
    constructor(name = "must", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);

      this.class = "Character_Must";

      return this;
    }
  }
  adventurejs.Character_Must = Character_Must;
})();

// Character.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Character
   * @augments adventurejs.Tangible
   * @class adventurejs.Character
   * @ajsconstruct MyGame.createAsset({ "class":"Character", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading CharacterClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Base class for all character types.
   * @tutorial Characters_NPCs
   * @tutorial CreatePlayer
   * @ajstangiblecontainer in
   * @todo more methods, better example
   * @classdesc
   * <p>
   * <strong>Character</strong> is anything that moves or speaks
   * or takes or gives. {@link adventurejs.Player|Player} and
   * {@link adventurejs.NPC|NPCs} are both Characters.
   * Character can sense things, hold things, be asked things,
   * be told things...
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   "class": "Character",
   *   "name": "Yurtle",
   *   "synonyms": ["turtle"],
   *   "place": {in: "Pond"},
   * })
   * </code></pre>
   */
  class Character extends adventurejs.Tangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Character";

      this.is = new adventurejs.Character_Is("is", this.game_name, this.id).set(
        {
          parent_id: this.id,
        }
      );

      this.can = new adventurejs.Character_Can(
        "can",
        this.game_name,
        this.id
      ).set({
        parent_id: this.id,
      });

      this.setIOVs(["throw", "take", "give", "hold", "tie"]);

      this.posture = "stand";

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
      });

      this.dont_use_articles = true;
      this.name_is_proper = true;
    }

    /**
     * Get / set nest.
     * @var {Object} adventurejs.Character#nest
     */
    get nest() {
      return this._nest;
    }
    set nest(nest) {
      if (Object(nest) !== nest) {
        var msg = this.id + ".nest received a malformed value ";
        this.game.log("error", "critical", msg, "Tangible");

        nest = {};
      } else {
        var keys = Object.keys(nest);

        if (keys.length > 1) {
          var msg =
            this.id +
            ".nest received more than one location. Using the first. ";
          for (var i = 0; i < keys.length; i++) {
            msg += keys[i] + ", ";
          }
          nest = { [keys[0]]: nest[keys[0]] };
          this.game.log("error", "critical", msg, "Character");
        }

        if (keys.length === 1) {
          // serialize asset name
          nest[keys[0]] = A.serialize(nest[keys[0]]);

          // verify asset
          if ("string" !== typeof nest[keys[0]]) {
            var msg = this.id + ".nest set to an invalid asset ";
            this.game.log("error", "critical", msg, "Tangible");
          }
        }

        if (keys.length === 0) {
        }
      }

      this._nest = nest;
    }
  }
  adventurejs.Character = Character;
})();

// $getKey.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Returns one key that player is carrying, if any,
   * to unlock the specified asset.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#$getKey
   * @param {Object|String} direct_object An asset or asset ID to unlock.
   * @returns {Object|null} A Key asset, if player has any.
   */
  p.$getKey = function Character__getKey(direct_object)
  {
    let keys = this.getIOVkeys('unlock',direct_object);
    return keys[0] || null;
  }
 }());
// $getKeys.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Returns a list of keys that player is carrying, if any,
   * to unlock the specified asset.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#$getKeys
   * @param {Object|String} direct_object An asset or asset ID to unlock.
   * @returns {Array} An array of Key assets, if player has any.
   */
  p.$getKeys = function Character__getKeys(direct_object)
  {
    return this.getIOVkeys('unlock',direct_object);
  }
 }());
// $hasKey.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Checks to see if player has any keys to unlock the specified asset.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#$hasKey
   * @param {Object|String} direct_object An asset or asset ID to unlock.
   * @returns {Array} An array of Key assets, if player has any.
   */
  p.$hasKey = function Character__hasKey(direct_object)
  {
    return this.getIOVkeys('unlock',direct_object).length?true:false;
  }
 }());
// getInventory.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Get the character inventory, 
   * including things inside character and held by character.
   * Does not return nested items.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#getInventory
   * @returns {Object|Boolean}
   * @todo should this return nested items?
   * it probably should return nested items
   */
  p.getInventory = function Character_getInventory() 
  {
    return this.getContentsAt('in').concat( this.IOVgetConnections('hold') );
  }
}());
// getIOVkeys.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Returns a list of assets carried by the player, if any, that can perform
   * the specified verb upon the specified asset as defined in the
   * target asset.dov[verb].with_assets/with_classes
   * property. Works with verbs including open & close, pick,
   * lock & unlock, and seal & unseal.
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#getIOVkeys
   * @param {String} verb The name of a verb.
   * @param {Object|String} direct_object An asset or asset ID of a direct object that the player has tried to perform an indirect verb on.
   * @returns {Array} An array of Key assets, if player has any.
   */
  p.getIOVkeys = function Character_getIOVkeys(verb, direct_object) {
    //console.warn('getIOVkeys',verb, direct_object, this.game.dictionary.verbs[verb] );
    // we might've received a string
    if ("string" === typeof direct_object)
      direct_object = this.game.getAsset(direct_object);
    if (
      !verb ||
      !this.game.dictionary.verbs[verb] ||
      !direct_object ||
      !direct_object.isDOV(verb)
    )
      return [];

    this.game.log(
      "log",
      "high",
      "getIOVkeys.js >  " + verb + " " + direct_object.name,
      "Game"
    );

    var indirect_objects = [];
    // classes_that_can_verb_this
    var direct_object_classes = direct_object.dov[verb].with_classes;
    var direct_object_assets = direct_object.dov[verb].with_assets;

    // get class instances in player
    // findClassInThis calls getAllNestedContents
    if (direct_object_classes) {
      for (var i = 0; i < direct_object_classes.length; i++) {
        var classed_ids = this.findClassInThis(direct_object_classes[i]);
        for (var id = 0; id < classed_ids.length; id++) {
          // findClassInThis returns ids so we gotta get assets
          var classet = this.game.getAsset(classed_ids[id]);
          if (classet) indirect_objects.push(classet);
        }
      }
    }

    // find direct_object_assets in character
    if (direct_object_assets) {
      for (var i = 0; i < direct_object_assets.length; i++) {
        var indirect_object = this.game.getAsset(direct_object_assets[i]);
        if (indirect_object.isIn(this)) indirect_objects.push(indirect_object);
      }
    }

    // classes_this_can_verb
    var inventory = this.getAllNestedContents();
    for (var i = 0; i < inventory.length; i++) {
      var inventory_item = this.game.getAsset(inventory[i]);
      if (
        inventory_item.iov[verb]?.with_classes &&
        -1 !== inventory_item.iov[verb]?.with_classes.indexOf(direct_object.id)
      ) {
        var dupe = false;
        for (var asset in indirect_objects) {
          if (indirect_objects[asset].id === inventory_item.id) dupe = true;
        }
        if (!dupe) indirect_objects.push(indirect_object);
      }
    }

    // subtract unknown / unreachable items
    for (var i = indirect_objects.length - 1; i > -1; i--) {
      // it's possible for player to not know about items in inventory
      var asset = indirect_objects[i];
      if (!asset.is.known) indirect_objects.splice(i);
      if (!asset.areAnscestorsKnown()) indirect_objects.splice(i);
    }

    return indirect_objects;
  };
})();

// getNest.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Returns the ID of character asset's nest parent 
   * or a blank string.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#getNest
   * @return {String}
   */
   p.getNest = function Character_getNest()
   {
    // if( "undefined" === typeof this.nest 
    // || Object.keys( this.nest ).length === 0 ) 
    // {
    //   return "";
    // }
    // return this.nest[ Object.keys( this.nest )[0] ];
    return this.nest;
  }
}());
// getNestAnscestorId.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#getNestAnscestorId
   * @returns {String}
   */
  p.getNestAnscestorId = function Character_getNestAnscestorId() 
  {
    if( !this.isNested() ) { return ""; }
    var child, parent_asset;
    if(this.getNestAsset) child = this.getNestAsset();
    if(child.getParentAsset) parent_asset = child.getParentAsset();

    // child parent is room
    if( parent_asset && parent_asset instanceof adventurejs.Room ) 
    {
      return child.id;
    }
  
    while ( parent_asset ) 
    {
      child = parent_asset;
      parent_asset = parent_asset.getPlaceAsset(); 
      if( parent_asset && parent_asset instanceof adventurejs.Room ) 
      {
        return child.id;
      }
    }                  
    return "";
  }
}());
// getNestAspect.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Returns the aspect of this asset's parent
   * asset, or a blank string.
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#getNestAspect
   * @return {Array}
   */
  p.getNestAspect = function Character_getNestAspect() {
    if (
      "undefined" === typeof this.nest ||
      Object.keys(this.nest).length === 0
    ) {
      return "";
    }
    let preposition = Object.keys(this.nest)[0];
    let asset = this.game.getAsset(this.nest[preposition]);
    return asset.aspects[preposition];
  };
})();

// getNestAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Get the object of this character asset's nest parent asset.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#getNestAsset
   * @returns {Object|Boolean}
   */
  p.getNestAsset = p.$nest = function Character_getNestAsset() 
  {
    return this.game.getAsset( this.getNestId() );
  }
}());
// getNestId.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#getNestId
   * @returns {String}
   */
  p.getNestId = function Character_getNestId() 
  {
    if( "undefined" === typeof this.nest 
    || Object.keys( this.nest ).length === 0 ) 
    {
      return "";
    }
    return this.nest[ Object.keys( this.nest )[0] ];
    //return this.getNest();
  }
}());
// getNestOrPlaceAspect.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Get aspect of character's parent. If character is nested,
   * returns nest asset preposition, otherwise returns room asset preposition.
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#getNestOrPlaceAspect
   * @return {Boolean}
   */
  p.getNestOrPlaceAspect = function Character_getNestOrPlaceAspect() {
    if (this.isNested()) {
      return this.getNestAspect();
    } else {
      return this.getPlaceAspect();
    }
  };
})();

// getNestOrPlaceAsset.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Get character's parent asset. If character is nested, 
   * returns nest asset, otherwise returns room asset.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#getNestOrPlaceAsset
   * @return {Boolean}
   */
   p.getNestOrPlaceAsset = function Character_getNestOrPlace( )
   {
     if(this.isNested()) { return this.getNestAsset(); }
     else { return this.getPlaceAsset(); }
   }
  }());
// getNestPreposition.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Returns the preposition of this asset's parent
   * aspect, or a blank string.
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#getNestPreposition
   * @return {Array}
   */
  p.getNestPreposition = function Character_getNestPreposition() {
    if (
      "undefined" === typeof this.nest ||
      Object.keys(this.nest).length === 0
    ) {
      return "";
    }
    return Object.keys(this.nest)[0];
  };
})();

// getPostureGerund.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Get the gerund version of the player's posture.
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#getPostureGerund
   * @returns {Object|Boolean}
   */
  p.getPostureGerund = function Character_getPostureGerund() {
    return this.game.dictionary.getStringLookup(
      "posture_gerunds",
      this.posture
    );
  };
})();

// getPostureVerb.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Get the gerund version of the player's posture.
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#getPostureVerb
   * @returns {Object|Boolean}
   */
  p.getPostureVerb = function Character_getPostureVerb() {
    return this.game.dictionary.getStringLookup("movement_verbs", this.posture);
  };
})();

// getPrettyUnnestPreposition.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Get preposition to be used when character is leaving the Aspect 
   * in which it is nested.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#getPrettyUnnestPreposition
   * @returns {Object|Boolean}
   */
  p.getPrettyUnnestPreposition = function Character_getPrettyUnnestPreposition() 
  {
    var prep = this.game.dictionary.pretty_exit_prepositions[ this.getNestPreposition() ];
    if (prep) return prep;
    return false;
  }
}());
// getUnnestPreposition.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Get preposition to be used when character is leaving the Aspect 
   * in which it is nested.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#getUnnestPreposition
   * @returns {Object|Boolean}
   */
  p.getUnnestPreposition = function Character_getUnnestPreposition() 
  {
    var prep = this.game.dictionary.exit_prepositions[ this.getNestPreposition() ];
    if (prep) return prep;
    return false;
  }
}());
// getWornAssets.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Get all worn contents.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#getWornAssets
   * @return {Array}
   */
   p.getWornAssets = function Character_getWornAssets() 
   {
    var contents = this.getAllContents();
    var worn = [];
    for( var i = 0; i < contents.length; i++ )
    {
      var asset = this.game.getAsset(contents[i]);
      if( asset.is.worn ) 
      {
        worn.push( contents[i] );
      }
    }
    return worn;
   }
 }());
// getWornOptics.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Get all worn optical devices (aka glasses).
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#getWornOptics
   * @return {Array}
   */
  p.getWornOptics = function Character_getWornOptics() {
    var worn = this.getWornAssets();
    var optics = [];
    for (var i = 0; i < worn.length; i++) {
      var asset = this.game.getAsset(worn[i]);
      if (asset.is.lookthroughable) {
        optics.push(worn[i]);
      }
    }
    return optics;
  };
})();

// isNested.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Determine whether character asset has a nest. Can be used 
   * to test against specific aspects and parent assets.
   * For example, player.isNested( 'in', 'bed' )
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#isNested
   * @return {Boolean}
   */
  p.isNested = p.$nested = function Character_isNested( prep, prop )
  {
    if( "undefined" === typeof this.nest ) return false;

    var prepkey = Object.keys( this.nest )[0];
    var propvalue = this.nest[prepkey];

    if( prep && "undefined" === typeof prepkey ) return false;
    if( prep && prep !== prepkey ) return false;

    if( prop && "undefined" === typeof propvalue ) return false;
    if( prop && prop !== propvalue ) return false;

    // received isNested()
    if( "undefined" === typeof prep 
    && "undefined" === typeof prop )
    {
      if( propvalue ) return true;
      else return false;
    }

    return true;
  }
}());
// isNestedOnBottom.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Determine if player is nested at the bottom of parent asset.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#isNestedOnBottom
   * @return {Boolean}
   */
   p.isNestedOnBottom = function Character_isNestedOnBottom() 
   {
    var bool = false;
    if( false === this.isNested('on') ){ return false; }
    var thing = this.getNestAsset();
    if( false === thing ) return false;
    var bottom = thing.getYBottom();
    if( bottom >= this.position.y ) 
    {
      bool = true;
    }
    return bool;
  }
 }());
// isNestedOnTop.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Determine if player is nested at the bottom of parent asset.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#isNestedOnTop
   * @return {Boolean}
   */
  p.isNestedOnTop = function Character_isNestedOnTop() 
  {
    var bool = false;
    if( false === this.isNested('on') ){ return false; }
    var thing = this.getNestAsset();
    if( false === thing ) return false;
    var top = thing.getYTop();
    if( this.position.y >= top ) 
    {
      bool = true;
    }
    return bool;
  }
 }());
// isOnFloor.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Determine whether player is on floor.
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#isOnFloor
   * @returns {Boolean}
   */
  p.isOnFloor = function Character_isOnFloor() {
    if (
      (!this.isNested() || this.getNestAsset() instanceof adventurejs.Floor) &&
      ["sit", "kneel", "lie"].indexOf(this.posture) > -1
    ) {
      return true;
    }
    return false;
  };
})();

// onNestThisToThat.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Called when player asset is nested to another asset.
   * Provides opportunities to override default behavior
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb reactions</a>
   * doNestThisToThat and doNestThatToThis.
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#onNestThisToThat
   * @param {Object} asset
   * @param {String} aspect
   * @returns {Boolean}
   */
  p.onNestThisToThat = function Character_onNestThisToThat(asset, aspect) {
    this.game.log(
      "log",
      "high",
      "Nest " + this.name + " to " + asset.name + ".",
      "Behavior"
    );
    if (!asset) return;
    if (!aspect) return;

    var results;

    //if( asset instanceof adventurejs.Floor ) return;

    // Verify with player that nothing prevents
    // it from nesting in target asset.

    results = this.callAction("doNestThisToThat", asset.name, {});
    if ("undefined" !== typeof results) return results;

    // don't nest to floors
    if (asset instanceof adventurejs.Floor) return;

    // Verify with target asset that nothing
    // prevents it from hosting player.

    results = asset.callAction("onNestThatToThis", this.name, this);
    if ("undefined" !== typeof results) return results;

    this.nest = { [aspect]: asset.id };
    if (this.isWithinYRange(asset)) {
      // nothing
    } else if (this.getY() > asset.getYTop()) {
      this.setY(asset.getYTop());
    } else if (this.getY() < asset.getYBottom()) {
      this.setY(asset.getYBottom());
    }

    //this.game.updateDisplayRoom();
    return;
  };
})();

// onUnnestThisFromThat.js
(function() {
	/*global adventurejs A*/ 
  "use strict";
  var p = adventurejs.Character.prototype;	
  /**
   * Called when player is unnested from another asset.
   * Provides an opportunity to override default behavior 
   * through the use of
   * <a href="/doc/Scripting_VerbReactions.html">verb reactions</a> 
   * doUnnestThisFromThat and doUnnestThatFromThis.
   * @memberOf adventurejs.Character
	 * @method adventurejs.Character#onUnnestThisFromThat
   * @param {Object} asset
   * @returns {Boolean}
   */
  p.onUnnestThisFromThat = function Character_unnestThisFromThat( asset ) 
  {
    this.game.log( "log", "high", this.name + " onUnnestThisFromThat " + asset.name + "." , 'Behavior' );
    if(!asset) return;
    var results;

    results = this.callAction('doUnnestThisFromThat', asset.name, {} );
    if( "undefined" !== typeof results ) return results;            
      
    results = asset.callAction('doUnnestThatFromThis', this.name, {} );
    if( "undefined" !== typeof results ) return results;            
 
    this.unsetNest();
    //this.game.updateDisplayRoom();
    return;
  } 
}());
// unsetNest.js
(function () {
  /*global adventurejs A*/
  "use strict";
  var p = adventurejs.Character.prototype;
  /**
   * Clear character's nest location.
   * @memberOf adventurejs.Character
   * @method adventurejs.Character#unsetNest
   * @return {Boolean}
   */
  p.unsetNest = function Character_unsetNest() {
    this._nest = {};
  };
})();

// NPC.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Character.NPC
   * @augments adventurejs.Character
   * @class adventurejs.NPC
   * @ajsnavheading CharacterClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary For non-player characters.
   * @todo AI, movement, conversation.
   * @tutorial Characters_NPCs
   * @todo more methods, better example
   * @classdesc
   * <p>
   * <strong>NPC</strong> is a subclass of
   * {@link adventurejs.Character|Character} and the base class
   * for all non-player characters.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   "class": "NPC",
   *   "name": "Floyd",
   *   "synonyms": ["robot"],
   *   "place":{ in: "Utility Closet" },
   * })
   * </code></pre>
   **/
  class NPC extends adventurejs.Character {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "NPC";
    }
  }
  adventurejs.NPC = NPC;
})();

// Player.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Character.Player
   * @augments adventurejs.Character
   * @class adventurejs.Player
   * @ajsnavheading CharacterClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary The player character.
   * @todo Character swapping.
   * @classdesc
   * <p>
   * <strong>Player</strong> is a subclass of
   * {@link adventurejs.Character|Character}, used for
   * the player character(s). It will be possible to have
   * multiple player characters, though that hasn't been
   * implemented yet.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class Player extends adventurejs.Character {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Player";

      this.is.active = false;
      this.is._known = true;
      this.is._seen = true;

      this.setIOVs([{ hold: { with_params: { max_connections: 2 } } }]);
    }

    validate(game) {
      super.validate(game);

      // do we already have an active player?
      if (
        "" !== this.game.world._player &&
        "undefined" !== typeof this.game.world[this.game.world._player] &&
        Object.keys(this.game.world[this.game.world._player]).length > 0
      ) {
        var msg =
          "Player.js > " +
          this.game.world[this.game.world._player].name +
          " and " +
          this.name +
          " are both set is.active. " +
          "\nOnly one Player can be active. " +
          "Using " +
          this.game.world[this.game.world._player].name +
          ". ";
        this.game.log("warn", "critical", msg, "Character");

        this.is.active = false;
      } else {
        this.game.world._player = this.id;
        this.synonyms.push("me", "myself");
      }

      return true;
    }
  }
  adventurejs.Player = Player;
})();

// Room.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Room
   * @augments adventurejs.Tangible
   * @class adventurejs.Room
   * @ajsconstruct MyGame.createAsset({ "class":"Room", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading RoomAssets
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Where all the action happens.
   * @tutorial CreateRoom
   * @ajstangiblecontainer in
   * @ajstangiblecontainer attached
   * @classdesc
   * <p>
   * <strong>Room</strong> is a subclass of
   * {@link adventurejs.Tangible|Tangible} and the class for
   * all {@link adventurejs.Game|Game} locations. Player is always
   * in a Room. Rooms connect to other Rooms via
   * {@link adventurejs.Exit|Exits}, and can be decorated with
   * {@link adventurejs.Scenery|Scenery} and random events.
   * To learn more, see
   * <a href="/doc/GetStarted_CreateARoom.html">Create a Room</a>.
   * </p>
   *
   * <h3 class="examples">Exits:</h3>
   * <p>
   * There are two methods to define Exits, which can be mixed & matched.
   * The first method is a simple shortcut that defines an Exit
   * as part of a Room definition, using a direction and a
   * Room name, as in the following example. Exits are one-way, and
   * the other Rooms will need Exits back to this Room.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "West of House",
   *   exits: {
   *     south: "South of House",
   *     north: "North of House",
   *     west: "Forest",
   *     east: "The door is boarded and you can't remove the boards. "
   *   }
   * })
   * </code></pre>
   * <p>
   * In the example above, the south, north and west Exits all lead to
   * other Rooms. There is no east Exit, but by providing a string
   * instead of a Room name, that string will be returned to players
   * who try to go east.
   * </p>
   * <p>
   * This next example uses the second method of defining an Exit,
   * which is to create the Room and its Exits as distinct objects.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Inside the Barrow",
   * });
   * MyGame.createAsset({
   *   class: "Exit",
   *   direction: "south",
   *   place: { in: "Inside the Barrow" },
   *   destination: "Narrow Tunnel",
   * });
   * </code></pre>
   * <p>
   * This second method supports greater complexity and allows
   * for more granular control once you get into custom coded Exits.
   * To learn more, see
   * <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   *
   * <h3 class="examples">Scenery:</h3>
   * <p>
   * By default,
   * {@link adventurejs.Game|Game} instances include a number of
   * {@link adventurejs.Scenery|Scenery}
   * {@link adventurejs.Asset|Assets} which are available to use
   * in any Room. Scenery Assets can be sensed but not interacted
   * with, like sun and sky, rain and room tone, odors, walls,
   * and non-existent exits (to provide responses when players try
   * to use exits that don't exist).
   * Default Scenery objects can be enabled, customized, and disabled
   * at will by Room, by {@link adventurejs.Zone|Zone}, and globally.
   * It's also possible to create new custom Scenery Assets.
   * In the example below, we enable and set custom descriptions
   * for the global <code>sky</code>, <code>clouds</code>,
   * <code>sun</code>, and <code>rain</code>;
   * and create a new custom Scenery <code>crows</code>.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Creepy Playground",
   *   descriptions: {
   *     at: "This creepy looking playground is dominated by a rusted jungle gym. ",
   *   },
   *   room_scenery: {
   *     global_sky: {
   *       enabled: true,
   *       description: "The clouded sky is dark and foreboding. ",
   *     },
   *     global_clouds: {
   *       enabled: true,
   *       description: "Heavy, black, and pendulous. ",
   *     },
   *     global_thunder: {
   *       enabled: true,
   *       description: "Occasional thunder plays in the distance. ",
   *     },
   *     global_lightning: {
   *       enabled: true,
   *       description: "None yet, but it wouldn't surprise you. ",
   *     },
   *     global_sun: {
   *       enabled: true,
   *       description: "You can barely see it through the dark clouds. ",
   *     },
   *     global_rain: {
   *       enabled: true,
   *       description: "The rain patters onto the playground's worn rubber mats. ",
   *     },
   *     crows: {
   *       create: true,
   *       enabled: true,
   *       description: "Evil looking crows circle the playground. ",
   *     },
   *   },
   * });
   * </code></pre>
   * <p>
   * To learn more about using the default Scenery Assets, see
   * <a href="/doc/NextSteps_GlobalScenery.html">Global Scenery</a>.
   * </p>
   *
   * <h3 class="examples">Events:</h3>
   * <p>
   * Events are arbitrary messages that can be attached to a Room
   * and set so that they are appended to any other output for the
   * turn. Use the <code>frequency</code> property of
   * <code>room_events</code> to set the frequency of events.
   * A frequency of 1 will play an event on every turn; .1 will play
   * an event every 10th turn; etc. The <code>randomize</code>
   * property determines whether events are selected to play randomly.
   * If <code>randomize</code> is set to true, events will play in
   * random order, otherwise events will play in the order they are
   * set in the array, looping as needed.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Creepy Playground",
   *   descriptions: {
   *     at: "This creepy looking playground is dominated by a rusted jungle gym. ",
   *   },
   *   room_events: [
   *     {
   *       frequency: .1,
   *       randomize: true,
   *     },
   *     "A crow shrieks loudly, startling you. ",
   *     "Rain pings metallically off the jungle gym. ",
   *     "The rain raises a tarry odor from the playground's rubber mats. ",
   *     "Distant thunder rolls through the clouds. ",
   *     "The barest hint of lightning flicks in the distance. ",
   *   ],
   * });
   * </code></pre>
   * <p>
   * To learn more about using events, see
   * <a href="/doc/NextSteps_SceneEvents.html">Scene Events</a>.
   * </p>
   **/
  class Room extends adventurejs.Tangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Room";

      this.synonyms = ["room"];
      this.singlePluralPairs = [["room", "rooms"]];

      this.indefinite_article = "a";
      this.definite_article = "the";
      this.use_definite_article_in_lists = true;
      this.default_aspect = "in";
      this.exits = {};
      //this.split_name_for_world_lookup = false;

      this.room_scenery = {
        global_air: { enabled: null },
        global_moon: { enabled: null },
        global_sky: { enabled: null },
        global_sun: { enabled: null },
        global_stars: { enabled: null },
        global_sound: { enabled: null },
        global_rain: { enabled: null },
        global_wind: { enabled: null },
        global_clouds: { enabled: null },
        global_lightning: { enabled: null },
        global_floor: { enabled: null },
        global_ceiling: { enabled: null },

        global_north_wall: { enabled: null },
        global_east_wall: { enabled: null },
        global_west_wall: { enabled: null },
        global_south_wall: { enabled: null },
        global_aft_wall: { enabled: null },
        global_fore_wall: { enabled: null },
        global_northeast_wall: { enabled: null },
        global_northwest_wall: { enabled: null },
        global_port_wall: { enabled: null },
        global_southeast_wall: { enabled: null },
        global_southwest_wall: { enabled: null },
        global_starboard_wall: { enabled: null },

        global_north: { enabled: true },
        global_east: { enabled: true },
        global_west: { enabled: true },
        global_south: { enabled: true },
        global_aft: { enabled: true },
        global_fore: { enabled: true },
        global_northeast: { enabled: true },
        global_northwest: { enabled: true },
        global_port: { enabled: true },
        global_southeast: { enabled: true },
        global_southwest: { enabled: true },
        global_starboard: { enabled: true },
        global_up: { enabled: true },
        global_down: { enabled: true },
      };

      this.zone = "";

      this.dimensions.height = 1;
      this.player_has_visited = false;

      // unset these verbs inherited from Matter / Tangible
      this.unsetDOVs(["push", "take", "give", "drop", "move", "pull", "throw"]);
      this.unsetIOV("throw");
      this.setIOVs(["take", "drop", "put"]);

      /**
       * If set true, when player tries to go in a direction that hasn't
       * got an {@link adventurejs.Exit|Exit},
       * we'll print the current room's Exits as a reminder
       * of what Exits are available.
       * <br><br>
       * Setting this to true or false per room will override global
       * {@link adventurejs.Settings|Settings} for that room.
       * @var {Boolean} adventurejs.Room#when_travel_fails_list_exits
       * @default true
       */
      this.when_travel_fails_list_exits = null;

      /**
       * If set true,
       * {@link adventurejs.Exit|Exit} descriptions can include
       * the name of the {@link adventurejs.Room|Room} that the
       * Exit leads to. (The logic for this may also consider other
       * conditions such as whether the player knows about the
       * other Room.)
       * <br><br>
       * Setting this to true or false per room will override global
       * {@link adventurejs.Settings|Settings} for that room.
       * @var {Boolean} adventurejs.Room#show_room_names_in_exit_descriptions
       * @default null
       */
      this.show_room_names_in_exit_descriptions = null;

      /**
       * If set true,
       * {@link adventurejs.Exit|Exit} descriptions can include
       * the name of the {@link adventurejs.Room|Room} that the
       * Exit leads to once player knows about the destination Room.
       * Generally player must visit a room to know about it, but
       * there can be exceptions.
       * <br><br>
       * Setting this to true or false per room will override global
       * {@link adventurejs.Settings|Settings} for that room.
       * @var {Boolean} adventurejs.Settings#show_room_names_in_exit_descriptions_only_when_room_is_known
       * @default null
       */
      this.show_room_names_in_exit_descriptions_only_when_room_is_known = null;

      /**
       * If set true,
       * {@link adventurejs.Exit|Exit} descriptions can include
       * the name of the {@link adventurejs.Room|Room} that the
       * Exit leads to once player has used the Exit.
       * <br><br>
       * Setting this to true or false per room will override global
       * {@link adventurejs.Settings|Settings} for that room.
       * @var {Boolean} adventurejs.Settings#show_room_names_in_exit_descriptions_only_after_exit_has_been_used
       * @default null
       */
      this.show_room_names_in_exit_descriptions_only_after_exit_has_been_used =
        null;

      this.dimensions.size = 1;

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
        player: {
          preposition: "in",
          posture: "stand",
          initial_position: { x: 0, y: 0, z: 0 },
          can: {
            bounce: true,
            crawl: true,
            enter: true,
            exit: true,
            hear: true,
            hop: true,
            jump: true,
            kneel: true,
            lie: true,
            ride: true,
            see: true,
            sit: true,
            stand: true,
            swim: false,
            walk: true,
          },
        },
      });

      this.aspects.in.vessel = new adventurejs.Vessel("in", this.game_name).set(
        {
          maxvolume: Infinity,
          vessel_is_known: true,
          is_body_of_substance: true,
        },
      );

      this.aspects.attached = new adventurejs.Aspect(
        "attached",
        this.game_name,
      ).set({
        parent_id: this.id,
      });

      /**
       * A collection of properties that defines whether a player may
       * enter this aspect, what actions they are allowed to perform
       * in it, and the default posture they will take upon entering.
       * Aspects and Rooms both share these properties.
       * @var {boolean} adventurejs.Room#player
       * @default {}
       */
      this.player = new adventurejs.Aspect_Player(
        "player",
        this.game_name,
        this.id,
        "in",
      ).set({
        parent_id: this.parent_id,
        preposition: "in",
        can: {
          bounce: true,
          crawl: true,
          enter: true,
          exit: true,
          hear: true,
          hop: true,
          jump: true,
          kneel: true,
          lie: true,
          ride: true,
          see: true,
          sit: true,
          stand: true,
          swim: false,
        },
      });

      this.descriptions.listen = "$(We) hear the room tone.";

      this.is_vacuum = false;
      this.location_unneccessary = true;

      this.is.closed = null;
    }

    // returns array of strings
    getAllContents() {
      var contents = this.aspects.in.contents;
      return contents;
    }

    onMoveThatToThis(object) {
      this.game.log(
        "log",
        "low",
        "move " + object.name + " to " + this.name + ".",
        "Room",
        "Room",
      );
      var results = true;

      results = super.onMoveThatToThis(object);
      if ("undefined" !== typeof results) return results;

      if (object.id === this.game.world._player) {
        this.showRoomToPlayer(object);
      }
      return;
    }

    showRoomToPlayer(object) {
      this.player_has_visited = true;
      this.setKnown();
      this.setSeen();

      // player recognizes exits
      var keys = Object.keys(this.exits);
      for (var i = 0; i < keys.length; i++) {
        var exitID = this.exits[keys[i]];
        var exit = this.game.world[exitID];
        if (
          exit.is.hidden ||
          this.game.world[this.game.world._player].is.blind
        ) {
          /* || TODO dark / no visibility */
        } else {
          exit.setKnown();
          exit.setSeen();
        }
      }
    }

    /**
     * Room inherits validate from {@link adventurejs.Tangible|Tangible}
     * and adds some additional chunks to handle
     * {@link adventurejs.Scenery|Scenery} and
     * {@link adventurejs.Exit|Exits}. If the Room's definition includes
     * Scenery or Exits that haven't been defined distinctly, they will be
     * added to a list of deferredObjects to be constructed after the
     * {@link adventurejs.Game|Game's} main validation/initialization pass.
     * @method adventurejs.Room#validate
     * @memberof adventurejs.Room
     */
    validate(game) {
      super.validate(game);

      this.zone = A.serialize(this.zone);

      var sceneryCount = Object.keys(this.room_scenery).length;
      if (sceneryCount > 0) {
        var sceneries = Object.keys(this.room_scenery);
        for (var i = 0; i < sceneries.length; i++) {
          if (!this.game.getAsset(sceneries[i])) {
            var newScenery = {};
            var already_deferred = false;

            newScenery = Object.assign(
              newScenery,
              this.room_scenery[sceneries[i]],
            );
            newScenery.name = sceneries[i];
            newScenery.class = "Scenery";
            if (newScenery.is && newScenery.is.global) {
              // if it's global, it must be known in order
              // for player to refer to it from anywhere
              newScenery.is.known = true;
            } else {
              // otherwise put it in this room
              newScenery.place = { in: this.id };
            }

            // if it's global, it can be listed in multiple rooms,
            // but we only want to construct it once,
            // and we only want to construct the one that has create:true
            for (var d = 0; d < this.game.deferredObjects.length; d++) {
              if (sceneries[i] === this.game.deferredObjects[d].name) {
                if (true === this.game.deferredObjects[d].create) {
                  // created by that other instance
                  already_deferred = true;
                } else if (true === newScenery.create) {
                  // created by this instance
                  this.game.deferredObjects[d] = newScenery;
                }
              }
            }
            if (false === already_deferred) {
              this.game.deferredObjects.push(newScenery);
            }
          }
        }
      }

      var exitCount = Object.keys(this.exits).length;
      if (exitCount === 0) {
        var msg = "Room.js > " + this.name + " has no exits. ";
        //this.game.log( "warn", "critical", msg , 'Room' , 'Room' );
      }

      if (exitCount > 0) {
        var directions = Object.keys(this.exits);
        for (var i = 0; i < directions.length; i++) {
          var direction = directions[i];
          var exit = this.exits[direction];
          if (typeof exit === "string") {
            // at minimum we need location & direction, secondarily destinationName
            // does the string match a Room ID?
            // if not treat it as a description
            var newDirection = { descriptions: {} };
            var destinationName = exit;
            var destinationID = A.serialize(destinationName);
            newDirection.place = { in: this.name };
            newDirection.direction = direction;
            newDirection.class = "Exit";

            if (
              "undefined" !== typeof this.game.world[destinationID] &&
              this.game.world[destinationID] instanceof adventurejs.Room
            ) {
              // exit string matches a Room
              newDirection.destination = destinationName;
            } else {
              // doesn't match a room so treat it as a description
              newDirection.descriptions.look = destinationName;
            }

            // push it to deferredObjects for construction/validation
            // after the initial validation pass
            this.game.deferredObjects.push(newDirection);

            // erase the intitial string
            delete this.exits[direction];
          } else if (typeof this.exits[direction] === "object") {
            var newDirection = {};
            newDirection = Object.assign(newDirection, this.exits[direction]);
            newDirection.class = "Exit";
            newDirection.direction = direction;
            newDirection.place = { in: this.id };
            this.game.deferredObjects.push(newDirection);
          }
        } // for( var i = 0; i < directions.length
      } // if( exitCount

      return true;
    }

    /**
     * Rooms never have a place/parent, but they get queried as a Tangible class.
     * Returns false to cover bases.
     * @memberOf adventurejs.Room
     * @method adventurejs.Room#getPlaceAssetId
     * @returns {Boolean}
     */
    getPlaceAssetId() {
      return false;
    }
    /**
     * Rooms never have a place/parent, but they get queried as a Tangible class.
     * Returns false to cover bases.
     * @memberOf adventurejs.Room
     * @method adventurejs.Room#getPlaceAsset
     * @returns {Boolean}
     */
    getPlaceAsset() {
      return false;
    }

    /**
     * Rooms never have a place/parent, but they get queried as a Tangible class.
     * Returns false to cover bases.
     * @memberOf adventurejs.Room
     * @method adventurejs.Room#getPlaceAspect
     * @returns {Boolean}
     */
    getPlaceAspect() {
      return false;
    }

    initialize(game) {
      super.initialize(game);

      // add to list of rooms, which we use for "go to room"
      this.game.room_lookup.push(this.id);

      return true;
    }

    /**
     * Get this.exits.
     * @memberOf adventurejs.Room
     * @method adventurejs.Room#$exits
     * @returns {Boolean}
     */
    $exits() {
      return this.exits;
    }

    /**
     * Get a list of directions leaving this room.
     * @memberOf adventurejs.Room
     * @method adventurejs.Room#$directions
     * @returns {Boolean}
     */
    $directions() {
      return Object.keys(this.exits);
    }
  }

  adventurejs.Room = Room;
})();

// Scenery.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Scenery
   * @augments adventurejs.Tangible
   * @class adventurejs.Scenery
   * @ajsconstruct MyGame.createAsset({ "class":"Scenery", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Stop and smell the roses.
   * @tutorial NextSteps_GlobalScenery
   * @classdesc
   * <p>
   * <strong>Scenery</strong> is a subclass of
   * {@link adventurejs.Tangible|Tangible}
   * that is used to create simple, minimally
   * interactive objects that the player can
   * only sense but not manipulate.
   * Imagine an outdoor {@link adventurejs.Room|Room}
   * with sun and sky and distant mountains.
   * Use Scenery {@link adventurejs.Asset|Assets}
   * to provide responses to player input like
   * <code class="property">examine sky</code>
   * without coding complex objects.
   * </p>
   * <p>Before creating new Scenery, take note that
   * {@link adventurejs.Game|Game} predefines a group
   * of global Scenery Assets that includes sun, sky,
   * moon, stars and a few others; walls for each
   * direction; and fake
   * {@link adventurejs.Exit|Exits} to provide messages
   * when players try to travel in directions that
   * have no actual Exits. To learn more about
   * predefined Scenery, see the
   * {@link adventurejs.Zone|Zone} page or
   * <a href="/doc/NextSteps_GlobalScenery.html">Global Scenery</a>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * There are two ways to construct new Scenery Assets.
   * First, there is the standard
   * {@link adventurejs.Asset#createAsset|createAsset} method.
   * Scenery can be made either local or global. To make
   * Scenery local, set its
   * <code class="property">location</code> property or
   * <code class="property">thing_this_is_in</code>
   * property (they're equivalent) to the Room it should
   * appear in. To make it global, set its
   * <code class="property">is.global</code>
   * property to true. Global Scenery can be seen in any
   * Room for which it is enabled.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Scenery",
   *   name: "fireflies",
   *   descriptions: { look: "Fireflies! They blink cheerfully against the dusky evening. ", },
   *   is: { global: true }, // for global availability use this
   *   is: { known: true }, // necessary if setting global
   *   //place: { in: "Dusky Woods" }, // for single location use this
   * });
   * </code></pre>
   * <p>
   * The shortcut method is to add Scenery to a Room's
   * <code class="property">room_scenery</code> property.
   * If the Scenery is to be global, it can be added to
   * multiple Rooms this way. The Scenery only needs to
   * be defined one time, using
   * <code class="property">create:true</code>.
   * Other Rooms can simply have the Scenery's
   * <code class="property">enabled</code>
   * property set to true. Other rooms can also be set
   * to show a different description for the Scenery.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Deep Forest",
   *   room_scenery: {
   *     fireflies: {
   * <span class="new">      create: true, // only set this once</span>
   *       is: { global: true }, // available in any Room
   *       enabled: true, // per room
   *       descriptions: { look: "Fireflies!", }, // global unless specified elsewhere
   *     },
   *   },
   * }
   *
   * MyGame.createAsset({
   *   class: "Room",
   *   name: "Deeper Forest",
   *   room_scenery: {
   *     fireflies: {
   *       enabled: true, // uses same description as above
   *     },
   *   },
   * }
   *
   * MyGame.createAsset({
   *   class: "Room",
   *   name: "Deepest Forest",
   *   room_scenery: {
   *     fireflies: {
   *       enabled: true,
   *       descriptions: { look: "Thick as a field of stars.", }, // uses unique description
   *     },
   *   },
   * }
   * </code></pre>
   * <p>
   * To learn more about working with Scenery, see the
   * {@link adventurejs.Zone|Zone} page or
   * <a href="/doc/NextSteps_GlobalScenery.html">Global Scenery</a>.
   * </p>
   **/
  class Scenery extends adventurejs.Tangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Scenery";

      this.is.listed_in_room = false;
      this.is.fixed = true;

      // unset VerbSubscriptions inherited from Matter
      this.unsetDOVs([
        "touch",
        "kick",
        "push",
        "shake",
        "move",
        "pull",
        "hit",
        "throw",
      ]);
    }
  }
  adventurejs.Scenery = Scenery;
})();

// Collection.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Scenery.Collection
   * @augments adventurejs.Scenery
   * @class adventurejs.Collection
   * @ajsconstruct MyGame.createAsset({ "class":"Collection", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading SceneryClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary An Asset that provides a way to refer to a group of Assets together.
   * @tutorial Tangibles_Collections
   * @classdesc
   * <p>
   * <strong>Collection</strong> provides a way to perform some verbs
   * on a specific group of related objects. In the example below,
   * a {@link adventurejs.Desk|Desk} has three
   * {@link adventurejs.Drawer|Drawers}. Each drawer can be open or
   * closed. A player might input something like
   * <code class="property">examine drawers</code>.
   * Normally, that would lead to a
   * <a href="/doc/NextSteps_Disambiguation.html">disambiguation</a>
   * prompt such as <code class="property">Which did $(we) mean?
   * 1. The top drawer, 2. the middle drawer, or
   * 3. the bottom drawer?</code>
   * Here, we've made a collection for the three drawers lets players
   * refer to the three drawers as one object.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Desk",
   *   name: "desk",
   *   place: { in: "Office" },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "It's a heavy wooden desk. It has three drawers
   *       stacked vertically. The top drawer is $( top drawer is| open or| closed ),
   *       the middle drawer is $( middle drawer is| open or| closed ),
   *       and the bottom drawer is $( bottom drawer is| open or| closed )."
   *     },
   *   },
   *   adjectives: "wooden, heavy",
   * });
   * MyGame.createAsset({
   *   class: "Drawer",
   *   name: "top drawer",
   *   synonyms: "top desk drawer, top drawer lock, lock",
   *   descriptions: { look: "The top drawer is $( top drawer is| open or| closed ). ", },
   *   adjectives: "desk",
   *   place: { attached: "desk" },
   *   dov: {
   *     unlock: { with_assets: ['tiny brass key'], },
   *   },
   *   is: { locked: true, listed_in_parent: false },
   * });
   * MyGame.createAsset({
   *   class: "Drawer",
   *   name: "middle drawer",
   *   synonyms: "middle desk drawer",
   *   descriptions: { look: "The middle drawer is $( middle drawer is| open or| closed ). ", },
   *   adjectives: "desk",
   *   place: { attached: "desk" },
   *   is: { listed_in_parent: false },
   * });
   * MyGame.createAsset({
   *   class: "Drawer",
   *   name: "bottom drawer",
   *   synonyms: "bottom desk drawer",
   *   descriptions: { look: "The bottom drawer is $( bottom drawer is| open or| closed ). ", },
   *   adjectives: "desk",
   *   place: { attached: "desk" },
   *   is: { listed_in_parent: false },
   * });
   * MyGame.createAsset({
   *   class: "Collection",
   *   name: "desk drawers",
   *   place: { attached: "desk" },
   *   collection: "top drawer, middle drawer, bottom drawer",
   *   synonyms: [ "drawers", "three drawers" ],
   *   is: { listed_in_parent: false },
   *   descriptions: {
   *     look: function()
   *     {
   *       var openCount = [];
   *       var closedCount = [];
   *       var complicatedMsg = "The desk has three drawers stacked vertically. ";   *
   *       MyGame.$("top drawer").is.closed ?
   *         closedCount.push( "top drawer" ) : openCount.push( "top drawer" );
   *       MyGame.$("middle drawer").is.closed ?
   *         closedCount.push( "middle drawer" ) : openCount.push( "middle drawer" );
   *       MyGame.$("bottom drawer").is.closed ?
   *         closedCount.push( "bottom drawer" ) : openCount.push( "bottom drawer" );
   *
   *       if( 0 === openCount.length )
   *       {
   *         complicatedMsg += "All three are closed.";
   *       }
   *       else if( 0 === closedCount.length )
   *       {
   *         complicatedMsg += "All three are open.";
   *       }
   *       else if ( 2 == openCount.length )
   *       {
   *         complicatedMsg += "The "
   *         + openCount[ 0 ]
   *         + " and the "
   *         + openCount[ 1 ]
   *         + " are open. The "
   *         + closedCount[ 0 ]
   *         + " is closed. ";
   *       }
   *       else if ( 2 == closedCount.length )
   *       {
   *         complicatedMsg += "The "
   *         + closedCount[ 0 ]
   *         + " and the "
   *         + closedCount[ 1 ]
   *         + " are closed. The "
   *         + openCount[ 0 ]
   *         + " is open. ";
   *       }
   *       return complicatedMsg
   *     },
   *   },
   * });
   * </code></pre>
   * <p>In the "desk drawers" Collection,
   * take special note of these lines:</p>
   * <pre class="display"><code class="language-javascript">name: "desk drawers",
   *   synonyms: [ "drawers", "three drawers" ],
   *   collection: "top drawer, middle drawer, bottom drawer",
   *   place: { attached: "desk" },
   *   is: { listed_in_parent: false },
   * </code></pre>
   * <li>
   * <code class="property">collection</code> is set to a list of the items that
   * the Collection represents. This is important, because some
   * {@link adventurejs.Verb|Verb} actions will be forwarded to
   * the items in the list. In this example,
   * <code class="property">open drawers</code>
   * will try to open each drawer in turn as if the player had input
   * <code class="property">open top drawer then open middle drawer
   * then open bottom drawer</code>.
   * </li>
   * <li><code class="property">name</code> and
   * <code class="property">synonyms</code> have been set
   * to plural words that players are likely to use.</li>
   * <li>
   * <code class="property">thing_this_is_attached</code>
   * is set to <code class="property">desk</code>,
   * the same as the drawers, and
   * <code class="property">is.listed_in_parent</code>
   * is set to <code class="property">desk</code> so that
   * the Collection doesn't show up in the
   * {@link adventurejs.Room|Room} description.
   * </li>
   **/
  class Collection extends adventurejs.Scenery {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Collection";

      this.is.collection = true;
      this.is.listed_in_room = false;
    }
  }

  adventurejs.Collection = Collection;
})();

//GlobalAir.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_air
   * @augments {adventurejs.Scenery}
   * @class global_air
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_air", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "air",
    synonyms: ["air"],
    descriptions: { look: "The air smells clean and clear. " },
    dov: { smell: true },
    is_intangible: true,
    enabled: false,
  });
})();

//GlobalClouds.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_clouds
   * @augments {adventurejs.Scenery}
   * @class global_clouds
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_clouds", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "clouds",
    synonyms: ["clouds"],
    descriptions: { look: "Heavy clouds obscure the sky. " },
    is_intangible: true,
    enabled: false,
  });
})();

//GlobalLightning.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_lightning
   * @augments {adventurejs.Scenery}
   * @class global_lightning
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_lightning", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "lightning",
    synonyms: ["lightning"],
    descriptions: {
      look: "A thin tongue of lightning flickers in the distance. ",
    },
    is_intangible: true,
    enabled: false,
  });
})();

//GlobalMoon.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_moon
   * @augments {adventurejs.Scenery}
   * @class global_moon
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_moon", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "moon",
    synonyms: ["moon"],
    descriptions: { look: "Just a cool blue sliver. " },
    is: { distant: true },
    enabled: false,
  });
})();

//GlobalMountain.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_mountain
   * @augments {adventurejs.Scenery}
   * @class global_mountain
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_mountain", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "mountain",
    synonyms: ["mountain", "mountains"],
    descriptions: { look: "Mount Doom looms over the landscape. " },
    // is: { distant: true, },
    enabled: false,
  });
})();

//GlobalMountains.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_mountains
   * @augments {adventurejs.Scenery}
   * @class global_mountains
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_mountains", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "mountains",
    synonyms: ["mountains", "mountains"],
    descriptions: { look: "Ominous mountains loom in the distance. " },
    // is: { distant: true, },
    enabled: false,
  });
})();

//GlobalRain.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_rain
   * @augments {adventurejs.Scenery}
   * @class global_rain
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_rain", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "rain",
    synonyms: ["rain"],
    descriptions: { look: "Just a light misting. " },
    is_intangible: true,
    enabled: false,
  });
})();

// GlobalSky.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_sky
   * @augments {adventurejs.Scenery}
   * @class global_sky
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_sky", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "sky",
    synonyms: ["sky"],
    descriptions: { look: "The sky is blue! " },
    is: { distant: true },
    enabled: false,
  });
})();

//GlobalRoomtone.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_sound
   * @augments {adventurejs.Scenery}
   * @class global_sound
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_sound", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "sound",
    synonyms: ["room", "tone", "roomtone", "room tone"],
    // @TODO this form isn't handled by createGlobalScenery
    // which bypasses createAsset / constructAsset
    dov: { listen: true },
    descriptions: {
      look: "$(We) hear a slight tone over a steady low rumble. ",
      sound: "$(We) hear a slight tone over a steady low rumble. ",
    },
    enabled: false,
  });
})();

//GlobalStars.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_stars
   * @augments {adventurejs.Scenery}
   * @class global_stars
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_stars", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "stars",
    synonyms: ["star", "stars"],
    //singlePluralPairs: [["star","stars"]],
    descriptions: { look: "All the stars like grains of sand. " },
    is: { distant: true },
    enabled: false,
  });
})();

//GlobalSun.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_sun
   * @augments {adventurejs.Scenery}
   * @class global_sun
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_sun", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "sun",
    synonyms: ["sun"],
    descriptions: { look: "The sun is too bright to look at directly. " },
    is: { distant: true },
    enabled: false,
  });
})();

//GlobalThunder.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_thunder
   * @augments {adventurejs.Scenery}
   * @class global_thunder
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_thunder", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "thunder",
    synonyms: ["thunder"],
    descriptions: { look: "Thunder rumbles in the distance. " },
    is_intangible: true,
    enabled: false,
  });
})();

//GlobalTrees.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_trees
   * @augments {adventurejs.Scenery}
   * @class global_trees
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_trees", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "trees",
    synonyms: ["trees", "forest"],
    descriptions: { look: "$(We) can't see the forest for the trees. " },
    // is: { distant: true, },
    enabled: false,
  });
})();

//GlobalWind.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_wind
   * @augments {adventurejs.Scenery}
   * @class global_wind
   * @ajsconstruct MyGame.createGlobalScenery({ "name": "global_wind", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalScenery
   * @hideconstructor
   * @ajsinstanceof Scenery
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalScenery
   * @tutorial NextSteps_GlobalScenery
   * @summary A global scenery object.
   * @ajsglobal GlobalScenery
   */
  A.GlobalAssets.Scenery.push({
    name: "wind",
    synonyms: ["wind", "breeze"],
    descriptions: { look: "Just a slight breeze. " },
    is_intangible: true,
    enabled: false,
  });
})();

// Sky.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Scenery.Sky
   * @augments adventurejs.Scenery
   * @class adventurejs.Sky
   * @ajsconstruct MyGame.createAsset({ "class":"Sky", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading SceneryClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A scenery Asset.
   * @classdesc
   * <p>
   * <strong>Sky</strong> is a subclass of
   * {@link adventurejs.Scenery|Scenery}.
   * It's a simple object that only exists to be examined.
   * Sky is arguably redundant, as there
   * is a {@link global_sky}
   * {@link adventurejs.Asset|Asset} that can be configured by
   * {@link adventurejs.Room|Room} or by
   * {@link adventurejs.Zone|Zone} or globally. See
   * <a href="/doc/NextSteps_GlobalScenery.html">Global Scenery</a>.
   * to learn more about configuring global Scenery.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Sky",
   *   name: "oppressive sky",
   *   description: "The oppressive sky hangs low and heavy. ",
   *   is: { known: true },
   *   place: { in: "Barren Landscape" },
   * });
   * </code></pre>
   **/
  class Sky extends adventurejs.Scenery {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Sky";

      this.is.distant = true;

      this.synonyms = ["sky"];
    }
  }

  adventurejs.Sky = Sky;
})();

// Ceiling.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Ceiling
   * @augments adventurejs.Tangible
   * @class adventurejs.Ceiling
   * @ajsconstruct MyGame.createAsset({ "class":"Ceiling", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading RoomAssets
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Look up.
   * @classdesc
   * <p>
   * <strong>Ceiling</strong> has no special properties and only
   * exists to offer verisimilitude in case players try to look
   * up at the ceiling.
   * </p>
   **/
  class Ceiling extends adventurejs.Tangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Ceiling";

      this.is.listed_in_room = false;
    }

    validate(game) {
      super.validate(game);

      /**
       * Global ceiling is a special case which exists to catch
       * ceiling interactions where authors haven't
       * made a custom ceiling. They don't need further validation.
       */
      if (this.is.global) {
        return true;
      }

      /**
       * TODO
       * What other validation does a ceiling need?
       */
    }
  }
  adventurejs.Ceiling = Ceiling;
})();

// GlobalCeiling.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_ceiling
   * @augments {adventurejs.Ceiling}
   * @class global_ceiling
   * @ajsconstruct MyGame.createGlobalCeilings({ "name": "global_ceiling", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalCeilings
   * @hideconstructor
   * @ajsinstanceof ceiling
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalAssets
   * @summary Look up from anywhere.
   * @ajsglobal GlobalCeiling
   * @classdesc
   * <p>
   * <strong>GlobalCeiling</strong> is a
   * {@link adventurejs.Ceiling|Ceiling}
   * that can be seen from any
   * {@link adventurejs.Room|Room}. It exists as a convenience
   * to let authors offer a single generic ceiling description
   * as opposed to unique ceilings in each room.
   * </p>
   */
  A.GlobalAssets.Ceilings.push({
    name: "ceiling",
    descriptions: { look: "$(We) see nothing special about the ceiling. " },
  });
})();

// Exit_Is.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Is.Tangible_Is.Exit_Is
   * @augments adventurejs.Tangible_Is
   * @class adventurejs.Exit_Is
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <p>
   * <strong>Exit_Is.js</strong> handles is.state management for
   * {@link adventurejs.Exit|Exit Assets}.
   **/

  class Exit_Is extends adventurejs.Tangible_Is {
    constructor(name = "is", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);
      this.class = "Exit_Is";
      this._used = false;
      this.exit = true;
      return this;
    }

    set used(value) {
      this._used = value;
      this.setLinkedApertureState("used", value);
    }
    get used() {
      return this._used;
    }

    /**
     * The Exit class has no intrinsic open/closed states, and
     * instead looks for a linked {@link adventurejs.Aperture} asset.
     * <code>closed</code> is a paired property. Setting open = true
     * also sets close = false, and if this exit's aperture has a linked
     * asset, open and close are set for that asset as well.
     * @var {Boolean} adventurejs.Exit#is!closed
     * @default false
     */
    get closed() {
      return this.getLinkedApertureState("closed");
    }
    // set closed(value) {
    //   this.setLinkedApertureState("closed", value);
    // }

    /**
     * The Exit class has no intrinsic locked/unlocked states, and
     * instead looks for a linked {@link adventurejs.Aperture} asset.
     * <code>locked</code> is a paired property. Setting locked = true
     * also sets unlocked = false, and if this exit's aperture has a linked
     * asset, locked and unlocked are set for that asset as well.
     * @var {Boolean} adventurejs.Exit#is!locked
     * @default false
     */
    get locked() {
      return this.getLinkedApertureState("locked");
    }
    // set locked(value) {
    //   this.setLinkedApertureState("locked", value);
    // }

    /**
     * The Exit class has no intrinsic sealed/unsealed states, and
     * instead looks for a linked {@link adventurejs.Aperture} asset.
     * <code>sealed</code> is a paired property. Setting sealed = true
     * also sets unsealed = false, and if this exit's aperture has a linked
     * asset, sealed and unsealed are set for that asset as well.
     * @var {Boolean} adventurejs.Exit#is!sealed
     * @default false
     */
    get sealed() {
      return this.getLinkedApertureState("sealed");
    }
    // set sealed(value) {
    //   this.setLinkedApertureState("sealed", value);
    // }

    /**
     * The Exit class is a simple class used primarily to facilitate
     * travel between two locations. It's not treated as a physical thing
     * and doesn't have any of the intrinsic states that you would
     * associate with a door. If an exit needs a physical manifestation,
     * it can be paired with a linked {@link adventurejs.Aperture} asset.
     * It's the Aperture that contains all the state information. In order
     * to support queries like exit.is.closed we redirect the getter/setter
     * to the specified property on the linked Aperture.
     * @var {Boolean} adventurejs.Exit#is!setLinkedApertureState
     * @param {String} property
     * @param {*} value
     */
    setLinkedApertureState(property, value) {
      var parent = this.parent;
      if (parent && parent.aperture) {
        var aperture = this.game.getAsset(parent.aperture);
        if (aperture && aperture[this.name]) {
          aperture[this.name][property] = value;
        }
      }
    }

    /**
     * The Exit class is a simple class used primarily to facilitate
     * travel between two locaions. It's not treated as a physical thing
     * and doesn't have any of the intrinsic states that you would
     * associate with a door. If an exit needs a physical manifestation,
     * it can be paired with a linked {@link adventurejs.Aperture} asset.
     * It's the Aperture that contains all the state information. In order
     * to support queries like exit.is.closed we redirect the getter/setter
     * to the specified property on the linked Aperture.
     * @var {Boolean} adventurejs.Exit#is!getLinkedApertureState
     * @param {String} property
     */
    getLinkedApertureState(property) {
      var parent = this.parent;
      if (!parent || !parent.aperture) {
        return null;
      }
      var aperture = this.game.getAsset(parent.aperture);
      if (!aperture) {
        return null;
      }
      return aperture.is[property];
    }
  }
  adventurejs.Exit_Is = Exit_Is;
})();

// Exit.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments adventurejs.Tangible
   * @class adventurejs.Exit
   * @ajsconstruct MyGame.createAsset({ <br>&nbsp;&nbsp;"class":"Exit", <br>&nbsp;&nbsp;"direction":"x", <br>&nbsp;&nbsp;"place":{in:"room a"},<br>&nbsp;&nbsp;"destination":"room b",<br>&nbsp;&nbsp;[...]<br> })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajsnavheading DoorExitClasses
   * @summary Makes travel between Rooms possible.
   * @tutorial CreateExit
   * @tutorial CreateKey
   * @classdesc
   * <p>
   * <strong>Exit</strong> allows travel between
   * {@link adventurejs.Room|Rooms}.
   * An Exit must be assigned a
   * location, a direction, and a destination.
   * Unlike other classes, no name is required.
   * Though Exits are created via
   * <a href="/doc/adventurejs.Game.html#createAsset">Game.createAsset()</a>
   * like other
   * {@link adventurejs.Asset|Assets},
   * they are unique in that they don't take a
   * <a href="#name">name</a>
   * to generate an
   * <a href="#id">id</a>.
   * Rather, an id is generated from
   * the exit's location and direction.
   * </p>
   * <p>
   * Exits have no physical properties of their own. By default,
   * they allow travel with no special actions from the player.
   * If there's a north exit, typing
   * <code class="property">go north</code>
   * take the player north.
   * To add physical elements to an Exit, it must be paired with an
   * {@link adventurejs.Aperture|Aperture},
   * which is a class that includes subclasses such as lockable
   * {@link adventurejs.Door|Doors} and
   * {@link adventurejs.Window|Windows}, etc.
   * Apertures provide
   * {@link adventurejs.Tangible|Tangible}
   * Assets
   * with all the usual methods for physical interactions.
   * </p>
   * <p>
   * Exits are one-way. To create a two-way passage, you'll need
   * to create two Exits, one in each Room. Ordinary Exits
   * are singular, meaning that they only exist in the Room
   * they are assigned to.
   * </p>
   * <p>
   * The exception to the singular rule are GlobalExits.
   * GlobalExits are a set of predefined Exits with their
   * <code class="property">{@link adventurejs.Asset#is!global|is.global}</code>
   * property set to true.
   * GlobalExits capture direction inquiries
   * in rooms without exits in those directions.
   * For example, if a player inputs
   * <code class="property">go north</code>
   * in a Room with no north Exit, Game will return
   * the description for {@link global_north},
   * which should be some version of
   * <code class="property">You don't see any exit to the north.</code>
   * GlobalExit descriptions can be customized,
   * so you can write a different snarky comment
   * for each direction, if you so desire. To learn more about
   * customizing GlobalExits, see
   * <a href="/doc/NextSteps_GlobalScenery.html">Global Scenery</a>.
   * </p>
   * <p>
   * But let's say you want to provide Room-specific messages
   * when a player tries to travel in a wrong direction. Maybe
   * you've built a maze and you want to provide hints. That's
   * possible too, by creating Exits with no destination. When
   * a player tries to travel, only a description is returned.
   * Keep reading to see examples of this below.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * There are two ways to create an Exit.
   * If you don't need an Aperture, you can use this
   * simple shortcut: define a Room with an
   * <code class="property">exits</code> property,
   * with nested properties for each direction you
   * want to place an Exit. Set each
   * <a class="external"
   * href="https://www.w3schools.com/Js/js_json_objects.asp">key/value pair</a>
   * to a direction / a name of a Room to travel to.
   * This provides the minimum information for the game
   * to automatically construct new Exits at runtime.
   * In this example, we define a Room
   * called "Field of Dreams" with Exits to north and south.
   * This example assumes that there are additional Rooms called
   * "Corn Field" and "Front Yard".
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Field of Dreams",
   *   descriptions: { look: "If you build it, he will come. ", },
   *   exits: {
   *     north: "Corn Field"
   *     south: "Front Yard",
   *   }
   * });
   * </code></pre>
   * <p>
   * This method can also be used to create non-functioning
   * exits that return an error when a player tries to use a
   * non-existent exit. Instead of providing a Room name,
   * simply provide a string to return as a message. This
   * method can provide useful feedback to players. (This
   * provides results that are very similar to setting custom
   * GlobalExit messages as mentioned above. It's just
   * another way of doing it.)
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Middle Beach",
   *   descriptions: {
   *     look: {
   *       "A sandy strip between a rough tide to the
   *       east and a rocky sea wall to the west. You can walk north
   *       or south along the water's edge. ",
   *     },
   *   },
   *   exits: {
   *     north: "North Beach",
   *     south: "South Beach",
   *     east: "The rough tides turn you back. ",
   *     west: "A towering rock wall blocks passage to the west. ",
   *   },
   * });
   * </code></pre>
   * <p>
   * This results in an interaction like the following example.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; go west</span>
   * A towering rock wall blocks passage to the west.
   * </pre>
   * <hr>
   * <p>
   * Alternately, Exits can be defined like other distinct Assets.
   * In this example, we create a Room, an Exit, a lockable Aperture,
   * and a {@link adventurejs.Key|Key}. Note that the Exit is
   * given a direction, a location, and a destination, and a
   * name for the Aperture it should be linked with. The main benefit
   * of this arrangement is that it provides more granular control
   * over the Exit details.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Ice King's Living Room",
   *   descriptions: {
   *     look: "It's the Ice King's Living Room. Man that guy is a slob.
   *     No wonder he can't get a Princess. Schmowza! ",
   *   },
   * });
   *
   * MyGame.createAsset({
   *   class: "Exit",
   *   direction: "north",
   *   place: { in: "Ice King's Living Room" },
   *   destination: "Ice King's Boudoir",
   *   aperture: "icy door",
   *   descriptions: {
   *     look: "It looks frosty that way. Brrr. ",
   *     for_exits_list: "north to the Boudoir",
   *   }
   * });
   *
   * MyGame.createAsset({
   *   class: "Door",
   *   name: "icy door",
   *   adjectives: "icy, north",
   *   synonyms: ["icy north door"],
   *   place: { in: "Ice King's Living Room" },
   *   direction: "north",
   *   descriptions: {
   *     look: "The icy door is very slightly translucent.
   *     You can't see through it, but it has a bit of a glow. ",
   *     open: "The icy door is open. ",
   *     closed: "The icy door is closed. ",
   *     touch: "The icy door is cold to the touch. ",
   *     through: function()
   *     {
   *       if( MyGame.$( "icy door" ).$is("open") )
   *       {
   *         return "Through the open door you can see
   *         the Ice King's Boudoir. "
   *       }
   *       else
   *       {
   *         return "Though the closed door appears to be
   *         very slightly translucent, you can't see through it. "
   *       }
   *     },
   *   }
   *   dov: {
   *     unlock: { with_assets: ['glass key'], },
   *   },
   *   is: {
   *         closed: true,
   *         locked: true
   *   },
   *   linked_asset: "boudoir door",
   * });
   *
   * MyGame.createAsset({
   *   class: "Key",
   *   name: "Boudoir key",
   *   article: "the",
   *   opacity: .5,
   *   iov: {
   *     unlock: { then_destroy: { on_success: 'The fragile key crumbles into pieces after use. ' }, },
   *   },
   * });
   * </code></pre>
   * <p>
   * As with the simpler method,
   * it's also possible to construct a non-functioning Exit
   * that returns a message when a player tries to go that way.
   * Though the outcome is the same as with the simpler method,
   * you might find that this method provides more granular
   * control over the Exit Asset.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *  class: "Room",
   *  name: "Pantheon",
   *  descriptions: {
   *    look: "One of the most inspiring sites in Rome. ",
   *  ),
   *  exits: {
   *    north: "Piazza della Rotonda",
   *  },
   * });
   *
   * MyGame.createAsset({
   *   class: "Exit",
   *   name: "hole in the roof",
   *   place: { in: "Pantheon" },
   *   direction: "up",
   *   descriptions: {
   *     look: {
   *       "You see a dot of blue sky through a
   *       tiny hole in the roof, but you could never reach it. ",
   *       split_name_for_world_lookup: false,
   *     },
   *   },
   * });
   * </code></pre>
   * <p>
   * It's ok to mix the two methods. For instance a Room might
   * have one exit with an Aperture and another without.
   * It's fine to construct an Exit instance to go with the
   * Aperture, and use the simple method for the other Exit.
   * To learn more about Apertures and Exits, see
   * <a href="/doc/GetStarted_CreateAnExit.html">Create an Exit</a>.
   * </p>
   **/
  class Exit extends adventurejs.Tangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Exit";

      this.is = new adventurejs.Exit_Is("is", this.game_name, this.id).set({
        parent_id: this.id,
      });

      this.singlePluralPairs = [
        ["exit", "exits"],
        ["passage", "passages"],
      ];
      //this.name = this.direction + " passage";

      // TODO I had this excluded and can't remember specifically why
      // but then disabled because of stoomphing_room exit "hole" in ground
      //this.exclude_from_lookup = true;

      this.is.listed_in_room = false;
      this.split_name_for_world_lookup = false;

      /**
       * Exit instances aren't named in the usual way. Instead
       * they're given an id that is parent room + direction.
       * @nestedproperty
       * @var {Boolean} adventurejs.Exit#is!nameless
       * @default false
       */
      this.is.nameless = true;

      /**
       * Set an ID representing an Aperture. Used chiefly for Exit class to set a
       * physical component corresponding to the exit.
       * @var {String} adventurejs.Tangible#aperture
       * @default ""
       */
      this.aperture = ""; // for use with exits

      //this.is.known = false;
      //this.is.seen = false;
      //this.is.used = false;
    }

    initialize(game) {
      super.initialize(game);
      return this;
    }

    validate(game) {
      super.validate(game);
      /**
       * The simple way to define an exit's destination
       * is to set destination to a Room name.
       * If we find a destination,
       * we save it to destinationName and Serialize it to destinationID.
       *
       * It is also permissible to leave destination empty,
       * in which case trying to exit in this direction returns a description.
       *
       * In order to support more advanced features such as
       * randomized destination or custom functions that return
       * different destinations depending on state, we invite
       * authors to set destinationID directly. This means we
       * need to check destinationID for advanced methods.
       *
       */

      // check the exit's direction
      if (!this.direction && !this.is.global) {
        var msg = "Exit " + this.name + "has no direction.";
        //console.error( msg );
        this.game.log("error", "critical", msg, "Exit");
        return false;
      }

      if (!this.name) {
        this.name = this.direction + " passage";
      }

      // add all synonyms for this exit's direction, as adjectives
      // so player can refer to, eg, "east exit" or "e exit"
      //console.warn( "this.direction" );
      //console.warn( this );
      //console.warn( this.direction );
      var directionSynonyms =
        this.game.dictionary.directionLookup[this.direction].synonyms;
      for (var i = 0; i < directionSynonyms.length; i++) {
        this.adjectives.push(directionSynonyms[i]);
      }

      // also add direction adjectives so player can refer to, eg, "eastern exit"
      var directionAdjectives =
        this.game.dictionary.directionLookup[this.direction].adjectives;
      for (var i = 0; i < directionAdjectives.length; i++) {
        this.adjectives.push(directionAdjectives[i]);
      }

      /**
       * Global exits are a special case which only exist to catch
       * direction queries in rooms with no query matches.
       * They don't need destination or location or aperture,
       * so we're done validating.
       */
      if (this.is.global) {
        return true;
      }

      /**
       * The author hasn't set a destination.
       * This is permissible and the exit will be treated
       * as a description if player attempts to travel.
       */
      if (!this.destination) {
        var msg =
          "Exit.js > " +
          this.id +
          " has no destination. " +
          "Treating it as a non-travel description rather than an exit.";
        this.game.log("warn", "critical", msg, "Exit");
        //console.warn( msg );
      } else if (
        /**
         * Author provided a string in destination so Serialize it for an ID.
         */
        "string" === typeof this.destination &&
        "" !== this.destination
      ) {
        this.destinationName = this.destination;
        this.destinationID = A.serialize(this.destination);
      }

      /**
       * If destination is not an array or a function
       * or a non-travel string,
       * by now we should have a serialized destinationID,
       * so validate the destination.
       */
      if (!this.destination) {
        // do nothing - we've accepted exit as a non-travel string
      } else if ("string" === typeof this.destinationID) {
        var destinationObject = this.game.getAsset(this.destinationID);
        if (!destinationObject) {
          var msg = `Exit ${this.name}'s destination ${this.destinationID} doesn't map to a valid object. `;
          this.game.log("error", "critical", msg, "Exit");
          //console.error( msg );
          return false;
        }

        if (false === destinationObject instanceof adventurejs.Room) {
          var msg =
            "Exit " +
            this.name +
            "'s destination is set to " +
            destinationObject.name +
            ", which is a " +
            destinationObject.constructor.name +
            " rather than a Room.";
          this.game.log("error", "critical", msg, "Exit");
          //console.error( msg );
          return false;
        }

        //this.destination = destinationObject;
        this.destinationID = destinationObject.id;
        // we should be good to go on
      } // if( "string" === typeof this.destinationID )

      /**
       * destination can also be an array,
       * which needs to have each item validated.
       */
      else if (Array.isArray(this.destination)) {
        for (var i = 0; i < this.destination; i++) {
          /**
           * Each item in an array must be a string,
           * and we assume each one represents a unique Room.
           */
          if (
            "string" !== typeof this.destination[i] ||
            "" === this.destination[i]
          ) {
            var msg =
              "Exit " +
              this.name +
              "'s destination is an array, and item " +
              i +
              " is either empty or not a string.";
            this.game.log("error", "critical", msg, "Exit");
            //console.error( msg );
            return false;
          }

          // keep a copy of the original for error messaging
          var inputID = this.destination[i];

          // make sure it's serialized
          this.destination[i] = A.serialize(this.destination[i]);

          var destinationObject = this.game.getAsset(this.destination[i]);

          if (!destinationObject) {
            var msg =
              "Exit " +
              this.name +
              "'s destination is an array, and item " +
              i +
              ", " +
              inputID +
              " is invalid.";
            this.game.log("error", "critical", msg, "Exit");
            //console.error( msg );
            return false;
          }

          if (false === destinationObject instanceof adventurejs.Room) {
            var msg =
              "Exit " +
              this.name +
              "'s destination is an array, and item " +
              i +
              ", " +
              inputID +
              " refers to " +
              destinationObject.name +
              " which is a " +
              destinationObject.constructor.name +
              " rather than a Room.";
            this.game.log("error", "critical", msg, "Exit");
            //console.error( msg );
            return false;
          }
        } // for( var i = 0; i < destinationID

        /**
         * We're leaving this.destination as provided by author
         * because it's a valid array.
         * We should be good to proceed.
         */
      } // if( Array.isArray( destinationID )

      /**
       * Destination can also be a custom function,
       * which needs to be validated.
       */
      else if ("function" === typeof this.destination) {
        /**
         * Try calling the function.
         * This is tricky because while we can require
         * that custom functions return a string,
         * they may depend on state which isn't available prior to gameplay.
         */
        var test = this.destination();

        if ("string" !== typeof test) {
          var msg =
            "Exit " +
            this.name +
            "'s destination is a function " +
            "that returns something other than a string.";
          this.game.log("error", "critical", msg, "Exit");
          //console.error( msg );
          return false;
        }

        if ("string" === typeof test) {
          var testinput = test;
          test = A.serialize(test);
          var destinationObject = this.game.getAsset(test);

          if (!destinationObject) {
            var msg =
              "Exit " +
              this.name +
              "'s destination is a function that returns " +
              testinput +
              ", which  is invalid. Allowing this to validate, " +
              "but be sure your function works as you expect.";
            this.game.log("warn", "critical", msg, "Exit");
            //console.warn( msg );
            // don't return false and hope author knows what they're doing
          }

          if (false === destinationObject instanceof adventurejs.Room) {
            var msg =
              "Exit " +
              this.name +
              "'s destination is a function that returns " +
              testinput +
              ", " +
              " which refers to " +
              destinationObject.name +
              " which is a " +
              destinationObject.constructor.name +
              " rather than a Room. Allowing this to validate, " +
              "but be sure your function works as you expect.";
            this.game.log("warn", "critical", msg, "Exit");
            //console.warn( msg );
            // don't return false and hope author knows what they're doing
          }
        } // if( "string" === typeof test )

        /**
         * As long as it returns a string,
         * we're leaving this.destination() as provided by author.
         * We don't know for sure that it's a valid function
         * but we've done our best to warn the author.
         */
      } // else if( "function" === typeof this.destination )

      /**
       * If place has not been set...
       */
      if (!this.place || Object.keys(this.place).length === 0) {
        var msg = "Exit " + this.name + "'s location is undefined.";
        this.game.log("error", "critical", msg, "Exit");
        //console.error( msg );
        return false;
      }

      /**
       * place set to something other than a string?
       */
      if ("string" !== typeof this.place[Object.keys(this.place)[0]]) {
        var msg = "Exit " + this.name + "'s location is not a string.";
        this.game.log("error", "critical", msg, "Exit");
        //console.error( msg );
        return false;
      }

      // save a temp copy of the original string for error messaging
      var myplace = this.getPlaceAssetId();

      // get the object referred to by the ID
      var placeAsset = this.game.getAsset(myplace);

      // no such object
      if (!placeAsset) {
        var msg =
          "Exit " + this.name + "'s location " + myplace + " is invalid.";
        this.game.log("error", "critical", msg, "Exit");
        return false;
      }

      // object isn't a Room
      if (!(placeAsset instanceof adventurejs.Room)) {
        var msg =
          "Exit " +
          this.name +
          "'s location refers to " +
          placeAsset.name +
          " which is a " +
          placeAsset.constructor.name +
          " rather than a Room.";
        this.game.log("error", "critical", msg, "Exit");
        return false;
      }

      /**
       * Oh yeah and also check the aperture.
       * An exit is not required to have an aperture,
       * though an aperture is required to have an exit,
       * and each will ensure that the other has a reference to it.
       */
      if (this.aperture && "string" !== typeof this.aperture) {
        var msg =
          "Exit " +
          this.name +
          "'s aperture " +
          this.aperture +
          " is not a string.";
        this.game.log("error", "critical", msg, "Exit");
        return false;
      }

      // no such object
      if (this.aperture) {
        var inputAperture = this.aperture;
        this.aperture = A.serialize(this.aperture);
        var apertureObject = this.game.getAsset(this.aperture);

        if (!apertureObject) {
          var msg =
            "Exit " +
            this.name +
            "'s aperture " +
            inputAperture +
            " is invalid.";
          this.game.log("error", "critical", msg, "Exit");
          return false;
        }

        // not actually an Aperture
        if (!(apertureObject instanceof adventurejs.Aperture)) {
          var msg =
            "Exit " +
            this.name +
            "'s aperture " +
            apertureObject.name +
            " is a " +
            placeAsset.constructor.name +
            " rather than an Aperture.";
          this.game.log("error", "critical", msg, "Exit");
          return false;
        }

        // looks like we have a valid aperture
        //this.aperture = apertureObject;
        // no longer saving object - now keeping string

        // looks like we're good to go with aperture
        //this.aperture.exit = this;
        // no longer saving object - now keeping string
        apertureObject.exit = this.id;
      }

      // BOOM! Add it to its room's exits object.
      //placeAsset.exits[ this.direction ] = this; // EtoS
      placeAsset.exits[this.direction] = this.id;

      return this;
    }

    /**
     * Get a description, such as "look in book", where
     * "in" has been defined as a key at
     * asset.descriptions.in.
     * "look" is always the default description.
     * This is modified from asset.getDescription to allow
     * exit descriptions to be stored on their apertures.
     * @memberOf adventurejs.Asset
     * @method adventurejs.Asset#getDescription
     * @param {String} description
     * @return {String}
     */
    getDescription(description) {
      console.warn("Exit getDescription");
      description = description || "look";

      if (this.aperture) {
        let aperture = this.game.getAsset(this.aperture);
        if (
          aperture &&
          aperture.descriptions &&
          aperture.descriptions[description]
        ) {
          return aperture.getDescription(description);
        }
      }

      if (!this.descriptions[description]) description = "look";
      if (this.descriptions[description]) {
        if (
          Array.isArray(this.descriptions[description]) ||
          "string" === typeof this.descriptions[description] ||
          "function" === typeof this.descriptions[description]
        ) {
          return A.getSAF.call(this.game, this.descriptions[description]);
        }

        if (
          "object" === typeof this.descriptions[description] &&
          this.descriptions[description].default
        ) {
          return A.getSAF.call(
            this.game,
            this.descriptions[description].default
          );
        }
      }

      return `${this.Articlename} is undescribed. `;
    }
  }
  adventurejs.Exit = Exit;
})();

// GlobalExitAft.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_aft
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_aft", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_aft
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "aft",

    class: "Exit",

    descriptions: {
      look: "There's no exit aft of here. What, do $(we) think $(we're) on a boat?",
    },
  });
})();

// GlobalExitDown.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_down
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_down", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_down
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "down",

    descriptions: { look: "$(We) don't see any way to go down from here." },
  });
})();

// GlobalExitEast.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_east
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_east", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_east
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "east",

    descriptions: { look: "$(We) don't see any exit to the east." },
  });
})();

// GlobalExitEnter.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_enter
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_enter", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_enter
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "enter",

    descriptions: {
      look: "There doesn't appear to be anything to enter here.",
    },
  });
})();

// GlobalExitExit.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_exit
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_exit", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_exit
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "exit",

    descriptions: { look: "There doesn't appear to be an obvious main exit." },
  });
})();

// GlobalExitFore.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_fore
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_fore", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_fore
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "fore",

    descriptions: {
      look: "There's nothing fore of here. What, do $(we) think $(we're) on a boat?",
    },
  });
})();

// GlobalExitIn.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_in
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_in", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_in
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "in",

    class: "Exit",

    descriptions: { look: "There's no way in." },
  });
})();

// GlobalExitNorth.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_north
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_north", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_north
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "north",

    descriptions: { look: "$(We) don't see any exit to the north." },
  });
})();

// GlobalExitNortheast.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_northeast
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_northeast", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_northeast
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "northeast",

    descriptions: { look: "$(We) don't see any exit to the northeast." },
  });
})();

// GlobalExitNorthwest.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_northwest
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_northwest", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_northwest
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "northwest",

    descriptions: { look: "$(We) don't see any exit to the northwest." },
  });
})();

// GlobalExitOut.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_out
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_out", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_out
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "out",

    class: "Exit",

    descriptions: { look: "There's no way out of here." },
  });
})();

// GlobalExitPort.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_port
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_port", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_port
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "port",

    descriptions: {
      look: "There's no exit to port of here. What, do $(we) think $(we're) on a boat?",
    },
  });
})();

// GlobalExitSouth.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_south
   * @classdesc Description of the exit.
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_south", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_south
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "south",

    descriptions: { look: "$(We) don't see any exit to the south." },
  });
})();

// GlobalExitSoutheast.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_southeast
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_southeast", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_southeast
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "southeast",

    descriptions: { look: "$(We) don't see any exit to the southeast." },
  });
})();

// GlobalExitSouthwest.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_southwest
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_southwest", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_southwest
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "southwest",

    descriptions: { look: "$(We) don't see any exit to the southwest." },
  });
})();

// GlobalExitStarboard.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_starboard
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_starboard", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_starboard
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "starboard",

    descriptions: {
      look: "There's no exit starboard of here. What, do $(we) think $(we're) on a boat?",
    },
  });
})();

// GlobalExitUp.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_up
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_up", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_up
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "up",

    descriptions: { look: "$(We) can't see any way up from here." },
  });
})();

// GlobalExitWest.js

(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments {adventurejs.Exit}
   * @class global_west
   * @ajsconstruct MyGame.createGlobalExits({ "name": "global_west", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalExits
   * @hideconstructor
   * @ajsinstanceof Exit
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalExits
   * @ajsnode game.world.global_west
   * @tutorial NextSteps_GlobalScenery
   * @summary A global exit.
   * @ajsglobal GlobalExit
   */
  A.GlobalAssets.Exits.push({
    direction: "west",

    descriptions: { look: "$(We) don't see any exit to the west." },
  });
})();

// Floor.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Floor
   * @class adventurejs.Floor
   * @augments adventurejs.Tangible
   * @ajsconstruct MyGame.createAsset({ "class":"Floor", "name":"foo" })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading RoomAssets
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @param {String} game_name The name of the top level game object.
   * @summary Catches player input such as
   * <code class="property">pour water on floor</code>.
   * @classdesc
   * <p>
   * <strong>Floor</strong> is a special
   * {@link adventurejs.Asset|Asset}
   * that exists to catch player input that refers to the floor,
   * such as <code class="property">sit on floor</code> or
   *  <code class="property">pour water on floor</code> or
   *  <code class="property">empty bucket on floor</code>.
   * </p>
   * <p>There is already a {@link global_floor} already
   * available in all rooms, so it's not necessary to
   * create a Floor for each room, but you can if you want to,
   * perhaps in order to attach custom code to them. </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class:"Floor",
   *   name:"Candy Room floor",
   *   place: { in: "Candy Room" },
   *   descriptions: { look: "It appears to be made of red jelly beans. " },
   * });
   * </code></pre>
   **/
  class Floor extends adventurejs.Tangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Floor";

      this.aspects.on = new adventurejs.Aspect("on", this.game_name).set({
        list_in_room: false,
        list_in_examine: true,
        maxheight: -1,
        maxwidth: -1,
        maxdepth: -1,
        maxcount: -1,
        maxsize: -1,
        maxweight: -1,
        player: {
          posture: "stand",
          preposition: "on",
          can: {
            enter: true,
            sit: true,
            crawl: true,
            kneel: true,
            lie: true,
            stand: true,
          },
        },
      });

      this.is.false_nest = true;
      this.is.deep_nest = true;
      this.is.listed_in_room = false;
      this.quirks.stand_means_get_off = true;
    }

    validate(game) {
      super.validate(game);

      /**
       * Global floor is a special case which exists to catch
       * floor interactions where authors haven't
       * made a custom floor. They don't need further validation.
       */
      if (this.is.global) {
        return true;
      }

      /**
       * TODO
       * What other validation does a floor need?
       */
    }
  }
  adventurejs.Floor = Floor;
})();

// GlobalFloor.js
(function () {
  /*global adventurejs A*/
  "use strict";

  var p = adventurejs.Game.prototype;

  /**
   * @augments {adventurejs.Floor}
   * @class global_floor
   * @ajsconstruct MyGame.createGlobalFloors({ "name": "global_floor", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalFloors
   * @hideconstructor
   * @ajsinstanceof floor
   * @ajsmodifiedby adventurejs.Game#setGlobalDescriptions
   * @ajsnavheading GlobalAssets
   * @ajsnode game.world.global_floor
   * @summary Summary of the floor.
   * @ajsglobal GlobalFloor
   * @classdesc Description of the floor.
   */
  A.GlobalAssets.Floors.push({
    name: "floor",
    descriptions: { look: "$(We) see nothing special about the floor. " },
  });
})();

// Wall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Wall
   * @augments adventurejs.Thing
   * @class adventurejs.Wall
   * @ajsconstruct MyGame.createAsset({ "class":"Wall", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading RoomAssets
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary When the world slips you a Jeffrey, stroke the furry wall.
   * @tutorial NextSteps_GlobalScenery
   * @classdesc
   * <p>
   * <strong>Wall</strong> is a subclass of
   * {@link adventurejs.Thing|Thing},
   * with no particular special properties. However, the
   * {@link adventurejs.Game|Game}
   * instance creates a set of global walls which can be
   * referred to from any Room in the Game, and can be customized
   * globally or by
   * {@link adventurejs.Room|Room} or
   * {@link adventurejs.Zone|Zone}. Each of the
   * predefined global walls corresponds to one of twelve
   * directions: the four cardinal directions,
   * or north, south, east, west;
   * the four ordinal directions, or northeast, northwest,
   * southeast, southwest; fore and aft; and port and starboard.
   * This provides
   * a way to respond to player input like "examine north wall",
   * with a cogent response without coding unique objects for
   * each Room. Authors can enable or disable global walls
   * per Room, per Zone, or per Game.
   * The Wall class was written with the assumption that this
   * is the only way they'd be used. It's possible to construct
   * unique instances of Walls, though if you want them to do
   * anything more you may need to write custom code for it.
   * To learn more, see
   * <a href="/doc/NextSteps_GlobalScenery.html">Global Scenery</a>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>Here is an example of a simple wall constructor.</p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   "class":"Wall",
   *   "direction":"north",
   *   "place":{in:"South Room"},
   * })
   * </code></pre>
   * <p>Here is an example of how you would enable specified walls
   * for a Room.</p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Room",
   *   name: "Ship's Cabin",
   *   descriptions: {
   *     look: "The tiny cabin has walls fore and aft, and to port and starboard. ",
   *   },
   *   room_scenery: {
   *     fore_wall: {
   *       enabled: true,
   *       descriptions: {
   *         look: "Though it has no windows, you know that beyond
   *         the fore wall lies the bow of the ship. ",
   *       },
   *     },
   *     aft_wall: {
   *       enabled: true,
   *       descriptions: {
   *         look: "Though the wall has no windows, you know that
   *         the Captain's quarters lie beyond the aft wall. ",
   *       },
   *     },
   *     port_wall: {
   *       enabled: true,
   *       descriptions: {
   *         look: "Through a porthole in the port wall you can see far off land. ",
   *       },
   *     },
   *     starboard_wall: {
   *       enabled: true,
   *       descriptions: {
   *         look: "Nothing but sea is visible through the porthole in the starboard wall. ",
   *       },
   *     },
   *   },
   * });
   * </code></pre>
   **/
  class Wall extends adventurejs.Tangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Wall";
      this.is.listed_in_room = false;
      this.is.climbable = false; // but could be true
    }

    validate(game) {
      super.validate(game);

      // check the wall's direction
      // @todo can we have a wall without a direction?
      if (this.direction && !this.is.global) {
        var msg = "Wall " + this.name + "has no direction.";
        console.error(msg);
        return false;
      }

      if (!this.name) {
        this.name = this.direction + " wall";
      }

      // add all synonyms for this wall's direction, as adjectives
      // so player can refer to, eg, "east wall" or "e wall"
      var directionSynonyms =
        this.game.dictionary.directionLookup[this.direction].synonyms;
      for (var i = 0; i < directionSynonyms.length; i++) {
        this.adjectives.push(directionSynonyms[i]);
      }

      // also add direction adjectives so player can refer to, eg, "eastern wall"
      var directionAdjectives =
        this.game.dictionary.directionLookup[this.direction].adjectives;
      for (var i = 0; i < directionAdjectives.length; i++) {
        this.adjectives.push(directionAdjectives[i]);
      }

      /**
       * Global walls are a special case which exist to catch
       * provide descriptions for walls where authors haven't
       * made custom walls. They don't need further validation.
       */
      if (this.is.global) {
        return true;
      }

      /**
       * TODO
       * What other validation does a wall need?
       */
    }
  }
  adventurejs.Wall = Wall;
})();

//GlobalAftWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_aft_wall
   * @augments {adventurejs.Wall}
   * @class global_aft_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_aft_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "aft",
    descriptions: { look: "$(We) see nothing special about the aft wall. " },
    enabled: false,
  });
})();

//GlobalEastWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_east_wall
   * @augments {adventurejs.Wall}
   * @class global_east_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_east_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "east",
    descriptions: { look: "$(We) see nothing special about the east wall. " },
    enabled: false,
  });
})();

//GlobalForeWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_fore_wall
   * @augments {adventurejs.Wall}
   * @class global_fore_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_fore_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "fore",
    descriptions: { look: "$(We) see nothing special about the fore wall. " },
    enabled: false,
  });
})();

//GlobalNortheastWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_northeast_wall
   * @augments {adventurejs.Wall}
   * @class global_northeast_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_northeast_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "northeast",
    descriptions: {
      look: "$(We) see nothing special about the northeast wall. ",
    },
    enabled: false,
  });
})();

//GlobalNorthWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_north_wall
   * @augments {adventurejs.Wall}
   * @class global_north_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_north_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "north",
    descriptions: { look: "$(We) see nothing special about the north wall. " },
    enabled: false,
  });
})();

//GlobalNorthwestWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_northwest_wall
   * @augments {adventurejs.Wall}
   * @class global_northwest_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_northwest_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "northwest",
    descriptions: {
      look: "$(We) see nothing special about the northwest wall. ",
    },
    enabled: false,
  });
})();

//GlobalPortWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_port_wall
   * @augments {adventurejs.Wall}
   * @class global_port_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_port_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "port",
    descriptions: { look: "$(We) see nothing special about the port wall. " },
    enabled: false,
  });
})();

//GlobalSoutheastWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_southeast_wall
   * @augments {adventurejs.Wall}
   * @class global_southeast_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_southeast_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "southeast",
    descriptions: {
      look: "$(We) see nothing special about the southeast wall. ",
    },
    enabled: false,
  });
})();

//GlobalSouthWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_south_wall
   * @augments {adventurejs.Wall}
   * @class global_south_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_south_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "south",
    descriptions: { look: "$(We) see nothing special about the south wall. " },
    enabled: false,
  });
})();

//GlobalSouthwestWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_southwest_wall
   * @augments {adventurejs.Wall}
   * @class global_southwest_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_southwest_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "southwest",
    descriptions: {
      look: "$(We) see nothing special about the southwest wall. ",
    },
    enabled: false,
  });
})();

//GlobalStarboardWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_starboard_wall
   * @augments {adventurejs.Wall}
   * @class global_starboard_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_starboard_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "starboard",
    descriptions: {
      look: "$(We) see nothing special about the starboard wall. ",
    },
    enabled: false,
  });
})();

//GlobalWestWall.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajsnode game.world.global_west_wall
   * @augments {adventurejs.Wall}
   * @class global_west_wall
   * @ajsconstruct MyGame.createGlobalWalls({ "name": "global_west_wall", [...] });
   * @ajsconstructedby adventurejs.Game#createGlobalWalls
   * @hideconstructor
   * @ajsinstanceof Wall
   * @ajsnavheading GlobalWalls
   * @summary A global wall.
   * @tutorial NextSteps_GlobalScenery
   */
  A.GlobalAssets.Walls.push({
    direction: "west",
    descriptions: { look: "$(We) see nothing special about the west wall. " },
    enabled: false,
  });
})();

// Thing.js
(function () {
  /*global adventurejs A*/
  "use strict";
  /**
   * @augments adventurejs.Tangible
   * @class adventurejs.Thing
   * @ajsconstruct MyGame.createAsset({ "class":"Thing", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BaseClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing
   * @summary Base class for most things with physical properties.
   * @classdesc
   * <p>
   * <strong>Thing</strong> is a subclass of
   * {@link adventurejs.Tangible|Tangible}
   * and a base class for most all
   * {@link adventurejs.Asset|Assets}
   * with physical properties in the game world,
   * excluding a few Tangible subclasses such as
   * Characters, Rooms, and a few other special classes.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class Thing extends adventurejs.Tangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Thing";
      this.setDOVs(["take", "drop", "put", "throw"]);
    }

    initialize(game) {
      super.initialize(game);
      return this;
    }
  }
  adventurejs.Thing = Thing;
})();

// Aperture_Is.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Is.Tangible_Is.Aperture_Is
   * @augments adventurejs.Tangible_Is
   * @class adventurejs.Aperture_Is
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <strong>Aperture_Is.js</strong>  is a state management class
   * used to handle a variety of properties for
   * {@link adventurejs.Aperture|Aperture Assets}.
   **/

  class Aperture_Is extends adventurejs.Tangible_Is {
    constructor(name = "is", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);
      this.class = "Aperture_Is";

      this._used = false;
      this._closed = false;
      this._locked = false;
      this._sealed = false;

      this.aperture = true;
      this.listed_in_room = false;

      return this;
    }

    get closed() {
      return this._closed;
    }
    set closed(value) {
      this._closed = value;
      this.setLinkedAssetState("_closed", value);
    }

    get locked() {
      return this._locked;
    }
    set locked(value) {
      this._locked = value;
      this.setLinkedAssetState("_locked", value);
    }

    get sealed() {
      return this._sealed;
    }
    set sealed(value) {
      this._sealed = value;
      this.setLinkedAssetState("_sealed", value);
    }

    get used() {
      return this._used;
    }
    set used(value) {
      this._used = value;
      this.setLinkedAssetState("_used", value);
    }

    get known() {
      return this._known;
    }
    set known(value) {
      this._known = value;
      this.setLinkedAssetState("_known", value);
    }

    get seen() {
      return this._seen;
    }
    set seen(value) {
      this._seen = value;
      this.setLinkedAssetState("_seen", value);
    }
  }
  adventurejs.Aperture_Is = Aperture_Is;
})();

// Aperture.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @augments adventurejs.Thing
   * @class adventurejs.Aperture
   * @ajsconstruct MyGame.createAsset({ "class":"Aperture", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading DoorExitClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Base class for doors, windows, and other passageways.
   * @tutorial CreateExit
   * @classdesc
   * <p>
   * <strong>Aperture</strong> is the base class for all
   * {@link adventurejs.Door|Doors},
   * {@link adventurejs.Window|Windows},
   * and other types of passageway. An Aperture is
   * always associated with an {@link adventurejs.Exit|Exit}.
   * Because Exits have no physical properties of their own,
   * Apertures provide a way to add those missing
   * manipulatable physical properties.
   * Each Aperture only exists in one {@link adventurejs.Room|Room}
   * and is one-way. To make a two-way passage, create
   * two Apertures, one in each Room, and set each Aperture's
   * <a href="#linked_asset">linked_asset</a>
   * property to its mate. This allows them to share state,
   * i.e., unlocking one side also unlocks the other.
   * This example shows two Rooms with a two-way passage between them.
   * </p>
   * <h3 class="example">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   "class":"Exit",
   *   "direction":"north",
   *   "place":{in:"South Room"},
   *   "destination":"North Room",
   *   "aperture":"icy door"
   * });
   * MyGame.createAsset({
   *   "class":"Door",
   *   "name":"icy door",
   *   "place":{in:"South Room"},
   *   "direction":"north",
   *   "linked_asset":"warm door"
   * });
   * MyGame.createAsset({
   *   "class":"Exit",
   *   "direction":"south",
   *   "place":{in:"North Room"},
   *   "destination":"South Room",
   *   "aperture":"warm door"
   * });
   * MyGame.createAsset({
   *   "class":"Door",
   *   "name":"warm door",
   *   "place":{in:"North Room"},
   *   "direction":"south",
   *   "linked_asset":"icy door"
   * });
   * </code></pre>
   *
   **/
  class Aperture extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Aperture";

      this.is = new adventurejs.Aperture_Is("is", this.game_name, this.id).set({
        parent_id: this.id,
      });

      this.unsetDOV("take");
      this.setDOVs([
        "open",
        "close" /*,'lock','unlock','seal','unseal','pick'*/,
      ]);

      /**
       * Set a direction for this asset. Chiefly used with Aperture class to set
       * directions apertures. Takes a direction string, ie "north", "northeast", "down".
       * @var {String} adventurejs.Tangible#direction
       * @default ""
       * @todo Use lookup table for this? In a GUI this would be a pull-down menu.
       */
      this.direction = ""; // for use with apertures

      /**
       * Set an ID representing an Exit. Used chiefly for Aperture class to set an
       * exit corresponding to an aperture.
       * @var {String} adventurejs.Tangible#exit
       * @default ""
       */
      this.exit = ""; // for use with apertures

      this.location_required = true;
      // ex: this.direction = "north"; // an aperture will be associated with an exit direction

      this.can.auto_unlock = true;
      this.can.auto_unseal = true;
      this.can.auto_open = true;

      /**
       * ID of an Asset that is the other side of this. Used
       * for connecting doors.
       * @var {String} adventurejs.Aperture#linked_asset
       * @default ""
       */
      //this.linked_asset = "";
    }

    initialize(game) {
      super.initialize(game);

      var words = [];

      words.push(this.direction);
      var directionConstructor =
        this.direction + " " + this.constructor.name.toLowerCase();
      words.push(directionConstructor);
      words.push(A.serialize(directionConstructor));

      var directionName = this.direction + " " + this.name.toLowerCase();
      words.push(directionName);
      words.push(A.serialize(directionName));

      while (words.length > 0) {
        if (!this.game.world_lookup[words[0]]) {
          this.game.world_lookup[words[0]] = {};
          this.game.world_lookup[words[0]].IDs = [];
          this.game.world_lookup[words[0]].type = "direction";
        }
        if (-1 === this.game.world_lookup[words[0]].IDs.indexOf(this.id)) {
          this.game.world_lookup[words[0]].IDs.push(this.id);
        }
        words.shift();
      }

      return this;
    }

    validate(game) {
      super.validate(game);

      var msg = "";

      if (this.linked_asset) {
        var linked_asset = this.game.getAsset(this.linked_asset);

        if (!(linked_asset instanceof adventurejs.Aperture)) {
          msg = `${this.constructor.name} ${this.name}'s linked_asset, ${this.linked_asset}, is not an Aperture. `;
          this.game.log("error", "critical", msg, "Tangible");
          return false;
        }

        // we reset linked_asset, known, and seen because these
        // also set the properties of linked assets, and
        // though this would have been called during construction,
        // the linked asset might not yet have been constructed
        // to receive the linkage
        //this.linked_asset = this.linked_asset;
        // this.is.known = this.is.known;
        // this.is.seen = this.is.seen;
        // this.is.closed = this.is.closed;
        // this.is.locked = this.is.locked;
        // this.is.sealed = this.is.sealed;
      }

      // this check was already performed in tangible.validate
      // but it's optional in tangible whereas aperture must have a place
      if (!this.hasPlace()) {
        msg = `${this.constructor.name} ${this.name}'s place isn't set. `;
        this.game.log("error", "critical", msg, "Tangible");
        return false;
      }

      // check the aperture's direction
      // aperture must have a direction
      if (!this.direction) {
        msg = `${this.constructor.name} ${this.name} has no direction. `;
        this.game.log("error", "critical", msg, "Tangible");
        return false;
      }

      // this.place will have been validated in tangible.validate
      var exitObject = this.game.getAsset(
        this.place[Object.keys(this.place)[0]] + "_" + this.direction
      );

      //if( "undefined" === typeof exitObject )
      if (Object(exitObject) !== exitObject) {
        msg = `${this.constructor.name} ${this.name}'s place + direction do not match an exit. `;
        this.game.log("error", "critical", msg, "Tangible");
        return false;
      }

      if (!(exitObject instanceof adventurejs.Exit)) {
        msg = `${this.constructor.name} ${this.name}'s place + direction matches ${exitObject.name} which is a ${exitObject.constructor.name} rather than an Exit. `;
        this.game.log("error", "critical", msg, "Tangible");
        return false;
      }

      // BOOM!
      // looks like we have a valid exit
      this.exit = exitObject.id;

      // make sure our exit refers back to this
      // depending on order validated, the exit might already have it
      //this.exit.aperture = this.id;
      //this.game.world[this.exit].aperture = this.id;
      exitObject.aperture = this.id;
    }

    /*doc@this*/
    get linked_asset() {
      return this._linked_asset;
    }
    set linked_asset(value) {
      var oldasset, newasset;
      value = A.serialize(value);
      if (this._linked_asset && this._linked_asset !== value) {
        // we have to inform the old asset
        oldasset = this.game.getAsset(this._linked_asset);
        oldasset._linked_asset = "";
      }
      newasset = this.game.getAsset(value);
      if (newasset) {
        // inform the new asset
        newasset._linked_asset = this.id;
      }
      this._linked_asset = value;
    }
  }
  adventurejs.Aperture = Aperture;
})();

// Door.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Aperture.Door
   * @augments adventurejs.Aperture
   * @class adventurejs.Door
   * @ajsconstruct MyGame.createAsset({ "class":"Door", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading DoorExitClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Shut the door!
   * @tutorial CreateExit
   * @classdesc
   * <p>
   * <strong>Door</strong> is a subclass of
   * {@link adventurejs.Aperture|Aperture}. Doors can be opened,
   * closed, locked and unlocked. By itself, a Door doesn't
   * move a player from {@link adventurejs.Room|Room} to room -
   * a Door must be linked with an
   * {@link adventurejs.Exit|Exit} in order to allow travel.
   * Doors are singular, meaning they only exist in one Room.
   * To allow two-way travel between Rooms, you must have two
   * Doors, each with its <a href="#linked_asset">linked_asset</a>
   * property set to the other Door. Following is an example
   * with two Doors + Exits.
   * </p>
   * <h3 class="example">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   "class":"Exit",
   *   "direction":"east",
   *   "place":{ in: "Sunset" },
   *   "destination":"Sunrise",
   *   "aperture":"bright door"
   * });
   * MyGame.createAsset({
   *   "class":"Door",
   *   "name":"bright door",
   *   "direction":"east",
   *   "place":{ in: "Sunset" },
   *   "linked_asset":"dim door"
   * });
   * MyGame.createAsset({
   *   "class":"Exit",
   *   "direction":"west",
   *   "place":{ in: "Sunrise" },
   *   "destination":"Sunset",
   *   "aperture":"dim door"
   * });
   * MyGame.createAsset({
   *   "class":"Door",
   *   "name":"dim door",
   *   "place":{ in: "Sunrise" },
   *   "direction":"west",
   *   "linked_asset":"bright door"
   * });
   * </code></pre>
   * <p>
   * To make a pair of linked Doors that are locked and unlocked
   * with a particular {@link adventurejs.Key|Key},
   * we need to create a Key and list it in the Doors'
   * <code class="property">asset.dov.unlock.with_assets</code>
   * as in the example below.
   * </p>
   * <h3 class="example">Example:</h3>
   * <pre class="display"><code class="language-javascript"><span class="new">MyGame.createAsset({
   *   class: "Key",
   *   name: "day key",
   *   iov: { unlock: { with_assets: ['bright door','dim door'], }, },
   * });</span>
   * MyGame.createAsset({
   *   class: "Exit",
   *   direction: "east",
   *   place: { in: "Sunset" },
   *   destination: "Sunrise",
   *   aperture: "bright door"
   * });
   * MyGame.createAsset({
   *   class: "Door",
   *   name: "bright door",
   *   direction: "east",
   *   place: { in: "Sunset" },
   *   linked_asset :"dim door",
   * <span class="new">  dov: { unlock: { with_assets: ['day key'], }, },
   *   is: { closed: true, locked: true },
   * });
   * MyGame.createAsset({
   *   class:"Exit",
   *   direction:"west",
   *   place:{ in: "Sunrise" },
   *   destination: "Sunset",
   *   aperture: "dim door"
   * });
   * MyGame.createAsset({
   *   class: "Door",
   *   name: "dim door",
   *   place: { in: "Sunrise" },
   *   direction: "west",
   *   linked_asset: "bright door",
   * <span class="new">  dov: { unlock: { with_assets: ['day key'], }, },
   *   is: { closed: true, locked: true },</span>
   * });
   * </code></pre>
   **/
  class Door extends adventurejs.Aperture {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Door";

      this.noun = "door";
      this.plural = "doors";
      this.singlePluralPairs = [["door", "doors"]];

      this.setDOVs(["open", "close"]);
      this.setDOV({
        open: {
          with_nothing: true,
          automatically_after_use: true,
        },
      });
      this.setDOV({
        close: {
          with_nothing: true,
          automatically_after_use: true,
        },
      });
      this.setDOV({
        lock: {
          with_nothing: false,
          automatically_after_use: true,
        },
      });
      this.setDOV({
        unlock: {
          with_nothing: false,
          automatically_after_use: true,
        },
      });

      // this.exit = ""; // a door will be associated with an exit direction
    }
  }
  adventurejs.Door = Door;
})();

// Hole.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Aperture.Hole
   * @augments adventurejs.Aperture
   * @class adventurejs.Hole
   * @ajsconstruct MyGame.createAsset({ "class":"Hole", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading DoorExitClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Big enough to climb through.
   * @tutorial CreateExit
   * @classdesc
   * <p>
   * <strong>Hole</strong> is a subclass of
   * {@link adventurejs.Aperture|Aperture}. Holes are open
   * by default and don't need to be locked or unlocked, though
   * they can be sealed with a lid as in the subclass
   * {@link adventurejs.Manhole|Manhole}.
   * Holes are singular, meaning they only exist in one Room.
   * To allow two-way travel between Rooms, you must have two
   * Holes, each with its <a href="#linked_asset">linked_asset</a>
   * property set to the other Hole. Following is an example
   * with two Holes + Exits.
   * </p>
   * <h3 class="example">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   "class":"Exit",
   *   "direction":"down",
   *   "place":{ in: "Dungeon" },
   *   "destination":"Oubliette",
   *   "aperture":"dark hole"
   * });
   * MyGame.createAsset({
   *   "class":"Hole",
   *   "name":"dark hole",
   *   "direction":"down",
   *   "place":{ in: "Cave" },
   *   "linked_asset":"bright hole"
   * });
   * MyGame.createAsset({
   *   "class":"Exit",
   *   "direction":"up",
   *   "place":{ in: "Oubliette" },
   *   "destination":"Dungeon",
   *   "aperture":"bright hole"
   * });
   * MyGame.createAsset({
   *   "class":"Hole",
   *   "name":"bright hole",
   *   "place":{ in: "Oubliette" },
   *   "direction":"up",
   *   "linked_asset":"dark hole"
   * });
   * </code></pre>
   **/
  class Hole extends adventurejs.Aperture {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Hole";

      this.noun = "hole";
      this.plural = "holes";
      this.singlePluralPairs = [["hole", "holes"]];
      //this.adjectives = "";
    }
  }
  adventurejs.Hole = Hole;
})();

// Window.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Aperture.Window
   * @augments adventurejs.Aperture
   * @class adventurejs.Window
   * @ajsconstruct MyGame.createAsset({ "class":"Window", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading DoorExitClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary You make a better door than a window.
   * @tutorial CreateExit
   * @classdesc
   * <p>
   * <strong>Window</strong> is a subclass of
   * {@link adventurejs.Aperture|Aperture}. Windows can be
   * opened and closed, and locked and unlocked without a key.
   * Windows are singular, meaning they only exist in one Room.
   * To allow two-way travel between Windows, you must have two
   * Windows, each with its <a href="#linked_asset">linked_asset</a>
   * property set to the other Window. To make a window that
   * locks from the inside but not the outside, set
   * <code class="property">dov.unlock.with_nothing</code>
   * to <code class="property">false</code>.
   * Following is an example
   * with two Windows + Exits, with a lock on the inside.
   * </p>
   * <h3 class="example">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class:"Exit",
   *   direction:"south",
   *   place:{ in: "Schoolroom" },
   *   destination:"Play yard",
   *   aperture:"inside window"
   * });
   * MyGame.createAsset({
   *   class:"Window",
   *   name:"inside window",
   *   direction:"south",
   *   place:{ in: "Schoolroom" },
   *   linked_asset:"outside window",
   *   dov: {
   *     unlock: { with_nothing:true, },
   *     lock: { with_nothing:true, },
   *   },
   * });
   * MyGame.createAsset({
   *   class:"Exit",
   *   direction:"north",
   *   place:{ in: "Play yard" },
   *   destination:"Schoolroom",
   *   aperture:"outside window"
   * });
   * MyGame.createAsset({
   *   class:"Window",
   *   name:"outside window",
   *   place:{ in: "Play yard" },
   *   direction:"north",
   *   linked_asset:"inside window",
   *   dov: {
   *     unlock: { with_nothing:true, },
   *     lock: { with_nothing:true, },
   *   },
   * });
   * </code></pre>
   **/
  class Window extends adventurejs.Aperture {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Window";

      this.noun = "window";
      this.plural = "windows";
      this.singlePluralPairs = [["window", "windows"]];
      //this.adjectives = "";

      this.is.aperture = true;
      this.is.listed_in_room = false;

      // this.setDOVs([
      //   'lock','unlock'
      // ]);
      this.setDOV({ open: { with_nothing: true } });
      this.setDOV({ close: { with_nothing: true } });
      this.setDOV({ lock: { with_nothing: true } });
      this.setDOV({ unlock: { with_nothing: true } });

      this.exit = "";

      this.is.lookthroughable = true;
      this.aspects.through = new adventurejs.Aspect(
        "through",
        this.game_name
      ).set({
        parent_id: this.id,
      });
    }
  }
  adventurejs.Window = Window;
})();

// Candle.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Candle
   * @augments adventurejs.Thing
   * @class adventurejs.Candle
   * @ajsconstruct MyGame.createAsset({ "class":"Candle", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading LightingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Asset class for a candle that can be lit and provide light.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Candle</strong> is a subclass of
   * {@link adventurejs.Thing|Thing}.
   * {@link adventurejs.Asset|Assets}
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Candle",
   *   name: "occult candle",
   *   article: "an",
   *   place: { on: "table" },
   *   descriptions: { look: "It's an occult candle. ", },
   * });
   * </code></pre>
   * @TODO Light candle, extinguish candle, put candle in candle holder, provide light.
   */
  class Candle extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Candle";

      this.singlePluralPairs = [["candle", "candles"]];
      this.is.listed_in_parent = true;

      this.setDOVs(["shine", "take", "drop", "give", "throw"]);
      this.setIOV("look");

      this.descriptions.look = "It's a candle. ";
    }
  }

  adventurejs.Candle = Candle;
})();

// Cap.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Cap
   * @augments adventurejs.Thing
   * @class adventurejs.Cap
   * @ajsconstruct MyGame.createAsset({ "class":"Cap", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Not the kind you wear, but the kind you attach to another thing.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Cap</strong> is a subclass of
   * {@link adventurejs.Thing|Thing}
   * which can be attached to / detached from a parent.
   * {@link adventurejs.Asset|Assets}
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Cap",
   *   name: "pen cap",
   *   article: "a",
   *   place: { on: "table" },
   *   descriptions: { look: "It's a cap for a pen. ", },
   * });
   * </code></pre>
   **/
  class Cap extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Cap";
      this.singlePluralPairs = [["cap", "caps"]];

      this.is.listed_in_parent = true;

      this.setDOVs([
        "put",
        "give",
        "take",
        "drop",
        "throw",
        "attach",
        "detach",
      ]);
      this.setIOVs(["attach", "detach"]);

      this.descriptions.look = "It's a cap.";
    }
  }
  adventurejs.Cap = Cap;
})();

// PenCap.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Cap.PenCap
   * @augments adventurejs.Cap
   * @class adventurejs.PenCap
   * @ajsconstruct MyGame.createAsset({ "class":"PenCap", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A cap for a pen.
   * @classdesc
   * <p>
   * <strong>PenCap</strong> is a subclass of Cap, with the idea
   * being that it only attaches to / detaches from a
   * {@link adventurejs.Pen|Pen}. However, the attachment is
   * determined by the Pen's
   * <code class="property">attached.with_classes</code>
   * property, which is set to PenCap. To learn more, see the
   * {@link adventurejs.Pen|Pen} class, or
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Pen",
   *   name: "blue pen",
   *   article: "a",
   *   adjectives: "blue",
   *   place: { on: "table" },
   *   descriptions: { look: "It's a pen with blue ink. ", },
   * });
   * MyGame.createAsset({
   *   class: "Pen",
   *   name: "red pen",
   *   article: "a",
   *   adjectives: "red",
   *   place: { on: "table" },
   *   descriptions: { look: "It's a pen with red ink. ", },
   * });
   * MyGame.createAsset({
   *   class: "PenCap",
   *   name: "pen cap",
   *   article: "a",
   *   place: { on: "table" },
   *   descriptions: { look: "It's a cap for a pen. ", },
   * });
   * </code></pre>
   * <p>
   * The above example uses <code class="property">with_classes</code>
   * and <code class="property">with_assets</code> to limit what a
   * player can put in without having to write custom
   * failure code for every object. To learn more, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   **/
  class PenCap extends adventurejs.Cap {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "PenCap";
    }
  }
  adventurejs.PenCap = PenCap;
})();

// Climbable.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Climbable
   * @augments adventurejs.Thing
   * @class adventurejs.Climbable
   * @ajsconstruct MyGame.createAsset({ "class":"Climbable", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Players can climb it.
   * @classdesc
   * <p>
   * <strong>Climbable</strong> is meant for players to climb; things
   * like ladders, vine, arbors. Player can climb on/to/from it,
   * swing to it, jump on/to/from it.
   * </p>
   **/
  class Climbable extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Climbable";

      this.setDOVs(["climb", "jump", "tie"]);

      this.is.climbable = true;

      this.can.jump_from = true;
      this.can.jump_to = true;
      this.can.swing_to = true;
      //this.can,swing_from = true;
      this.dimensions.height = 2;
      this.default_aspect_for_climb = "on";
      this.quirks.climb_means_go_on = false;
      this.quirks.go_on_means_climb = false;

      this.default_aspect = "on";

      this.is.listed_in_room = false;

      this.aspects.on = new adventurejs.Aspect("on", this.game_name).set({
        parent_id: this.id,
        list_in_room: false,
        player: { posture: "hang", can: { enter: true, jump: true } },
        orientation: "vertical",
      });
    }
  }

  adventurejs.Climbable = Climbable;
})();

// ClimbableVine.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Climbable.ClimbableVine
   * @augments adventurejs.Climbable
   * @class adventurejs.ClimbableVine
   * @ajsconstruct MyGame.createAsset({ "class":"ClimbableVine", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A hanging vine that player can climb.
   * @classdesc
   * <p>
   * <strong>ClimbableVine</strong> is a subclass of
   * {@link adventurejs.Climbable|Climbable}, a hanging vine
   * that a player can climb on/to/from,
   * swing on/to/from, jump to/from. What makes ClimableVine
   * special is its combination of its position.y and its height
   * properties. Here is an example of a
   * hanging vine that doesn't reach the ground, making a puzzle
   * of how to reach it.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "ClimbableVine",
   *   name: "vine",
   *   place: { in: "Cave" },
   *   descriptions: { look: "It's a vine. ", },
   *   position: { x:0, y:3, z:0 },
   *   height: -2,
   *   quirks.let_go_of_means_go_off: true,
   *   things_player_can_reach_from_this: [ "tree", "stalactite" ],
   * });
   * </code></pre>
   * <p>
   * See that the vine's position.y is 3 units high, presumably
   * at ceiling height, and that its height is -2, meaning that
   * it hangs down 2 units from the ceiling and reaches 1 unit
   * above the ground, just out of reach of the player.
   * </p>
   **/
  class ClimbableVine extends adventurejs.Climbable {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "ClimbableVine";

      this.singlePluralPairs = [["vine", "vines"]];

      this.setDOVs(["hold", "take", "pull"]);
      this.quirks.take_means_hold = true;

      this.is.supported = true;
      this.is.listed_in_room = false;
      this.position.y = 2;
      this.dimensions.height = -2;
      this.player_can_hang_on_this = true;
      this.can.jump_to = true;
      this.can.jump_from = false;
      this.can.swing_from = true;
      this.can.swing_to = true;
      this.can.swing_on = true;
      this.can.swing_on_if_nested = true;
      this.can.swing_on_if_holding = true;
      this.can.swing_on_if_holding_and_supported = true;

      this.default_aspect_for_climb = "on";
      this.default_posture_for_jump_to = "hang";
      this.default_aspect_for_jump_to = "on";
      this.default_posture_for_jump_to = "hang";
      this.default_aspect_for_jump_to = "on";

      this.must.let_go_after_swing = true;

      this.aspects.on.set({
        player: { posture: "hang" },
      });
    }
  }

  adventurejs.ClimbableVine = ClimbableVine;
})();

// Ladder.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Climbable.Ladder
   * @augments adventurejs.Climbable
   * @class adventurejs.Ladder
   * @ajsconstruct MyGame.createAsset({ "class":"Ladder", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary It's bad luck to walk under it.
   * @classdesc
   * <p>
   * <strong>Ladder</strong> is a subclass of
   * {@link adventurejs.Climbable|Climbable}.
   * Player can climb on/to/from, and step on to climb.
   * </p>
   **/
  class Ladder extends adventurejs.Climbable {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Ladder";

      this.singlePluralPairs = [["ladder", "ladders"]];
      this.group = ["tools"];
      this.dimensions.height = 2;

      this.default_aspect_for_climb = "on";
      this.quirks.climb_means_go_on = false;

      this.aspects.on.set({
        player: { posture: "stand" },
      });
    }
  }

  adventurejs.Ladder = Ladder;
})();

// Staircase.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Climbable.Staircase
   * @augments adventurejs.Climbable
   * @class adventurejs.Staircase
   * @ajsconstruct MyGame.createAsset({ "class":"Staircase", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A stairway to heaven?
   * @classdesc
   * <p>
   * <strong>Staircase</strong> is a subclass of
   * {@link adventurejs.Climbable|Climbable}.
   * Player can climb on/to/from, and step on to climb.
   * </p>
   **/
  class Staircase extends adventurejs.Climbable {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Staircase";

      this.singlePluralPairs = [
        ["stairs", "stairs"],
        ["staircase", "staircases"],
      ];
      this.group = [];
      this.dimensions.height = 2;

      this.default_aspect_for_climb = "on";
      this.quirks.climb_means_go_on = true;

      this.aspects.on.set({
        player: { posture: "stand" },
      });
    }
  }
  adventurejs.Staircase = Staircase;
})();

// Stalactite.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Climbable.Stalactite
   * @augments adventurejs.Climbable
   * @class adventurejs.Stalactite
   * @ajsconstruct MyGame.createAsset({ "class":"Stalactite", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading UndergroundClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary It clings tight to the ceiling.
   * @classdesc
   * <p>
   * <strong>Stalactite</strong> is a subclass of
   * {@link adventurejs.Climbable|Climbable}.
   * It hangs down from the ceiling and
   * player can climb on/to/from.
   * See its position.y and its height
   * properties in this example.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Stalactite",
   *   name: "stalactite",
   *   place: { in: "Cave" },
   *   descriptions: { look: "It's a stalactite. ", },
   *   position: { x:0, y:3, z:0 },
   *   height: -1,
   *   quirks.let_go_of_means_go_off: true,
   *   things_player_can_reach_from_this: [ "vine" ],
   * });
   * </code></pre>
   * <p>
   * See that the stalactite's position.y is 3 units high, presumably
   * at ceiling height, and that its height is -1, meaning that
   * it hangs down 1 unit from the ceiling and reaches to 2 units
   * above the ground, out of reach of the player.
   * </p>
   **/
  class Stalactite extends adventurejs.Climbable {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Stalactite";

      this.singlePluralPairs = [["stalactite", "stalactites"]];
      this.position.y = 2;
      this.dimensions.height = -1;
      this.player_can_hang_on_this = true;

      this.default_aspect_for_climb = "on";
      //this.quirks.climb_means_go_on = false;
      this.default_posture_for_swing_to = "hang";
      this.default_aspect_for_swing_to = "on";

      this.is.listed_in_room = false;

      this.aspects.on.set({
        player: { posture: "hang" },
        orientation: "vertical",
      });
    }
  }
  adventurejs.Stalactite = Stalactite;
})();

// Tree.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Climbable.Tree
   * @augments adventurejs.Climbable
   * @class adventurejs.Tree
   * @ajsconstruct MyGame.createAsset({ "class":"Tree", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ForestClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary One grows in Brooklyn.
   * @ajstangiblecontainer on
   * @classdesc
   * <p>
   * <strong>Tree</strong> is a subclass of
   * {@link adventurejs.Climbable|Climbable}.
   * Player can climb on/to/from, and swing to.
   * </p>
   **/
  class Tree extends adventurejs.Climbable {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Tree";

      this.singlePluralPairs = [["tree", "trees"]];
      this.group = [];
      this.dimensions.height = 3;
      this.can.jump_to = true;
      this.can.jump_from = true;
      this.can.swing_to = true;
      this.is.climbable = true;

      this.default_posture_for_swing_to = "hang";

      this.setDOV("hang");

      this.aspects.on.set({
        list_in_room: true,
        player: { posture: "hang" },
      });

      this.aspects.hung = new adventurejs.Aspect("hung", this.game_name).set({
        parent_id: this.id,
        list_in_room: true,
      });
    }
  }
  adventurejs.Tree = Tree;
})();

// Clothing.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Clothing
   * @augments adventurejs.Thing
   * @class adventurejs.Clothing
   * @ajsconstruct MyGame.createAsset({ "class":"Clothing", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ClothingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Clothes make the [wo]man.
   * @classdesc
   * <p>
   * The primary characteristic of <strong>Clothing</strong>
   * is that it can be worn. Worn {@link adventurejs.Asset|Assets}
   * go {@link adventurejs.Aspect|in}
   * {@link adventurejs.Player|Player} inventory, but they are
   * treated a bit differently by some {@link adventurejs.Verb|Verb}
   * actions. For example, worn Assets are excluded from
   * <code class="property">all</code> by verbs including
   * <code class="property">drop all</code>,
   * <code class="property">put all</code>, and
   * <code class="property">give all</code>, and others.
   * </p>
   */
  class Clothing extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Clothing";

      this.setDOVs([
        "wear",
        "remove",
        "tear",
        "take",
        "give",
        "drop",
        "throw",
        "put",
      ]);

      this.can_wear = true;

      this.on_tie_to_this_take_this = true;
      this.on_tie_to_drag_behind_rope = true;
    }
  }

  adventurejs.Clothing = Clothing;
})();

// Scrunchy.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Clothing.Scrunchy
   * @augments adventurejs.Clothing
   * @class adventurejs.Scrunchy
   * @ajsconstruct MyGame.createAsset({ "class":"Scrunchy", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ClothingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Bringing back the man bun.
   * @classdesc
   * <p>
   * <strong>Scrunchy</strong> is a subclass of
   * {@link adventurejs.Clothing|Clothing}, meaning it can be worn.
   * </p>
   **/
  class Scrunchy extends adventurejs.Clothing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Scrunchy";
    }
  }

  adventurejs.Scrunchy = Scrunchy;
})();

// Coathook.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Coathook
   * @augments adventurejs.Thing
   * @class adventurejs.Coathook
   * @ajsconstruct MyGame.createAsset({ "class":"Coathook", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A place to hang your hat. And coat, of course.
   * @ajstangiblecontainer on
   * @classdesc
   * <p>
   * <strong>Coathook</strong> is a simple subclass of
   * {@link adventurejs.Thing|Thing} that can have things
   * hung on it. By default it does not exclude anything
   * from being hung, which might lead to players hanging
   * odd things. See the example below for an example of
   * how to restrict a Coathook to cloathing.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Coathook",
   *   name: "coathook",
   *   synonyms: "hook",
   *   place: { in: "Foyer" },
   *   descriptions: { look: "It's a coathook. ", },
   *   aspects: { on: {
   *     with_classes: ["Clothing"]
   *   }, },
   * });
   * </code></pre>
   * <p>
   * It's also possible to allow only certain objects
   * to be hung.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Coathook",
   *   name: "coathook",
   *   place: { in: "Foyer" },
   *   descriptions: { look: "It's a coathook. ", },
   *   on: {
   *     with_assets: ["burberry coat", "mackintosh coat"]
   *   }
   * });
   * </code></pre>
   * <p>
   * The above example uses
   * <code class="property">with_classes</code>
   * and <code class="property">with_assets</code>
   * to limit what a
   * player can put in without having to write custom
   * failure code for every object. To learn more, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   **/
  class Coathook extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Coathook";
      this.setIOVs(["put", "hang", "take", "tie"]);
      this.can.hang_things_on_this = true;
      this.is.listed_in_room = false;
      this.aspects.on = new adventurejs.Aspect("on", this.game_name).set({
        parent_id: this.id,
        maxcount: 1,
      });
    }
  }

  adventurejs.Coathook = Coathook;
})();

// Coatrack.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Coatrack
   * @augments adventurejs.Thing
   * @class adventurejs.Coatrack
   * @ajsconstruct MyGame.createAsset({ "class":"Coatrack", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A place to hang your coat. And hat, of course.
   * @ajstangiblecontainer on
   * @classdesc
   * <p>
   * <strong>Coatrack</strong> is a simple subclass of
   * {@link adventurejs.Thing|Thing} that can have things
   * hung on it. By default it does not exclude anything
   * from being hung, which might lead to players hanging
   * odd things. See the example below for an example of
   * how to restrict a Coatrack to cloathing.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Coatrack",
   *   name: "coatrack",
   *   synonyms: "rack",
   *   place: { in: "Foyer" },
   *   descriptions: { look: "It's a coatrack. ", },
   *   aspects: { on: {
   *     with_classes: ["Clothing"]
   *   }, },
   * });
   * </code></pre>
   * <p>
   * It's also possible to allow only certain objects
   * to be hung.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Coatrack",
   *   name: "coatrack",
   *   place: { in: "Foyer" },
   *   descriptions: { look: "It's a coatrack. ", },
   *   on: {
   *     with_assets: ["burberry coat", "mackintosh coat"]
   *   }
   * });
   * </code></pre>
   * <p>
   * The above example uses <code class="property">with_classes</code>
   * and <code class="property">with_assets</code> to limit what a
   * player can put in without having to write custom
   * failure code for every object. To learn more, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   **/
  class Coatrack extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Coatrack";
      this.setIOVs(["put", "hang", "take", "tie"]);
      this.can.hang_things_on_this = true;
      this.is.listed_in_room = true;
      this.aspects.on = new adventurejs.Aspect("on", this.game_name).set({
        parent_id: this.id,
        maxcount: 4,
      });
    }
  }

  adventurejs.Coatrack = Coatrack;
})();

// Container.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container
   * @augments adventurejs.Thing
   * @class adventurejs.Container
   * @ajsconstruct MyGame.createAsset({ "class":"Container", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Thing to put things in.
   * @classdesc
   * <p>
   * <strong>Container</strong> is the base class for
   * {@link adventurejs.GasContainer|GasContainers},
   * {@link adventurejs.LiquidContainer|LiquidContainers},
   * {@link adventurejs.SolidContainer|SolidContainers}, and
   * {@link adventurejs.SurfaceContainer|SurfaceContainers}.
   * Container has no particular properties - each of the
   * subclasses define unique properties.
   * </p>
   **/
  class Container extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Container";

      this.is.hollow = true;
      this.default_aspect = "in";
    }

    initialize(game) {
      super.initialize(game);
      return this;
    }
  }
  adventurejs.Container = Container;
})();

// GasContainer.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.GasContainer
   * @augments adventurejs.Container
   * @class adventurejs.GasContainer
   * @ajsconstruct MyGame.createAsset({ "class":"GasContainer", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary For propane tanks, helium tanks, and the like.
   * @classdesc
   * <p>
   * <strong></strong>
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class GasContainer extends adventurejs.Container {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "GasContainer";

      this.Container_constructor(name, game_name);
      this.is.airtight = true;
      this.is.sealed = true; // might not be true but starting here
    }
  }
  adventurejs.GasContainer = GasContainer;
})();

// LiquidContainer.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.LiquidContainer
   * @augments adventurejs.Container
   * @class adventurejs.LiquidContainer
   * @ajsconstruct MyGame.createAsset({ "class":"Tub", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A base class for all kinds of containers which hold liquid.
   * @ajssubstancecontainer in
   * @ajstangiblecontainer in
   * @classdesc <strong>LiquidContainer</strong> is a child class
   * of {@link adventurejs.Container|Container} and the ancestor class for
   * all types of containers that hold liquid (or other substances).
   * It can be filled, emptied, poured from, drunk from. LiquidContainers
   * can be set with a fixed maximum volume,
   * and variable volume and substance. Substance volumes
   * are set in mililiters by default. See the example below to create
   * a new LiquidContainer.
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "LiquidContainer",
   *   name: "dog dish",
   *   descriptions: { look: "That's Fido's water bowl! ", },
   *   in: {
   *     vessel: {
   *       volume: 500,
   *       maxvolume: 1000,
   *       substance_id: "water",
   *     }
   *   },
   * });
   * </code></pre>
   * Before working with LiquidContainers, it's useful to understand
   * the structure of nested {@link adventurejs.Asset|Assets}. All
   * {@link adventurejs.Tangible|Tangible}
   * Assets can have multiple
   * {@link adventurejs.Aspect|Aspects}
   * that correspond to in/on/under/behind/attached.
   * Aspects allow players to put Tangible things
   * in other Tangible things.
   * {@link adventurejs.Substance|Substances} differ from Tangibles
   * in that they are not singular, but rather exist in quantities
   * that can be poured, filled,
   * emptied, and divided. For example: water, milk, sand,
   * dirt, and mercury are all Substances.
   * In order for a Tangible to hold a
   * Substance, Tangible.Aspect has nested in it a
   * {@link adventurejs.Vessel|Vessel}.
   * SubstanceLocations have their own set of properties and methods
   * for dealing with Substances.
   * <br><br>
   * Most of the pouring and filling is handled
   * automatically by internal methods, but this might make
   * for a bit of confusion if you're custom coding
   * SubstanceLocations at runtime. For example, here's how
   * you would set a bowl filled with milk:
   * <pre class="display"><code class="language-javascript">MyGame.world.my_bowl.aspects.in.vessel.substance_id = "milk";
   * MyGame.world.my_bowl.aspects.in.vessel.volume = 500;
   * </code></pre>
   **/
  class LiquidContainer extends adventurejs.Container {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "LiquidContainer";

      this.setDOVs(["fill", "empty", "pour", "drink"]);
      this.setIOVs(["fill", "empty", "pour"]);

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
      });

      this.aspects.in.vessel = new adventurejs.Vessel("in", game_name).set({
        parent_id: this.id,
      });

      this.onPourLiquidOutOfMe = function LiquidContainer_onPourLiquidOutOfMe(
        id
      ) {
        console.log(this.name, "onPourLiquidOutOfMe", id);
      };

      this.doPourLiquidOutOfMe = {};

      this.onPourLiquidIntoMe = function LiquidContainer_onPourLiquidIntoMe(
        id
      ) {
        console.log(this.name, "onPourLiquidIntoMe", id);
      };

      this.doPourLiquidIntoMe = {};
    }

    initialize(game) {
      super.initialize(game);
      return this;
    }
  }
  adventurejs.LiquidContainer = LiquidContainer;
})();

// SolidContainer.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.SolidContainer
   * @augments adventurejs.Container
   * @class adventurejs.SolidContainer
   * @ajsconstruct MyGame.createAsset({ "class":"SolidContainer", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A container for solid substances.
   * @ajstangiblecontainer in
   * @todo Is this a useful class?
   * @classdesc
   * <p>
   * <strong></strong>
   * </p>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class SolidContainer extends adventurejs.Container {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "SolidContainer";

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
      });
    }
  }
  adventurejs.SolidContainer = SolidContainer;
})();

// SurfaceContainer.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.SurfaceContainer
   * @augments adventurejs.Container
   * @class adventurejs.SurfaceContainer
   * @ajsconstruct MyGame.createAsset({ "class":"SurfaceContainer", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajstangiblecontainer on
   * @summary A simple base class with a surface.
   * @classdesc <strong>SurfaceContainer</strong> is a simple
   * child class of {@link adventurejs.Container|Container},
   * with only one additional property, which is that you can put other
   * things on it. In practice, any {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset} can be made into a surface
   * simply by giving it a
   * {@link adventurejs.Aspect|Aspect}.
   **/
  class SurfaceContainer extends adventurejs.Container {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "SurfaceContainer";

      this.default_aspect = "on";

      this.aspects.on = new adventurejs.Aspect("on", this.game_name).set({
        parent_id: this.id,
        list_in_room: true,
        list_in_examine: true,
        maxheight: 6,
        maxwidth: 6,
        maxdepth: 6,
        maxcount: 10,
        maxsize: 20,
        maxweight: 100,
        player: { can: { enter: true, stand: true, exit: false } },
      });
    }
  }

  adventurejs.SurfaceContainer = SurfaceContainer;
})();


// Bowl.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.LiquidContainer.Bowl
   * @augments adventurejs.LiquidContainer
   * @class adventurejs.Bowl
   * @ajsconstruct MyGame.createAsset({ "class":"Bowl", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading KitchenClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Waiter, there's a fly in my soup!
   * @tutorial Tangibles_AboutTangibles
   * @classdesc <strong>Bowl</strong> is child class of
   * {@link adventurejs.Container|Container} /
   * {@link adventurejs.LiquidContainer|LiquidContainer}.
   * It can hold liquids (or other fluid substances),
   * be filled, emptied, poured from, drunk from.
   * See the example below to set
   * a container's volume, maxvolume, and substance.
   * See {@link adventurejs.LiquidContainer|LiquidContainer} for
   * more information about how substances are handled under the hood.
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Bowl",
   *   name: "dog dish",
   *   descriptions: { look: "That's Fido's water bowl! ", },
   *   in: {
   *     vessel: {
   *       volume: 500,
   *       maxvolume: 1000,
   *       substance_id: "water",
   *     }
   *   },
   * });
   * </code></pre>
   **/
  class Bowl extends adventurejs.LiquidContainer {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Bowl";

      this.noun = "bowl";
      this.plural = "bowls";
      this.singlePluralPairs = [["bowl", "bowls"]];

      this.setDOVs(["take", "give", "put"]);

      this.aspects.in.vessel.maxvolume = 500;
      this.aspects.in.vessel.can_overflow = true;
    }
  }
  adventurejs.Bowl = Bowl;
})();

// Chalice.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.LiquidContainer.Chalice
   * @augments adventurejs.LiquidContainer
   * @class adventurejs.Chalice
   * @ajsconstruct MyGame.createAsset({ "class":"Chalice", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading TreasureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary You have chosen wisely.
   * @classdesc <strong>Chalice</strong> is child class of
   * {@link adventurejs.Container|Container} /
   * {@link adventurejs.LiquidContainer|LiquidContainer}.
   * It can hold liquids (or other fluid substances),
   * be filled, emptied, poured from, drunk from.
   * This Chalice class is set to have an infinite volume of water,
   * so it never empties.
   * See {@link adventurejs.LiquidContainer|LiquidContainer} for
   * more information about how substances are handled under the hood.
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Chalice",
   *   name: "carpenter's cup",
   *   descriptions: { look: "Now this is the cup of a carpenter. ", },
   *   in: {
   *     vessel: {
   *       volume: Infinity,
   *       maxvolume: Infinity,
   *       substance_id: "water",
   *     }
   *   },
   * });
   * </code></pre>
   **/
  class Chalice extends adventurejs.LiquidContainer {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Chalice";

      this.noun = "chalice";
      this.plural = "chalices";
      this.singlePluralPairs = [["chalice", "chalices"]];

      this.setDOVs(["take", "give", "put"]);

      this.aspects.in.vessel.volume = Infinity;
      this.aspects.in.vessel.maxvolume = Infinity;
    }
  }
  adventurejs.Chalice = Chalice;
})();

// Drainable_Is.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.StateManager.Asset_Is.Tangible_Is.Drainable_Is
   * @augments adventurejs.Tangible_Is
   * @class adventurejs.Drainable_Is
   * @ajsnavheading StateClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary A container for state variables.
   * @classdesc
   * <p>
   * <strong>Drainable_Is.js</strong> handles is.state management for
   * {@link adventurejs.Drainable|Drainable Assets}.
   **/

  class Drainable_Is extends adventurejs.Tangible_Is {
    constructor(name = "is", game_name, parent_id) {
      // Call the constructor of the parent class
      super(name, game_name, parent_id);
      this.class = "Drainable_Is";
      this._plugged = false;
      return this;
    }

    /**
     * <code>plugged</code> indicates whether the object is plugged
     * via the verb plug. The Drainable class handles plugged
     * distinctly from other classes, because a Drainable instance
     * may be set so that substances drain out of it, or it may be
     * linked to a separate asset that acts as its drain. This
     * sounds confusing, so here's an example: imagine an author
     * wants to make a sink that users can plug and unplug with a
     * stopper. Fair enough, and we can set that sink.is.plugged.
     * Now, imagine an author wants players to be able to interact
     * with the sink and the drain as distinct objects; in this
     * case the author would link a Drain asset to the Sink asset.
     * In the latter scenario, checking plugged on the sink
     * would actually return the plugged value of the drain.
     * @var {Boolean} adventurejs.Drainable#is!plugged
     * @default false
     */
    get plugged() {
      let parent = this.parent;
      if (parent.registered_parts?.Drain) {
        let drain = this.game.getAsset(parent.registered_parts.Drain);
        return drain.is.plugged;
      } else return this._plugged;
    }
    set plugged(value) {
      let parent = this.parent;
      if (parent.registered_parts?.Drain) {
        let drain = this.game.getAsset(parent.registered_parts.Drain);
        drain.is.plugged = value;
      } else this._plugged = value;
    }
  }
  adventurejs.Drainable_Is = Drainable_Is;
})();

// Drainable.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.LiquidContainer.Drainable
   * @augments adventurejs.LiquidContainer
   * @class adventurejs.Drainable
   * @ajsconstruct MyGame.createAsset({ "class":"Drainable", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajsparts Faucet, GraduatedController, Drain, Plug
   * @summary Ancestor class for Sinks and Bathtubs.
   * @ajssubstancecontainer in
   * @ajstangiblecontainer in
   * @ajstangiblecontainer attached
   * @classdesc
   * <p>
   * <strong>Drainable</strong> is a subsclass of
   * {@link adventurejs.Container|Container} /
   * {@link adventurejs.LiquidContainer|LiquidContainer},
   * and the ancestor class for
   * {@link adventurejs.Sink|Sink} and
   * {@link adventurejs.Bathtub|Bathtub} and other basins.
   * You wouldn't construct a Drainable directly, but you can
   * subclass it to create new types of Drainables.
   * </p>
   * <p>
   * Drainables can be easily linked with
   * {@link adventurejs.Faucet|Faucets},
   * {@link adventurejs.Handle|Handles},
   * {@link adventurejs.Drain|Drains} and
   * {@link adventurejs.Plug|Plugs}
   * through the use of the
   * <code class="property">{@link adventurejs.Tangible#parts|parts}</code>
   * property,
   * a special convenience property that can be used to link some
   * {@link adventurejs.Asset|Asset} classes to other Asset classes.
   * To learn more about which classes can be linked with
   * <code class="property">parts</code>, see <a href="/doc/Tangibles_LinkedAssets.html">Linked Assets</a>.
   * </p>
   **/
  class Drainable extends adventurejs.LiquidContainer {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Drainable";

      this.noun = "drainable";
      this.plural = "drainables";
      this.singlePluralPairs = [["drainable", "drainables"]];

      this.is = new adventurejs.Drainable_Is("is", this.game_name, this.id).set(
        {
          parent_id: this.id,
        }
      );

      this.unsetDOVs(["take", "give", "put"]);
      this.setDOVs(["fill", "empty", "turn", "drink", "pour"]);

      this.default_aspect = "in";
      this.aspects.attached = new adventurejs.Aspect(
        "attached",
        this.game_name
      ).set({
        parent_id: this.id,
        list_in_examine: false,
        list_in_room: false,
        player_can_add_assets_to_contents: false,
        player_can_remove_assets_from_contents: false,
      });

      this.registerableClasses = {
        Faucet: function (object) {
          this.registered_parts.Faucet = object.id;
          // this faucet = faucet
          // faucet sink = this
          // what else does a sink need to know about a faucet?
          // faucet is attached to sink

          object.setPlace("attached", this.id);
          object.aspects.in.vessel.target_id = this.id;
        },

        GraduatedController: function (object) {
          // this faucets push faucet
          // can have multiple handles
          // faucet sink = this
          // where do we ask about multiple inputs mixing?
          // is each handle worth a fraction of max_volume_of_flow_per_turn?
          if (
            "undefined" === typeof this.registered_parts.GraduatedControllers
          ) {
            this.registered_parts.GraduatedControllers = [];
          }
          this.registered_parts.GraduatedControllers.push(object.id);
          // handles are attached to sink... but don't need to be? shower handles/
          object.control_target_id = this.id;
          object.setPlace("attached", this.id);
        },

        Drain: function (object) {
          this.registered_parts.Drain = object.id;
          // this drain = drain
          // drain sink = this
          // what else does a sink need to know about a drain?
          // drain is attached to sink

          object.setPlace("attached", this.id);
        },

        Plug: function (object) {
          // this plugs push plug // can have multiple plugs
          if ("undefined" === typeof this.registered_parts.Plugs) {
            this.registered_parts.Plugs = [];
          }
          this.registered_parts.Plugs.push(object.id);
        },
      };

      this.linkRegisteredParts = function Drainable_linkRegisteredParts() {
        var drain;

        // link handles to faucet
        if (
          "undefined" !== typeof this.registered_parts.Faucet &&
          "undefined" !== typeof this.registered_parts.GraduatedControllers
        ) {
          var faucet = this.game.getAsset(this.registered_parts.Faucet);
          if (
            "undefined" === typeof faucet.registered_parts.GraduatedControllers
          ) {
            faucet.registered_parts.GraduatedControllers = [];
          }
          this.registered_parts.GraduatedControllers.forEach(function (id) {
            this.game.getAsset(id).control_target_id =
              this.registered_parts.Faucet;
            faucet.registered_parts.GraduatedControllers.push(id);
          }, this);
        }

        // link drain to sink
        if ("undefined" !== typeof this.registered_parts.Drain) {
          drain = this.game.getAsset(this.registered_parts.Drain);
          this.aspects.in.vessel.drain_id = drain.id;
        } else {
          drain = this;
        }

        // link plugs to drain
        if ("undefined" !== typeof this.registered_parts.Plugs) {
          //console.warn('drain',drain);
          this.registered_parts.Plugs.forEach(function (id) {
            var plug = this.game.getAsset(id);
            //console.warn('Drainable linkRegisteredParts plug',plug);

            // plug sink with plug
            // need to add verb connections

            drain.DOVsetWithAsset("plug", plug);
            // drain is direct object, should have plug as indirect connection

            // plug is indirect object, should have drain as direct connection
            plug.IOVsetWithAsset("plug", drain);

            // @TODO PLUGCHECK
          }, this);
        }
      }; // linkRegisteredParts

      this.dov.turn.doAfterTry = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var direct_preposition = input.getPreposition(1);

        // sentence structure: verb preposition noun
        if (input.hasStructure("verb preposition noun")) {
          if (direct_preposition === "on") return this.turnOn_doAfterTry();
          if (direct_preposition === "off") return this.turnOff_doAfterTry();
        } // verb preposition noun
      };

      this.turnOn_doAfterTry = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var msg = "";

        // nothing with which to turn the faucet on
        if (
          "undefined" ===
            typeof direct_object.registered_parts.GraduatedControllers ||
          0 === direct_object.registered_parts.GraduatedControllers.length
        ) {
          this.game.debug(
            `F1847 | Drainable.js | ${direct_object.id} has no GraduatedControllers `
          );
          msg += `$(We) can't turn on ${direct_object.articlename}. `;
          this.game.dictionary.verbs[params.verb].handleFailure(msg);
          return null;
        }
        // else if( 1 === direct_object.registered_parts.GraduatedControllers.length )
        else {
          var controllers = direct_object.registered_parts.GraduatedControllers;
          var controller_count = controllers.length;
          var rand = Math.floor(Math.random() * controller_count);
          var controller = this.game.getAsset(controllers[rand]);
          input.setAsset(1, controller);
          input.allow_circular_verb = true;
          this.game.dictionary.doVerb("turn");
          return null;
        }
      };

      this.turnOff_doAfterTry = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);

        // nothing with which to turn the faucet off
        if (
          "undefined" ===
          typeof direct_object.registered_parts.GraduatedControllers
        ) {
          this.game.debug(
            `F1846 | Drainable.js | ${direct_object.id} has no GraduatedControllers `
          );
          msg += `$(We) can't turn off ${direct_object.articlename}. `;
          this.game.dictionary.verbs[params.verb].handleFailure(msg);
          return null;
        }

        var controllers = direct_object.registered_parts.GraduatedControllers;
        var controller_count = controllers.length;
        var controllers_to_turn_off_count = 0;
        for (var c = 0; c < controller_count; c++) {
          var controller = this.game.getAsset(controllers[c]);
          if (0 < controller.current_position) {
            controllers_to_turn_off_count++;
            input.setAsset(1, controller);
            input.allow_circular_verb = true;
            this.game.dictionary.doVerb("turn");
          }
        }
        if (0 === controllers_to_turn_off_count) {
          var msg = direct_object.Articlename + " isn't on. ";
          this.game.dictionary.verbs[params.verb].handleFailure(msg);
        }
        return null;
      };
    }
  }
  adventurejs.Drainable = Drainable;
})();

// DrinkingGlass.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.LiquidContainer.DrinkingGlass
   * @augments adventurejs.LiquidContainer
   * @class adventurejs.DrinkingGlass
   * @ajsconstruct MyGame.createAsset({ "class":"DrinkingGlass", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading KitchenClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary My partner will high-dive into this ordinary glass o' water.
   * @classdesc
   * <p>
   * <strong>DrinkingGlass</strong> is a subclass of
   * {@link adventurejs.LiquidContainer|LiquidContainer}.
   * Player can drink from it, pour from it, pour into it.
   * It has low opacity so it can be seen through.
   * Authors can set a maximum volume / current volume
   * for DrinkingGlass.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "DrinkingGlass",
   *   name: "crystal goblet",
   *   descriptions: { look: "It's a crystal goblet. Not the cup of a carpenter. ", },
   *   in: {
   *     vessel: {
   *       maxvolume: 1000,
   *       volume: 500,
   *       substance_id: "wine",
   *     },
   *   },
   * });
   * </code></pre>
   **/
  class DrinkingGlass extends adventurejs.LiquidContainer {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "DrinkingGlass";

      this.noun = "glass";
      this.plural = "glasses";
      this.singlePluralPairs = [["glass", "glasses"]];
      this.adjectives = ["drinking"];

      this.setDOVs(["take", "give", "put"]);

      this.dimensions.opacity = 0.1;
      this.aspects.in.vessel.maxvolume = 500;
    }
  }
  adventurejs.DrinkingGlass = DrinkingGlass;
})();

// DrinkingMug.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.LiquidContainer.DrinkingMug
   * @augments adventurejs.LiquidContainer
   * @class adventurejs.DrinkingMug
   * @ajsconstruct MyGame.createAsset({ "class":"DrinkingMug", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading KitchenClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajssubstancecontainer in
   * @ajstangiblecontainer in
   * @ajstangiblecontainer attached
   * @summary A place for your coffee.
   * @classdesc
   * <p>
   * <strong>DrinkingMug</strong> is a subclass of
   * {@link adventurejs.LiquidContainer|LiquidContainer}.
   * Player can drink from it, pour from it, pour into it.
   * Authors can set a maximum volume / current volume
   * for DrinkingMug. DrinkingMug isn't very
   * different from
   * {@link adventurejs.DrinkingGlass|DrinkingGlass}
   * apart from it's opaque, and has a
   * {@link adventurejs.Aspect|Aspect}
   * that lets you optionally attach a handle to it.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "DrinkingMug",
   *   name: "ugly mug",
   *   descriptions: { look: "It's a stained porcelain mug with a chipped handle. ", },
   *   in: {
   *     vessel: {
   *       maxvolume: 500,
   *       volume: 250,
   *       substance_id: "coffee",
   *     },
   *   },
   * });
   * </code></pre>
   * <p>
   * Notice how the description of the mug refers to a handle.
   * In real life a mug would have a handle, and your player
   * might be prompted to input <code class="property">examine handle</code>.
   * Maybe that's more detail than you care about, or maybe
   * you like that sort of fiddly detail. It's your choice.
   * To give a mug a handle that players can refer to, but which
   * they can't necessarily  manipulate on its own, you can create
   * a unique {@link adventurejs.Asset|Asset}
   * and attach it to the DrinkingMug, as in the next example.
   * We haven't created a special mug handle class, so in this
   * example we're making an instance of the
   * {@link adventurejs.Thing|Thing} class, which is a low level
   * class used for most of the manipulatable objects
   * in the game world. Note the
   * <code class="property">thing_this_is_attached</code>
   * property.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Thing",
   *   name: "chipped handle",
   *   descriptions: { look: "The mug's handle is cracked but serviceable. ", },
   *   place: { attached: "ugly mug" },
   * });
   * </code></pre>
   **/
  class DrinkingMug extends adventurejs.LiquidContainer {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "DrinkingMug";

      this.descriptions.look = "It's a coffee mug.";
      this.noun = "mug";
      this.plural = "mugs";
      this.singlePluralPairs = [["mug", "mugs"]];
      this.adjectives = ["coffee"];

      this.setDOVs(["take", "give", "put"]);

      this.aspects.attached = new adventurejs.Aspect(
        "attached",
        this.game_name
      ).set({
        enabled: true,
        list_in_room: false,
        list_in_examine: false,
        player_can_add_assets_to_contents: false,
        player_can_remove_assets_from_contents: false,
      });

      // this.parts.handle = {
      //     adjectives: "",
      //     descriptions: { look: "There's nothing special about the mug's handle.", },
      //     nouns: "handle",
      // };

      this.aspects.in.vessel.maxvolume = 500;
    }
  }
  adventurejs.DrinkingMug = DrinkingMug;
})();

// Bathtub.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.LiquidContainer.Drainable.Bathtub
   * @augments adventurejs.Drainable
   * @class adventurejs.Bathtub
   * @ajsconstruct MyGame.createAsset({ "class":"Bathtub", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BathroomClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajsparts Faucet, GraduatedController, Drain, Plug
   * @summary Rub a dub dub.
   * @tutorial Substances_Vessels
   * @tutorial Tangibles_LinkedAssets
   * @tutorial Tangibles_Collections
   * @classdesc
   * <p>
   * <strong>Bathtub</strong> is a subclass of
   * {@link adventurejs.Drainable|Drainable}.
   * A Bathtub can be linked with a
   * {@link adventurejs.Faucet|Faucet} and
   * {@link adventurejs.FaucetHandle|Handles} and a
   * {@link adventurejs.Drain|Drain} and
   * {@link adventurejs.Plug|Plug}
   * through the use of the
   * <code class="property">{@link adventurejs.Tangible#parts|parts}</code>
   * property.
   * </p>
   * <p>
   * Note that <code class="property">parts</code>
   * is a special convenience property that only pertains to some
   * {@link adventurejs.Asset|Asset} classes with inherent code
   * for linking certain other Asset classes.
   * To learn more about which classes can be linked through the
   * <code class="property">parts</code> property, see <a href="/doc/Tangibles_LinkedAssets.html">Linked Assets</a>.
   * </p>
   * <p>
   * Following is an example of a Bathtub with
   * Handles, a Drain and Plug, and a Faucet.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Bathtub",
   *   name: "bathtub",
   *   place: { in: "Standing Room" },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "A clawfoot tub with porcelain handles
   *       and a stainless steel faucet. Its drain appears to
   *       be $( bathtub drain is| open or| closed ). ";
   *       // see <a href="/doc/Scripting_CustomTemplates.html">Custom Templates</a>
   *     },
   *   },
   *   in: {
   *     vessel: {
   *       drain_id: "bathtub drain",
   *     }
   *   },
   *   parts: [
   *     "hot water handle",
   *     "cold water handle",
   *     "faucet",
   *     "drain",
   *     "plug"
   *   ],
   * });
   *
   * MyGame.createAsset({
   *   class: "Drain", // see {@link adventurejs.Drain|Drain} class
   *   name: "bathtub drain",
   *   synonyms: "bathtub drain",
   *   is: { open: true, },
   *   dov: { open: true, close: true, },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "A dark drain. Currently
   *       $( bathtub drain is| open or| closed ). "
   *     },
   *   },
   * });
   *
   * MyGame.createAsset({
   *   class: "Faucet", // see {@link adventurejs.Faucet|Faucet} class
   *   name: "faucet",
   *   descriptions: { look: "The bathtub faucet. ", },
   *   substance_id: "water",
   *   max_volume_of_flow_per_turn: 1000,
   * });
   *
   * MyGame.createAsset({
   *   class: "FaucetHandle", // see {@link adventurejs.FaucetHandle|FaucetHandle} class
   *   name: "hot water handle",
   *   synonyms: [ "handle", "bathtub handle" ],
   *   adjectives: [ "hot water", "bathtub", "porcelain" ],
   *   descriptions: { look: "The bathtub's hot water handle. ", },
   *   set_substance_id: "hot water",
   *   set_substance_temperature: 70
   * });
   *
   * MyGame.createAsset({
   *   class: "FaucetHandle",
   *   name: "cold water handle",
   *   descriptions: { look: "The bathtub's cold water handle. ", },
   *   set_substance_id: "cold water",
   *   set_substance_temperature: 20
   * });
   *
   * MyGame.createAsset({
   *   class: "Collection", // see {@link adventurejs.Collection|Collection} class
   *   name: "bathtub handles",
   *   synonyms: [ "porcelain handles" ],
   *   place: { attached: "bathtub" },
   *   collection: [ "hot water handle", "cold water handle"],
   *   is: { listed_in_parent: false },
   *   descriptions: { look: "Two porcelain bathtub handles, hot and cold. ", },
   * });
   *
   * MyGame.createAsset({
   *   class: "Plug",
   *   name: "bathtub plug",
   *   synonyms: "plug",
   *   place: { in: "bathtub" },
   *   descriptions: { look: "A bathtub drain plug. ", },
   * });
   * </code></pre>
   * <p>
   * The above example uses $(string) substitutions to
   * create a dynamic description. To learn more, see
   * <a href="/doc/Scripting_CustomTemplates.html">Custom Templates</a>.
   * </p>
   *
   * **/
  class Bathtub extends adventurejs.Drainable {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Bathtub";

      this.noun = "bathtub";
      this.plural = "bathtubs";
      this.synonyms = ["tub"];
      this.singlePluralPairs = [["bathtub", "bathtubs"]];

      this.setIOVs(["fill", "empty", "drink", "pour"]);
      this.setDOVs(["fill", "empty"]);

      this.default_aspect = "in";

      this.can.jump_in = true;

      // this.aspects.attached.set({
      // });

      this.aspects.in.set({
        list_in_examine: true,
        list_in_room: false,
        maxheight: 2,
        maxwidth: 6,
        maxdepth: 2,
        maxcount: 10,
        maxsize: 2,
        maxweight: 100,

        player: {
          posture: "sit",
          preposition: "in",
          can: {
            enter: true,
            exit: false,
            hide: true,
            kneel: true,
            lie: true,
            sit: true,
            stand: true,
          },
        },
      });

      this.aspects.in.vessel.set({
        maxvolume: "200L",
      });
    }
  }
  adventurejs.Bathtub = Bathtub;
})();

// Sink.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.LiquidContainer.Drainable.Sink
   * @augments adventurejs.Drainable
   * @class adventurejs.Sink
   * @classdesc Explanation of the class.
   * @ajsconstruct MyGame.createAsset({ "class":"Sink", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajsparts Faucet, GraduatedController, Drain, Plug
   * @summary For bathrooms and kitchens.
   * @classdesc
   * <p>
   * <strong>Sink</strong> is a subclass of
   * {@link adventurejs.Drainable|Drainable}.
   * A Sink can be linked with a
   * {@link adventurejs.Faucet|Faucet} and
   * {@link adventurejs.FaucetHandle|Handles} and a
   * {@link adventurejs.Drain|Drain} and
   * {@link adventurejs.Plug|Plug}
   * through the use of the
   * <code class="property">{@link adventurejs.Tangible#parts|parts}</code>
   * property.
   * </p>
   * <p>
   * Note that <code class="property">parts</code>
   * is a special convenience property that only pertains to some
   * {@link adventurejs.Asset|Asset} classes with inherent methods
   * for linking certain other Asset classes.
   * To learn more about which classes can be linked through the
   * <code class="property">parts</code> property, see <a href="/doc/Tangibles_LinkedAssets.html">Linked Assets</a>.
   * </p>
   * <p>
   * Following is an example of a Sink with a
   * {@link adventurejs.Faucet|Faucet},
   * {@link adventurejs.FaucetHandle|Handles}, a
   * {@link adventurejs.Drain|Drain} and
   * {@link adventurejs.Plug|Plug}.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Sink",
   *   name: "sink",
   *   place: { in: "Standing Room" },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "A pedestal sink with porcelain handles
   *       and a stainless steel faucet. Its drain appears to
   *       be $( sink drain is| open or| closed ). ";
   *     },
   *   },
   *   in: {
   *     vessel: {
   *       drain_id: "sink drain",
   *     }
   *   },
   *   parts: [
   *     "hot water handle",
   *     "cold water handle",
   *     "faucet",
   *     "drain",
   *     "plug"
   *   ],
   * });
   * MyGame.createAsset({
   *   class: "Drain",
   *   name: "sink drain",
   *   synonyms: "sink drain",
   *   is: { open: true, },
   *   dov: { open: true, close: true, },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "A dark drain. Currently
   *       $( sink drain is| open or| closed ). "
   *     },
   *   },
   * });
   * MyGame.createAsset({
   *   class: "Faucet",
   *   name: "faucet",
   *   descriptions: { look: "The sink faucet. ", },
   *   substance_id: "water",
   *   max_volume_of_flow_per_turn: 1000,
   * });
   * MyGame.createAsset({
   *   class: "Handle",
   *   name: "hot water handle",
   *   synonyms: [ "handle", "sink handle" ],
   *   adjectives: [ "hot water", "sink", "porcelain" ],
   *   descriptions: { look: "The sink's hot water handle. ", },
   *   set_substance_id: "hot water",
   *   set_substance_temperature: 70
   * });
   * MyGame.createAsset({
   *   class: "Handle",
   *   name: "cold water handle",
   *   descriptions: { look: "The sink's cold water handle. ", },
   *   set_substance_id: "cold water",
   *   set_substance_temperature: 20
   * });
   * MyGame.createAsset({
   *   class: "Collection",
   *   name: "sink handles",
   *   synonyms: [ "porcelain handles" ],
   *   place: { attached: "sink" },
   *   collection: [ "hot water handle", "cold water handle"],
   *   is: { listed_in_parent: false },
   *   descriptions: { look: "Two porcelain sink handles, hot and cold. ", },
   * });
   * MyGame.createAsset({
   *   class: "Plug",
   *   name: "sink plug",
   *   synonyms: "plug",
   *   place: { in: "sink" },
   *   descriptions: { look: "A sink drain plug. ", },
   * });
   * </code></pre>
   * <p>
   * The above example uses $(string) substitutions to
   * create a dynamic description. To learn more, see
   * <a href="/doc/Scripting_CustomTemplates.html">Custom Templates</a>.
   * </p>
   **/
  class Sink extends adventurejs.Drainable {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Sink";

      this.noun = "sink";
      this.plural = "sinks";
      this.singlePluralPairs = [["sink", "sinks"]];
      this.default_aspect = "in";

      this.setDOVs(["turn", "plug"]);
      this.setDOV({ unplug: { with_nothing: true } });
      this.setIOVs(["put", "take"]);

      this.aspects.in.set({
        maxheight: 2,
        maxwidth: 2,
        maxdepth: 2,
        maxcount: 5,
        maxsize: 2,
        maxweight: 10,
        list_in_examine: true,
        list_in_room: true,
        player: { can: { enter: false } },
      });

      this.aspects.in.vessel.set({
        maxvolume: "4L",
      });
    }
  }
  adventurejs.Sink = Sink;
})();

// Chest.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.SolidContainer.Chest
   * @augments adventurejs.SolidContainer
   * @class adventurejs.Chest
   * @ajsconstruct MyGame.createAsset({ "class":"Chest", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading TreasureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Maybe there's gold inside! Arg a trap!
   * @ajstangiblecontainer in
   * @classdesc <strong>Chest</strong> is a subclass of
   * {@link adventurejs.Container|Container} /
   * {@link adventurejs.SolidContainer|SolidContainer}. Chests can be
   * locked and unlocked with a {@link adventurejs.Key|Key}
   * (or {@link adventurejs.Lockpick|Lockpick}).
   *
   * The interaction is determined by properties on both the
   * Chest and the Key.
   * The Chest will have the Key ID listed in its
   * <code class="property">asset.dov.unlock.with_assets</code>.
   * The Key will also have a list of Asset IDs it can unlock in its
   * <code class="property">asset.iov.unlock.with_assets</code>
   * property.
   * (You can set just one or the other in your game file.
   * As long as one is set, the Key and Lock will be associated during
   * initialization. )
   * See the example below to create locked chest with a key.
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Chest",
   *   name: "treasure chest",
   *   place: { in: "Treasure Room" },
   *   is: { locked: true },
   *   dov: { unlock: { with_assets: ['brass key'], }, },
   * });
   * MyGame.createAsset({
   *   class: "Key",
   *   name: "brass key",
   *   place: { in: "Treasure Room" },
   *   iov: { unlock: { with_assets: ['treasure chest'], }, },
   * });
   * </code></pre>
   **/
  class Chest extends adventurejs.SolidContainer {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Chest";

      this.noun = "chest";
      this.plural = "chests";
      this.singlePluralPairs = [["chest", "chests"]];

      this.unsetDOVs(["take", "put", "give"]); // depends on size of chest - up to author
      this.setDOVs(["close", "open"]);
      this.setDOV({
        unlock: { with_nothing: false },
      });
      this.setDOV({
        lock: { with_nothing: false },
      });

      this.is.closed = true;
      this.is.locked = true;

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
        list_in_examine: true,
        maxheight: 6,
        maxwidth: 6,
        maxdepth: 6,
        maxcount: 10,
        maxsize: 20,
        maxweight: 100,
      });
    }
  }

  adventurejs.Chest = Chest;
})();

// Drawer.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Container.SolidContainer.Drawer
   * @augments adventurejs.SolidContainer
   * @class adventurejs.Drawer
   * @ajsconstruct MyGame.createAsset({ "class":"Drawer", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Like you'd find in a desk.
   * @ajstangiblecontainer in
   * @classdesc
   * <p>
   * <strong>Drawer</strong> is a child class of
   * {@link adventurejs.Container|Container} /
   * {@link adventurejs.SolidContainer|SolidContainer}.
   * A Drawer can easily be attached to a
   * {@link adventurejs.Desk|Desk} (or any
   * {@link adventurejs.Tangible|Tangible}, really),
   * as in this example.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Desk",
   *   name: "desk",
   *   place: { in: "Office" },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "It's a heavy wooden desk, with an old office chair.
   *       It has three drawers stacked vertically. The top drawer is
   *       $( top drawer is| open or| closed ).";
   *     },
   *   },
   * });
   * MyGame.createAsset({
   *   class: "Drawer",
   *   name: "top drawer",
   *   descriptions: { look: "The top drawer is $( top drawer is| open or| closed ). ", },
   *   adjectives: "desk",
   *   place: { attached: "desk" },
   *   dov: { unlock: { with_assets: ['tiny brass key'], }, },
   *   is: { locked: true, listed_in_parent: false },
   * });
   * </code></pre>
   * <p>
   * The above example uses $(string) substitutions to
   * create a dynamic description. To learn more, see
   * <a href="/doc/Scripting_CustomTemplates.html">Custom Templates</a>.
   * </p>
   * <p>
   * While you can add multiple drawers to a desk,
   * that can lead to problems with disambiguation,
   * leading to player interactions like this one.
   * </p>
   * <pre class="display border outline"><code class="language-javascript">
   * <span class="input">&lt; examine drawers</span>
   * Which drawer do you mean? The top drawer, the middle drawer, or the bottom drawer?
   * </code></pre>
   * <p>
   * You can address this by creating a
   * {@link adventurejs.Collection|Collection}.
   * To learn more about Collections, see
   * <a href="/doc/Tangibles_Collections.html">Collections</a>.
   * </p>
   **/
  class Drawer extends adventurejs.SolidContainer {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Drawer";

      this.singlePluralPairs = [["drawer", "drawers"]];

      this.unsetDOVs(["take", "put", "give"]);
      this.setDOVs(["lock", "unlock"]);
      this.setDOV({ open: { with_nothing: true } });
      this.setDOV({ close: { with_nothing: true } });
      this.is.closed = true;
      this.is.hollow = true;
      this.is.locked = false;

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
        list_in_examine: true,
        maxheight: 1,
        maxwidth: 3,
        maxdepth: 2,
        maxcount: 10,
        maxsize: 4,
        maxweight: 5,
      });

      this.is.fixed = true;
      this.is.listed_in_room = false;
    }
  }

  adventurejs.Drawer = Drawer;
})();

// Control.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Control
   * @augments adventurejs.Thing
   * @class adventurejs.Control
   * @ajsconstruct MyGame.createAsset({ "class":"Control", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ControlClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Base class for controls of all kinds.
   * @tutorial Tangibles_Controllers
   * @classdesc
   * <p>
   * <strong>Control</strong> is a base class for things like
   * {@link adventurejs.Button|Buttons},
   * {@link adventurejs.Dial|Dials},
   * {@link adventurejs.Gauge|Gauges},
   * {@link adventurejs.Lever|Levers}, and
   * {@link adventurejs.Switch|Switches}.
   * Control has no particular properties - each of the
   * subclasses define unique properties.
   * </p>
   **/
  class Control extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Control";

      this.descriptions.look = "Control.";
      this.singlePluralPairs = [["control", "controls"]];
    }
  }

  adventurejs.Control = Control;
})();

// Button.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Control.Button
   * @augments adventurejs.Control
   * @class adventurejs.Button
   * @ajsconstruct MyGame.createAsset({ "class":"Button", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ControlClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Please don't press this button again.
   * @tutorial Tangibles_Controllers
   * @todo How to hook a button up to an action.
   * @classdesc
   * <p>
   * <strong>Button</strong> is a subclass of
   * {@link adventurejs.Control|Control} that can be
   * pushed or pressed.
   * </p>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class Button extends adventurejs.Control {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Button";

      this.singlePluralPairs = [["button", "buttons"]];

      this.setDOVs(["push", "press"]);
    }
  }
  adventurejs.Button = Button;
})();

// Dial.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Control.Dial
   * @augments adventurejs.Control
   * @class adventurejs.Dial
   * @ajsconstruct MyGame.createAsset({ "class":"Dial", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ControlClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Turn turn turn.
   * @tutorial Tangibles_Controllers
   * @classdesc
   * <p>
   * <strong>Dial</strong> is a subclass of
   * {@link adventurejs.Control|Control} that can be
   * turned or twisted.
   * </p>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class Dial extends adventurejs.Control {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Dial";

      this.singlePluralPairs = [["dial ", "dials"]];

      this.setDOVs(["turn", "twist"]);
    }
  }
  adventurejs.Dial = Dial;
})();

// Gauge.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Control.Gauge
   * @augments adventurejs.Control
   * @class adventurejs.Gauge
   * @ajsconstruct MyGame.createAsset({ "class":"Gauge", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ControlClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A tool of measurement.
   * @tutorial Tangibles_Controllers
   * @classdesc
   * <p>
   * <strong>Gauge</strong> is a subclass of
   * {@link adventurejs.Control|Control} that can be
   * tapped and read.
   * </p>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class Gauge extends adventurejs.Control {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Gauge";

      this.singlePluralPairs = [["gauge ", "gauges"]];

      this.setDOVs(["tap", "read"]);
    }
  }
  adventurejs.Gauge = Gauge;
})();

// Lever.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Control.Lever
   * @augments adventurejs.Control
   * @class adventurejs.Lever
   * @ajsconstruct MyGame.createAsset({ "class":"Lever", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ControlClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Pull the lever!
   * @tutorial Tangibles_Controllers
   * @classdesc
   * <p>
   * <strong>Lever</strong> is a subclass of
   * {@link adventurejs.Control|Control} that can be
   * pushed or pulled.
   * </p>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class Lever extends adventurejs.Control {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Lever";

      this.singlePluralPairs = [["lever ", "levers"]];

      this.setDOVs(["push", "pull"]);
    }
  }
  adventurejs.Lever = Lever;
})();

// Switch.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Control.Switch
   * @augments adventurejs.Control
   * @class adventurejs.Switch
   * @ajsconstruct MyGame.createAsset({ "class":"Switch", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ControlClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Flip the switch.
   * @tutorial Tangibles_Controllers
   * @classdesc
   * <p>
   * <strong>Switch</strong> is a subclass of
   * {@link adventurejs.Control|Control} that can be
   * pressed, pushed, pulled, toggled, flicked, or flipped.
   * </p>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class Switch extends adventurejs.Control {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Switch";

      this.singlePluralPairs = [["switch ", "switches"]];

      this.setDOVs(["press", "push", "pull", "toggle", "flick", "flip"]);
    }
  }
  adventurejs.Switch = Switch;
})();

// Doll.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Doll
   * @augments adventurejs.Thing
   * @class adventurejs.Doll
   * @ajsconstruct MyGame.createAsset({ "class":"Doll", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Not the kind you wear, but the kind you attach to another thing.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Doll</strong> is a subclass of
   * {@link adventurejs.Thing|Thing}
   * which can be attached to / detached from a parent.
   * {@link adventurejs.Asset|Assets}
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Doll",
   *   name: "Raggedy Ann",
   *   article: "",
   *   place: { on: "table" },
   *   descriptions: { look: "She's my dolly. ", },
   * });
   * </code></pre>
   **/
  class Doll extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Doll";

      this.singlePluralPairs = [["doll", "dolls"]];

      this.is.listed_in_parent = true;

      this.setDOVs([
        "put",
        "give",
        "take",
        "drop",
        "throw",
        "attach",
        "detach",
      ]);
      this.setIOVs(["attach", "detach"]);

      this.descriptions.look = "It's a doll.";
    }
  }

  adventurejs.Doll = Doll;
})();

// Drain.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Drain
   * @augments adventurejs.Thing
   * @class adventurejs.Drain
   * @ajsconstruct MyGame.createAsset({ "class":"Drain", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajspartof Sink
   * @ajsparts Plug
   * @summary Roto Rooter, that's the name, to send your troubles down the drain.
   * @tutorial Substances_Vessels
   * @tutorial Tangibles_LinkedAssets
   * @ajssubstancecontainer in
   * @ajstangiblecontainer in
   * @todo Implement parts:Plug separately for Drain.
   * @classdesc
   * <p>
   * <strong>Drain</strong> is a subclass of the simple generic
   * {@link adventurejs.Thing|Thing}. What makes it unique is its
   * container properties. Drain has a
   * {@link adventurejs.Aspect|Aspect} with a
   * {@link adventurejs.Vessel|Vessel}.
   * That part is typical - all Vessels reside inside
   * Aspects â what makes Drain unique is that its
   * Vessel has infinite capacity, and it can be linked
   * with another Vessel such as a
   * {@link adventurejs.Sink|Sink}
   * with a limited capacity, so
   * that when the Drain is plugged, the Sink fills, and when
   * Drain is unplugged, the Sink empties into the Drain.
   * </p>
   * <p>
   * A Drain can exist on its own, or a Drain can be
   * attached to a
   * {@link adventurejs.Sink|Sink} or
   * {@link adventurejs.Bathtub|Bathtub} or other
   * {@link adventurejs.Drainable|Drainable} subclass which itself
   * has a Vessel, such that the Drainable drains
   * via the Drain. A Drain can be plugged by a
   * {@link adventurejs.Plug|Plug} to allow the
   * linked Drainable to hold liquid.
   * </p>
   * <p>
   * Links between a Drain and Plug
   * can be created automatically through the use of the
   * <code class="property">parts</code> property. Note that
   * <code class="property">parts</code>
   * is a special convenience property that only pertains to some
   * classes with inherent code for making links.
   * To learn more about the <code class="property">parts</code>
   * property, see <a href="/doc/Tangibles_LinkedAssets.html">Linked Assets</a>.
   * </p>
   * <p>
   * Following is an example of a Drain with a
   * related Plug.
   * To see an example of a more complete
   * arrangement with a Drainable, Faucet, Handles, Drain
   * and Plug, see the {@link adventurejs.Sink|Sink class}.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Drain",
   *   name: "dank drain",
   *   descriptions: { look: "A dark drain. ", },
   *   parts: ["plug"],
   * });
   *
   * MyGame.createAsset({
   *   class: "Plug",
   *   name: "plug",
   *   synonyms: "plug",
   *   descriptions: { look: "A drain plug. ", },
   * });
   * </code></pre>
   **/
  class Drain extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Drain";

      this.singlePluralPairs = [["drain", "drains"]];

      this.is.listed_in_parent = false;

      this.descriptions.look = "It's a drain.";

      this.setDOVs(["open", "close", "plug"]);
      this.setDOV({ unplug: { with_nothing: true } });

      this.setIOVs(["pour", "fill", "put", "throw"]);
      this.can.be_poured_into = true;
      this.can.be_filled_from = false;

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
        list_in_examine: true,
        know_with_parent: true,
        list_in_room: false,
        maxheight: 1,
        maxwidth: 1,
        maxdepth: 1,
        maxcount: 1,
        maxsize: 1,
        maxweight: 1,
      });

      this.aspects.in.vessel = new adventurejs.Vessel("in", game_name).set({
        maxvolume: Infinity,
        is_drain: true,
      });

      this.registerableClasses = {
        Plug: function (object) {
          // this plugs push plug // can have multiple plugs
          if ("undefined" === typeof this.registered_parts.Plugs) {
            this.registered_parts.Plugs = [];
          }
          this.registered_parts.Plugs.push(object.id);
        },
      };

      this.linkRegisteredParts = function Drainable_linkRegisteredParts() {
        // link plugs to drain
        if ("undefined" !== typeof this.registered_parts.Plugs) {
          var drain = this; //.game.getAsset(this.registered_parts.Drain);
          this.registered_parts.Plugs.forEach(function (id) {
            var plug = this.game.getAsset(id);
            console.warn("Drain linkRegisteredParts plug", plug);
            drain.IOVsetWithAsset("plug", plug);
            plug.DOVsetWithAsset("plug", drain);
          }, this);
        }
      };
    }

    // override onMoveThatToThis inherited from Tangible
    // to check if asset is plug and close drain
    onMoveThatToThis(asset, where) {
      console.warn("Drain_onMoveThatToThis " + asset.name);
      console.warn(`moving ${asset.id} ${where} ${this.id}`);
      var results = this.Thing_onMoveThatToThis(asset, where);
      if ("undefined" !== typeof results) return results;

      if (this.DOVallowWithAsset("plug", asset)) {
        this.dov.plug.with_params.connections = [asset.id];
        this.is.plugged = true;
      }

      return;
    }

    // override onRemoveThatFromThis inherited from Tangible
    // to check if asset is plug and open drain
    onRemoveThatFromThis(asset) {
      console.warn("Drain_onRemoveThatFromThis " + asset.name);
      console.warn(`removing ${asset.id} from ${this.id}`);
      var results = this.Thing_onRemoveThatFromThis(asset);
      if ("undefined" !== typeof results) return results;

      console.warn(
        "this.DOVisConnectedToAsset('plug',asset)",
        this.DOVisConnectedToAsset("plug", asset)
      );
      console.warn(
        "this.IOVisConnectedToAsset('plug',asset)",
        this.IOVisConnectedToAsset("plug", asset)
      );
      if (this.DOVisConnectedToAsset("plug", asset)) {
        console.warn(`${this.id}.DOVisConnectedToAsset('plug',${asset})`);
        this.is.plugged = false;
        this.dov.plug.with_params.connections = [];
        if (asset.iov.plug) {
          asset.iov.plug.with_params.connections = [];
        }
        var parent = this.getPlaceAsset();

        if (parent.aspects.in.vessel.getVolume() > 0) {
          var substance = this.game.getAsset(
            parent.aspects.in.vessel.substance_id
          );
          parent.aspects.in.vessel.empty();
          var msg = `${substance.Name} drains out of ${parent.articlename}. `;
          this.game.getInput().appendToOutput(msg);
        }
      }
      return;
    }
  }
  adventurejs.Drain = Drain;
})();

// Edible.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Edible
   * @augments adventurejs.Thing
   * @class adventurejs.Edible
   * @ajsconstruct MyGame.createAsset({ "class":"Edible", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Trick or treat, give me something good to eat.
   * @classdesc
   * <p>
   * <strong>Edible</strong> can be eaten.
   * </p>
   **/
  class Edible extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Edible";

      this.setDOVs(["eat", "take", "give", "put"]);
    }
  }

  adventurejs.Edible = Edible;
})();

// Electronics.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Electronics
   * @augments adventurejs.Electronics
   * @class adventurejs.Electronics
   * @ajsconstruct MyGame.createAsset({ "class":"Electronics", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ElectronicsClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Use to create things player can tie rope to and swing from.
   * @classdesc
   * <p>
   * <strong>Electronics</strong> is a minimally specialized
   * subclass of
   * {@link adventurejs.Thing|Thing},
   * meant for building more complex electronic classes
   * such as {@link adventurejs.Radio|radios} and
   * {@link adventurejs.Computer|computers}.
   * </p>
   **/
  class Electronics extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Electronics";
      this.setDOV("plugIn");
    }
  }

  adventurejs.Electronics = Electronics;
})();

// Computer.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Electronics.Computer
   * @augments adventurejs.Thing
   * @class adventurejs.Computer
   * @ajsconstruct MyGame.createAsset({ "class":"Computer", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ElectronicsClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Asset class for computers, including desktops and laptops and Landru.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Computers</strong>. What can't they do?
   * </p>
   **/
  class Computer extends adventurejs.Electronics {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Computer";

      this.descriptions.look = "Computer.";
      this.singlePluralPairs = [["computer", "computers"]];
    }
  }

  adventurejs.Computer = Computer;
})();

// Outlet.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Electronics.Outlet
   * @augments adventurejs.Electronics
   * @class adventurejs.Outlet
   * @ajsconstruct MyGame.createAsset({ "class":"Outlet", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ElectronicsClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary An electrical outlet.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Outlet</strong> is a subclass of Electronics,
   * with no special properties, but meant to build upon.
   * Can be fixed, like a wall outlet, or mobile like a
   * power strip.
   * </p>
   **/
  class Outlet extends adventurejs.Electronics {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Outlet";

      this.descriptions.look = "Outlet.";
      this.singlePluralPairs = [["outlet", "outlets"]];

      this.setIOVs(["plugIn", "unplug"]);
      this.unsetDOV("plugIn");
    }
  }

  adventurejs.Outlet = Outlet;
})();

// Phone.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Electronics.Phone
   * @augments adventurejs.Thing
   * @class adventurejs.Phone
   * @ajsconstruct MyGame.createAsset({ "class":"Phone", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ElectronicsClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Asset class for scanners, meaning the type used as computer peripherals.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Phones</strong> are a simple base class.
   * TODO add dial, call, hang up.
   * </p>
   **/
  class Phone extends adventurejs.Electronics {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Phone";

      this.descriptions.look = "A phone.";
      this.singlePluralPairs = [["phone", "phones"]];
      this.setDOV("hang");

      this.is.connected = false;
    }
  }

  adventurejs.Phone = Phone;
})();

// Printer.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Electronics.Printer
   * @augments adventurejs.Thing
   * @class adventurejs.Printer
   * @ajsconstruct MyGame.createAsset({ "class":"Printer", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ElectronicsClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Asset class for printers, meaning the type used as computer peripherals.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Printers</strong> are a simple base class.
   * TODO add printing and paper spawning.
   * </p>
   **/
  class Printer extends adventurejs.Electronics {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Printer";

      this.descriptions.look = "Printer.";
      this.singlePluralPairs = [["printer", "printers"]];
    }
  }

  adventurejs.Printer = Printer;
})();

// Radio.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Electronics.Radio
   * @augments adventurejs.Electronics
   * @class adventurejs.Radio
   * @ajsconstruct MyGame.createAsset({ "class":"Radio", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ElectronicsClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Asset class for radios, including desktops, handhelds, and car.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Radio</strong> is a subclass of Electronics,
   * with no special properties, but meant to build upon.
   * </p>
   **/
  class Radio extends adventurejs.Electronics {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Radio";

      this.descriptions.look = "Radio.";
      this.singlePluralPairs = [["radio", "radios"]];
    }
  }
  adventurejs.Radio = Radio;
})();

// Scanner.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Electronics.Scanner
   * @augments adventurejs.Thing
   * @class adventurejs.Scanner
   * @ajsconstruct MyGame.createAsset({ "class":"Scanner", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ElectronicsClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Asset class for scanners, meaning the type used as computer peripherals.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Scanners</strong> are a simple base class.
   * TODO add document copying.
   * </p>
   **/
  class Scanner extends adventurejs.Electronics {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Scanner";

      this.descriptions.look = "Scanner.";
      this.singlePluralPairs = [["scanner", "scanners"]];
    }
  }

  adventurejs.Scanner = Scanner;
})();

// Eraser.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Eraser
   * @augments adventurejs.Thing
   * @class adventurejs.Eraser
   * @ajsconstruct MyGame.createAsset({ "class":"Eraser", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Fixes all mistakes. Or at least the ones in pencil.
   * @todo Erase specific writing?
   * @classdesc
   * <p>
   * <strong>Eraser</strong> is a subclass of
   * {@link adventurejs.Thing|Thing}, and is chiefly notable
   * in that it has
   * <code class="property">dov.erase</code>
   * set to true, which allows a player to erase things
   * they have written on Assets that have
   * <code class="property">dov.write</code>
   * set to true, such as {@link adventurejs.Paper|Paper}.
   * </p>
   * <p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Eraser",
   *   name: "frog eraser",
   *   article: "the",
   *   place: { on: "table" },
   *   descriptions: { look: "It's an eraser in the shape of a frog. ", },
   * });
   * MyGame.createAsset({
   *   class: "Pencil",
   *   name: "chewed pencil",
   *   article: "a",
   *   place: { on: "table" },
   *   descriptions: { look: "It's a #2 pencil with teeth marks and a worn out eraser. ", },
   * });
   * MyGame.createAsset({
   *   class: "Paper",
   *   name: "construction paper",
   *   descriptions: { look: "It's a yellow sheet of construction paper. ", },
   *   adjectives: ["yellow"],
   *   place: { on: "table" },
   * });
   * </code></pre>
   **/
  class Eraser extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Eraser";

      this.singlePluralPairs = [["eraser", "erasers"]];

      this.setDOVs(["take", "give", "put"]);
      this.setIOV("erase");
    }
  }

  adventurejs.Eraser = Eraser;
})();

// Extrusion.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Extrusion
   * @augments adventurejs.Thing
   * @class adventurejs.Extrusion
   * @ajsconstruct MyGame.createAsset({ "class":"Extrusion", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Use to create things player can tie rope to and swing from.
   * @classdesc
   * <p>
   * <strong>Extrusion</strong> is a minimally specialized
   * subclass of
   * {@link adventurejs.Thing|Thing},
   * with properties that allow
   * a player to {@link lasso_with|lasso} it, or
   * {@link tie_noun1_to_noun2|tie} a {@link adventurejs.Rope|Rope}
   * to it, and {@link swing_on|swing on} the tied Rope.
   * You might use it to make a branch, or a flagpole,
   * or a broken cornice, or a protruding piece of pipe,
   * anything that a player might use to lasso and swing
   * from one spot to another.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Extrusion",
   *   name: "broken rebar",
   *   place: { on: "underside of the bridge" },
   *   descriptions: {
   *     look: "A thick chunk of rebar extrudes from the underside of the bridge. ",
   *   },
   *   z: 2,
   * });
   * </code></pre>
   * <p>
   * To learn more about swinging, see
   * <a href="/doc/Tangibles_SwingingAndChasms.html">Swinging and Chasms</a>.
   * </p>
   **/
  class Extrusion extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Extrusion";

      this.is.listed_in_room = false;

      this.setDOVs(["lasso", "tie"]);

      this.can.support_swinging = true;
    }
  }

  adventurejs.Extrusion = Extrusion;
})();

// ExtrusionBranch.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Extrusion.ExtrusionBranch
   * @augments adventurejs.Extrusion
   * @class adventurejs.ExtrusionBranch
   * @ajsconstruct MyGame.createAsset({ "class":"ExtrusionBranch", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ForestClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A branch that player can tie rope to and swing from.
   * @classdesc
   * <p>
   * <strong>ExtrusionBranch</strong> is a subclass of
   * {@link adventurejs.Extrusion|Extrusion}, with properties that allow
   * a player to {@link lasso_with|lasso} it, or
   * {@link tie_noun1_to_noun2|tie} a {@link adventurejs.Rope|Rope}
   * to it, and {@link swing_on|swing on} the tied Rope.
   * For example, you might attach an ExtrusionBranch to a
   * {@link adventurejs.Tree|Tree}, to give players a unique
   * part of the Tree to interact with.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Tree",
   *   name: "blasted tree",
   *   place: { in: "east side of moat" },
   *   descriptions: {
   *     look: "The tree has been blasted by lightning,
   *     and fire, leaving only one stubby branch. ",
   *   },
   *   height: 3,
   *   attached:{
   *     enabled: true,
   *     list_in_room: false,
   *     list_in_examine: true, // must examine tree to see
   *   },
   *   is: { listed_in_room: false }, // tree is in room description
   *   is.climbable: false,
   * });
   *
   * MyGame.createAsset({
   *   class: "ExtrusionBranch",
   *   name: "stubby branch",
   *   place: { attached: "blasted tree" },
   *   descriptions: { look: "A short, thick branch. ", },
   *   position: { z: 2 }, // out of reach
   * });
   * </code></pre>
   * <p>
   * To learn more about swinging, see
   * <a href="/doc/Tangibles_SwingingAndChasms.html">Swinging and Chasms</a>.
   * </p>
   **/
  class ExtrusionBranch extends adventurejs.Extrusion {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "ExtrusionBranch";

      this.singlePluralPairs = [["branch", "branches"]];
      this.group = ["branches"];

      this.is.climbable = true;
      this.can.jump_to = true;
    }
  }

  adventurejs.ExtrusionBranch = ExtrusionBranch;
})();

// FloorChasm.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.FloorChasm
   * @augments adventurejs.Thing
   * @class adventurejs.FloorChasm
   * @ajsconstruct MyGame.createAsset({ "class":"FloorChasm", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A chasm or gap or pit in the floor.
   * @todo Does this need to be more thoroughly implemented?
   * @classdesc
   * <p>
   * <strong>FloorChasm</strong> is a chasm or gap or pit in the floor,
   * intended as an obstacle which a player might need to puzzle out a
   * way to cross.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * This example shows a FloorChasm separating two
   * {@link adventurejs.Platform|Platforms}, with the
   * idea that a player might swing across the chasm.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "FloorChasm",
   *   name: "deep chasm",
   *   place: { in: "Bottomless Chasm" },
   *   descriptions: { look: "It's a deep chasm. ", },
   *   is: { listed_in_room: false },
   *   things_player_can_swing_to_across_this: [
   *     "east side of chasm",
   *     "west side of chasm"
   *   ],
   *   can: { swing_across: true },
   * });
   *
   * MyGame.createAsset({
   *   class: "Platform",
   *   name: "east side of the chasm",
   *   place: { in: "Bottomless Chasm" },
   *   descriptions: { look: "The east side of the deep chasm.", },
   *   things_player_can_swing_to_from_this: "west side of the chasm",
   * });
   *
   * MyGame.createAsset({
   *   class: "Platform",
   *   name: "west side of the chasm",
   *   place: { in: "Bottomless Chasm" },
   *   descriptions: { look: "The west side of the deep chasm.", },
   *   things_player_can_swing_to_from_this: "east side of the chasm",
   *   things_player_can_reach_from_this: [ "vine" ],
   * });
   * </code></pre>
   **/
  class FloorChasm extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "FloorChasm";

      this.can.float_over = true;
      this.can.fly_over = true;
      this.can.hover_over = true;
      this.can.jump_in = true;
      this.can.jump_across = true;
      this.can.jump_over = true;
      this.can.swing_across = true;

      this.is_bottomless = true;
    }
  }

  adventurejs.FloorChasm = FloorChasm;
})();

// Furniture.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Furniture
   * @augments adventurejs.Thing
   * @class adventurejs.Furniture
   * @ajsconstruct MyGame.createAsset({ "class":"Furniture", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A base class for all kinds of furniture.
   * @tutorial Tangibles_AboutTangibles
   * @ajstangiblecontainer on
   * @classdesc
   * <p>
   * <strong>Furniture</strong> is the ancestor class for
   * all types of furniture including
   * {@link adventurejs.Bed|Bed},
   * {@link adventurejs.Chair|Chair},
   * {@link adventurejs.Table|Table}, and
   * {@link adventurejs.Desk|Desk}.
   * </p>
   * <p>Note that Furniture and its subclasses have their
   * <code class="property">group</code> property set
   * to "furniture", which allows players to use the word
   * "furniture" as a shortcut to refer to all Furniture
   * instances that are present in the current
   * {@link adventurejs.Room|Room}. Doing so will prompt
   * the player for disambiguation and offer a list of
   * available {@link adventurejs.Asset|Assets}, for example:
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; x furniture</span>
   * Which did you mean? 1. The stained bed,
   * 2. the crooked table, 3. the unsprung chair, or
   * 4. the blasted desk?
   * </pre>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Desk",
   *   name: "desk",
   *   place: { in: "Ancient classroom" },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "It's a heavy wooden desk with three
   *       vertically stacked drawers. The top drawer is
   *       $( top drawer is| open or| closed ),
   *       the middle drawer is
   *       $( middle drawer is| open or| closed ),
   *       and the bottom drawer is
   *       $( bottom drawer is| open or| closed )."
   *     },
   *   },
   *   adjectives: "wooden, heavy",
   * });
   * </code></pre>
   * <p>The above example uses string substitutions to
   * create a dynamic description. To learn more, see
   * <a href="/doc/Scripting_CustomTemplates.html">Custom Templates</a>.
   * </p>
   **/
  class Furniture extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Furniture";
      this.group = ["furniture"];

      this.setDOVs(["climb", "stand", "sit", "lie", "tie"]);
      this.unsetDOVs(["take", "give", "put"]);
      this.setIOVs(["take"]);

      //this.is.climbable = true;
      this.quirks.climb_means_go_on = true;
      this.quirks.stand_means_get_off = true;

      this.can.jump_to = true;
      this.can.jump_from = true;

      this.default_aspect = "on";
      this.dimensions.height = 0.5;

      this.aspects.on = new adventurejs.Aspect("on", this.game_name).set({
        parent_id: this.id,
        list_in_room: true,
        list_in_examine: true,
        maxheight: 6,
        maxwidth: 6,
        maxdepth: 6,
        maxcount: 10,
        maxsize: 20,
        maxweight: 100,
        player: {
          posture: "sit",
          preposition: "on",
          can: {
            enter: true,
            sit: true,
            kneel: true,
            lie: true,
            stand: true,
          },
        },
        orientation: "horizontal",
      });

      this.quirks.step_on_means_stand_on = true;
      this.quirks.climb_means_stand_on = true;
    }
  }
  adventurejs.Furniture = Furniture;
})();

// Bed.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Furniture.Bed
   * @augments adventurejs.Furniture
   * @class adventurejs.Bed
   * @ajsconstruct MyGame.createAsset({ "class":"Bed", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Zzzzzzzbuhbuhbuhbuhbuhzzzzz.
   * @tutorial Tangibles_AboutTangibles
   * @ajstangiblecontainer on
   * @ajstangiblecontainer under
   * @classdesc
   * <p>
   * <strong>Bed</strong> is child class of
   * {@link adventurejs.Furniture|Furniture}. Player can sit on it, lie on it,
   * go under it, jump on it, put things on it, etc. By default,
   * beds are set so that
   * "lie in" and "lie on" are interchangeable, via the
   * <a href="#quirks.in_means_on">quirks.in_means_on</a>
   * property.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Bed",
   *   name: "uncomfortable looking bed",
   *   place: { in: "cell" },
   *   descriptions: { look: "It's a thin, uncomfortable looking bed. ", },
   *   adjectives: "uncomfortable, thin",
   *   things_player_can_jump_to_from_this: [ "grate" ],
   *   indefinite_article: "an", // so it's listed as 'an uncomfortable looking bed'
   *   behind: {
   *     // by default, Bed class hasn't got a behind {@link adventurejs.Aspect|Aspect}
   *     // this is a shortcut method to create a custom Aspect
   *     // on a class instance
   *     "class": "Aspect",
   *     "parent_id": "uncomfortable_looking_bed",
   *     "list_in_examine": true,
   *     "list_in_room": true,
   *   }
   * });
   * </code></pre>
   **/
  class Bed extends adventurejs.Furniture {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Bed";

      this.noun = "bed";
      this.plural = "beds";
      this.singlePluralPairs = [["bed", "beds"]];

      this.default_aspect = "on";
      this.quirks.in_means_on = true;
      this.quirks.get_up_means_get_off = true;
      this.quirks.stand_means_get_off = true;

      this.can.jump_to = true;
      this.can.jump_from = true;
      this.aspects.on.set({
        list_in_room: true,
        list_in_examine: true,
        maxheight: 1,
        maxwidth: 6,
        maxdepth: 3,
        maxcount: 10,
        maxsize: 10,
        maxweight: 100,
        player: {
          posture: "lie",
          preposition: "on",
          can: {
            bounce: true,
            crawl: true,
            enter: true,
            exit: false,
            hide: true,
            jump: true,
            kneel: true,
            lie: true,
            sit: true,
            stand: true,
          },
        },
      });

      this.aspects.under = new adventurejs.Aspect("under", this.game_name).set({
        parent_id: this.id,
        list_in_room: false,
        list_in_examine: true,
        maxheight: 1,
        maxwidth: 6,
        maxdepth: 3,
        maxcount: 10,
        maxsize: 10,
        maxweight: 100,
        player: {
          posture: "lie",
          can: {
            bounce: true,
            crawl: true,
            enter: true,
            exit: false,
            hide: true,
            jump: true,
            kneel: true,
            lie: true,
            sit: true,
            stand: true,
          },
        },
      });
    }
  }

  adventurejs.Bed = Bed;
})();

// Chair.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Furniture.Chair
   * @augments adventurejs.Furniture
   * @class adventurejs.Chair
   * @classdesc Plain text description. Explanation of the class.
   * @ajsconstruct MyGame.createAsset({ "class":"Chair", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary For sitting.
   * @tutorial Tangibles_AboutTangibles
   * @ajstangiblecontainer on
   * @ajstangiblecontainer under
   * @classdesc <strong>Chair</strong> is child class of
   * {@link adventurejs.Furniture|Furniture}. Player can sit on it, sit in it,
   * put things on it, etc. By default, chairs are set so that
   * "sit in" and "sit on" are interchangeable, via the
   * <a href="#quirks.in_means_on">quirks.in_means_on</a>
   * property.
   **/
  class Chair extends adventurejs.Furniture {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Chair";

      this.noun = "chair";
      this.plural = "chairs";
      this.singlePluralPairs = [["chair", "chairs"]];

      this.setDOVs(["move", "push"]);
      this.can.push_from_room = true;
      this.can.turn = true;
      this.quirks.stand_means_get_off = true;
      this.quirks.get_up_means_get_off = true;
      this.quirks.in_means_on = true;

      this.default_aspect = "on";

      this.aspects.under = new adventurejs.Aspect("under", this.game_name).set({
        parent_id: this.id,
        list_in_room: false,
        maxheight: 1,
        maxwidth: 6,
        maxdepth: 3,
        maxcount: 10,
        maxsize: 10,
        maxweight: 100,
      });

      this.aspects.on.set({
        list_in_room: false,
        maxheight: 1,
        maxwidth: 1,
        maxdepth: 1,
        maxcount: 10,
        maxsize: 2,
        maxweight: 100,
        player: {
          posture: "sit",
          preposition: "on",
          can: { sit: true, stand: true, enter: true },
        },
      });
    }
  }
  adventurejs.Chair = Chair;
})();

// Desk.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Furniture.Desk
   * @augments adventurejs.Furniture
   * @class adventurejs.Desk
   * @ajsconstruct MyGame.createAsset({ "class":"Desk", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Get back to work!
   * @tutorial Tangibles_AboutTangibles
   * @ajstangiblecontainer behind
   * @ajstangiblecontainer attached
   * @classdesc
   * <p>
   * <strong>Desk</strong> is child class of
   * {@link adventurejs.Furniture|Furniture}.
   * In order to add {@link adventurejs.Drawer|Drawers},
   * create separate Drawer assets and attach them to a Desk,
   * as in this example.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Desk",
   *   name: "desk",
   *   place: { in: "Office" },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "It's a heavy wooden desk, with an old office chair.
   *       It has three drawers stacked vertically. The top drawer is
   *       $( top drawer is| open or| closed )."
   *     },
   *   },
   * });
   * MyGame.createAsset({
   *   class: "Drawer",
   *   name: "top drawer",
   *   descriptions: { look: "The top drawer is $( top drawer is| open or| closed ). ", },
   *   adjectives: "desk",
   *   place: { attached: "desk" },
   *   dov: { unlock: { with_assets: ['tiny brass key'], }, },
   *   is: { locked: true, listed_in_parent: false },
   * });
   * </code></pre>
   * <p>
   * The above example uses $(string) substitutions to
   * create a dynamic description. To learn more, see
   * <a href="/doc/Scripting_CustomTemplates.html">Custom Templates</a>.
   * </p>
   * <p>
   * While you can add multiple drawers to a desk, that can lead to problems
   * with disambiguation, leading to player interactions like this one.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; examine drawers</i>
   * Which drawer do you mean? The top drawer, the middle drawer, or the bottom drawer?
   * </pre>
   * <p>
   * You can address this by creating a
   * {@link adventurejs.Collection|Collection}.
   * To learn more, see
   * <a href="/doc/Tangibles_Collections.html">Collections</a>.
   * </p>
   **/
  class Desk extends adventurejs.Furniture {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Desk";

      this.noun = "desk";
      this.plural = "desks";
      this.singlePluralPairs = [["desk", "desks"]];

      this.setDOV("write");
      this.append_written_strings_to_description = true;
      this.quirks.jump_means_jump_on = false; // as in "bounce on"
      this.quirks.jump_means_jump_off = true; // as in "leap from"

      this.default_aspect = "on";

      this.can.jump_to = true;
      (this.can.jump_from = true),
        this.aspects.on.set({
          list_in_room: true,
          list_in_examine: true,
          player: {
            posture: "stand",
            can: {
              enter: true,
              kneel: true,
              stand: true,
              jump: true,
              sit: true,
            },
          },
        });

      this.aspects.behind = new adventurejs.Aspect(
        "behind",
        this.game_name
      ).set({
        parent_id: this.id,
        list_in_room: false,
        list_in_examine: true,
        player: {
          posture: "kneel",
          can: {
            enter: true,
            kneel: true,
            stand: true,
          },
        },
      });

      this.aspects.attached = new adventurejs.Aspect(
        "attached",
        this.game_name
      ).set({
        parent_id: this.id,
        list_in_room: false,
        list_in_examine: true,
        player_can_add_assets_to_contents: false,
        player_can_remove_assets_from_contents: false,
      });
    }
  }
  adventurejs.Desk = Desk;
})();

// Pedestal.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Furniture.Pedestal
   * @augments adventurejs.Furniture
   * @class adventurejs.Pedestal
   * @ajsconstruct MyGame.createAsset({ "class":"Pedestal", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A thing on which to put other things.
   * @tutorial Tangibles_AboutTangibles
   * @ajstangiblecontainer on
   * @classdesc <strong>Pedestal</strong> is child class of
   * {@link adventurejs.Furniture|Furniture}. Put things on it.
   **/
  class Pedestal extends adventurejs.Furniture {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Pedestal";

      this.noun = "pedestal";
      this.plural = "pedestals";
      this.singlePluralPairs = [["pedestal", "pedestals"]];
      this.default_aspect = "on";
      this.aspects.on.set({
        maxcount: 1,
        player: { can: { enter: false } },
      });
    }
  }
  adventurejs.Pedestal = Pedestal;
})();

// Table.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Furniture.Table
   * @augments adventurejs.Furniture
   * @class adventurejs.Table
   * @ajsconstruct MyGame.createAsset({ "class":"Table", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Time for din-din!
   * @tutorial Tangibles_AboutTangibles
   * @ajstangiblecontainer on
   * @ajstangiblecontainer under
   * @classdesc <strong>Table</strong> is child class of
   * {@link adventurejs.Furniture|Furniture}. Put things on it or under it.
   **/
  class Table extends adventurejs.Furniture {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Table";

      this.noun = "table";
      this.plural = "tables";
      this.singlePluralPairs = [["table", "tables"]];

      this.default_aspect = "on";

      this.can.jump_to = true;
      (this.can.jump_from = true),
        (this.aspects.under = new adventurejs.Aspect(
          "under",
          this.game_name
        ).set({
          parent_id: this.id,
          list_in_room: false,
          list_in_examine: true,
          maxheight: 3,
          maxwidth: 6,
          maxdepth: 3,
          maxcount: 10,
          maxsize: 10,
          maxweight: 100,
          player: {
            posture: "sit",
            can: {
              enter: true,
              kneel: true,
              lie: true,
              sit: true,
              crawl: true,
            },
          },
        }));

      this.aspects.on.set({
        maxheight: 3,
        maxwidth: 6,
        maxdepth: 3,
        maxcount: 10,
        maxsize: 10,
        maxweight: 100,
        player: {
          posture: "stand",
          can: { enter: true, kneel: true, lie: true, sit: true, jump: true },
        },
      });
    }
  }
  adventurejs.Table = Table;
})();

// Tub.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Furniture.Tub
   * @augments adventurejs.Furniture
   * @class adventurejs.Tub
   * @ajsconstruct MyGame.createAsset({ "class":"Tub", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading FurnitureClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A non-interactive tub.
   * @tutorial Tangibles_AboutTangibles
   * @ajstangiblecontainer in
   * @ajstangiblecontainer attached
   * @classdesc <strong>Tub</strong> is child class of
   * {@link adventurejs.Furniture|Furniture}.
   * This is a simple version of a tub. Players can get in
   * it and pour water in it, but it doesn't have a faucet
   * or drain. For a more interactive version with linked
   * faucet/handles/drain, see
   * {@link adventurejs.Bathtub|Bathtub}.
   **/
  class Tub extends adventurejs.Furniture {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Tub";

      this.noun = "tub";
      this.plural = "tubs";
      this.singlePluralPairs = [["tub", "tubs"]];

      this.setDOVs(["fill", "empty"]);
      this.setIOVs(["fill", "empty", "drink", "pour"]);
      this.can.be_filled_from = true;
      this.can.be_poured_into = true;

      this.default_aspect = "in";
      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
        list_in_examine: true,
        list_in_room: false,
        maxheight: 2,
        maxwidth: 6,
        maxdepth: 2,
        maxcount: 10,
        maxsize: 2,
        maxweight: 100,

        player: {
          posture: "stand",
          preposition: "in",
          can: {
            enter: true,
            sit: true,
            kneel: true,
            hide: true,
            lie: true,
            stand: true,
          },
        },
      });

      this.aspects.in.vessel = new adventurejs.Vessel("in", game_name).set({
        parent_id: this.id,
        maxvolume: "200L",
      });

      this.aspects.attached = new adventurejs.Aspect(
        "attached",
        this.game_name
      ).set({
        parent_id: this.id,
        list_in_room: false,
        list_in_examine: false,
        player_can_add_assets_to_contents: false,
        player_can_remove_assets_from_contents: false,
      });
    }
  }
  adventurejs.Tub = Tub;
})();

// OpticalDevice.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.OpticalDevice
   * @augments adventurejs.Thing
   * @class adventurejs.OpticalDevice
   * @ajsconstruct MyGame.createAsset({ "class":"OpticalDevice", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading OpticalClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Base class for EyeGlass, Binocular, Telescope, etc.
   * @classdesc
   * <p>
   * <strong>OpticalDevice</strong> can be looked through via
   * <code>can_do_through.look</code>, or looked with via
   * <code>dov.look</code>.
   * When "with" is allowed, it resolves to "through".
   * The intention is that you can "look with" or "look through" something
   * like a spyglass, but you can only "look through" something like a window.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "OpticalDevice",
   *   name: "Spyglass",
   *   descriptions: { look: "A spyglass, apparently made of polished amber. ", },
   *   place: { in: "satchel" },
   * });
   * </code></pre>
   */
  class OpticalDevice extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "OpticalDevice";

      // this.descriptions.look = "OpticalDevice.";
      // this.singlePluralPairs = [ ["optical device","optical devices"] ];
      this.setDOVs(["take", "give", "tie"]);
      this.setIOV("look");

      this.on_tie_to_this_take_this = true;
      this.on_tie_to_drag_behind_rope = true;

      this.quirks.look_with_means_look_through = true;
      this.is.lookthroughable = true;
    }
  }

  adventurejs.OpticalDevice = OpticalDevice;
})();

// Binoculars.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.OpticalDevice.Binoculars
   * @class adventurejs.Binoculars
   * @augments adventurejs.OpticalDevice
   * @ajsconstruct MyGame.createAsset({ "class":"Binoculars", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading OpticalClasses
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @param {String} game_name The name of the top level game object.
   * @summary Curse this blasted balcony seat.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Binoculars</strong> is a subclass of
   * {@link adventurejs.OpticalDevice|OpticalDevice},
   * which can be looked through or with via
   * <code>iov.look</code>.
   * </p>
   * <p>
   * Authors might find the distinction between
   * "look through" and "look with" unnecessary, in which case it's
   * possible to combine these verbs or disable one or the other.
   * To learn more, see
   * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Binoculars",
   *   name: "binoculars",
   *   descriptions: { look: "I call them my 'birdnoculars'. Because they're for birding. Heh. ", },
   *   place: { in: "desk drawer" },
   * });
   * </code></pre>
   **/
  class Binoculars extends adventurejs.OpticalDevice {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Binoculars";

      this.singlePluralPairs = [["binoculars", "binoculars"]];
      this.must.be_in_hands_to_look_through = true;
    }
  }
  adventurejs.Binoculars = Binoculars;
})();

// EyeGlasses.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.EyeGlasses
   * @augments adventurejs.Thing
   * @class adventurejs.EyeGlasses
   * @ajsconstruct MyGame.createAsset({ "class":"EyeGlasses", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading OpticalClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Blast! These aren't my cheaters!
   * @classdesc
   * <p>
   * <strong>EyeGlasses</strong> is a subclass of
   * {@link adventurejs.OpticalDevice|OpticalDevice},
   * which can be worn, and
   * which can be looked through or with via
   * <code>iov.look</code>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "EyeGlasses",
   *   name: "glasses",
   *   descriptions: { look: "My reading glasses. ", },
   *   place: { in: "desk drawer" },
   * });
   * </code></pre>
   **/
  class EyeGlasses extends adventurejs.OpticalDevice {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "EyeGlasses";

      this.descriptions.look = "Glasses.";
      this.singlePluralPairs = [
        ["eyeglasses", "eyeglasses"],
        ["glasses", "glasses"],
      ];

      this.setDOVs(["wear", "remove"]);

      this.must.be_worn_to_look_through = true;
    }
  }

  adventurejs.EyeGlasses = EyeGlasses;
})();

// StationaryTelescope.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.OpticalDevice.StationaryTelescope
   * @class adventurejs.StationaryTelescope
   * @augments adventurejs.OpticalDevice
   * @ajsconstruct MyGame.createAsset({ "class":"StationaryTelescope", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading OpticalClasses
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @param {String} game_name The name of the top level game object.
   * @summary You LOVE the Plane-arium.
   * @classdesc
   * <p>
   * <strong>StationaryTelescope</strong> is a subclass of
   * {@link adventurejs.OpticalDevice|OpticalDevice},
   * which can be looked through or with via
   * <code>iov.look</code>.
   * It differs from
   * {@link adventurejs.StationaryTelescope|Telescope}
   * in that it can't be carried.
   * </p>
   * <p>
   * Authors might find the distinction between
   * "look through" and "look with" unnecessary, in which case it's
   * possible to combine these verbs or disable one or the other.
   * To learn more, see
   * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "StationaryTelescope",
   *   name: "stationary telescope",
   *   descriptions: { look: "It's a big mounted telescope. ", },
   *   place: { in: "Observatory" },
   * });
   * </code></pre>
   **/
  class StationaryTelescope extends adventurejs.OpticalDevice {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "StationaryTelescope";

      this.singlePluralPairs = [["telescope", "telescopes"]];

      this.setDOVs(["tie"]);
      this.unsetDOVs(["take", "give", "shake"]);

      this.on_tie_to_this_take_this = false;
      this.on_tie_to_drag_behind_rope = false;

      // only if it's handheld
      this.must.be_in_hands_to_look_through = false;
    }
  }
  adventurejs.StationaryTelescope = StationaryTelescope;
})();

// Telescope.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.OpticalDevice.Telescope
   * @class adventurejs.Telescope
   * @augments adventurejs.OpticalDevice
   * @ajsconstruct MyGame.createAsset({ "class":"Telescope", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading OpticalClasses
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @param {String} game_name The name of the top level game object.
   * @summary Curse this blasted balcony seat.
   * @classdesc
   * <p>
   * <strong>Telescope</strong> is a subclass of
   * {@link adventurejs.OpticalDevice|OpticalDevice},
   * which can be looked through or with via
   * <code>iov.look</code>.
   * Telescope is a handheld device. For stationary
   * telescopes, see the
   * {@link adventurejs.StationaryTelescope|StationaryTelescope} class.
   * </p>
   * <p>
   * Authors might find the distinction between
   * "look through" and "look with" unnecessary, in which case it's
   * possible to combine these verbs or disable one or the other.
   * To learn more, see
   * <a href="/doc/Verbs_ModifyVerbs.html">Modify Verbs</a>
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Telescope",
   *   name: "telescope",
   *   descriptions: { look: "It's a brass pocket telescope. ", },
   *   place: { in: "saddlebag" },
   * });
   * </code></pre>
   **/
  class Telescope extends adventurejs.OpticalDevice {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Telescope";

      this.singlePluralPairs = [["telescope", "telescopes"]];

      // only if it's handheld
      this.must.be_in_hands_to_look_through = true;
    }
  }
  adventurejs.Telescope = Telescope;
})();

// GraduatedController.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.GraduatedController
   * @augments adventurejs.Thing
   * @class adventurejs.GraduatedController
   * @ajsconstruct MyGame.createAsset({ "class":"GraduatedController", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A controller with multiple settings, like a dial.
   * @classdesc
   * <p>
   * <strong>GraduatedController</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} and a base class for controllers
   * that have multiple positions which can be used to affect
   * levels of flow of
   * {@link adventurejs.SubstanceEmitter|SubstanceEmitters},
   * such as setting a sink handle which can be set to low, medium,
   * or high or any number of positions in between. This is possibly
   * overkill but that's the kind of game framework this is.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "FaucetHandle",
   *   name: "sink's cold water handle",
   *   synonyms: [ "handle", "sink handle" ],
   *   adjectives: [ "cold water", "sink", "porcelain" ],
   *   place: { attached: "sink" },
   *   description: "The sink's cold water handle. ",
   *   target_id: "sink faucet",
   *   set_substance_id: "water",
   *   set_substance_temperature: 15
   * });
   * </code></pre>
   **/
  class GraduatedController extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "GraduatedController";

      this.singlePluralPairs = [["controller", "controllers"]];

      this.descriptions.look = "It's a controller.";

      this.is.listed_in_parent = false;
      this.can.turn = true;

      this.dimensions.width = 1;
      this.dimensions.height = 1;

      this.unsetDOV("take");
      this.setDOVs([{ turn: { with_nothing: true } }]);

      this.control_positions = 2; // toggle
      //this.control_positions = 5; // range
      this.current_position = 0; // off

      this.set_substance_id = "";
      this.set_substance_temperature = 25;

      this.turnOn_doAfterTry = function (params) {
        //var game = window[game_name];
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var msg = "";

        if (2 > direct_object.control_positions) {
          // it doesn't turn
          msg += `${direct_object.Articlename} can't be turned on. `;
          if (msg) this.game.print(msg, input.output_class);
          return null;
        }

        if (
          direct_object.current_position + 1 ===
          direct_object.control_positions
        ) {
          // already as open as it can be
          msg = `${direct_object.Articlename} is already turned on. `;
          if (msg) this.game.print(msg, input.output_class);
          return null;
        }

        return true;
      };

      this.turnOn_doBeforeSuccess = function (params) {
        var game = window[game_name];
        var input = game.getInput();
        var direct_object = input.getAsset(1);
        var msg = "";
        var results;

        direct_object.current_position = direct_object.current_position + 1;

        // if controller has more than 2 positions
        if (2 < direct_object.control_positions) {
          // is it fully on?
          if (
            direct_object.current_position + 1 ===
            direct_object.control_positions
          ) {
            msg += `$(We) turn ${direct_object.articlename} all the way on. `;
          } else {
            // or not?
            msg += `$(We) turn ${direct_object.articlename} further on. `;
          }
        } else {
          msg += `$(We) turn ${direct_object.articlename} to on. `;
        }

        // if this has a target, inform target of new setting
        var indirect_object = game.getAsset(direct_object.control_target_id);
        //if( "undefined" !== typeof indirect_object
        if (
          Object(indirect_object) === indirect_object &&
          "function" === typeof indirect_object.onChangeGraduatedController
        ) {
          results = indirect_object.onChangeGraduatedController(direct_object);
          if (A.isFalseOrNull(results)) return results;
          // if successful, target might return a string for output
          if ("string" === typeof results) msg += results;
        }

        if (msg) game.print(msg, input.output_class);
        return null;
      };

      this.turnOff_doAfterTry = function (params) {
        var game = window[game_name];
        var input = game.getInput();
        var direct_object = input.getAsset(1);
        var msg = "";

        if (2 > direct_object.control_positions) {
          // it doesn't actually turn off
          msg = `${direct_object.Articlename} can't be turned off. `;
          if (msg) game.print(msg, input.output_class);
          return null;
        }

        if (direct_object.current_position === 0) {
          // already as off as it can be
          msg = `${direct_object.Articlename} is already turned off. `;
          if (msg) game.print(msg, input.output_class);
          return null;
        }

        return true;
      };

      this.turnOff_doBeforeSuccess = function (params) {
        var game = window[game_name];
        var input = game.getInput();
        var direct_object = input.getAsset(1);
        var msg = "";
        var results;

        direct_object.current_position = direct_object.current_position - 1;

        // if controller has more than 2 positions
        if (2 < direct_object.control_positions) {
          // is it fully off?
          if (direct_object.current_position === 0) {
            msg += `$(We) turn ${direct_object.articlename} all the way off. `;
          } else {
            // or not?
            msg += `$(We) turn ${direct_object.articlename} further off. `;
          }
        } else {
          msg += `$(We) turn ${direct_object.articlename} to off. `;
        }

        // if this has a target, inform target of new setting
        var indirect_object = game.getAsset(direct_object.control_target_id);
        //if( "undefined" !== typeof indirect_object
        if (
          Object(indirect_object) === indirect_object &&
          "function" === typeof indirect_object.onChangeGraduatedController
        ) {
          results = indirect_object.onChangeGraduatedController(direct_object);
          if (A.isFalseOrNull(results)) return results;
          // if successful, target might return a string for output
          if ("string" === typeof results) msg += results;
        }

        if (msg) game.print(msg, input.output_class);
        return null;
      };

      this.dov.turn.doAfterTry = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var direct_preposition = input.getPreposition(1);

        // sentence structure: verb preposition noun
        if (input.hasStructure("verb preposition noun")) {
          if (direct_preposition === "on") return this.turnOn_doAfterTry();
          if (direct_preposition === "off") return this.turnOff_doAfterTry();
        } // verb preposition noun

        // sentence structure: verb noun
        if (input.hasStructure("verb noun")) {
          if (direct_object.control_positions < 2) {
            // it doesn't actually turn
            var msg = direct_object.Articlename + " doesn't turn. ";
            if (msg) this.game.print(msg, input.output_class);
            return null;
          }
        } // verb noun

        return true;
      };

      this.dov.turn.doBeforeSuccess = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var direct_preposition = input.getPreposition(1);
        var msg = "";
        var results;

        // sentence structure: verb preposition noun
        if (input.hasStructure("verb preposition noun")) {
          if (direct_preposition === "on") return this.turnOn_doBeforeSuccess();
          if (direct_preposition === "off")
            return this.turnOff_doBeforeSuccess();
        } // verb preposition noun

        // sentence structure: verb noun
        if (input.hasStructure("verb noun")) {
          if (direct_object.control_positions === 2) {
            // Turn doesn't specify a direction.
            // If element only has two positions then it's a toggle
            // and we can assume player meant to open or close.
            direct_object.current_position = Math.abs(
              direct_object.current_position - 1
            );
            msg += `$(We) turn ${direct_object.articlename} to ${
              direct_object.current_position == 1 ? "open" : "closed"
            }. `;
          } else if (2 < direct_object.control_positions) {
            // it has multiple positions, but turn doesn't specify direction
            // so how to decide what direction?
            if (
              direct_object.current_position <
              direct_object.control_positions - 1
            ) {
              direct_object.current_position++;
            } else {
              direct_object.current_position--;
            }
          }

          // if this has a target, inform target of new setting
          var indirect_object = this.game.getAsset(
            direct_object.control_target_id
          );
          //if( "undefined" !== typeof indirect_object
          if (
            Object(indirect_object) === indirect_object &&
            "function" === typeof indirect_object.onChangeGraduatedController
          ) {
            results =
              indirect_object.onChangeGraduatedController(direct_object);
            if (A.isFalseOrNull(results)) return results;

            // if successful, target might return a string for output
            if ("string" === typeof results) msg += results;
          }

          if (msg) this.game.print(msg, input.output_class);
          return null;
        } // verb noun

        return true;
      };
    }

    get set_substance_id() {
      return this.__set_substance_id;
    }
    set set_substance_id(substance_id) {
      if ("string" !== typeof substance_id) {
        var msg = this.id + ".set_substance_id must be a string. ";
        this.game.log("warn", "critical", msg);
        return;
      }
      this.__set_substance_id = A.serialize(substance_id);
    }

    get set_substance_temperature() {
      return this.__set_substance_temperature;
    }
    set set_substance_temperature(substance_temperature) {
      if ("number" !== typeof substance_temperature) {
        var msg = this.id + ".set_substance_temperature must be a number. ";
        this.game.log("warn", "critical", msg);
        return;
      }
      this.__set_substance_temperature = substance_temperature;
    }
  }

  adventurejs.GraduatedController = GraduatedController;
})();

// FaucetHandle.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspartof Sink
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.GraduatedController.Handle
   * @augments adventurejs.GraduatedController
   * @class adventurejs.FaucetHandle
   * @ajsconstruct MyGame.createAsset({ "class":"FaucetHandle", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BathroomClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A handle that can be turned by degrees.
   * @classdesc
   * <strong>FaucetHandle</strong> is a subclass of
   * {@link adventurejs.GraduatedController|GraduatedController}
   * which can be used to affect levels of flow of
   * {@link adventurejs.SubstanceEmitter|SubstanceEmitters},
   * such as setting a sink handle which can be set to low, medium,
   * or high or any number of positions in between.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "FaucetHandle",
   *   name: "sink's cold water handle",
   *   synonyms: [ "handle", "sink handle" ],
   *   adjectives: [ "cold water", "sink", "porcelain" ],
   *   place: { attached: "sink" },
   *   description: "The sink's cold water handle. ",
   *   target_id: "sink faucet",
   *   set_substance_id: "water",
   *   set_substance_temperature: 15
   * });
   * </code></pre>
   **/
  class FaucetHandle extends adventurejs.GraduatedController {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "FaucetHandle";

      this.singlePluralPairs = [["handle", "handles"]];

      this.descriptions.look = "It's a handle.";

      this.setDOVs(["turn"]);
      this.unsetDOVs(["give", "take"]);

      this.is.listed_in_parent = false;

      this.dimensions.width = 1;
      this.dimensions.height = 1;

      this.control_positions = 2; // toggle
      //this.control_positions = 5; // range
    }
  }
  adventurejs.FaucetHandle = FaucetHandle;
})();

// Key.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Key
   * @augments {adventurejs.Thing}
   * @class adventurejs.Key
   * @ajsconstruct MyGame.createAsset({ "class":"Key", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading KeyClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Keys unlock locks.
   * @tutorial CreateKey
   * @classdesc
   * <p>
   * <strong>Key</strong> is a subclass of
   * {@link adventurejs.Thing|Thing}
   * that can be used to unlock locked
   * {@link adventurejs.Asset|Assets}.
   * The interaction is determined by properties on both objects.
   * The Key will have a list of Asset
   * <a href="#id">IDs</a> it can unlock in its
   * <code class="property">asset.iov.unlock.with_assets</code>,
   * and the locked object will also have the Key ID listed in its
   * <code class="property">asset.dov.unlock.with_assets</code>.
   * (You can set just one or the other in your game file.
   * As long as one is set, the Key and Lock will be associated during
   * initialization.) The locked object will also have
   * asset.dov.lock.enabled set to true.
   * See the example below to create a key and a locked chest.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Key",
   *   name: "brass key",
   *   place: { in: "Treasure Room" },
   *   iov: { unlock: { with_assets: ['treasure chest'], }, },
   * });
   * MyGame.createAsset({
   *   class: "Chest",
   *   name: "treasure chest",
   *   place: { in: "Treasure Room" },
   *   is_locked: true,
   *   dov: { unlock: { with_assets: ['brass key'], }, },
   * });
   * </code></pre>
   **/
  class Key extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Key";

      this.setDOVs(["put", "give", "take", "drop", "throw", "tie"]);
      this.setIOVs(["lock", "unlock"]);

      this.descriptions.look = "It's a key.";
      this.singlePluralPairs = [["key", "keys"]];
      this.on_tie_to_this_take_this = true;
      this.on_tie_to_drag_behind_rope = true;
    }
  }
  adventurejs.Key = Key;
})();

// Lockpick.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Key.Lockpick
   * @augments adventurejs.Key
   * @class adventurejs.Lockpick
   * @ajsconstruct MyGame.createAsset({ "class":"Lockpick", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading KeyClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Lockpicks can be used to pick locks.
   * @tutorial CreateKey
   * @classdesc
   * <p>
   * <strong>Lockpick</strong> is a subclass of
   * {@link adventurejs.Key|Key}
   * that can be used to unlock locked
   * {@link adventurejs.Asset|Assets}.
   * Lockpick has
   * <code>quirks.pick_means_unlock</code>
   * set to true, which makes
   * <code class="property">pick lock with lockpick</code>
   * equivalent to
   * <code class="property">unlock lock with key</code>.
   * The interaction is determined by properties on both objects.
   * The Lockpick will have a list of Asset
   * <a href="#id">IDs</a> it can unlock in its
   * <code class="property">asset.iov.unlock.with_assets</code>,
   * and the locked object will also have the
   * Lockpick ID listed in its
   * <code class="property">asset.dov.unlock.with_assets</code>.
   * property. (You can set just one or the other in your game file.
   * As long as one is set, the Lockpick and Lock will be associated during
   * initialization.) The locked object will also have
   * asset.dov.lock.enabled set to true. See the example below to create a Lockpick and
   * a locked chest.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Lockpick",
   *   name: "iron lockpick",
   *   place: { in: "Treasure Room" },
   *   iov: { pick: { with_assets: ['treasure chest'], }, },
   * });
   * MyGame.createAsset({
   *   class: "Chest",
   *   name: "iron chest",
   *   place: { in: "Treasure Room" },
   *   dov: { pick: { with_assets: ['iron lockpick'], }, },
   *   is: { locked: true, },
   * });
   * </code></pre>
   **/
  class Lockpick extends adventurejs.Key {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Lockpick";
      
      this.singlePluralPairs = [
        ["pick", "picks"],
        ["lockpick", "lockpicks"],
      ];

      this.setIOV("pick");

      this.quirks.pick_means_unlock = true;
    }
  }

  adventurejs.Lockpick = Lockpick;
})();

// SingleUseKey.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Key.SingleUseKey
   * @augments adventurejs.Key
   * @class adventurejs.SingleUseKey
   * @ajsconstruct MyGame.createAsset({ "class":"SingleUseKey", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading KeyClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A single use key can unlock a lock. Once.
   * @tutorial CreateKey
   * @classdesc
   * <p>
   * <strong>SingleUseKey</strong> is a subclass of
   * {@link adventurejs.Key|Key}
   * that can be used to unlock locked
   * {@link adventurejs.Asset|Assets}.
   * SingleUseKey uses
   * <code class="property">asset.iov.pick.then_destroy</code>,
   * to destroy the asset after one use.
   * The interaction is determined by properties on both objects.
   * The SingleUseKey will have a list of Asset
   * <a href="#id">IDs</a> it can unlock in its
   * <code class="property">asset.iov.unlock.with_assets</code>,
   * and the locked object will also have the
   * SingleUseKey ID listed in its
   * <code class="property">asset.dov.unlock.with_assets</code>.
   * (You can set just one or the other in your game file.
   * As long as one is set, the SingleUseKey
   * and Lock will be associated during
   * initialization.) The locked object will also have
   * asset.dov.lock.enabled set to true. See the example below to create a key and
   * a locked chest.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Key",
   *   name: "brass key",
   *   place: { in: "Treasure Room" },
   *   iov: { unlock: { with_assets: ['treasure chest'], }, },
   * });
   * MyGame.createAsset({
   *   class: "Chest",
   *   name: "treasure chest",
   *   place: { in: "Treasure Room" },
   *   is_locked: true,
   *   dov: { unlock: { with_assets: ['brass key'], }, },
   * });
   * </code></pre>
   **/
  class SingleUseKey extends adventurejs.Key {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "SingleUseKey";

      this.setIOV({ unlock: { then_destroy: true } });
    }
  }

  adventurejs.SingleUseKey = SingleUseKey;
})();

// SingleUseLockpick.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Key.SingleUseLockpick
   * @augments adventurejs.Lockpick
   * @class adventurejs.SingleUseLockpick
   * @ajsconstruct MyGame.createAsset({ "class":"SingleUseLockpick", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading KeyClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A single use lockpick can be used to pick a lock. Once.
   * @tutorial CreateKey
   * @classdesc
   * <p>
   * <strong>SingleUseLockpick</strong> is a subclass of
   * {@link adventurejs.Lockpick|Lockpick}
   * that can be used to unlock locked
   * {@link adventurejs.Asset|Assets}.
   * The parent class Lockpick has
   * <code>quirks.pick_means_unlock</code>
   * set to true, which makes 'pick' equivalent to
   * <code class="property">unlock door with key</code>.
   * SingleUseLockpick uses
   * <code class="property">asset.iov.pick.then_destroy</code>,
   * to destroy the asset after one use.
   * The interaction is determined by properties on both objects.
   * The SingleUseLockpick will have a list of Asset
   * <a href="#id">IDs</a> it can pick in its
   * <code class="property">asset.iov.pick.with_assets</code>,
   * property, and the locked object will also have the
   * SingleUseLockpick ID listed in its
   * <code class="property">asset.dov.pick.with_assets</code>.
   * (You can set just one or the other in your game file.
   * As long as one is set, the SingleUseLockpick
   * and Lock will be associated during
   * initialization.) The locked object will also have
   * asset.dov.lock.enabled set to true.
   * See the example below to create a SingleUseLockpick and a locked chest.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "SingleUseLockpick",
   *   name: "iron lockpick",
   *   place: { in: "Treasure Room" },
   *   iov: { pick: { with_assets: ['iron chest'], then_destroy: true, }, },
   * });
   * MyGame.createAsset({
   *   class: "Chest",
   *   name: "iron chest",
   *   place: { in: "Treasure Room" },
   *   is_locked: true,
   *   dov: { pick: { with_assets: ['iron lockpick'], }, },
   * });
   * </code></pre>
   **/
  class SingleUseLockpick extends adventurejs.Key {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "SingleUseLockpick";

      this.setIOV({ pick: { then_destroy: true } });
      this.setIOV({ unlock: { then_destroy: true } });
    }
  }
  adventurejs.SingleUseLockpick = SingleUseLockpick;
})();

// SkeletonKey.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Key.SkeletonKey
   * @augments adventurejs.Key
   * @class adventurejs.SkeletonKey
   * @ajsconstruct MyGame.createAsset({ "class":"SkeletonKey", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading KeyClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary SkeletonKeys can be used to unlock...anything?
   * @tutorial CreateKey
   * @classdesc
   * <p>
   * <strong>SkeletonKey</strong> is a subclass of
   * {@link adventurejs.Key|Key}
   * that can be used to unlock any locked
   * {@link adventurejs.Asset|Assets}.
   * Of course it can't actually unlock anything by default.
   * Verb subscriptions can be set to allow entire classes
   * to apply verbs to each other. In this case, either the
   * assets to be unlocked will need an indirect verb
   * subscription:
   * <code class="property">asset.dov.unlock.with_classes = ["SkeletonKey"]</code>;
   * or the key asset will need a direct verb subscription:
   * <code class="property">asset.iov.unlock.with_classes = ["Lock"]</code>.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "SkeletonKey",
   *   name: "skeleton key",
   *   place: { in: "Treasure Room" },
   *   iov: { pick: { with_classes: ['Door'], }, },
   * });
   * MyGame.createAsset({
   *   class: "Door",
   *   name: "iron door",
   *   place: { in: "Treasure Room" },
   *   is: {
   *     closed: true,
   *     locked: true,
   *   },
   *   dov: { unlock: { with_classes: ['SkeletonKey'], }, },
   * });
   * </code></pre>
   **/
  class SkeletonKey extends adventurejs.Key {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "SkeletonKey";

      this.singlePluralPairs = [["skeleton key", "skeleton keys"]];
    }
  }
  adventurejs.SkeletonKey = SkeletonKey;
})();

// Keyboard.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Keyboard
   * @augments adventurejs.Thing
   * @class adventurejs.Keyboard
   * @ajsconstruct MyGame.createAsset({ "class":"Keyboard", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ElectronicsClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A computer keyboard that players can type on.
   * @classdesc
   * <p>
   * <strong>Keyboard</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} with a
   * verb phase for the
   * {@link adventurejs.Verb|Verb} {@link type}.
   * (For more information about verb hooks, see
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.)
   * It accepts input in the form of
   * <code class="property">type "foo" on keyboard</code> where "foo" is a
   * string with quotes around it. Keyboard can have its
   * <code class="property">typing_target_id</code> set to an
   * {@link adventurejs.Asset|Asset} with its
   * <code class="property">is.typing_target</code> property set to true,
   * and the input string will display on it. See the following
   * transcript to get an idea how this plays out.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; type "It was the best of times, it was the BLURST of times?" on keyboard</span>
   * You type "It was the best of times, it was the BLURST of times?"
   * on the keyboard. Your input appears on the screen as you type.
   *
   * <span class="input">&gt; x screen</span>
   * It's a fancy monitor. A line of input is visible on it:
   * "It was the best of times, it was the BLURST of times?"
   * </pre>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Keyboard",
   *   name: "keyboard",
   *   place: { on: "desk" },
   *   descriptions: { look: "It's a keyboard. You can type on it. ", },
   *   dov: { take: false },
   *   typing_target_id: "screen",
   * });
   * MyGame.createAsset({
   *   class: "Screen",
   *   name: "screen",
   *   place: { on: "desk" },
   *   descriptions: { look: "It's a fancy monitor. ", },
   *   dov: { take: true },
   * });
   * </code></pre>
   **/
  class Keyboard extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Keyboard";
      this.setDOV("type");
      this.setIOV("type");

      /**
       * Keyboard can operate on a separate typing_target_id.
       *
       * doAfterTry lets the verb's standard checks run
       * before checking specifics for this object
       *
       * doBeforeSuccess preempts doSuccess because
       * we want to override the standard success
       */

      // @TODO dov or iov or both? or already handled by verb?
      // "type on keyboard" = dov
      // "type foo on keyboard" = iov?
      this.dov.type.doBeforeSuccess = function (params) {
        console.warn("CUSTOM type");
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var indirect_object = this.game.getAsset(
          direct_object.typing_target_id
        );
        var msg = "";

        // state change?
        if (indirect_object && input.strings.length) {
          indirect_object.written_strings.push(input.strings[0]);
        }

        // compose output
        msg += `$(We) type `;
        msg += input.strings.length ? `${input.strings[0]} ` : ``;
        msg += `on ${direct_object.articlename}. `;
        msg += indirect_object
          ? `$(Our) input appears on ${indirect_object.articlename} as $(we) type. `
          : ``;

        // print output
        this.game.dictionary.verbs[params.verb].handleSuccess(
          msg,
          direct_object
        );
        return null;
      };
    }
  }
  adventurejs.Keyboard = Keyboard;
})();

// Lantern.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Lantern
   * @augments adventurejs.Thing
   * @class adventurejs.Lantern
   * @ajsconstruct MyGame.createAsset({ "class":"Lantern", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading LightingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Asset class for a lantern that can be lit and provide light.
   * @tutorial Tangibles_AboutTangibles
   * @classdesc
   * <p>
   * <strong>Lantern</strong> is a subclass of
   * {@link adventurejs.Thing|Thing}
   * which can be attached to / detached from a parent.
   * {@link adventurejs.Asset|Assets}
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Lantern",
   *   name: "brass lantern",
   *   article: "a",
   *   place: { on: "table" },
   *   descriptions: { look: "It's a brass lantern. ", },
   * });
   * </code></pre>
   * @TODO Turn on / turn off, provide light, extinguish after time or when wet.
   */
  class Lantern extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Lantern";

      this.singlePluralPairs = [["lantern", "lanterns"]];
      this.is.listed_in_parent = true;

      this.setDOVs(["shine", "turn"]);
      this.setIOV("look");

      this.descriptions.look = "It's an antique brass lantern. ";
    }
  }
  adventurejs.Lantern = Lantern;
})();

// Luggage.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Luggage
   * @augments adventurejs.Thing
   * @class adventurejs.Luggage
   * @ajsconstruct MyGame.createAsset({ "class":"Luggage", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading LuggageClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A base class for all kinds of luggage.
   * @tutorial Tangibles_Aspects
   * @ajstangiblecontainer in
   * @classdesc
   * <p>
   * <strong>Luggage</strong> is a parent class for all
   * kinds of carry containers. See
   * {@link adventurejs.Knapsack|Knapsack} for an example
   * of a Luggage subclass that can be
   * worn and removed. It's possible to limit what can
   * be put in Luggage by size, weight, and quantity.
   * It's also possible to restrict its contents to
   * certain classes or specific items.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * This example shows a Luggage instance that with
   * restrictions on the size, number, and weight of
   * things that can be put in it.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Luggage",
   *   name: "purse",
   *   place: { on: "Coat rack" },
   *   descriptions: { look: "It's Prada, dahling. ", },
   *   adjectives: "prada",
   *   dov: { wear: true, remove: true },
   *   in:
   *   {
   *     maxheight: .25,
   *     maxwidth: .25,
   *     maxdepth: .1,
   *     maxcount: 6, // can't hold more than 6 things
   *     maxweight: 5, // can't carry more than 5 units
   *   }
   * });
   * </code></pre>
   * <p>
   * This example shows a Luggage instance that only
   * allows player to put certain items or classes in it.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Luggage",
   *   name: "makeup bag",
   *   place: { on: "Coat rack" },
   *   descriptions: { look: "I never leave home without it. ", },
   *   dov: { wear: true, remove: true },
   *   aspects: { in:
   *   {
   *     with_classes: ["Makeup"], // any instance
   *     with_assets: ["lipstick", "compact", "eye liner"], // specific items
   *   }, },
   * });
   * </code></pre>
   **/
  class Luggage extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Luggage";

      this.is.closed = true;
      this.is.hollow = true;

      // give & take depends on size of chest - up to author
      this.setDOVs(["put", "give", "take", "drop", "throw"]);
      this.setDOV({ open: { with_nothing: true } });
      this.setDOV({ close: { with_nothing: true } });

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
        list_in_examine: true,
      });
    }
  }

  adventurejs.Luggage = Luggage;
})();

// Coinpurse.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajstangiblecontainer in
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Luggage.Coinpurse
   * @augments adventurejs.Luggage
   * @class adventurejs.Coinpurse
   * @ajsconstruct MyGame.createAsset({ "class":"Coinpurse", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading LuggageClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A place for your arcade tokens.
   * @tutorial Tangibles_Aspects
   * @classdesc
   * <p>
   * <strong>Coinpurse</strong> is a subclass of
   * {@link adventurejs.Luggage|Luggage}. Its only real
   * characteristic of note is that you can put small things in it.
   * See the example below to limit a Coinpurse to hold only coins
   * or specified objects.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Coinpurse",
   *   name: "coinpurse",
   *   descriptions: { look: "It's a small coinpurse. ", },
   *   aspects: { in: {
   *     with_classes: ["Coin"],
   *   }, },
   * });
   * </code></pre>
   * <p>
   * The above example uses <code class="property">with_classes</code>
   * and <code class="property">with_assets</code> to limit what a
   * player can put in without having to write custom
   * failure code for every object. To learn more, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   **/
  class Coinpurse extends adventurejs.Luggage {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Coinpurse";

      this.singlePluralPairs = [["coinpurse", "coinpurses"]];
      this.aspects.in.set({
        maxheight: 0.1,
        maxwidth: 0.05,
        maxdepth: 0.025,
        maxcount: 3,
        maxsize: 0.2,
        maxweight: 1,
      });
    }
  }

  adventurejs.Coinpurse = Coinpurse;
})();

// Knapsack.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajstangiblecontainer in
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Luggage.Knapsack
   * @augments adventurejs.Luggage
   * @class adventurejs.Knapsack
   * @ajsconstruct MyGame.createAsset({ "class":"Knapsack", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading LuggageClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary For carrying your schoolbooks.
   * @tutorial Tangibles_Aspects
   * @classdesc
   * <p>
   * <strong>Knapsack</strong> is a subclass of
   * {@link adventurejs.Luggage|Luggage} that can be
   * worn and removed. It's possible to limit what can
   * be put in it by size, weight, and quantity.
   * It's also possible to restrict its contents to
   * certain classes or specific items.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * This example shows a Luggage instance that with
   * restrictions on the size, number, and weight of
   * things that can be put in it.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Knapsack",
   *   name: "knapsack",
   *   place: { in: "Closet" },
   *   descriptions: { look: "It's my favorite knapsack. I wear it everywhere. ", },
   *   adjectives: "favorite",
   *   in:
   *   {
   *     maxheight: 1,
   *     maxwidth: .5,
   *     maxdepth: .25,
   *     maxcount: 10, // can't hold more than 10 things
   *     maxweight: 100, // can't carry more than 100 units
   *   }
   * });
   * </code></pre>
   * <p>
   * This example shows a Knapsack instance that only
   * allows player to put certain items or classes in it.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Knapsack",
   *   name: "crapsack",
   *   place: { in: "Closet" },
   *   descriptions: { look: "I hate this knapsack. It's crap. ", },
   *   adjectives: "crappy",
   *   aspects: { in:
   *   {
   *     with_classes: ["Book", "Pen", "Pencil"], // any instance
   *     with_assets: ["pocket lint", "jacket fluff"], // specific items
   *   }, },
   * });
   * </code></pre>
   **/
  class Knapsack extends adventurejs.Luggage {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Knapsack";

      this.singlePluralPairs = [["knapsack", "knapsacks"]];
      this.synonyms = ["rucksack"];

      this.setDOVs(["wear", "remove"]);

      this.aspects.in.maxheight = 1;
      this.aspects.in.maxwidth = 0.5;
      this.aspects.in.maxdepth = 0.25;
      this.aspects.in.maxcount = 10;
      this.aspects.in.maxsize = 3;
      this.aspects.in.maxweight = 100;
      this.dimensions.size = 3;

      // this.parts.zipper = {
      //     adjectives: "",
      //     descriptions: { look: "There's nothing special about the knapsack's zipper.", },
      //     nouns: "zipper",
      // };
    }
  }

  adventurejs.Knapsack = Knapsack;
})();

// Purse.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajstangiblecontainer in
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Luggage.Purse
   * @augments adventurejs.Luggage
   * @class adventurejs.Purse
   * @ajsconstruct MyGame.createAsset({ "class":"Purse", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading LuggageClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary For carrying anything and everything.
   * @tutorial Tangibles_Aspects
   * @classdesc
   * <p>
   * <strong>Purse</strong> is a subclass of
   * {@link adventurejs.Luggage|Luggage} that can be
   * worn and removed. It's possible to limit what can
   * be put in it by size, weight, and quantity.
   * It's also possible to restrict its contents to
   * certain classes or specific items.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * This example shows a Luggage instance that with
   * restrictions on the size, number, and weight of
   * things that can be put in it.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Purse",
   *   name: "leather purse",
   *   place: { in: "Closet" },
   *   descriptions: { look: "It's a satchel, dammit! ", },
   *   in:
   *   {
   *     maxheight: .25,
   *     maxwidth: .1,
   *     maxdepth: .25,
   *     maxcount: 4, // can't hold more than 4 things
   *     maxweight: 2, // can't carry more than 2 units
   *   }
   * });
   * </code></pre>
   * <p>
   * This example shows a Knapsack instance that only
   * allows player to put certain items or classes in it.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Purse",
   *   name: "cheap vinyl purse",
   *   place: { in: "Closet" },
   *   descriptions: { look: "It's my low rent makeup bag. ", },
   *   aspects: { in:
   *   {
   *     with_classes: ["Makeup"], // any instance
   *     with_assets: ["lipstick", "compact", "eye liner"], // specific items
   *   }, },
   * });
   * </code></pre>
   **/
  class Purse extends adventurejs.Luggage {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Purse";

      this.singlePluralPairs = [["purse", "purses"]];

      this.aspects.in.maxheight = 0.5;
      this.aspects.in.maxwidth = 0.25;
      this.aspects.in.maxdepth = 0.1;
      this.aspects.in.maxcount = 10;
      this.aspects.in.maxsize = 1;
      this.aspects.in.maxweight = 5;

      this.setDOVs(["wear", "remove"]);
    }
  }

  adventurejs.Purse = Purse;
})();

// PaperMoney.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Money.PaperMoney
   * @augments adventurejs.Thing
   * @class adventurejs.PaperMoney
   * @ajsconstruct MyGame.createAsset({ "class":"PaperMoney", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A piece of paper money.
   * @classdesc
   * <p>
   * <strong>PaperMoney</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} meant for use as
   * currency.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; examine bill
   * It's a five dollar bill featuring Abraham Lincoln with an
   * old fashioned twirly mustache drawn on in black ink.
   * </pre>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "PaperMoney",
   *   name: "five dollar bill",
   *   descriptions: { look: "It's a five dollar bill. ", },
   *   place: { in: "leather wallet" },
   * });
   * </code></pre>
   **/
  class PaperMoney extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "PaperMoney";

      this.synonyms = ["bill", "money", "dollar"];
      this.setDOVs(["take", "give", "tear", "write"]);
      this.setIOV("type"); // ?

      this.append_written_strings_to_description = true;
    }
  }

  adventurejs.PaperMoney = PaperMoney;
})();

// Paper.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Paper
   * @augments adventurejs.Thing
   * @class adventurejs.Paper
   * @ajsconstruct MyGame.createAsset({ "class":"Paper", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A sheet of paper that can be typed on or written on.
   * @classdesc
   * <p>
   * <strong>Paper</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} with
   * <code class="property">asset.dov.write.enabled</code> and
   * <code class="property">can.be_typed_on</code> set to true.
   * <code class="property">asset.dov.write.enabled</code> allows it to receive
   * strings using the
   * {@link adventurejs.Verb|Verb} {@link write}.
   * <code class="property">can.be_typed_on</code> allows it to receive
   * strings typed on a
   * {@link adventurejs.Typewriter|Typewriter}
   * using the Verb {@link type}.
   * With Paper's
   * <code class="property">append_written_strings_to_description</code>
   * property set to true, anything written or typed
   * on it can be included in the Paper's description.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; write "cordon bleu" on blue sheet
   * You write "cordon bleu" on the blue sheet with the blue pencil.
   *
   * <span class="input">&gt; examine blue sheet
   * It's a blue sheet of paper. Written on the blue sheet is a phrase: "cordon bleu".
   * </pre>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Paper",
   *   name: "blue sheet",
   *   descriptions: { look: "It's a blue sheet of paper. ", },
   *   place: { in: "middle drawer" },
   * });
   * MyGame.createAsset({
   *   class: "Paper",
   *   name: "goldenrod sheet",
   *   descriptions: { look: "It's a goldenrod sheet of paper. ", },
   *   place: { in: "bottom drawer" },
   * });
   * MyGame.createAsset({
   *   class: "Paper",
   *   name: "pink sheet",
   *   descriptions: { look: "It's a pink sheet of paper. ", },
   *   place: { in: "top drawer" },
   * });
   * MyGame.createAsset({
   *   class: "Typewriter",
   *   name: "typewriter",
   *   place: { on: "desk" },
   *   descriptions: { look: "It's a top of the line IBM Selectric typewriter. ", },
   *   dov: { take: false, },
   * });
   * </code></pre>
   **/
  class Paper extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Paper";

      this.synonyms = ["paper"];
      this.setDOVs(["take", "give", "tear", "write"]);
      this.setIOV("type"); // ?

      this.append_written_strings_to_description = true;
    }
  }

  adventurejs.Paper = Paper;
})();

// Platform.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Platform
   * @augments adventurejs.Thing
   * @class adventurejs.Platform
   * @ajsconstruct MyGame.createAsset({ "class":"Platform", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajstangiblecontainer on
   * @summary Useful for dividing a Room into distinct areas.
   * @todo Expand this - clarify features and add examples
   * @classdesc
   * <p>
   * <strong>Platform</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} that can be used to
   * create distinct areas in a Room. Platform acts like a
   * floor and allows players to go on it, climb on it,
   * walk on it, sit on it, swing to/from it, etc.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * The example below shows two Platforms with their
   * <code>things_player_can_swing_to_from_this</code>
   * properties set to each other, with the idea that a
   * player could swing on a vine from one to the other.
   * Their <code>player_can_exit</code> property is set to false
   * so that a player can't just step off either platform.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Platform",
   *   name: "east side of the chasm",
   *   place: { in: "Deep Chasm" },
   *   description: "The east side of the deep chasm. ",
   *   things_player_can_swing_to_from_this: "west side of the chasm",
   * });
   * MyGame.createAsset({
   *   class: "Platform",
   *   name: "west side of the chasm",
   *   place: { in: "Deep Chasm" },
   *   description: "The west side of the deep chasm.",
   *   things_player_can_swing_to_from_this: "east side of the chasm",
   * });
   * </code></pre>
   **/
  class Platform extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Platform";

      this.is.listed_in_room = false;
      this.is.unlisted_but_list_children = true;

      this.is.climbable = true;

      this.quirks.go_on_means_climb = true;
      this.is.unleavable = true;

      this.can.float_over = true;
      this.can.jump_from = true;
      this.can.jump_to = true;
      this.can.run_over = true;
      this.quirks.step_on_means_stand_on = true;
      this.can.swing_from = true;
      this.can.swing_to = true;
      this.can.swing_over = false;
      this.can.swing_across = false;
      this.can.walk_over = false;

      this.default_aspect = "on";

      this.aspects.on = new adventurejs.Aspect("on", this.game_name).set({
        parent_id: this.id,
        list_in_room: true,
        list_in_examine: true,
        player: {
          can: {
            enter: true,
            crawl: true,
            exit: false,
            jump: true,
            kneel: true,
            lie: true,
            sit: true,
            stand: true,
          },
        },
      });

      // TODO
      // special handling for unnesting
    }
  }
  adventurejs.Platform = Platform;
})();

// Potion.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Potion
   * @augments adventurejs.Thing
   * @class adventurejs.Potion
   * @ajsconstruct MyGame.createAsset({ "class":"Potion", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Thing to put things in.
   * @classdesc
   * <p>
   * <strong>Potion</strong> that does not actually contain
   * any substance but which can be drunk and is destroyed
   * on drinking.
   * </p>
   **/
  class Potion extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Potion";

      this.setDOV({ drink: { then_destroy: true } });
      this.setDOVs(["take", "give"]);
      this.on_drink_destroy = true;
    }
  }

  adventurejs.Potion = Potion;
})();

// Rideable.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Rideable
   * @augments adventurejs.Thing
   * @class adventurejs.Rideable
   * @classdesc Explanation of the class.
   * @ajsconstruct MyGame.createAsset({ "class":"Rideable", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Base class for things like bicycles and skateboards.
   * @tutorial Tangibles_SimpleVehicles
   * @ajstangiblecontainer on
   * @classdesc
   * <p>
   * <strong>Rideable</strong> is the ancestor class for
   * things like {@link adventurejs.Bicycle|Bicycle} and
   * {@link adventurejs.Skateboard|Skateboard}.
   * Rideables are unique among other Asset classes in that
   * {@link adventurejs.Character|Characters} may carry them,
   * while also being nested in/on them.
   * Nesting is a special kind of parent/child relationship that
   * is only used for Characters.
   * This feature is a function of
   * {@link adventurejs.Tangible|Tangible}'s
   * <a href="#property_is_rideable" class="code property">is.rideable</a> property.
   * To learn more, see
   * <a href="/doc/Tangibles_SimpleVehicles.html">Simple Vehicles</a>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Rideable",
   *   name: "pogo stick",
   *   place: { in: "Toy Closet" },
   *   descriptions: { look: "It's a pogo stick. ", },
   * });
   * </code></pre>
   **/
  class Rideable extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Rideable";

      /**
       * Setting a Tangible
       * {@link adventurejs.Asset|Asset}'s
       * <strong>is.rideable</strong>
       * property to true allows players to ride the Tangible Asset
       * while still holding it in inventory.
       * <br><br>
       * Normally, when putting one Tangible
       * in/on/under/behind another, the child asset is
       * added to the parent asset's in/on/under/behind
       * {@link adventurejs.Aspect|Aspect}.
       * <br><br>
       * In the case of {@link adventurejs.Character|Characters},
       * they can only be
       * <strong>in</strong> the {@link adventurejs.Room|Room}
       * they are in. When Characters move in/on/under/behind
       * Tangible subclasses such as {@link adventurejs.Chair|Chairs}
       * or {@link adventurejs.Bed|Beds}, they become
       * <strong>nested</strong>, which is a secondary form of
       * parent/child relationship.
       * <br><br>
       * For example, the player is <strong>IN</strong> a room.
       * A bed is also <strong>IN</strong> the same room.
       * When the player gets <strong>ON</strong> the bed,
       * the player remains <strong>IN</strong> the room
       * and also becomes <strong>NESTED ON</strong> the bed.
       * <br><br>
       * We do this for a couple of reasons. One is to prevent
       * overcomplicating the routines that determine what
       * Tangible Assets are considered to be within scope when
       * parsing player input. Another is to avoid
       * circular child/parent relationships,
       * which overcomplicate save/restore operations.
       * Circular relationships also overcomplicate parsing player input.
       * <br><br>
       * For example, imagine that a player holds a skateboard
       * <strong>IN</strong> their inventory
       * and then stands <strong>ON</strong> the skateboard.
       * If both objects were in each other's Aspects,
       * that would be a circular relationship. By nesting the
       * player to the skateboard, the skateboard can remain
       * in the player's inventory with fewer complications.
       * @var {Boolean} adventurejs.Tangible#is!rideable
       * @default false
       *
       */
      this.is.rideable = true;

      this.setDOVs(["ride", "take", "give", "tie"]);

      this.on_tie_to_this_take_this = false;
      this.on_tie_to_drag_behind_rope = true;

      this.aspects.on = new adventurejs.Aspect("on", this.game_name).set({
        parent_id: this.id,
        list_in_room: false,
        list_in_examine: true,
        maxcount: 1, // presumably a cap
        with_classes: ["Character"],
        player: { can: { enter: true, stand: true, exit: true, ride: true } },
      });
    }
  }

  adventurejs.Rideable = Rideable;
})();

// Bicycle.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajstangiblecontainer on
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Rideable.Bicycle
   * @augments adventurejs.Rideable
   * @class adventurejs.Bicycle
   * @ajsconstruct MyGame.createAsset({ "class":"Bicycle", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading SportsEquipment
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary I want to ride my bicycle I want to ride my bike.
   * @tutorial Tangibles_SimpleVehicles
   * @classdesc
   * <p>
   * <strong>Bicycle</strong> is a child class of
   * {@link adventurejs.Rideable|Rideable},
   * which are unique in that
   * {@link adventurejs.Player|Player}
   * can both carry them in
   * inventory and simultaneously be nested in/on them.
   * Nesting is a special kind of parent/child relationship that
   * is only used for
   * {@link adventurejs.Character|Characters}.
   * For more information about the unique behavior of this class,
   * see the {@link adventurejs.Rideable|Rideable} page, or see
   * <a href="/doc/Tangibles_SimpleVehicles.html">Simple Vehicles</a>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Bicycle",
   *   name: "Sting Ray",
   *   synonyms: ["bike"], // the word "bicycle" is already provided with the class
   *   adjectives: ["Schwinn", "banana"],
   *   place: { in: "Garage" },
   *   descriptions: { look: "It's a classic Schwinn Sting Ray bicycle with banana seat. ", },
   *   customNestThatToThis: { // see <a href="/doc/Scripting_VerbActions.html">Verb Actions</a>
   *     "My Player": function(){
   *       MyGame.prependToOutput( "You wobble a bit getting on the bike. " );
   *       MyGame.appendToOutput( "Whew! " );
   *       // see <a href="/doc/Scripting_CustomizeOutput.html">Customize Output</a>
   *     }
   *   },
   *   customUnnestThatFromThis: {
   *     "My Player": function(){
   *       MyGame.prependToOutput( "You nearly fall getting off the bike. " );
   *       MyGame.appendToOutput( "Back on solid ground. " );
   *     }
   *   },
   * });
   * </code></pre>
   * <p>
   * The example above includes the use of several advanced methods
   * that are worth noting:
   * </p>
   * <ul>
   * <li>
   * {@link adventurejs.Tangible#customNestThatToThis|customNestThatToThis}
   * and
   * {@link adventurejs.Tangible#customUnnestThatFromThis|customUnnestThatFromThis}
   * are verb reactions that provide a way to run custom code
   * when a Character moves in/out of any other Asset that is
   * not a Room. To learn more, see
   * <a href="/doc/Scripting_VerbReactions.html">Verb Reactions</a>.
   * </li>
   * <li>
   * {@link adventurejs.Game#prependToOutput|prependToOutput}
   * and
   * {@link adventurejs.Game#appendToOutput|appendToOutput}
   * are methods that provide a way to prepend or append custom
   * strings to whatever default message will be output this turn.
   * To learn more, see
   * <a href="/doc/Scripting_CustomizeOutput.html">Customize Output</a>.
   * </li>
   * </ul>
   **/
  class Bicycle extends adventurejs.Rideable {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Bicycle";

      this.singlePluralPairs = [["bicycle", "bicycles"]];

      this.setDOVs(["tie"]);

      this.default_aspect = "on";

      this.quirks.climb_means_go_on = true;

      this.dimensions.size = 7;

      this.aspects.on = new adventurejs.Aspect("on", this.game_name).set({
        parent_id: this.id,
        maxcount: 0,
        player: {
          posture: "sit",
          preposition: "on",
          can: { enter: true, sit: true },
        },
      });
    }
  }
  adventurejs.Bicycle = Bicycle;
})();

// Skateboard.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajstangiblecontainer on
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Rideable.Skateboard
   * @augments adventurejs.Rideable
   * @class adventurejs.Skateboard
   * @ajsconstruct MyGame.createAsset({ "class":"Skateboard", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading SportsEquipment
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Whoa, that's a gnarly deck, dude.
   * @tutorial Tangibles_SimpleVehicles
   * @classdesc
   * <p>
   * <strong>Skateboard</strong> is a child class of
   * {@link adventurejs.Rideable|Rideable},
   * which are unique in that
   * {@link adventurejs.Player|Player}
   * can both carry them in
   * inventory and simultaneously be nested in/on them.
   * Nesting is a special kind of parent/child relationship that
   * is only used for
   * {@link adventurejs.Character|Characters}.
   * For more information about the unique behavior of this class,
   * see the {@link adventurejs.Rideable|Rideable} page, or see
   * <a href="/doc/Tangibles_SimpleVehicles.html">Simple Vehicles</a>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Skateboard",
   *   name: "Road Rider",
   *   synonyms: ["board"], // the word "skateboard" is already provided with the class
   *   adjectives: ["vintage"],
   *   place: { in: "Garage" },
   *   descriptions: { look: "It's a vintage 1970's Road Rider. ", },
   *   customNestThatToThis: { // see <a href="/doc/Scripting_VerbActions.html">Verb Actions</a>
   *     "My Player": function(){
   *       MyGame.prependToOutput( "You nearly wipe out trying to put one foot on the board. " );
   *       MyGame.appendToOutput( "You steady yourself slightly. " );
   *       // see <a href="/doc/Scripting_CustomizeOutput.html">Customize Output</a>
   *     }
   *   },
   *   customUnnestThatFromThis: {
   *     "My Player": function(){
   *       MyGame.prependToOutput( "The board nearly gets away as you prepare to dismount. " );
   *       MyGame.appendToOutput( "You take a small trip. " );
   *     }
   *   },
   * });
   * </code></pre>
   * <p>
   * The example above includes the use of several advanced methods
   * that are worth noting:
   * </p>
   * <ul>
   * <li>
   * {@link adventurejs.Tangible#customNestThatToThis|customNestThatToThis}
   * and
   * {@link adventurejs.Tangible#customUnnestThatFromThis|customUnnestThatFromThis}
   * are verb reactions that provide a way to run custom code
   * when a Character moves in/out of any other Asset that is
   * not a Room. To learn more, see
   * <a href="/doc/Scripting_VerbReactions.html">Verb Reactions</a>.
   * </li>
   * <li>
   * {@link adventurejs.Game#prependToOutput|prependToOutput}
   * and
   * {@link adventurejs.Game#appendToOutput|appendToOutput}
   * are methods that provide a way to prepend or append custom
   * strings to whatever default message will be output this turn.
   * To learn more, see
   * <a href="/doc/Scripting_CustomizeOutput.html">Customize Output</a>.
   * </li>
   * </ul>  **/
  class Skateboard extends adventurejs.Rideable {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Skateboard";
      this.singlePluralPairs = [["skateboard", "skateboards"]];
      this.default_aspect = "on";
      this.is.climbable = true;
      this.is.skateable = true;
      this.quirks.climb_means_go_on = true;
      this.quirks.step_on_means_stand_on = true;
    }
  }
  adventurejs.Skateboard = Skateboard;
})();

// Rope.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Rope
   * @augments adventurejs.Thing
   * @class adventurejs.Rope
   * @ajsconstruct MyGame.createAsset({ "class":"Rope", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Tie to things, tie things to other things.
   * @classdesc
   * <p>
   * <strong>Rope</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} that can be tied
   * to other Things. Ropes can be used to lasso other Things,
   * and can be used to swing across other things.
   * In theory a Rope can be tied to an item in a Room
   * and stretched across multiple Rooms.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Rope",
   *   name: "rope",
   *   place: { in: "Standing Room" },
   *   description: "It's a cotton rope. ",
   *   adjectives: [ "cotton" ],
   *   can: { be_in_multiple_rooms: false, },
   *   length_in_rooms: 1,
   * });
   * </code></pre>
   **/
  class Rope extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Rope";

      this.singlePluralPairs = [["rope", "ropes"]];

      this.setDOVs([
        "hold",
        "take",
        "give",
        "untie",
        "tie",
        "pull",
        "lasso",
        "tie",
      ]);
      this.unsetDOV("cut"); // ??

      this.descriptions.look = "It's a rope.";

      this.can.be_in_multiple_rooms = false;
      this.length_in_rooms = 0; // TODO traveling with rope
      this.can_cut_in_half = false; // ??

      //this.can.swing_on_if_holding = true;
      //this.must_be_supported_to_swing_on = true;
      this.can.swing_on_if_holding_and_supported = true;
      this.must.let_go_after_swing = true;
    }

    /**
     * A rope that is tied to things can be held but not taken.
     * @var adventurejs.Rope#can_hold
     */
    get can_hold() {
      var bool = false;
      var player = this.game.getPlayer();
      if (
        this.dov.tie?.with_params.connections.length ===
        this.dov.tie.with_params.max_connections
      ) {
        bool = true;
      }
      return bool;
    }
  }
  adventurejs.Rope = Rope;
})();

// Screen.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Screen
   * @augments adventurejs.Thing
   * @class adventurejs.Screen
   * @ajsconstruct MyGame.createAsset({ "class":"Screen", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading ElectronicsClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A screen that can display strings input on a {@link adventurejs.Keyboard|Keyboard}.
   * @classdesc
   * <p>
   * <strong>Screen</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} with its
   * <code class="property">is.typing_target</code> property set to true,
   * which allows it to receive and display strings input
   * on a {@link adventurejs.Keyboard|Keyboard}
   * using the
   * {@link adventurejs.Verb|Verb} {@link type}.
   * With Screen's
   * <code class="property">append_written_strings_to_description</code>
   * property set to true, anything typed on the Keyboard
   * can be included in the Screen's description.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; type "It was the best of times, it was the BLURST of times?" on keyboard</span>
   * You type "It was the best of times, it was the BLURST of times?"
   * on the keyboard. Your input appears on the screen as you type.
   *
   * <span class="input">&gt; x screen</span>
   * It's a fancy monitor. A line of input is visible on it:
   * "It was the best of times, it was the BLURST of times?"
   * </pre>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Screen",
   *   name: "screen",
   *   place: { on: "desk" },
   *   descriptions: { look: "It's an expensive looking computer display screen. ", },
   *   dov: { take: false, },
   * });
   * MyGame.createAsset({
   *   class: "Keyboard",
   *   name: "keyboard",
   *   place: { on: "desk" },
   *   descriptions: { look: "It's a keyboard. You can type on it. ", },
   *   dov: { take: false, },
   *   typing_target_id: "screen",
   * });
   * </code></pre>
   */
  class Screen extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Screen";

      this.is.typing_target = true;

      this.append_written_strings_to_description = true;
    }
  }
  adventurejs.Screen = Screen;
})();

// Plug.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Plug
   * @augments adventurejs.Thing
   * @class adventurejs.Plug
   * @ajsconstruct MyGame.createAsset({ "class":"Plug", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BathroomClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @ajspartof Drain, Sink
   * @summary Used to plug drains.
   * @classdesc
   * <p>
   * <strong>Plug</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} but in fact any
   * {@link adventurejs.Tangible|Tangible}
   * {@link adventurejs.Asset|Asset}
   * can be used as a plug by including the ID
   * of assets it can plug in its
   * <code>asset.iov.plug.with_assets</code>.
   * A corresponding
   * <code>asset.dov.plug.with_assets</code>.
   * value is set to specify assets that can be used to plug
   * {@link adventurejs.Drain|Drains}.
   * When setting up paired assets, it's only necessary to set one
   * or the other of these properties as the pairing will be applied
   * to both assets during game initialization.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <p>
   * The following example shows a plug and its corresponding drain.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Plug",
   *   name: "sink plug",
   *   synonyms: "plug",
   *   iov: { plug: { with_assets: { 'sink drain' }, }, },
   *   place: { in: "sink drain" },
   *   descriptions: { look: "A sink drain plug. ", },
   * });
   *
   * MyGame.createAsset({
   *   class: "Drain",
   *   name: "sink drain",
   *   is: { closed: true },
   *   dov: { plug: { with_assets: { 'sink plug' }, }, },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "A dark drain. Currently
   *       $( sink drain is| open or| closed ). "
   *     },
   *   },
   * });
   * </code></pre>
   *
   * <p>
   * Some classes contain more advanced methods for linking
   * specific related asset classes. For instance, the
   * {@link adventurejs.Sink|Sinks} class has a
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_parts">parts</a>
   * property that allows for easy linking of drain and plug assets.
   * </p>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Sink",
   *   name: "sink",
   *   place: { in: "Utility Room" },
   *   descriptions: {
   *     look: function()
   *     {
   *       return "A grubby utility sink with a stained drain that is currently $( sink drain is| open or| closed ). ";
   *       // see <a href="/doc/Scripting_CustomTemplates.html">Custom Templates</a> to learn about $( sink drain is| open or| closed )
   *     },
   *   },
   *   parts: [
   *     // see <a href="/doc/Tangibles_LinkedAssets.html">Linked Assets</a> to learn about parts
   *     "sink drain",
   *     "sink plug"
   *   ],
   * });
   * </code></pre>
   * <p>
   * <a class="code" href="/doc/adventurejs.Tangible.html#property_parts">parts</a>
   * allows an author to easily link certain types of class instances.
   * As shown here, the class for {@link adventurejs.Sink|Sinks}
   * contains a method for linking sinks with their constituent parts
   * including drains and faucets.
   * See
   * <a href="/doc/Tangibles_LinkedAssets.html">Linked Assets</a>
   * to learn about parts.
   * <br><br>
   * The Sink and Drain descriptions include this String Substitution:
   * $( sink drain is| open or| closed )
   * which will substitute the word "open" or
   * "closed" depending on the Drain's state. See
   * <a href="/doc/Scripting_CustomTemplates.html">Custom Templates</a>
   * to learn more.
   * </p>
   **/
  class Plug extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Plug";

      this.singlePluralPairs = [["plug", "plugs"]];

      this.descriptions.look = "It's a plug.";

      this.is.listed_in_parent = true;

      this.setDOVs(["take", "give", "put"]);

      this.setIOV("plug", {
        with_params: {
          take_breaks_connections: true,
        },
      });

      this.dimensions.width = 0.1;
      this.dimensions.height = 0.1;
    }
  }
  adventurejs.Plug = Plug;
})();

// SubstanceEmitter.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.SubstanceEmitter
   * @augments adventurejs.Thing
   * @class adventurejs.SubstanceEmitter
   * @ajsconstruct MyGame.createAsset({ "class":"SubstanceEmitter", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BaseClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Generates a specified substance, in specified quantity per turn.
   * @tutorial Substances_Emitters
   * @ajssubstancecontainer in
   * @ajstangiblecontainer in
   * @classdesc
   * <p>
   * <strong>SubstanceEmitter</strong> is a subclass of
   * {@link adventurejs.Thing|Thing},
   * and is a special class that emits a specified
   * {@link adventurejs.Substance|Substance},
   * like water from a
   * {@link adventurejs.Faucet|Faucet},
   * or dirt from a mining chute.
   * SubstanceEmitter has a
   * {@link adventurejs.Aspect|Aspect},
   * which in turn has a
   * {@link adventurejs.Vessel|Vessel}.
   * which has its
   * <code class="property"><a href="#is_emitter">is_emitter</a></code>
   * property set to true.
   * In other words,
   * <code class="property">Tangible.Aspect.Vessel.is_emitter = true</code>,
   * or as a practical example:
   * <code class="property">faucet.aspects.in.vessel.is_emitter = true</code>.
   * </p>
   * <p>
   * A SubstanceEmitter can be linked with a
   * {@link adventurejs.GraduatedController|GraduatedController}
   * such as a {@link adventurejs.Handle|Handle}
   * to control its rate of flow.
   * See the {@link adventurejs.Sink|Sink} page for an example
   * that includes a Sink with linked Faucet and Handle.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "SubstanceEmitter",
   *   name: "waterfall",
   *   descriptions: { look: "A thin waterfall sputters out of the cave wall. ", },
   *   substance_id: "water",
   *   max_volume_of_flow_per_turn: 10000, // in ml
   *   place: { attached: "cave wall" },
   * });
   * </code></pre>
   * <p>
   * To learn more, see
   * <a href="/doc/Substances_AboutSubstances.html">Substances</a>.
   * </p>
   * @todo add linked GraduatedController example
   **/
  class SubstanceEmitter extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "SubstanceEmitter";

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
      });

      this.aspects.in.vessel = new adventurejs.Vessel("in", game_name).set({
        parent_id: this.id,
        is_emitter: true,
        max_volume_of_flow_per_turn: 0,
      });

      // duplicate prop to substance, but justified
      this.rate_of_flow = 0; // 0 to 1 // setting this sets substance rate_of_flow

      // duplicate prop to substance, questionable
      //this.is_emitting = false;
      //this.substance_id = ""; //??
      //this.target_id = "";
      //this.max_volume_of_flow_per_turn = 0;

      this.can.be_filled_from = true;

      this.describe_temperatures = true;

      this.setDOVs(["turn"]);

      this.dov.turn.doAfterTry = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var direct_preposition = input.getPreposition(1);

        // sentence structure: verb preposition noun
        if (input.hasStructure("verb preposition noun")) {
          if (direct_preposition === "on") return this.turnOn_doAfterTry();
          if (direct_preposition === "off") return this.turnOff_doAfterTry();
        } // verb preposition noun
      };

      this.turnOn_doAfterTry = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var msg = "";

        // nothing with which to turn the faucet on
        // @TODO create option to turn on faucet without a controller
        // if( !direct_object.hasProperty('registered_parts.GraduatedControllers')
        // || 0 === direct_object.registered_parts.GraduatedControllers.length )
        if (!direct_object.registered_parts?.GraduatedControllers?.length) {
          this.game.debug(
            `F1561 | pour.js | ${direct_object.id} has no GraduatedControllers `
          );
          msg += `$(We) can't turn on ${direct_object.articlename}. `;
          this.game.dictionary.verbs[params.verb].handleFailure(msg);
          return null;
        } else {
          // get a list of controllers for this item
          // the reason there may be multiple controllers is to
          // handle things like sinks with multiple faucets
          // or a soda machine with multiple soda choices on one nozzle
          var controllers = direct_object.registered_parts.GraduatedControllers;
          var controller_count = controllers.length;
          // if there are multiple controllers, pick one at random
          var rand = Math.floor(Math.random() * controller_count);
          var controller = this.game.getAsset(controllers[rand]);
          input.setAsset(1, controller);
          input.allow_circular_verb = true;
          // Pass turn verb to the controller
          // because it has specialized logic of its own
          // that will call back to this object.
          // The reason for this circuity is to handle the player saying
          // "turn on faucet" instead of "turn handle"
          // It's the handle that turns on the faucet, but it's stupid
          // to tell the player "you can't turn on the faucet"
          this.game.dictionary.doVerb("turn");
          return null;
        }
      };

      this.turnOff_doAfterTry = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var msg = "";

        // nothing with which to turn the faucet off
        if (!direct_object.registered_parts.GraduatedControllers) {
          this.game.debug(
            `F1554 | SubstanceEmitter.js | ${direct_object.id} has no GraduatedControllers `
          );
          msg += `$(We) can't turn off ${direct_object.articlename}. `;
          this.game.dictionary.verbs[params.verb].handleFailure(msg);
          return null;
        }
        // turn off all controllers
        var controllers = direct_object.registered_parts.GraduatedControllers;
        var controller_count = controllers.length;
        var controllers_to_turn_off_count = 0;
        for (var c = 0; c < controller_count; c++) {
          var controller = this.game.getAsset(controllers[c]);
          if (0 < controller.current_position) {
            console.warn("turning off controller " + controller.id);
            controllers_to_turn_off_count++;
            input.setAsset(1, controller);
            input.allow_circular_verb = true;
            this.game.dictionary.doVerb("turn");
          }
        }
        if (0 === controllers_to_turn_off_count) {
          msg = `${direct_object.Articlename} isn't on. `;
          this.game.dictionary.verbs[params.verb].handleFailure(msg);
        }
        return null;
      };
    }

    /**
     * Shortcut to
     * Tangible.Aspect.Vessel.rate_of_flow.
     * @var {Getter/Setter} adventurejs.SubstanceEmitter#rate_of_flow
     */
    get rate_of_flow() {
      //return this.__rate_of_flow;
      return this.aspects.in.vessel.rate_of_flow;
    }
    set rate_of_flow(rate) {
      if (rate > 0) {
        this.setEmitter(true);
      }
      if (rate <= 0) {
        this.setEmitter(false);
      }
      //this.__rate_of_flow = rate;
      this.aspects.in.vessel.rate_of_flow = rate;
    }

    /**
     * Shortcut to
     * Tangible.Aspect.Vessel.volume_of_flow_per_turn
     * x Tangible.Aspect.Vessel.rate_of_flow
     * @var {Getter} adventurejs.SubstanceEmitter#volume
     */
    get volume() {
      return (
        this.aspects.in.vessel.volume_of_flow_per_turn *
        this.aspects.in.vessel.rate_of_flow
      );
    }

    /**
     * Shortcut to
     * Tangible.Aspect.Vessel.is_emitting.
     * @var {Getter/Setter} adventurejs.SubstanceEmitter#is_emitting
     */
    get is_emitting() {
      return this.aspects.in.vessel.is_emitting;
    }
    set is_emitting(bool) {
      this.aspects.in.vessel.is_emitting = bool;
    }

    /**
     * Shortcut to
     * Tangible.Aspect.Vessel.substance_id.
     * @var {Getter/Setter} adventurejs.SubstanceEmitter#substance_id
     */
    get substance_id() {
      return this.aspects.in.vessel.substance_id;
    }
    set substance_id(id) {
      this.aspects.in.vessel.substance_id = id;
    }

    /**
     * Shortcut to
     * Tangible.Aspect.Vessel.target_id.
     * @var {Getter/Setter} adventurejs.SubstanceEmitter#target_id
     */
    get target_id() {
      return this.aspects.in.vessel.target_id;
    }
    set target_id(id) {
      this.aspects.in.vessel.target_id = id;
    }

    /**
     * Shortcut to
     * Tangible.Aspect.Vessel.volume_of_flow_per_turn.
     * @var {Getter} adventurejs.SubstanceEmitter#volume_of_flow_per_turn
     */
    get volume_of_flow_per_turn() {
      return this.aspects.in.vessel.volume_of_flow_per_turn;
    }

    /**
     * Shortcut to
     * Tangible.Aspect.Vessel.max_volume_of_flow_per_turn.
     * @var {Getter/Setter} adventurejs.SubstanceEmitter#max_volume_of_flow_per_turn
     */
    get max_volume_of_flow_per_turn() {
      return this.aspects.in.vessel.max_volume_of_flow_per_turn;
    }
    set max_volume_of_flow_per_turn(maxvol) {
      this.aspects.in.vessel.max_volume_of_flow_per_turn = maxvol;
    }

    /**
     * Turns emitter on/off by setting this.is_emitting bool.
     * Also registers / unregisters with
     * {@link Adventurejs.Game#registerInterval|Game#registerInterval}
     * /
     * {@link Adventurejs.Game#unregisterInterval|Game#unregisterInterval},
     * which adds / subtracts this.emit() as a callback to
     * game.world._intervals. Registered callbacks are called at the
     * end of every turn. They're also saved with saved games, so that
     * restored games can resume with registered callbacks.
     * @memberof adventurejs.SubstanceEmitter
     * @method adventurejs.SubstanceEmitter#setEmitter
     */
    setEmitter(enable) {
      if (enable && false === this.is_emitting) {
        this.is_emitting = true;
        this.game.registerInterval(this.id, "emit");
      }
      if (false === enable && true === this.is_emitting) {
        this.is_emitting = false;
        this.game.unregisterInterval(this.id, "emit");
      }
    }

    /**
     * Causes the emitter to pour substance
     * into its target_id. If target already contains substance,
     * they are mixed. If target is infinite, it remains unaffected.
     * If target is full, it overflows into its container.
     * This gets registered as a callback through
     * {@link Adventurejs.Game#registerInterval|Game#registerInterval}
     * so that it can be called on every turn,
     * and its state can be saved with saved games.
     * @memberof adventurejs.SubstanceEmitter
     * @method adventurejs.SubstanceEmitter#emit
     */
    emit() {
      this.game.log(
        "log",
        "high",
        "SubstanceEmitter.js > " + this.name + " emit ",
        "SubstanceEmitter"
      );
      var msg = "";

      // has the emitter got flow?
      // if not, we're outta here
      if (0 >= this.aspects.in.vessel.volume_of_flow_per_turn) {
        return;
      }

      // create a SubstanceMixer to handle the details
      var mixer = new adventurejs.SubstanceMixer(this.game.game_name).set({
        source_input: this.id,
        source_aspect: "in",
        source_substance_id: this.aspects.in.vessel.substance_id,
        target_input: this.target_id,
      });

      var results = mixer.mix();
      if (A.isFalseOrNull(results)) return results;

      // Get temperature string. Temperature could be a spoiler
      // authors might not want, which is why we have an option.
      if (true === this.describe_temperatures) {
        var temp = this.game.dictionary.getStringLookupByRange(
          "substance_temperatures",
          this.aspects.in.vessel.temperature
        );
        msg = A.propercase(temp) + " " + mixer.source_substance_asset.name;
      } else {
        // no temp string
        msg = mixer.source_substance_asset.Name;
      }

      msg += " pours from the " + mixer.source_asset.name;

      var parent = mixer.source_asset.getPlaceAsset();
      if (mixer.target_asset) {
        var iparent = mixer.target_asset.getPlaceAsset();
        msg += " into the ";
        msg += mixer.target_asset.name;

        if (mixer.did_overflow_target) {
          msg +=
            " and spills out onto " +
            ("Room" === iparent.class ? "the floor" : iparent.articlename);
        } else if (mixer.can_drain_target) {
          msg += ", where it quickly drains away";
        }
      } else {
        msg += " and spills out onto ";
        msg += "Room" === parent.class ? "the floor" : parent.articlename;
      }
      msg += ". ";

      // print a thing if player is present
      if (mixer.source_asset.getRoomId() === this.game.world._currentRoom) {
        this.game.print(msg);
      }
    }

    /**
     * Responds to changes made to an associated GraduatedController.
     * @memberof adventurejs.SubstanceEmitter
     * @method adventurejs.SubstanceEmitter#onChangeGraduatedController
     */
    onChangeGraduatedController(direct_object) {
      // passing direct_object because it may not
      // be the same object found in game.getInput()
      //console.warn( "change " + direct_object.id + " > " + game );
      var old_rate = this.rate_of_flow;
      var new_rate = 0;
      var controller,
        controller_count,
        controller_percent,
        percent_per_controller;
      var substances = [];
      var temperatures = [];
      this.aspects.in.vessel.vessel_is_known = true;

      // check if any GraduatedControllers were registered
      if (
        "undefined" !== typeof this.registered_parts.GraduatedControllers &&
        0 < this.registered_parts.GraduatedControllers.length
      ) {
        // how many GraduatedControllers?
        controller_count = this.registered_parts.GraduatedControllers.length;
        percent_per_controller = 1 / controller_count;

        // check state of each controller
        // and calculate what volume it's contributing
        this.registered_parts.GraduatedControllers.forEach(function (id) {
          controller = this.game.getAsset(id);

          this.game.log(
            "log",
            "high",
            "SubstanceEmitter.js > GraduatedController " + id,
            "SubstanceEmitter"
          );
          this.game.log(
            "log",
            "high",
            "SubstanceEmitter.js >  .current_position " +
              controller.current_position,
            "SubstanceEmitter"
          );
          this.game.log(
            "log",
            "high",
            "SubstanceEmitter.js >  .control_positions " +
              controller.control_positions,
            "SubstanceEmitter"
          );
          this.game.log(
            "log",
            "high",
            "SubstanceEmitter.js >  .set_substance_id " +
              controller.set_substance_id,
            "SubstanceEmitter"
          );
          this.game.log(
            "log",
            "high",
            "SubstanceEmitter.js >  .set_substance_temperature " +
              controller.set_substance_temperature,
            "SubstanceEmitter"
          );

          if (controller && controller.current_position > 0) {
            controller_percent =
              controller.control_positions / (controller.current_position + 1);
            //console.warn( " - controller_percent " + controller_percent );
            new_rate = new_rate + controller_percent * percent_per_controller;
            if (controller.set_substance_id) {
              substances.push(controller.set_substance_id);
              if (!isNaN(controller.set_substance_temperature)) {
                temperatures.push(controller.set_substance_temperature);
              }
            }
          }
        }, this);
        this.rate_of_flow = new_rate;
        //console.warn( " - new_rate " + new_rate );
        //console.warn( " - substances " + substances.toString() );

        if (1 === substances.length) {
          this.game.log(
            "log",
            "high",
            "SubstanceEmitter.js > one substance found, set temperature of " +
              this.name +
              " to " +
              temperatures[0],
            "SubstanceEmitter"
          );
          this.aspects.in.vessel.substance_id = substances[0];
          this.aspects.in.vessel.temperature = temperatures[0];
        } else if (2 === substances.length) {
          var output_substance_id;
          var output_substance_asset;
          this.aspects.in.vessel.substance_id = substances[0];

          // TODO This is simplified/incomplete. Ideally temp should be
          // effected by volume of each input so if one handle is open
          // more than the other it should add more weight
          // see SubstanceMixer.mixTemps
          this.aspects.in.vessel.temperature = (
            (temperatures[0] + temperatures[1]) /
            2
          ).toFixed(0);
          var msg =
            "two substances found, set temperature of " +
            this.name +
            " to average of " +
            temperatures[0] +
            " and " +
            temperatures[1];
          this.game.log(
            "log",
            "high",
            "SubstanceEmitter.js > " + msg,
            "SubstanceEmitter"
          );

          var sub1 = this.game.getAsset(substances[0]);
          var sub2 = this.game.getAsset(substances[1]);

          this.game.log(
            "log",
            "high",
            "SubstanceEmitter.js > sub1 " + sub1,
            "SubstanceEmitter"
          );
          this.game.log(
            "log",
            "high",
            "SubstanceEmitter.js > sub2 " + sub2,
            "SubstanceEmitter"
          );

          if (sub1 && sub2) {
            if (sub1.mixwith[sub2.id]) {
              output_substance_id = sub1.mixwith[sub2.id];
            } else if (sub2.mixwith[sub1.id]) {
              output_substance_id = sub2.mixwith[sub1.id];
            }
          }
          if (output_substance_id) {
            output_substance_asset = this.game.getAsset(output_substance_id);
            if (output_substance_asset) {
              this.aspects.in.substance_id = output_substance_id;
            }
          }
        } else if (2 < substances.length) {
          // TODO more than two graduatedControllers
          // example being a soda fountain with multiple switches
        }
      }

      var msg = "";
      if (new_rate === old_rate) {
        msg = "Nothing happens. ";
      } else if (new_rate > old_rate && 0 === old_rate) {
        msg = this.Articlename + " turns on. ";
      } else if (new_rate > old_rate) {
        msg = this.Articlename + "'s pressure increases. ";
      } else if (new_rate === 0) {
        msg = this.Articlename + " shuts off. ";
      } else if (new_rate < old_rate) {
        msg = this.Articlename + "'s pressure decreases. ";
      } else {
        msg = "Nothing happens. ";
      }

      if (msg) return msg;
      else return true;
    }
  }
  adventurejs.SubstanceEmitter = SubstanceEmitter;
})();

// Faucet.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspartof Sink
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.SubstanceEmitter.Faucet
   * @augments adventurejs.SubstanceEmitter
   * @class adventurejs.Faucet
   * @ajsconstruct MyGame.createAsset({ "class":"Faucet", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BathroomClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Faucet is a SubstanceEmitter that can generate liquid.
   * @tutorial Substances_Emitters
   * @classdesc
   * <p>
   * <strong>Faucet</strong> is a subclass of
   * {@link adventurejs.SubstanceEmitter|SubstanceEmitter}.
   * When it's turned on, water (or other specified
   * {@link adventurejs.Substance|Substance})
   * will emit from it. A Faucet can be linked with a
   * {@link adventurejs.Sink|Sink} or
   * {@link adventurejs.Bathtub|Bathtub} or other
   * {@link adventurejs.Vessel|Vessel}
   * such that the Faucet pours into the basin. A Faucet
   * can also stand on its own, as with an outdoor hose bib,
   * and be allowed to pour onto the ground. By itself, a Faucet
   * has no controls. Pair it with a
   * {@link adventurejs.Handle|Handle}
   * to control its rate of flow.
   * Use a Faucet's
   * <code class="property">rate_of_flow</code> and
   * <code class="property">max_volume_of_flow_per_turn</code> properties to
   * set how much volume of substance will be generated per turn.
   * See the {@link adventurejs.Sink|Sink} page for an example
   * that includes a Sink with linked Faucet and Handle.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Faucet",
   *   name: "hose bib",
   *   synonyms: [ "bib" ],
   *   descriptions: { look: "A hose bib . ", },
   *   substance_id: "water",
   *   max_volume_of_flow_per_turn: 1000,
   *   place: { attached: "garden wall" },
   * });
   * </code></pre>
   * <p>
   * To learn more, see
   * <a href="/doc/Substances_AboutSubstances.html">Substances</a>.
   * </p>
   * @todo registerParts faucet+handle(s) without sink.
   **/
  class Faucet extends adventurejs.SubstanceEmitter {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Faucet";

      this.singlePluralPairs = [["faucet", "faucets"]];

      this.descriptions.look = "It's a faucet.";

      this.is.listed_in_parent = false;

      this.dimensions.width = 1;
      this.dimensions.height = 1;

      //this.max_volume_of_flow_per_turn = 500;
      this.aspects.in.vessel.max_volume_of_flow_per_turn = 500;

      this.setDOVs(["turn", "drink"]);

      this.unsetDOVs(["give", "take"]);
    }
  }
  adventurejs.Faucet = Faucet;
})();

// Typewriter.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.Typewriter
   * @augments adventurejs.Thing
   * @class adventurejs.Typewriter
   * @ajsconstruct MyGame.createAsset({ "class":"Typewriter", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A typewriter that players can type on.
   * @ajstangiblecontainer in
   * @classdesc
   * <strong>Typewriter</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} with a
   * verb_hooks for the
   * {@link adventurejs.Verb|Verb} {@link type}.
   * (For more information about verb hooks, see
   * <a href="/doc/Scripting_VerbPhases.html">Verb Phases</a>.)
   * It accepts input in the form of
   * <code class="property">type "foo" on typewriter</code> where "foo" is a
   * string with quotes around it. Keyboard can have its
   * <code class="property">typing_target_id</code> set to an
   * {@link adventurejs.Asset|Asset} with its
   * <code class="property">is.typing_target</code> property set to true,
   * and the input string will display on it. See the following
   * transcript to get an idea how this plays out.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; x typewriter</span>
   * It's a typewriter.
   *
   * <span class="input">&gt; type "foo" on typewriter</span>
   * There's no paper in the typewriter. You bang out "foo"
   * on the keys but nothing comes of it.
   *
   * <span class="input">&gt; open middle drawer</span>
   * You open the middle drawer. In the middle drawer you see a blue sheet.
   *
   * <span class="input">&gt; take blue sheet</span>
   * You take the blue sheet from the middle drawer.
   *
   * <span class="input">&gt; put blue sheet in typewriter</span>
   * You put the blue sheet in the typewriter.
   *
   * <span class="input">&gt; type "cordon bleu" on typewriter</span>
   * You type "cordon bleu" on the blue sheet.
   *
   * <span class="input">&gt; x blue sheet</span>
   * It's a blue sheet of paper. Printed on the blue sheet is a phrase: "cordon bleu".
   * </pre>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Typewriter",
   *   name: "typewriter",
   *   place: { on: "desk" },
   *   descriptions: { look: "It's an old fashioned Corona typewriter. ", },
   *   dov: { take: false, },
   * });
   * MyGame.createAsset({
   *   class: "Paper",
   *   name: "blue sheet",
   *   descriptions: { look: "It's a blue sheet of paper. ", },
   *   place: { in: "middle drawer" },
   * });
   * </code></pre>
   **/
  class Typewriter extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Typewriter";

      this.setDOVs(["type", "take", "give"]);
      this.setIOV("type");

      this.aspects.in = new adventurejs.Aspect("in", this.game_name).set({
        parent_id: this.id,
        classes_allowed: ["Paper"],
        list_in_examine: true,
        maxcount: 1,
      });

      /**
       * Typewriter needs a sheet of paper in it.
       *
       * doAfterTry lets the verb's standard checks run
       * before checking specifics for this object
       *
       * doBeforeSuccess preempts doSuccess because
       * we want to override the standard success
       */
      // @TODO dov? iov?
      this.dov.type.doAfterTry = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        if (direct_object.aspects.in.contents.length == 0) {
          var msg =
            "There's no paper in " +
            direct_object.articlename +
            ". $(We) bang ";
          if (0 < input.strings.length) {
            msg += "out " + input.strings[0] + " ";
          }
          msg += "on the keys but nothing comes of it. ";
          this.game.dictionary.verbs[params.verb].handleFailure(
            msg,
            direct_object
          );
          return null;
        }

        return true;
      };

      this.dov.type.doBeforeSuccess = function (params) {
        var input = this.game.getInput();
        var direct_object = input.getAsset(1);
        var msg = "";

        var indirect_object = this.game.getAsset(
          direct_object.aspects.in.contents[0]
        );

        // state change?
        if (indirect_object && input.strings.length) {
          indirect_object.written_strings.push(input.strings[0]);
        }

        // compose output
        msg += `$(We) type `;
        msg += input.strings.length ? `${input.strings[0]} ` : ``;
        msg += `on ${
          indirect_object
            ? indirect_object.articlename
            : direct_object.articlename
        }. `;

        // print output
        this.game.dictionary.verbs[params.verb].handleSuccess(
          msg,
          direct_object
        );
        return null;
      };
    }
  }
  adventurejs.Typewriter = Typewriter;
})();

// WritingImplement.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.WritingImplement
   * @augments adventurejs.Thing
   * @class adventurejs.WritingImplement
   * @ajsconstruct MyGame.createAsset({ "class":"WritingImplement", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Generic base class for pens, pencils and the like.
   * @ajstangiblecontainer attached
   * @classdesc
   * <p>
   * <strong>WritingImplement</strong> is a subclass of
   * {@link adventurejs.Thing|Thing}, and is chiefly notable
   * in that its <code class="property">iov.write</code>
   * property is set to true, which allows a player to write on things
   * with <code class="property">dov.write</code>
   * set to true, such as {@link adventurejs.Paper|Paper}.
   * </p>
   * <p>
   * WritingImplement has an <code class="property">attached</code>
   * {@link adventurejs.Aspect|Aspect}
   * which allows one thing to be attached to it. No particular
   * things are specified. See
   * {@link adventurejs.Pen|Pen} and
   * {@link adventurejs.Pencil|Pencil} for examples of
   * WritingImplements that specify a certain class which
   * may be attached.
   * To learn more about limiting what may be attached, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "WritingImplement",
   *   name: "purple crayon",
   *   article: "a",
   *   place: { in: "crayon box" },
   *   descriptions: { look: "This purple crayon looks like it could be used to draw anything. ", },
   * });
   * MyGame.createAsset({
   *   class: "Paper",
   *   name: "construction paper",
   *   descriptions: { look: "It's a pink sheet of construction paper. ", },
   *   adjectives: ["pink"]
   *   place: { in: "bottom drawer" },
   * });
   * </code></pre>
   **/
  class WritingImplement extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "WritingImplement";

      this.setIOV("write");
      this.setDOVs(["take", "give", "tie", "turn"]);

      this.on_tie_to_this_take_this = true;
      this.on_tie_to_drag_behind_rope = true;
      this.can.turn = true;
    }
  }
  adventurejs.WritingImplement = WritingImplement;
})();

// Chalk.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.WritingImplement.Chalk
   * @augments adventurejs.WritingImplement
   * @class adventurejs.Chalk
   * @ajsconstruct MyGame.createAsset({ "class":"Chalk", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A writing implement.
   * @classdesc
   * <p>
   * <strong>Chalk</strong> is a subclass of
   * {@link adventurejs.WritingImplement|WritingImplement}.
   * Chalk and other WritingImplements have
   * <code class="property">iov.write.enabled</code>
   * property set to true, which allows a player to write on things
   * with <code class="property">asset.dov.write.enabled</code>
   * set to true, such as {@link adventurejs.Paper|Paper}.
   * </p>
   * <p>
   * All that distinguishes Chalk from other WritingImplements
   * is that ...
   *
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Chalk",
   *   name: "stick of chalk",
   *   adjectives: [ "white" ],
   *   article: "a",
   *   place: { on: "table" },
   *   descriptions: { look: "It's an ordinary stick of white chalk. ", },
   * });
   * MyGame.createAsset({
   *   class: "Blackboard",
   *   name: "blackboard",
   *   descriptions: { look: "It's a large blackboard. ", },
   *   place: { in: "Schoolroom" },
   * });
   * </code></pre>
   * <p>
   * The above example uses
   * <code class="property">with_classes</code>
   * to limit what a
   * player can write on without having to write custom
   * failure code for every object. To learn more, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   **/
  class Chalk extends adventurejs.WritingImplement {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Chalk";

      this.noun = "chalk";
      this.plural = "chalk";
      this.singlePluralPairs = [["chalk", "chalk"]];
      this.group = ["writing implements"];
    }
  }
  adventurejs.Chalk = Chalk;
})();

// Marker.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.WritingImplement.Marker
   * @augments adventurejs.WritingImplement
   * @class adventurejs.Marker
   * @ajsconstruct MyGame.createAsset({ "class":"Marker", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A writing implement.
   * @classdesc
   * <p>
   * <strong>Marker</strong> is a subclass of
   * {@link adventurejs.WritingImplement|WritingImplement}.
   * Marker and other WritingImplements have their
   * <code class="property">iov.write</code>
   * property set to true, which allows a player to write on things
   * with <code class="property">asset.dov.write</code>
   * set to true, such as {@link adventurejs.Paper|Paper}.
   * </p>
   * <p>
   * All that distinguishes Marker from other WritingImplements
   * is that ...
   *
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Marker",
   *   name: "dry erase marker",
   *   adjectives: [ "green" ],
   *   article: "a",
   *   place: { on: "table" },
   *   descriptions: { look: "It's an ordinary green dry erase marker. ", },
   * });
   * MyGame.createAsset({
   *   class: "Whiteboard",
   *   name: "whiteboard",
   *   descriptions: { look: "It's a large whiteboard. ", },
   *   place: { in: "Office" },
   * });
   * </code></pre>
   * <p>
   * The above example uses
   * <code class="property">with_classes</code>
   * to limit what a
   * player can write on without having to write custom
   * failure code for every object. To learn more, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   **/
  class Marker extends adventurejs.WritingImplement {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Marker";

      this.noun = "marker";
      this.plural = "markers";
      this.singlePluralPairs = [["marker", "markers"]];
      this.group = ["writing implements"];
    }
  }
  adventurejs.Marker = Marker;
})();

// Pen.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.WritingImplement.Pen
   * @augments adventurejs.WritingImplement
   * @class adventurejs.Pen
   * @ajsconstruct MyGame.createAsset({ "class":"Pen", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A writing implement.
   * @classdesc
   * <p>
   * <strong>Pen</strong> is a subclass of
   * {@link adventurejs.WritingImplement|WritingImplement}.
   * Pens and other WritingImplements have their
   * <code class="property">iov.write.enabled</code>
   * property set to true, which allows a player to write on things
   * with <code class="property">asset.dov.write.enabled</code>
   * set to true, such as {@link adventurejs.Paper|Paper}.
   * </p>
   * <p>
   * All that distinguishes Pen from other WritingImplements
   * is that its
   * <code class="property">attached</code>
   * {@link adventurejs.Aspect|Aspect}
   * allows an instance of class
   * {@link adventurejs.PenCap|PenCap} to be attached.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Pen",
   *   name: "red pen",
   *   article: "a",
   *   adjectives: "red",
   *   place: { on: "table" },
   *   descriptions: { look: "It's a pen with red ink. ", },
   * });
   * MyGame.createAsset({
   *   class: "PenCap",
   *   name: "pen cap",
   *   article: "a",
   *   place: { on: "table" },
   *   descriptions: { look: "It's a cap for a pen. ", },
   * });
   * MyGame.createAsset({
   *   class: "Paper",
   *   name: "construction paper",
   *   descriptions: { look: "It's a pink sheet of construction paper. ", },
   *   adjectives: ["pink"]
   *   place: { on: "bottom drawer" },
   * });
   * </code></pre>
   * <p>
   * The above example uses
   * <code class="property">with_classes</code>
   * to limit what a
   * player can put in without having to write custom
   * failure code for every object. To learn more, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   **/
  class Pen extends adventurejs.WritingImplement {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Pen";

      this.noun = "pen";
      this.plural = "pens";
      this.singlePluralPairs = [["pen", "pens"]];
      this.group = ["writing implements"];

      this.aspects.attached = new adventurejs.Aspect(
        "attached",
        this.game_name
      ).set({
        parent_id: this.id,
        list_in_room: false,
        list_in_examine: true,
        maxcount: 1, // presumably a cap
        with_classes: ["PenCap"],
      });
    }
  }
  adventurejs.Pen = Pen;
})();

// Pencil.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.WritingImplement.Pencil
   * @augments adventurejs.WritingImplement
   * @class adventurejs.Pencil
   * @ajsconstruct MyGame.createAsset({ "class":"Pencil", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A writing implement.
   * @classdesc
   * <p>
   * <strong>Pencil</strong> is a subclass of
   * {@link adventurejs.WritingImplement|WritingImplement}.
   * Pens and other WritingImplements have their
   * <code class="property">iov.write.enabled</code>
   * property set to true, which allows a player to write on things
   * with <code class="property">asset.dov.write.enabled</code>
   * set to true, such as {@link adventurejs.Paper|Paper}.
   * </p>
   * <p>
   * All that distinguishes Pen from other WritingImplements
   * is that its
   * <code class="property">attached</code>
   * {@link adventurejs.Aspect|Aspect}
   * allows an instance of class
   * {@link adventurejs.Eraser|Eraser} to be attached.
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Pencil",
   *   name: "chewed pencil",
   *   article: "a",
   *   place: { on: "table" },
   *   descriptions: { look: "It's a #2 pencil with teeth marks and a worn out eraser. ", },
   * });
   * MyGame.createAsset({
   *   class: "Eraser",
   *   name: "frog eraser",
   *   article: "the",
   *   place: { on: "table" },
   *   descriptions: { look: "It's an eraser in the shape of a frog. ", },
   * });
   * MyGame.createAsset({
   *   class: "Paper",
   *   name: "construction paper",
   *   descriptions: { look: "It's a pink sheet of construction paper. ", },
   *   adjectives: ["pink"]
   *   place: { in: "bottom drawer" },
   * });
   * </code></pre>
   * <p>
   * The above example uses
   * <code class="property">with_classes</code>
   * to limit what a
   * player can put in without having to write custom
   * failure code for every object. To learn more, see
   * <a href="/doc/Tangibles_Aspects.html">How to Use Aspects</a>.
   * </p>
   **/
  class Pencil extends adventurejs.WritingImplement {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Pencil";

      this.noun = "pencil";
      this.plural = "pencils";
      this.singlePluralPairs = [["pencil", "pencils"]];
      this.group = ["writing implements"];

      this.aspects.attached = new adventurejs.Aspect(
        "attached",
        this.game_name
      ).set({
        parent_id: this.id,
        list_in_room: false,
        list_in_examine: true,
        maxcount: 1, // presumably a cap
        with_classes: ["Eraser"],
      });
    }
  }
  adventurejs.Pencil = Pencil;
})();

// WritingSurface.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.WritingSurface
   * @augments adventurejs.Thing
   * @class adventurejs.WritingSurface
   * @ajsconstruct MyGame.createAsset({ "class":"WritingSurface", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A surface that can be written on and erased.
   * @classdesc
   * <p>
   * <strong>WritingSurface</strong> is a subclass of
   * {@link adventurejs.Thing|Thing} with its
   * <code class="property">asset.dov.write.enabled</code> and
   * <code class="property">asset.dov.erase.enabled</code> properties set to true.
   * <code class="property">asset.dov.write.enabled</code> allows it to receive
   * strings using the
   * {@link adventurejs.Verb|Verb} {@link write}.
   * <code class="property">asset.dov.erase.enabled</code>
   * allows it to be erased and
   * <code class="property">asset.dov.erase.with_nothing</code>
   * allows it to be erased without an eraser.
   * With WritingSurface's
   * <code class="property">append_written_strings_to_description</code>
   * property set to true, anything written
   * on it can be included in the WritingSurface's description.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; write "I will not poop in class" on blackboard
   * You write "I will not poop in class" on the blackboard with the chalk.
   *
   * <span class="input">&gt; examine blackboard
   * It's a big blackboard. Written on it is a phrase: "I will not poop in class".
   * </pre>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Blackboard",
   *   name: "blackboard",
   *   descriptions: { look: "It's a big gradeschool-style blackboard. ", },
   *   place: { in: "Schoolroom" },
   * });
   * </code></pre>
   **/
  class WritingSurface extends adventurejs.Thing {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "WritingSurface";

      this.setDOVs(["write", "erase"]);

      this.append_written_strings_to_description = true;
    }
  }
  adventurejs.WritingSurface = WritingSurface;
})();

// Blackboard.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.WritingSurface.Blackboard
   * @augments adventurejs.WritingSurface
   * @class adventurejs.Blackboard
   * @ajsconstruct MyGame.createAsset({ "class":"Blackboard", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A blackboard that can be written on and erased.
   * @classdesc
   * <p>
   * <strong>Blackboard</strong> is a subclass of
   * {@link adventurejs.WritingSurface|WritingSurface} with
   * <code class="property">asset.dov.write.enabled</code> and its
   * <code class="property">asset.dov.erase.enabled</code> properties set to true.
   * <code class="property">asset.dov.write.enabled</code> allows it to receive
   * strings using the
   * {@link adventurejs.Verb|Verb} {@link write}.
   * <code class="property">asset.dov.erase.enabled</code>
   * allows it to be erased and
   * <code class="property">asset.dov.erase.with_nothing</code>
   * allows it to be erased without an eraser.
   * With Blackboard's
   * <code class="property">append_written_strings_to_description</code>
   * property set to true, anything written
   * on it can be included in the Blackboard's description.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; write "I will not poop in class" on blackboard
   * You write "I will not poop in class" on the blackboard with the chalk.
   *
   * <span class="input">&gt; examine blackboard
   * It's a big blackboard. Written on it is a phrase: "I will not poop in class".
   * </pre>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Blackboard",
   *   name: "blackboard",
   *   descriptions: { look: "It's a big gradeschool-style blackboard. ", },
   *   place: { in: "Schoolroom" },
   * });
   * </code></pre>
   **/
  class Blackboard extends adventurejs.WritingSurface {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Blackboard";

      this.synonyms = [
        "blackboard",
        "chalkboard",
        "black board",
        "chalk board",
      ];
      this.setDOV({ erase: { with_nothing: true } });
      this.setDOV({ write: { with_classes: "Chalk" } });
      this.unsetDOV("take");
    }
  }
  adventurejs.Blackboard = Blackboard;
})();

// Whiteboard.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Matter.Tangible.Thing.WritingSurface.Whiteboard
   * @augments adventurejs.WritingSurface
   * @class adventurejs.Whiteboard
   * @ajsconstruct MyGame.createAsset({ "class":"Whiteboard", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading WritingClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary A whiteboard that can be written on and erased.
   * @classdesc
   * <p>
   * <strong>Whiteboard</strong> is a subclass of
   * {@link adventurejs.WritingSurface|WritingSurface} with
   * asset.dov.write.enabled and
   * asset.dov.erase.enabled set to true.
   * <code class="property">asset.dov.write</code>
   * allows it to receive strings using the
   * {@link adventurejs.Verb|Verb} {@link write}.
   * <code class="property">asset.dov.erase</code>
   * allows it to be erased and
   * <code class="property">asset.dov.erase.with_nothing</code>
   * allows it to be erased without an eraser.
   * With Whiteboard's
   * <code class="property">append_written_strings_to_description</code>
   * property set to true, anything written
   * on it can be included in the Whiteboard's description.
   * </p>
   * <pre class="display border outline">
   * <span class="input">&gt; write "I am good at business" on whiteboard
   * You write "I am good at business" on the whiteboard with the chalk.
   *
   * <span class="input">&gt; examine whiteboard
   * It's a big whiteboard. Written on it is a phrase: "I am good at business".
   * </pre>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">MyGame.createAsset({
   *   class: "Whiteboard",
   *   name: "whiteboard",
   *   descriptions: { look: "It's a big office-style whiteboard. ", },
   *   place: { in: "Office" },
   * });
   * </code></pre>
   **/
  class Whiteboard extends adventurejs.WritingSurface {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Whiteboard";

      this.synonyms = ["whiteboard", "white board"];
      // this.adjectives = [ "white" ];
      this.setDOV({ erase: { with_nothing: true } });
      this.setDOV({ write: { with_classes: "Marker" } });
      this.unsetDOV("take");
    }
  }
  adventurejs.Whiteboard = Whiteboard;
})();

// Intangible.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.Intangible
   * @augments adventurejs.Asset
   * @class adventurejs.Intangible
   * @ajsconstruct MyGame.createAsset({ "class":"Intangible", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading BaseClasses
   * @param {String} game_name Name of top level game instance that is scoped to window.
   * @param {String} name Instance name.
   * @summary Base class for abtract objects with no physical presence.
   * @tutorial Intangibles_AboutIntangibles
   * @classdesc
   * <p>
   * <strong></strong>
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class Intangible extends adventurejs.Asset {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Intangible";
      //this.is.global = true;
      this.is.abstract = true;
    }
  }
  adventurejs.Intangible = Intangible;
})();

// Spell.js
//console.log("Loaded Spell.js");
(function () {
  /*global adventurejs A*/
  "use strict";

  // for inspiration, see:
  // https://rpg.stackexchange.com/questions/195322/what-happens-if-you-drop-a-30-foot-cube-of-water-from-a-height-of-30-feet-on-so

  /**
   * @ajspath adventurejs.Atom.Asset.Intangible.Spell
   * @augments adventurejs.Intangible
   * @class adventurejs.Spell
   * @ajsconstruct MyGame.createAsset({ "class":"Spell", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsnavheading MiscAssetClasses
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary _
   * @classdesc
   * <p>
   * <strong></strong>
   * </p>
   * <h3 class="examples">Example:</h3>
   * <pre class="display"><code class="language-javascript">
   * </code></pre>
   **/
  class Spell extends adventurejs.Intangible {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "Spell";

      this.onCastSpell = function Spell_onCastSpell() {};
      this.doCastSpell = {};
    }

    validate(game) {
      super.validate(game);
      return true;
    }
  }
  adventurejs.Spell = Spell;
})();

// GlobalAsset.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.GlobalAsset
   * @augments adventurejs.Asset
   * @class adventurejs.GlobalAsset
   * @ajsconstruct MyGame.createAsset({ "class":"GlobalAsset", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsinternal
   * @ajsnavheading LibraryAssets
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Special class, parent class for global assets.
   * @todo This isn't complete, is it?
   * @classdesc
   * <p>
   * <strong>GlobalAsset</strong> is a special class of abstract
   * global {@link adventurejs.Asset|Assets}.
   * Authors should not have to construct or modify this Asset.
   * </p>
   **/
  class GlobalAsset extends adventurejs.Asset {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "GlobalAsset";

      this.is.singleton = true;
      this.is.global = true;
      this.is.known = true;
      this.is.seen = true;

      // write "foo" on page
      // write "foo" on page with pen
      this.setDOV("write");

      // say "hello" to man
      this.setDOV("say");

      //type "hello" on keyboard
      this.setDOV("type");

      // enter "hello" on
      this.setDOV("enter");
    }
  }

  adventurejs.GlobalAsset = GlobalAsset;
})();

// GlobalNothing.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.GlobalAsset.GlobalNothing
   * @augments adventurejs.GlobalAsset
   * @class adventurejs.GlobalNothing
   * @ajsconstruct MyGame.createAsset({ "class":"GlobalNothing", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsinternal
   * @ajsnavheading LibraryAssets
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Special class to handle the word 'nothing'.
   * @todo This isn't complete, is it?
   * @classdesc
   * <p>
   * <strong>GlobalNothing</strong> is a subclass of
   * {@link adventurejs.GlobalAsset|GlobalAsset} used to
   * catch player input such as 'take nothing'. Authors
   * should not have to construct or modify this Asset.
   * </p>
   **/
  class GlobalNothing extends adventurejs.GlobalAsset {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "GlobalNothing";

      this.descriptions.look = "It's nothing.";
      this.noun = "nothing";
      this.plural = "nothings";
      this.singlePluralPairs = [["nothing", "nothings"]];
    }
  }

  adventurejs.GlobalNothing = GlobalNothing;
})();

// GlobalSomething.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.GlobalAsset.GlobalSomething
   * @augments adventurejs.GlobalAsset
   * @class adventurejs.GlobalSomething
   * @ajsconstruct MyGame.createAsset({ "class":"GlobalSomething", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsinternal
   * @ajsnavheading LibraryAssets
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Special class to handle the word 'something'.
   * @todo This isn't complete, is it?
   * @classdesc
   * <p>
   * <strong>GlobalSomething</strong> is a special subclass
   * of {@link adventurejs.GlobalAsset|GlobalAsset} used to
   * catch player input such as 'take something'. Authors
   * should not have to construct or modify this Asset.
   * </p>
   **/
  class GlobalSomething extends adventurejs.GlobalAsset {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "GlobalSomething";

      this.descriptions.look = "It's something.";
      this.noun = "something";
      this.plural = "somethings";
      this.singlePluralPairs = [["something", "somethings"]];
    }
  }

  adventurejs.GlobalSomething = GlobalSomething;
})();

// GlobalString.js
(function () {
  /*global adventurejs A*/
  "use strict";

  /**
   * @ajspath adventurejs.Atom.Asset.GlobalAsset.GlobalString
   * @augments adventurejs.Asset
   * @class adventurejs.GlobalString
   * @ajsconstruct MyGame.createAsset({ "class":"GlobalString", "name":"foo", [...] })
   * @ajsconstructedby adventurejs.Game#createAsset
   * @ajsinternal
   * @ajsnavheading LibraryAssets
   * @param {String} game_name The name of the top level game object.
   * @param {String} name A name for the object, to be serialized and used as ID.
   * @summary Special class to handle quoted strings in player input.
   * @todo Is this fully functional?
   * @classdesc
   * <p>
   * <strong>GlobalString</strong> is a special subclass
   * of {@link adventurejs.GlobalAsset|GlobalAsset} used to
   * handle player input that has quoted strings in it, such
   * as 'say "foo" to man'. Authors should not have to construct
   * or modify this Asset.
   * </p>
   **/

  class GlobalString extends adventurejs.GlobalAsset {
    constructor(name, game_name) {
      super(name, game_name);
      this.class = "GlobalString";

      this.name = "words";
      this.name_is_proper = false;
      //this.propername = "words";
      this.definite_article = "the";

      this.is.abstract = true;

      this.descriptions.look = "That's a string.";
      this.noun = "string";
      this.plural = "strings";
      this.singlePluralPairs = [["string", "strings"]];

      this.values = [];
    }
  }
  adventurejs.GlobalString = GlobalString;
})();
